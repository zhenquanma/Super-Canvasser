(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('async'), require('@angular/core'), require('rxjs'), require('@angular/common'), require('bingmaps')) :
    typeof define === 'function' && define.amd ? define('angular-maps', ['exports', 'async', '@angular/core', 'rxjs', '@angular/common', 'bingmaps'], factory) :
    (factory((global['angular-maps'] = {}),null,global.ng.core,global.rxjs,global.ng.common));
}(this, (function (exports,async,core,rxjs,common) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ InfoWindow = (function () {
        function InfoWindow() {
        }
        return InfoWindow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var MarkerTypeId = {
        None: 0,
        FontMarker: 1,
        CanvasMarker: 2,
        DynmaicCircleMarker: 3,
        RotatedImageMarker: 4,
        RoundedImageMarker: 5,
        ScaledImageMarker: 6,
        Custom: 7,
    };
    MarkerTypeId[MarkerTypeId.None] = "None";
    MarkerTypeId[MarkerTypeId.FontMarker] = "FontMarker";
    MarkerTypeId[MarkerTypeId.CanvasMarker] = "CanvasMarker";
    MarkerTypeId[MarkerTypeId.DynmaicCircleMarker] = "DynmaicCircleMarker";
    MarkerTypeId[MarkerTypeId.RotatedImageMarker] = "RotatedImageMarker";
    MarkerTypeId[MarkerTypeId.RoundedImageMarker] = "RoundedImageMarker";
    MarkerTypeId[MarkerTypeId.ScaledImageMarker] = "ScaledImageMarker";
    MarkerTypeId[MarkerTypeId.Custom] = "Custom";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This class defines the contract for a marker.
     *
     * @export
     * @abstract
     * @abstract
     */
    var Marker = (function () {
        function Marker() {
        }
        /**
         * Creates a marker based on the marker info. In turn calls a number of internal members to
         * create the actual marker.
         *
         * \@memberof Marker
         * @param {?} iconInfo - icon information. Depending on the marker type, various properties
         * need to be present. For performance, it is recommended to use an id for markers that are common to facilitate
         * reuse.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image.
         */
        Marker.CreateMarker = /**
         * Creates a marker based on the marker info. In turn calls a number of internal members to
         * create the actual marker.
         *
         * \@memberof Marker
         * @param {?} iconInfo - icon information. Depending on the marker type, various properties
         * need to be present. For performance, it is recommended to use an id for markers that are common to facilitate
         * reuse.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image.
         */
            function (iconInfo) {
                switch (iconInfo.markerType) {
                    case MarkerTypeId.CanvasMarker: return Marker.CreateCanvasMarker(iconInfo);
                    case MarkerTypeId.DynmaicCircleMarker: return Marker.CreateDynmaicCircleMarker(iconInfo);
                    case MarkerTypeId.FontMarker: return Marker.CreateFontBasedMarker(iconInfo);
                    case MarkerTypeId.RotatedImageMarker: return Marker.CreateRotatedImageMarker(iconInfo);
                    case MarkerTypeId.RoundedImageMarker: return Marker.CreateRoundedImageMarker(iconInfo);
                    case MarkerTypeId.ScaledImageMarker: return Marker.CreateScaledImageMarker(iconInfo);
                    case MarkerTypeId.Custom: throw Error('Custom Marker Creators are not currently supported.');
                }
                throw Error('Unsupported marker type: ' + iconInfo.markerType);
            };
        /**
         * Obtains a shared img element for a marker icon to prevent unecessary creation of
         * DOM items. This has sped up large scale makers on Bing Maps by about 70%
         * \@memberof Marker
         * @param {?} icon - The icon string (url, data url, svg) for which to obtain the image.
         * @return {?} - The obtained image element.
         */
        Marker.GetImageForMarker = /**
         * Obtains a shared img element for a marker icon to prevent unecessary creation of
         * DOM items. This has sped up large scale makers on Bing Maps by about 70%
         * \@memberof Marker
         * @param {?} icon - The icon string (url, data url, svg) for which to obtain the image.
         * @return {?} - The obtained image element.
         */
            function (icon) {
                if (icon == null || icon === '') {
                    return null;
                }
                var /** @type {?} */ img = null;
                img = Marker.ImageElementCache.get(icon);
                if (img != null) {
                    return img;
                }
                if (typeof (document) !== 'undefined' && document != null) {
                    img = document.createElement('img');
                    img.src = icon;
                    Marker.ImageElementCache.set(icon, img);
                }
                return img;
            };
        /**
         * Creates a canvased based marker using the point collection contained in the iconInfo parameter.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @returns - String with the data url for the marker image.
         *
         * @memberof Marker
         */
        /**
         * Creates a canvased based marker using the point collection contained in the iconInfo parameter.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
        Marker.CreateCanvasMarker = /**
         * Creates a canvased based marker using the point collection contained in the iconInfo parameter.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for canvas markers.');
                }
                if (iconInfo == null || iconInfo.size == null || iconInfo.points == null) {
                    throw Error('IMarkerIconInfo.size, and IMarkerIConInfo.points are required for canvas markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    var /** @type {?} */ mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                var /** @type {?} */ c = document.createElement('canvas');
                var /** @type {?} */ ctx = c.getContext('2d');
                c.width = iconInfo.size.width;
                c.height = iconInfo.size.height;
                if (iconInfo.rotation) {
                    // Offset the canvas such that we will rotate around the center of our arrow
                    ctx.translate(c.width * 0.5, c.height * 0.5);
                    // Rotate the canvas by the desired heading
                    ctx.rotate(iconInfo.rotation * Math.PI / 180);
                    // Return the canvas offset back to it's original position
                    ctx.translate(-c.width * 0.5, -c.height * 0.5);
                }
                ctx.fillStyle = iconInfo.color || 'red';
                // Draw a path in the shape of an arrow.
                ctx.beginPath();
                if (iconInfo.drawingOffset) {
                    ctx.moveTo(iconInfo.drawingOffset.x, iconInfo.drawingOffset.y);
                }
                iconInfo.points.forEach(function (p) { ctx.lineTo(p.x, p.y); });
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                var /** @type {?} */ s = c.toDataURL();
                if (iconInfo.id != null) {
                    Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                }
                return s;
            };
        /**
         * Creates a circle marker image using information contained in the iconInfo parameter.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @returns - String with the data url for the marker image.
         *
         * @memberof Marker
         */
        /**
         * Creates a circle marker image using information contained in the iconInfo parameter.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
        Marker.CreateDynmaicCircleMarker = /**
         * Creates a circle marker image using information contained in the iconInfo parameter.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for dynamic circle markers.');
                }
                if (iconInfo == null || iconInfo.size == null) {
                    throw Error('IMarkerIconInfo.size is required for dynamic circle markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    var /** @type {?} */ mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                var /** @type {?} */ strokeWidth = iconInfo.strokeWidth || 0;
                // Create an SVG string of a circle with the specified radius and color.
                var /** @type {?} */ svg = [
                    '<svg xmlns="http://www.w3.org/2000/svg" width="',
                    iconInfo.size.width.toString(),
                    '" height="',
                    iconInfo.size.width.toString(),
                    '"><circle cx="',
                    (iconInfo.size.width / 2).toString(),
                    '" cy="',
                    (iconInfo.size.width / 2).toString(),
                    '" r="',
                    ((iconInfo.size.width / 2) - strokeWidth).toString(),
                    '" stroke="',
                    iconInfo.color || 'red',
                    '" stroke-width="',
                    strokeWidth.toString(),
                    '" fill="',
                    iconInfo.color || 'red',
                    '"/></svg>'
                ];
                var /** @type {?} */ s = svg.join('');
                if (iconInfo.id != null) {
                    Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                }
                return s;
            };
        /**
         * Creates a font based marker image (such as Font-Awesome), by using information supplied in the parameters (such as Font-Awesome).
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @returns - String with the data url for the marker image.
         *
         * @memberof Marker
         */
        /**
         * Creates a font based marker image (such as Font-Awesome), by using information supplied in the parameters (such as Font-Awesome).
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
        Marker.CreateFontBasedMarker = /**
         * Creates a font based marker image (such as Font-Awesome), by using information supplied in the parameters (such as Font-Awesome).
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - String with the data url for the marker image.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for font based markers');
                }
                if (iconInfo == null || iconInfo.fontName == null || iconInfo.fontSize == null) {
                    throw Error('IMarkerIconInfo.fontName, IMarkerIconInfo.fontSize and IMarkerIConInfo.text are required for font based markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    var /** @type {?} */ mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                var /** @type {?} */ c = document.createElement('canvas');
                var /** @type {?} */ ctx = c.getContext('2d');
                var /** @type {?} */ font = iconInfo.fontSize + 'px ' + iconInfo.fontName;
                ctx.font = font;
                // Resize canvas based on sie of text.
                var /** @type {?} */ size = ctx.measureText(iconInfo.text);
                c.width = size.width;
                c.height = iconInfo.fontSize;
                if (iconInfo.rotation) {
                    // Offset the canvas such that we will rotate around the center of our arrow
                    ctx.translate(c.width * 0.5, c.height * 0.5);
                    // Rotate the canvas by the desired heading
                    ctx.rotate(iconInfo.rotation * Math.PI / 180);
                    // Return the canvas offset back to it's original position
                    ctx.translate(-c.width * 0.5, -c.height * 0.5);
                }
                // Reset font as it will be cleared by the resize.
                ctx.font = font;
                ctx.textBaseline = 'top';
                ctx.fillStyle = iconInfo.color || 'red';
                ctx.fillText(iconInfo.text, 0, 0);
                iconInfo.size = { width: c.width, height: c.height };
                var /** @type {?} */ s = c.toDataURL();
                if (iconInfo.id != null) {
                    Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                }
                return s;
            };
        /**
         * Creates an image marker by applying a roation to a supplied image.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @returns - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         * @memberof Marker
         */
        /**
         * Creates an image marker by applying a roation to a supplied image.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
        Marker.CreateRotatedImageMarker = /**
         * Creates an image marker by applying a roation to a supplied image.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for rotated image markers');
                }
                if (iconInfo == null || iconInfo.rotation == null || iconInfo.url == null) {
                    throw Error('IMarkerIconInfo.rotation, IMarkerIconInfo.url are required for rotated image markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    var /** @type {?} */ mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                var /** @type {?} */ image = new Image();
                var /** @type {?} */ promise = new Promise(function (resolve, reject) {
                    // Allow cross domain image editting.
                    image.crossOrigin = 'anonymous';
                    image.src = iconInfo.url;
                    if (iconInfo.size) {
                        image.width = iconInfo.size.width;
                        image.height = iconInfo.size.height;
                    }
                    image.onload = function () {
                        var /** @type {?} */ c = document.createElement('canvas');
                        var /** @type {?} */ ctx = c.getContext('2d');
                        var /** @type {?} */ rads = iconInfo.rotation * Math.PI / 180;
                        // Calculate rotated image size.
                        c.width = Math.ceil(Math.abs(image.width * Math.cos(rads)) + Math.abs(image.height * Math.sin(rads)));
                        c.height = Math.ceil(Math.abs(image.width * Math.sin(rads)) + Math.abs(image.height * Math.cos(rads)));
                        // Move to the center of the canvas.
                        ctx.translate(c.width / 2, c.height / 2);
                        // Rotate the canvas to the specified angle in degrees.
                        ctx.rotate(rads);
                        // Draw the image, since the context is rotated, the image will be rotated also.
                        ctx.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
                        iconInfo.size = { width: c.width, height: c.height };
                        var /** @type {?} */ s = c.toDataURL();
                        if (iconInfo.id != null) {
                            Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                        }
                        resolve({ icon: s, iconInfo: iconInfo });
                    };
                });
                return promise;
            };
        /**
         * Creates a rounded image marker by applying a circle mask to a supplied image.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @param iconInfo - Callback invoked once marker generation is complete. The callback
         * parameters are the data uri and the IMarkerIconInfo.
         * @returns - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         * @memberof Marker
         */
        /**
         * Creates a rounded image marker by applying a circle mask to a supplied image.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
        Marker.CreateRoundedImageMarker = /**
         * Creates a rounded image marker by applying a circle mask to a supplied image.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for rounded image markers');
                }
                if (iconInfo == null || iconInfo.size == null || iconInfo.url == null) {
                    throw Error('IMarkerIconInfo.size, IMarkerIconInfo.url are required for rounded image markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    var /** @type {?} */ mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                var /** @type {?} */ promise = new Promise(function (resolve, reject) {
                    var /** @type {?} */ radius = iconInfo.size.width / 2;
                    var /** @type {?} */ image = new Image();
                    var /** @type {?} */ offset = iconInfo.drawingOffset || { x: 0, y: 0 };
                    // Allow cross domain image editting.
                    image.crossOrigin = 'anonymous';
                    image.src = iconInfo.url;
                    image.onload = function () {
                        var /** @type {?} */ c = document.createElement('canvas');
                        var /** @type {?} */ ctx = c.getContext('2d');
                        c.width = iconInfo.size.width;
                        c.height = iconInfo.size.width;
                        // Draw a circle which can be used to clip the image, then draw the image.
                        ctx.beginPath();
                        ctx.arc(radius, radius, radius, 0, 2 * Math.PI, false);
                        ctx.fill();
                        ctx.clip();
                        ctx.drawImage(image, offset.x, offset.y, iconInfo.size.width, iconInfo.size.width);
                        iconInfo.size = { width: c.width, height: c.height };
                        var /** @type {?} */ s = c.toDataURL();
                        if (iconInfo.id != null) {
                            Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                        }
                        resolve({ icon: s, iconInfo: iconInfo });
                    };
                });
                return promise;
            };
        /**
         * Creates a scaled image marker by scaling a supplied image by a factor using a canvas.
         *
         * @protected
         * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @param iconInfo - Callback invoked once marker generation is complete. The callback
         * parameters are the data uri and the IMarkerIconInfo.
         * @returns - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         * @memberof Marker
         */
        /**
         * Creates a scaled image marker by scaling a supplied image by a factor using a canvas.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
        Marker.CreateScaledImageMarker = /**
         * Creates a scaled image marker by scaling a supplied image by a factor using a canvas.
         *
         * @protected
         * \@memberof Marker
         * @param {?} iconInfo - {\@link IMarkerIconInfo} containing the information necessary to create the icon.
         * @return {?} - a string or a promise for a string containing
         * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.
         *
         */
            function (iconInfo) {
                if (document == null) {
                    throw Error('Document context (window.document) is required for scaled image markers');
                }
                if (iconInfo == null || iconInfo.scale == null || iconInfo.url == null) {
                    throw Error('IMarkerIconInfo.scale, IMarkerIconInfo.url are required for scaled image markers.');
                }
                if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {
                    var /** @type {?} */ mi = Marker.MarkerCache.get(iconInfo.id);
                    iconInfo.size = mi.markerSize;
                    return mi.markerIconString;
                }
                var /** @type {?} */ promise = new Promise(function (resolve, reject) {
                    var /** @type {?} */ image = new Image();
                    // Allow cross domain image editting.
                    image.crossOrigin = 'anonymous';
                    image.src = iconInfo.url;
                    image.onload = function () {
                        var /** @type {?} */ c = document.createElement('canvas');
                        var /** @type {?} */ ctx = c.getContext('2d');
                        c.width = image.width * iconInfo.scale;
                        c.height = image.height * iconInfo.scale;
                        // Draw a circle which can be used to clip the image, then draw the image.
                        ctx.drawImage(image, 0, 0, c.width, c.height);
                        iconInfo.size = { width: c.width, height: c.height };
                        var /** @type {?} */ s = c.toDataURL();
                        if (iconInfo.id != null) {
                            Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size });
                        }
                        resolve({ icon: s, iconInfo: iconInfo });
                    };
                });
                return promise;
            };
        /**
         * Caches concrete img elements for marker icons to accelerate patining.
         *
         * \@memberof Marker
         */
        Marker.ImageElementCache = new Map();
        /**
         * Used to cache generated markers for performance and reusability.
         *
         * \@memberof Marker
         */
        Marker.MarkerCache = new Map();
        return Marker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var MapTypeId = {
        /** The aerial map type which uses top-down satellite & airplane imagery. */
        aerial: 0,
        /** A darker version of the road maps. */
        canvasDark: 1,
        /** A lighter version of the road maps which also has some of the details such as hill shading disabled. */
        canvasLight: 2,
        /** A grayscale version of the road maps. */
        grayscale: 3,
        /** The aerial map type including lables */
        hybrid: 4,
        /** Displays a blank canvas that uses the mercator map project. It basically removed the base maps layer. */
        mercator: 5,
        /** Ordnance survey map type (en-gb only). */
        ordnanceSurvey: 6,
        /** Road map type. */
        road: 7,
        /** Provides streetside panoramas from the street level. */
        streetside: 8,
    };
    MapTypeId[MapTypeId.aerial] = "aerial";
    MapTypeId[MapTypeId.canvasDark] = "canvasDark";
    MapTypeId[MapTypeId.canvasLight] = "canvasLight";
    MapTypeId[MapTypeId.grayscale] = "grayscale";
    MapTypeId[MapTypeId.hybrid] = "hybrid";
    MapTypeId[MapTypeId.mercator] = "mercator";
    MapTypeId[MapTypeId.ordnanceSurvey] = "ordnanceSurvey";
    MapTypeId[MapTypeId.road] = "road";
    MapTypeId[MapTypeId.streetside] = "streetside";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Defines the contract for a map layer implementation. Deriving providers should implements this abstract
     * to provide concrete layer functionality for the map.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Defines the contract for a map layer implementation. Deriving providers should implements this abstract
     * to provide concrete layer functionality for the map.
     *
     * @export
     * @abstract
     * @abstract
     */ Layer = (function () {
        function Layer() {
        }
        return Layer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract class defining the contract for a polygon in the architecture specific implementation.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Abstract class defining the contract for a polygon in the architecture specific implementation.
     *
     * @export
     * @abstract
     * @abstract
     */ Polygon = (function () {
        function Polygon() {
        }
        Object.defineProperty(Polygon.prototype, "Center", {
            get: /**
             * Gets the polygon's center.
             * \@readonly
             * \@memberof Polygon
             * @return {?}
             */ function () {
                if (this._center == null) {
                    this._center = this.GetBoundingCenter();
                }
                return this._center;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Polygon.prototype, "Centroid", {
            get: /**
             * Gets the polygon's centroid.
             * \@readonly
             * \@memberof Polygon
             * @return {?}
             */ function () {
                if (this._centroid == null) {
                    this._centroid = this.GetPolygonCentroid();
                }
                return this._centroid;
            },
            enumerable: true,
            configurable: true
        });
        ///
        /// Protected methods
        ///
        /**
         * Gets the center of the polygons' bounding box.
         *
         * @returns - ILatLong object containing the center of the bounding box.
         * @memberof Polygon
         * @method
         * @protected
         */
        /**
         * Gets the center of the polygons' bounding box.
         *
         * \@memberof Polygon
         * \@method
         * @protected
         * @return {?} - ILatLong object containing the center of the bounding box.
         */
        Polygon.prototype.GetBoundingCenter = /**
         * Gets the center of the polygons' bounding box.
         *
         * \@memberof Polygon
         * \@method
         * @protected
         * @return {?} - ILatLong object containing the center of the bounding box.
         */
            function () {
                var /** @type {?} */ c = { latitude: 0, longitude: 0 };
                var /** @type {?} */ x1 = 90, /** @type {?} */ x2 = -90, /** @type {?} */ y1 = 180, /** @type {?} */ y2 = -180;
                var /** @type {?} */ path = this.GetPaths();
                if (path) {
                    path.forEach(function (inner) {
                        return inner.forEach(function (p) {
                            if (p.latitude < x1) {
                                x1 = p.latitude;
                            }
                            if (p.latitude > x2) {
                                x2 = p.latitude;
                            }
                            if (p.longitude < y1) {
                                y1 = p.longitude;
                            }
                            if (p.longitude > y2) {
                                y2 = p.longitude;
                            }
                        });
                    });
                    c.latitude = x1 + (x2 - x1) / 2;
                    c.longitude = y1 + (y2 - y1) / 2;
                }
                else {
                    c = null;
                }
                return c;
            };
        /**
         * Get the centroid of the polygon based on the polygon path.
         *
         * @returns - The centroid coordinates of the polygon.
         * @memberof Polygon
         * @method
         * @protected
         */
        /**
         * Get the centroid of the polygon based on the polygon path.
         *
         * \@memberof Polygon
         * \@method
         * @protected
         * @return {?} - The centroid coordinates of the polygon.
         */
        Polygon.prototype.GetPolygonCentroid = /**
         * Get the centroid of the polygon based on the polygon path.
         *
         * \@memberof Polygon
         * \@method
         * @protected
         * @return {?} - The centroid coordinates of the polygon.
         */
            function () {
                var /** @type {?} */ c = { latitude: 0, longitude: 0 };
                var /** @type {?} */ path = this.GetPaths();
                var /** @type {?} */ off = path[0][0];
                if (off != null) {
                    var /** @type {?} */ twicearea = 0;
                    var /** @type {?} */ x = 0;
                    var /** @type {?} */ y = 0;
                    var /** @type {?} */ p1 = void 0, /** @type {?} */ p2 = void 0;
                    var /** @type {?} */ f = void 0;
                    for (var /** @type {?} */ k = 0; k < path.length; k++) {
                        for (var /** @type {?} */ i = 0, /** @type {?} */ j = path[k].length - 1; i < path[k].length; j = i++) {
                            p1 = path[k][i];
                            p2 = path[k][j];
                            f = (p1.latitude - off.latitude) * (p2.longitude - off.longitude) -
                                (p2.latitude - off.latitude) * (p1.longitude - off.longitude);
                            twicearea += f;
                            x += (p1.latitude + p2.latitude - 2 * off.latitude) * f;
                            y += (p1.longitude + p2.longitude - 2 * off.longitude) * f;
                        }
                    }
                    if (twicearea !== 0) {
                        f = twicearea * 3;
                        c.latitude = x / f + off.latitude;
                        c.longitude = y / f + off.longitude;
                    }
                    else {
                        c.latitude = off.latitude;
                        c.longitude = off.longitude;
                    }
                }
                else {
                    c = null;
                }
                return c;
            };
        return Polygon;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract class defining the contract for a polyline in the architecture specific implementation.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Abstract class defining the contract for a polyline in the architecture specific implementation.
     *
     * @export
     * @abstract
     * @abstract
     */ Polyline = (function () {
        function Polyline() {
        }
        Object.defineProperty(Polyline.prototype, "Center", {
            get: /**
             * Gets the polyline's center.
             * \@readonly
             * \@memberof Polyline
             * @return {?}
             */ function () {
                if (this._center == null) {
                    this._center = this.GetBoundingCenter();
                }
                return this._center;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Polyline.prototype, "Centroid", {
            get: /**
             * Gets the polyline's centroid.
             * \@readonly
             * \@memberof Polyline
             * @return {?}
             */ function () {
                if (this._centroid == null) {
                    this._centroid = this.GetPolylineCentroid();
                }
                return this._centroid;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Get the centroid of the polyline based on the a path.
         *
         * \@memberof Polyline
         * \@method
         * @param {?} path - the path for which to generate the centroid
         * @return {?} - The centroid coordinates of the polyline.
         */
        Polyline.GetPolylineCentroid = /**
         * Get the centroid of the polyline based on the a path.
         *
         * \@memberof Polyline
         * \@method
         * @param {?} path - the path for which to generate the centroid
         * @return {?} - The centroid coordinates of the polyline.
         */
            function (path) {
                var /** @type {?} */ c = { latitude: 0, longitude: 0 };
                var /** @type {?} */ off = path[0];
                if (off != null) {
                    var /** @type {?} */ twicearea = 0;
                    var /** @type {?} */ x = 0;
                    var /** @type {?} */ y = 0;
                    var /** @type {?} */ p1 = void 0, /** @type {?} */ p2 = void 0;
                    var /** @type {?} */ f = void 0;
                    for (var /** @type {?} */ i = 0, /** @type {?} */ j = path.length - 1; i < path.length; j = i++) {
                        p1 = path[i];
                        p2 = path[j];
                        f = (p1.latitude - off.latitude) * (p2.longitude - off.longitude) -
                            (p2.latitude - off.latitude) * (p1.longitude - off.longitude);
                        twicearea += f;
                        x += (p1.latitude + p2.latitude - 2 * off.latitude) * f;
                        y += (p1.longitude + p2.longitude - 2 * off.longitude) * f;
                    }
                    if (twicearea !== 0) {
                        f = twicearea * 3;
                        c.latitude = x / f + off.latitude;
                        c.longitude = y / f + off.longitude;
                    }
                    else {
                        c.latitude = off.latitude;
                        c.longitude = off.longitude;
                    }
                }
                else {
                    c = null;
                }
                return c;
            };
        ///
        /// Protected methods
        ///
        /**
         * Gets the center of the polyline' bounding box.
         *
         * @returns - {@link ILatLong} object containing the center of the bounding box.
         * @memberof Polyline
         * @method
         * @protected
         */
        /**
         * Gets the center of the polyline' bounding box.
         *
         * \@memberof Polyline
         * \@method
         * @protected
         * @return {?} - {\@link ILatLong} object containing the center of the bounding box.
         */
        Polyline.prototype.GetBoundingCenter = /**
         * Gets the center of the polyline' bounding box.
         *
         * \@memberof Polyline
         * \@method
         * @protected
         * @return {?} - {\@link ILatLong} object containing the center of the bounding box.
         */
            function () {
                var /** @type {?} */ c = { latitude: 0, longitude: 0 };
                var /** @type {?} */ x1 = 90, /** @type {?} */ x2 = -90, /** @type {?} */ y1 = 180, /** @type {?} */ y2 = -180;
                var /** @type {?} */ path = this.GetPath();
                if (path) {
                    path.forEach(function (p) {
                        if (p.latitude < x1) {
                            x1 = p.latitude;
                        }
                        if (p.latitude > x2) {
                            x2 = p.latitude;
                        }
                        if (p.longitude < y1) {
                            y1 = p.longitude;
                        }
                        if (p.longitude > y2) {
                            y2 = p.longitude;
                        }
                    });
                    c.latitude = x1 + (x2 - x1) / 2;
                    c.longitude = y1 + (y2 - y1) / 2;
                }
                else {
                    c = null;
                }
                return c;
            };
        /**
         * Get the centroid of the polyline based on the polyline path.
         *
         * @returns - The centroid coordinates of the polyline.
         * @memberof Polyline
         * @method
         * @protected
         */
        /**
         * Get the centroid of the polyline based on the polyline path.
         *
         * \@memberof Polyline
         * \@method
         * @protected
         * @return {?} - The centroid coordinates of the polyline.
         */
        Polyline.prototype.GetPolylineCentroid = /**
         * Get the centroid of the polyline based on the polyline path.
         *
         * \@memberof Polyline
         * \@method
         * @protected
         * @return {?} - The centroid coordinates of the polyline.
         */
            function () {
                var /** @type {?} */ path = this.GetPath();
                var /** @type {?} */ c = Polyline.GetPolylineCentroid(path);
                return c;
            };
        return Polyline;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ SpiderClusterMarker = (function (_super) {
        __extends(SpiderClusterMarker, _super);
        function SpiderClusterMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SpiderClusterMarker;
    }(Marker));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var ClusterPlacementMode = {
        None: 0,
        MeanValue: 1,
        FirstPin: 2,
    };
    ClusterPlacementMode[ClusterPlacementMode.None] = "None";
    ClusterPlacementMode[ClusterPlacementMode.MeanValue] = "MeanValue";
    ClusterPlacementMode[ClusterPlacementMode.FirstPin] = "FirstPin";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var ClusterClickAction = {
        None: 0,
        ZoomIntoCluster: 1,
        Spider: 2,
    };
    ClusterClickAction[ClusterClickAction.None] = "None";
    ClusterClickAction[ClusterClickAction.ZoomIntoCluster] = "ZoomIntoCluster";
    ClusterClickAction[ClusterClickAction.Spider] = "Spider";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ id = 0;
    /**
     * Abstract base implementing a canvas overlay to be placed on the map.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Abstract base implementing a canvas overlay to be placed on the map.
     *
     * @export
     * @abstract
     * @abstract
     */ CanvasOverlay = (function () {
        /**
         * Creates a new instance of the CanvasOverlay class.
         */
        function CanvasOverlay(drawCallback) {
            var _this = this;
            this._canvasReady = new Promise(function (resolve, reject) { _this._readyResolver = resolve; });
            this._drawCallback = drawCallback;
            id++;
        }
        Object.defineProperty(CanvasOverlay.prototype, "CanvasReady", {
            get: /**
             * Returns a promise that gets resolved when the canvas overlay is ready for interaction.
             * @return {?}
             */ function () { return this._canvasReady; },
            enumerable: true,
            configurable: true
        });
        /**
         * Deletes the canvas overlay.
         * @return {?}
         */
        CanvasOverlay.prototype.Delete = /**
         * Deletes the canvas overlay.
         * @return {?}
         */
            function () {
                this.SetMap(null);
            };
        /**
         * CanvasOverlay added to map, load canvas.
         * @return {?}
         */
        CanvasOverlay.prototype.OnAdd = /**
         * CanvasOverlay added to map, load canvas.
         * @return {?}
         */
            function () {
                this._canvas = document.createElement('canvas');
                this._canvas.style.position = 'absolute';
                this._canvas.style.left = '0px';
                this._canvas.style.top = '0px';
                this._canvas.id = "xMapOverlay" + id;
                // Add the canvas to the overlay.
                this.SetCanvasElement(this._canvas);
            };
        /**
         * When the CanvasLayer is removed from the map, release resources.
         * \@memberof CanvasOverlay
         * \@method
         * @return {?}
         */
        CanvasOverlay.prototype.OnRemove = /**
         * When the CanvasLayer is removed from the map, release resources.
         * \@memberof CanvasOverlay
         * \@method
         * @return {?}
         */
            function () {
                this.SetCanvasElement(null);
                this.RemoveEventHandlers();
                this._canvas = null;
            };
        /**
         * Redraws the canvas for the current map view.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} clear - True to clear the canvas before drawing.
         * @return {?}
         */
        CanvasOverlay.prototype.Redraw = /**
         * Redraws the canvas for the current map view.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} clear - True to clear the canvas before drawing.
         * @return {?}
         */
            function (clear) {
                if (this._canvas == null) {
                    return;
                }
                // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.
                if (clear) {
                    this.Resize();
                }
                // Call the drawing callback function if specified.
                if (this._drawCallback) {
                    this._drawCallback(this._canvas);
                }
            };
        /**
         * Simple function for updating the CSS position and dimensions of the canvas.
         * @param x The horizontal offset position of the canvas.
         * @param y The vertical offset position of the canvas.
         * @param w The width of the canvas.
         * @param h The height of the canvas.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Simple function for updating the CSS position and dimensions of the canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @param {?} x The horizontal offset position of the canvas.
         * @param {?} y The vertical offset position of the canvas.
         * @param {?} w The width of the canvas.
         * @param {?} h The height of the canvas.
         * @return {?}
         */
        CanvasOverlay.prototype.UpdatePosition = /**
         * Simple function for updating the CSS position and dimensions of the canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @param {?} x The horizontal offset position of the canvas.
         * @param {?} y The vertical offset position of the canvas.
         * @param {?} w The width of the canvas.
         * @param {?} h The height of the canvas.
         * @return {?}
         */
            function (x, y, w, h) {
                // Update CSS position.
                this._canvas.style.left = x + 'px';
                this._canvas.style.top = y + 'px';
                // Update CSS dimensions.
                this._canvas.style.width = w + 'px';
                this._canvas.style.height = h + 'px';
            };
        return CanvasOverlay;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of a map layer for the Bing Map Provider.
     *
     * @export
     */
    var /**
     * Concrete implementation of a map layer for the Bing Map Provider.
     *
     * @export
     */ BingLayer = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new instance of the BingClusterLayer class.
         *
         * @param _layer Microsoft.Maps.ClusterLayer. Native Bing Cluster Layer supporting the cluster layer.
         * @param _maps MapService. MapService implementation to leverage for the layer.
         *
         * @memberof BingLayer
         */
        function BingLayer(_layer, _maps) {
            this._layer = _layer;
            this._maps = _maps;
            this._pendingEntities = new Array();
        }
        Object.defineProperty(BingLayer.prototype, "NativePrimitve", {
            get: /**
             * Get the native primitive underneath the abstraction layer.
             *
             * \@memberof BingLayer
             * @return {?} Microsoft.Maps.Layer.
             *
             */ function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener for the layer.
         *
         * \@memberof BingLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
        BingLayer.prototype.AddListener = /**
         * Adds an event listener for the layer.
         *
         * \@memberof BingLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                Microsoft.Maps.Events.addHandler(this._layer, eventType, function (e) {
                    fn(e);
                });
            };
        /**
         * Adds an entity to the layer.
         *
         * \@memberof BingLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.
         *
         * @return {?}
         */
        BingLayer.prototype.AddEntity = /**
         * Adds an entity to the layer.
         *
         * \@memberof BingLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity && entity.NativePrimitve) {
                    if (this.GetVisible()) {
                        this._layer.add(entity.NativePrimitve);
                    }
                    else {
                        this._pendingEntities.push(entity);
                    }
                }
            };
        /**
         * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such
         * as marker, infowindow, polyline, polygon, etc..)
         *
         * \@memberof BingLayer
         * @param {?} entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.
         *
         * @return {?}
         */
        BingLayer.prototype.AddEntities = /**
         * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such
         * as marker, infowindow, polyline, polygon, etc..)
         *
         * \@memberof BingLayer
         * @param {?} entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                //
                // use eachSeries as opposed to _layer.add([]) to provide a non-blocking experience for larger data sets.
                //
                if (entities != null && Array.isArray(entities) && entities.length !== 0) {
                    async.eachSeries(__spread(entities), function (e, next) {
                        if (_this.GetVisible()) {
                            _this._layer.add(e.NativePrimitve);
                        }
                        else {
                            _this._pendingEntities.push(e);
                        }
                        async.nextTick(function () { return next(); });
                    });
                }
            };
        /**
         * Deletes the layer.
         *
         * \@memberof BingLayer
         * @return {?}
         */
        BingLayer.prototype.Delete = /**
         * Deletes the layer.
         *
         * \@memberof BingLayer
         * @return {?}
         */
            function () {
                this._maps.DeleteLayer(this);
            };
        /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof BingLayer
         * @return {?} IClusterOptions. The layer options.
         *
         */
        BingLayer.prototype.GetOptions = /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof BingLayer
         * @return {?} IClusterOptions. The layer options.
         *
         */
            function () {
                var /** @type {?} */ o = {
                    id: Number(this._layer.getId())
                };
                return o;
            };
        /**
         * Returns the visibility state of the layer.
         *
         * \@memberof BingLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
        BingLayer.prototype.GetVisible = /**
         * Returns the visibility state of the layer.
         *
         * \@memberof BingLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
            function () {
                return this._layer.getVisible();
            };
        /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline to be removed from the layer.
         *
         * @return {?}
         */
        BingLayer.prototype.RemoveEntity = /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline to be removed from the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve) {
                    this._layer.remove(entity.NativePrimitve);
                }
            };
        /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing the entities to add to the cluster.
         * This replaces any existing entities.
         *
         * @return {?}
         */
        BingLayer.prototype.SetEntities = /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing the entities to add to the cluster.
         * This replaces any existing entities.
         *
         * @return {?}
         */
            function (entities) {
                //
                // we are using removal and add as opposed to set as for large number of objects it yields a non-blocking, smoother performance...
                //
                this._layer.setPrimitives([]);
                this.AddEntities(entities);
            };
        /**
         * Sets the options for the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        BingLayer.prototype.SetOptions = /**
         * Sets the options for the cluster layer.
         *
         * \@memberof BingLayer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                this._layer.metadata.id = options.id.toString();
            };
        /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof BingLayer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
        BingLayer.prototype.SetVisible = /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof BingLayer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
            function (visible) {
                this._layer.setVisible(visible);
                if (visible && this._pendingEntities.length > 0) {
                    this.AddEntities(this._pendingEntities.splice(0));
                }
            };
        return BingLayer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This class contains helperfunctions to map various interfaces used to represent options and structures into the
     * corresponding Bing Maps V8 specific implementations.
     *
     * @export
     */
    var BingConversions = (function () {
        function BingConversions() {
        }
        /**
         * Maps an IInfoWindowAction to a Microsoft.Maps.IInfoboxActions
         *
         * \@memberof BingConversions
         * @param {?} action - Object to be mapped.
         * @return {?} - Navtive mapped object.
         *
         */
        BingConversions.TranslateAction = /**
         * Maps an IInfoWindowAction to a Microsoft.Maps.IInfoboxActions
         *
         * \@memberof BingConversions
         * @param {?} action - Object to be mapped.
         * @return {?} - Navtive mapped object.
         *
         */
            function (action) {
                var /** @type {?} */ a = {
                    eventHandler: action.eventHandler,
                    label: action.label
                };
                return a;
            };
        /**
         * Maps an Array of IInfoWindowAction to an Array of Microsoft.Maps.IInfoboxActions
         *
         * \@memberof BingConversions
         * @param {?} actions - Array of objects to be mapped.
         * @return {?} - Array of mapped objects.
         *
         */
        BingConversions.TranslateActions = /**
         * Maps an Array of IInfoWindowAction to an Array of Microsoft.Maps.IInfoboxActions
         *
         * \@memberof BingConversions
         * @param {?} actions - Array of objects to be mapped.
         * @return {?} - Array of mapped objects.
         *
         */
            function (actions) {
                var /** @type {?} */ a = new Array();
                actions.forEach(function (x) { return a.push(BingConversions.TranslateAction(x)); });
                return a;
            };
        /**
         * Maps an IBox object to a Microsoft.Maps.LocationRect object.
         *
         * \@memberof BingConversions
         * @param {?} box - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateBounds = /**
         * Maps an IBox object to a Microsoft.Maps.LocationRect object.
         *
         * \@memberof BingConversions
         * @param {?} box - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (box) {
                var /** @type {?} */ r = Microsoft.Maps.LocationRect.fromEdges(box.maxLatitude, box.minLongitude, box.minLatitude, box.maxLongitude);
                return r;
            };
        /**
         * Maps an IClusterOptions object to a Microsoft.Maps.IClusterLayerOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateClusterOptions = /**
         * Maps an IClusterOptions object to a Microsoft.Maps.IClusterLayerOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._clusterOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'layerOffset') {
                        o.layerOffset = BingConversions.TranslatePoint(options.layerOffset);
                    }
                    if (k === 'placementMode') {
                        if (options.placementMode === ClusterPlacementMode.FirstPin) {
                            o.placementMode = Microsoft.Maps.ClusterPlacementType.FirstLocation;
                        }
                        else {
                            o.placementMode = Microsoft.Maps.ClusterPlacementType.MeanAverage;
                        }
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IInfoWindowOptions object to a Microsoft.Maps.IInfoboxOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateInfoBoxOptions = /**
         * Maps an IInfoWindowOptions object to a Microsoft.Maps.IInfoboxOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._infoWindowOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'pixelOffset') {
                        o.offset = BingConversions.TranslatePoint(options.pixelOffset);
                    }
                    else if (k === 'position') {
                        o.location = BingConversions.TranslateLocation(options.position);
                    }
                    else if (k === 'actions') {
                        o.actions = BingConversions.TranslateActions(options.actions);
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IMapOptions object to a Microsoft.Maps.IMapLoadOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateLoadOptions = /**
         * Maps an IMapOptions object to a Microsoft.Maps.IMapLoadOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) {
                    return BingConversions._mapOptionsAttributes.indexOf(k) !== -1 || BingConversions._viewOptionsAttributes.indexOf(k) !== -1;
                })
                    .forEach(function (k) {
                    if (k === 'center') {
                        o.center = BingConversions.TranslateLocation(options.center);
                    }
                    else if (k === 'mapTypeId') {
                        if (options.mapTypeId === MapTypeId.hybrid) {
                            o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;
                            o.labelOverlay = Microsoft.Maps.LabelOverlay.visible;
                        }
                        else if (options.mapTypeId === MapTypeId.aerial) {
                            o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;
                            o.labelOverlay = Microsoft.Maps.LabelOverlay.hidden;
                        }
                        else {
                            o.mapTypeId = Microsoft.Maps.MapTypeId[((MapTypeId))[options.mapTypeId]];
                        }
                    }
                    else if (k === 'bounds') {
                        o.bounds = BingConversions.TranslateBounds(options.bounds);
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an ILatLong object to a Microsoft.Maps.Location object.
         *
         * \@memberof BingConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateLocation = /**
         * Maps an ILatLong object to a Microsoft.Maps.Location object.
         *
         * \@memberof BingConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlong) {
                var /** @type {?} */ l = new Microsoft.Maps.Location(latlong.latitude, latlong.longitude);
                return l;
            };
        /**
         * Maps an IMarkerOptions object to a Microsoft.Maps.IPushpinOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - The mapped object.
         *
         */
        BingConversions.TranslateMarkerOptions = /**
         * Maps an IMarkerOptions object to a Microsoft.Maps.IPushpinOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - The mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._markerOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'anchor') {
                        o.anchor = BingConversions.TranslatePoint(options.anchor);
                    }
                    else {
                        ((o))[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IMapOptions object to a Microsoft.Maps.IMapOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateOptions = /**
         * Maps an IMapOptions object to a Microsoft.Maps.IMapOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._mapOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'center') {
                        o.center = BingConversions.TranslateLocation(options.center);
                    }
                    else if (k === 'mapTypeId') {
                        o.mapTypeId = Microsoft.Maps.MapTypeId[((MapTypeId))[options.mapTypeId]];
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
         *
         * \@memberof BingConversions
         * @param {?} paths - ILatLong based locations to convert.
         * @return {?} - converted locations.
         *
         */
        BingConversions.TranslatePaths = /**
         * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
         *
         * \@memberof BingConversions
         * @param {?} paths - ILatLong based locations to convert.
         * @return {?} - converted locations.
         *
         */
            function (paths) {
                var /** @type {?} */ p = new Array();
                if (paths == null || !Array.isArray(paths) || paths.length === 0) {
                    p.push(new Array());
                }
                else if (Array.isArray(paths[0])) {
                    // parameter is an array or arrays
                    // us for loop for performance
                    var /** @type {?} */ p1 = (paths);
                    for (var /** @type {?} */ i = 0; i < p1.length; i++) {
                        var /** @type {?} */ _p = new Array();
                        for (var /** @type {?} */ j = 0; j < p1[i].length; j++) {
                            _p.push(new Microsoft.Maps.Location(p1[i][j].latitude, p1[i][j].longitude));
                        }
                        p.push(_p);
                    }
                }
                else {
                    // parameter is a simple array....
                    var /** @type {?} */ y = new Array();
                    var /** @type {?} */ p1 = (paths);
                    for (var /** @type {?} */ i = 0; i < p1.length; i++) {
                        y.push(new Microsoft.Maps.Location(p1[i].latitude, p1[i].longitude));
                    }
                    p.push(y);
                }
                return p;
            };
        /**
         *  Maps an IPoint object to a Microsoft.Maps.Point object.
         *
         * \@memberof BingConversions
         * @param {?} point - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslatePoint = /**
         *  Maps an IPoint object to a Microsoft.Maps.Point object.
         *
         * \@memberof BingConversions
         * @param {?} point - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (point) {
                var /** @type {?} */ p = new Microsoft.Maps.Point(point.x, point.y);
                return p;
            };
        /**
         *  Maps an IPolygonOptions object to a Microsoft.Maps.IPolygonOptions.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslatePolygonOptions = /**
         *  Maps an IPolygonOptions object to a Microsoft.Maps.IPolygonOptions.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                var /** @type {?} */ f = function (s, a) {
                    var /** @type {?} */ m = /rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*\d+[\.\d+]*)*\)/g.exec(s);
                    if (m && m.length > 3) {
                        a = a > 1 ? (a / 100) : a;
                        return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';
                    }
                    else if (s[0] === '#') {
                        var /** @type {?} */ z = s.substr(1);
                        var /** @type {?} */ r = parseInt(z.substr(0, 2), 16);
                        var /** @type {?} */ g = parseInt(z.substr(2, 2), 16);
                        var /** @type {?} */ b = parseInt(z.substr(4, 2), 16);
                        return 'rgba(' + [r, g, b, a].join(',') + ')';
                    }
                    else {
                        return s;
                    }
                };
                Object.keys(options)
                    .filter(function (k) { return BingConversions._polygonOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'strokeWeight') {
                        o.strokeThickness = options.strokeWeight;
                    }
                    else if (k === 'strokeColor') {
                        if (options.strokeOpacity) {
                            o.strokeColor = f(options.strokeColor, options.strokeOpacity);
                        }
                        else {
                            o.strokeColor = options.strokeColor;
                        }
                    }
                    else if (k === 'strokeOpacity') ;
                    else if (k === 'fillColor') {
                        if (options.fillOpacity) {
                            o.fillColor = f(options.fillColor, options.fillOpacity);
                        }
                        else {
                            o.fillColor = options.fillColor;
                        }
                    }
                    else if (k === 'fillOpacity') ;
                    else {
                        ((o))[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         *  Maps an IPolylineOptions object to a Microsoft.Maps.IPolylineOptions.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslatePolylineOptions = /**
         *  Maps an IPolylineOptions object to a Microsoft.Maps.IPolylineOptions.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                var /** @type {?} */ f = function (s, a) {
                    var /** @type {?} */ m = /rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*\d+[\.\d+]*)*\)/g.exec(s);
                    if (m && m.length > 3) {
                        a = a > 1 ? (a / 100) : a;
                        return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';
                    }
                    else if (s[0] === '#') {
                        var /** @type {?} */ z = s.substr(1);
                        var /** @type {?} */ r = parseInt(z.substr(0, 2), 16);
                        var /** @type {?} */ g = parseInt(z.substr(2, 2), 16);
                        var /** @type {?} */ b = parseInt(z.substr(4, 2), 16);
                        return 'rgba(' + [r, g, b, a].join(',') + ')';
                    }
                    else {
                        return s;
                    }
                };
                Object.keys(options)
                    .filter(function (k) { return BingConversions._polylineOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'strokeWeight') {
                        o.strokeThickness = options.strokeWeight;
                    }
                    else if (k === 'strokeColor') {
                        if (options.strokeOpacity) {
                            o.strokeColor = f(options.strokeColor, options.strokeOpacity);
                        }
                        else {
                            o.strokeColor = options.strokeColor;
                        }
                    }
                    else if (k === 'strokeOpacity') ;
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IMapOptions object to a Microsoft.Maps.IViewOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        BingConversions.TranslateViewOptions = /**
         * Maps an IMapOptions object to a Microsoft.Maps.IViewOptions object.
         *
         * \@memberof BingConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return BingConversions._viewOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'center') {
                        o.center = BingConversions.TranslateLocation(options.center);
                    }
                    else if (k === 'bounds') {
                        o.bounds = BingConversions.TranslateBounds(options.bounds);
                    }
                    else if (k === 'centerOffset') {
                        o.centerOffset = BingConversions.TranslatePoint(options.centerOffset);
                    }
                    else if (k === 'mapTypeId') {
                        o.mapTypeId = Microsoft.Maps.MapTypeId[((MapTypeId))[options.mapTypeId]];
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Map option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._mapOptionsAttributes = [
            'backgroundColor',
            'credentials',
            'customizeOverlays',
            'disableBirdseye',
            'disableKeyboardInput',
            'disableMouseInput',
            'disablePanning',
            'disableTouchInput',
            'disableUserInput',
            'disableZooming',
            'disableStreetside',
            'enableClickableLogo',
            'enableSearchLogo',
            'fixedMapPosition',
            'height',
            'inertiaIntensity',
            'navigationBarMode',
            'showBreadcrumb',
            'showCopyright',
            'showDashboard',
            'showMapTypeSelector',
            'showScalebar',
            'theme',
            'tileBuffer',
            'useInertia',
            'width',
            'center',
            'zoom',
            'mapTypeId'
        ];
        /**
         * View option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._viewOptionsAttributes = [
            'animate',
            'bounds',
            'center',
            'centerOffset',
            'heading',
            'labelOverlay',
            'mapTypeId',
            'padding',
            'zoom'
        ];
        /**
         * InfoWindow option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._infoWindowOptionsAttributes = [
            'actions',
            'description',
            'htmlContent',
            'id',
            'position',
            'pixelOffset',
            'showCloseButton',
            'showPointer',
            'pushpin',
            'title',
            'titleClickHandler',
            'typeName',
            'visible',
            'width',
            'height'
        ];
        /**
         * Marker option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._markerOptionsAttributes = [
            'anchor',
            'draggable',
            'height',
            'htmlContent',
            'icon',
            'infobox',
            'state',
            'title',
            'textOffset',
            'typeName',
            'visible',
            'width',
            'zIndex'
        ];
        /**
         * Polygon option attributes that are supported for conversion to Bing Map Polygon properties
         *
         * \@memberof BingConversions
         */
        BingConversions._polygonOptionsAttributes = [
            'cursor',
            'fillColor',
            'fillOpacity',
            'strokeColor',
            'strokeOpacity',
            'strokeWeight',
            'visible'
        ];
        /**
         * Polyline option attributes that are supported for conversion to Bing Map Polyline properties
         *
         * \@memberof BingConversions
         */
        BingConversions._polylineOptionsAttributes = [
            'cursor',
            'strokeColor',
            'strokeOpacity',
            'strokeWeight',
            'visible'
        ];
        /**
         * Cluster option attributes that are supported for conversion to Bing Map properties
         *
         * \@memberof BingConversions
         */
        BingConversions._clusterOptionsAttributes = [
            'callback',
            'clusteredPinCallback',
            'clusteringEnabled',
            'gridSize',
            'layerOffset',
            'placementMode',
            'visible',
            'zIndex'
        ];
        return BingConversions;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the {\@link Marker} contract for the Bing Maps V8 map architecture.
     *
     * @export
     */
    var /**
     * Concrete implementation of the {\@link Marker} contract for the Bing Maps V8 map architecture.
     *
     * @export
     */ BingMarker = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingMarker.
         * @param _pushpin - The {@link Microsoft.Maps.Pushpin} underlying the model.
         * @param _map - The context map.
         * @param _layer - The context layer.
         *
         * @memberof BingMarker
         */
        function BingMarker(_pushpin, _map, _layer) {
            this._pushpin = _pushpin;
            this._map = _map;
            this._layer = _layer;
            this._metadata = new Map();
            this._isFirst = false;
            this._isLast = true;
        }
        Object.defineProperty(BingMarker.prototype, "IsFirst", {
            get: /**
             * Indicates that the marker is the first marker in a set.
             *
             * \@memberof Marker
             * @return {?}
             */ function () { return this._isFirst; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._isFirst = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMarker.prototype, "IsLast", {
            get: /**
             * Indicates that the marker is the last marker in the set.
             *
             * \@memberof Marker
             * @return {?}
             */ function () { return this._isLast; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._isLast = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMarker.prototype, "Location", {
            get: /**
             * Gets the Location of the marker
             *
             * \@readonly
             * \@memberof BingMarker
             * @return {?}
             */ function () {
                var /** @type {?} */ l = this._pushpin.getLocation();
                return {
                    latitude: l.latitude,
                    longitude: l.longitude
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMarker.prototype, "Metadata", {
            get: /**
             * Gets the marker metadata.
             *
             * \@readonly
             * \@memberof BingMarker
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMarker.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the marker, in this case {\@link Microsoft.Maps.Pushpin}
             *
             * \@readonly
             * \@memberof BingMarker
             * @return {?}
             */ function () { return this._pushpin; },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener to the marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
        BingMarker.prototype.AddListener = /**
         * Adds an event listener to the marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                Microsoft.Maps.Events.addHandler(this._pushpin, eventType, function (e) {
                    fn(e);
                });
            };
        /**
         * Deletes the marker.
         *
         * @abstract
         *
         * \@memberof BingMarker
         * @return {?}
         */
        BingMarker.prototype.DeleteMarker = /**
         * Deletes the marker.
         *
         * @abstract
         *
         * \@memberof BingMarker
         * @return {?}
         */
            function () {
                if (!this._map && !this._layer) {
                    return;
                }
                if (this._layer) {
                    this._layer.remove(this.NativePrimitve);
                }
                else {
                    this._map.entities.remove(this.NativePrimitve);
                }
            };
        /**
         * Gets the marker label
         *
         * @abstract
         *
         * \@memberof BingMarker
         * @return {?}
         */
        BingMarker.prototype.GetLabel = /**
         * Gets the marker label
         *
         * @abstract
         *
         * \@memberof BingMarker
         * @return {?}
         */
            function () {
                return this._pushpin.getText();
            };
        /**
         * Gets whether the marker is visible.
         *
         * \@memberof BingMarker
         * @return {?} - True if the marker is visible, false otherwise.
         *
         */
        BingMarker.prototype.GetVisible = /**
         * Gets whether the marker is visible.
         *
         * \@memberof BingMarker
         * @return {?} - True if the marker is visible, false otherwise.
         *
         */
            function () {
                return this._pushpin.getVisible();
            };
        /**
         * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} anchor - Point coordinates for the marker anchor.
         *
         * @return {?}
         */
        BingMarker.prototype.SetAnchor = /**
         * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} anchor - Point coordinates for the marker anchor.
         *
         * @return {?}
         */
            function (anchor) {
                var /** @type {?} */ o = {};
                o.anchor = new Microsoft.Maps.Point(anchor.x, anchor.y);
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the draggability of a marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} draggable - True to mark the marker as draggable, false otherwise.
         *
         * @return {?}
         */
        BingMarker.prototype.SetDraggable = /**
         * Sets the draggability of a marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} draggable - True to mark the marker as draggable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                var /** @type {?} */ o = {};
                o.draggable = draggable;
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the icon for the marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} icon - String containing the icon in various forms (url, data url, etc.)
         *
         * @return {?}
         */
        BingMarker.prototype.SetIcon = /**
         * Sets the icon for the marker.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} icon - String containing the icon in various forms (url, data url, etc.)
         *
         * @return {?}
         */
            function (icon) {
                var /** @type {?} */ o = {};
                o.icon = icon;
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the marker label.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} label - String containing the label to set.
         *
         * @return {?}
         */
        BingMarker.prototype.SetLabel = /**
         * Sets the marker label.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} label - String containing the label to set.
         *
         * @return {?}
         */
            function (label) {
                var /** @type {?} */ o = {};
                o.text = label;
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the marker position.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} latLng - Geo coordinates to set the marker position to.
         *
         * @return {?}
         */
        BingMarker.prototype.SetPosition = /**
         * Sets the marker position.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} latLng - Geo coordinates to set the marker position to.
         *
         * @return {?}
         */
            function (latLng) {
                var /** @type {?} */ p = BingConversions.TranslateLocation(latLng);
                this._pushpin.setLocation(p);
            };
        /**
         * Sets the marker title.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} title - String containing the title to set.
         *
         * @return {?}
         */
        BingMarker.prototype.SetTitle = /**
         * Sets the marker title.
         *
         * @abstract
         * \@memberof BingMarker
         * @param {?} title - String containing the title to set.
         *
         * @return {?}
         */
            function (title) {
                var /** @type {?} */ o = {};
                o.title = title;
                this._pushpin.setOptions(o);
            };
        /**
         * Sets the marker options.
         *
         * @abstract
         * \@memberof Marker
         * @param {?} options - {\@link IMarkerOptions} object containing the marker options to set. The supplied options are
         * merged with the underlying marker options.
         * @return {?}
         */
        BingMarker.prototype.SetOptions = /**
         * Sets the marker options.
         *
         * @abstract
         * \@memberof Marker
         * @param {?} options - {\@link IMarkerOptions} object containing the marker options to set. The supplied options are
         * merged with the underlying marker options.
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = BingConversions.TranslateMarkerOptions(options);
                this._pushpin.setOptions(o);
            };
        /**
         * Sets whether the marker is visible.
         *
         * \@memberof Marker
         * @param {?} visible - True to set the marker visible, false otherwise.
         *
         * @return {?}
         */
        BingMarker.prototype.SetVisible = /**
         * Sets whether the marker is visible.
         *
         * \@memberof Marker
         * @param {?} visible - True to set the marker visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                var /** @type {?} */ o = {};
                o.visible = visible;
                this._pushpin.setOptions(o);
            };
        return BingMarker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BingSpiderClusterMarker = (function (_super) {
        __extends(BingSpiderClusterMarker, _super);
        function BingSpiderClusterMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return BingSpiderClusterMarker;
    }(BingMarker));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of a clustering layer for the Bing Map Provider.
     *
     * @export
     */
    var /**
     * Concrete implementation of a clustering layer for the Bing Map Provider.
     *
     * @export
     */ BingClusterLayer = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new instance of the BingClusterLayer class.
         *
         * @param _layer Microsoft.Maps.ClusterLayer. Native Bing Cluster Layer supporting the cluster layer.
         * @param _maps MapService. MapService implementation to leverage for the layer.
         *
         * @memberof BingClusterLayer
         */
        function BingClusterLayer(_layer, _maps) {
            this._layer = _layer;
            this._maps = _maps;
            this._isClustering = true;
            this._markers = new Array();
            this._markerLookup = new Map();
            this._pendingMarkers = new Array();
            this._spiderMarkers = new Array();
            this._spiderMarkerLookup = new Map();
            this._useSpiderCluster = false;
            this._mapclicks = 0;
            this._events = new Array();
            this._currentZoom = 0;
            this._spiderOptions = {
                circleSpiralSwitchover: 9,
                collapseClusterOnMapChange: false,
                collapseClusterOnNthClick: 1,
                invokeClickOnHover: true,
                minCircleLength: 60,
                minSpiralAngleSeperation: 25,
                spiralDistanceFactor: 5,
                stickStyle: {
                    strokeColor: 'black',
                    strokeThickness: 2
                },
                stickHoverStyle: { strokeColor: 'red' },
                markerSelected: null,
                markerUnSelected: null
            };
            this._currentCluster = null;
        }
        Object.defineProperty(BingClusterLayer.prototype, "NativePrimitve", {
            get: /**
             * Get the native primitive underneath the abstraction layer.
             *
             * \@memberof BingClusterLayer
             * @return {?} Microsoft.Maps.ClusterLayer.
             *
             */ function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener for the layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.AddListener = /**
         * Adds an event listener for the layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                Microsoft.Maps.Events.addHandler(this._layer, eventType, function (e) {
                    fn(e);
                });
            };
        /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof BingClusterLayer
         * @param {?} entity Marker. Entity to add to the layer.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.AddEntity = /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof BingClusterLayer
         * @param {?} entity Marker. Entity to add to the layer.
         *
         * @return {?}
         */
            function (entity) {
                var /** @type {?} */ isMarker = entity instanceof Marker;
                isMarker = entity instanceof BingMarker || isMarker;
                if (isMarker) {
                    if (entity.IsFirst) {
                        this.StopClustering();
                    }
                }
                if (entity.NativePrimitve && entity.Location) {
                    if (this._isClustering) {
                        var /** @type {?} */ p = this._layer.getPushpins();
                        p.push(entity.NativePrimitve);
                        this._layer.setPushpins(p);
                        this._markers.push(entity);
                    }
                    else {
                        this._pendingMarkers.push(entity);
                    }
                    this._markerLookup.set(entity.NativePrimitve, entity);
                }
                if (isMarker) {
                    if (entity.IsLast) {
                        this.StartClustering();
                    }
                }
            };
        /**
         * Adds a number of markers to the layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entities Array<Marker>. Entities to add to the layer.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.AddEntities = /**
         * Adds a number of markers to the layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entities Array<Marker>. Entities to add to the layer.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                if (entities != null && Array.isArray(entities) && entities.length !== 0) {
                    var /** @type {?} */ e = entities.map(function (p) {
                        _this._markerLookup.set(p.NativePrimitve, p);
                        return p.NativePrimitve;
                    });
                    if (this._isClustering) {
                        var /** @type {?} */ p = this._layer.getPushpins();
                        p.push.apply(p, __spread(e));
                        this._layer.setPushpins(p);
                        (_a = this._markers).push.apply(_a, __spread(entities));
                    }
                    else {
                        (_b = this._pendingMarkers).push.apply(_b, __spread(entities));
                    }
                }
                var _a, _b;
            };
        /**
         * Initializes spider behavior for the clusering layer (when a cluster maker is clicked, it explodes into a spider of the
         * individual underlying pins.
         *
         * \@memberof BingClusterLayer
         * @param {?=} options ISpiderClusterOptions. Optional. Options governing the behavior of the spider.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.InitializeSpiderClusterSupport = /**
         * Initializes spider behavior for the clusering layer (when a cluster maker is clicked, it explodes into a spider of the
         * individual underlying pins.
         *
         * \@memberof BingClusterLayer
         * @param {?=} options ISpiderClusterOptions. Optional. Options governing the behavior of the spider.
         *
         * @return {?}
         */
            function (options) {
                var _this = this;
                if (this._useSpiderCluster) {
                    return;
                }
                var /** @type {?} */ m = ((this._maps)).MapInstance;
                this._useSpiderCluster = true;
                this._spiderLayer = new Microsoft.Maps.Layer();
                this._currentZoom = m.getZoom();
                this.SetSpiderOptions(options);
                m.layers.insert(this._spiderLayer);
                this._events.push(Microsoft.Maps.Events.addHandler(m, 'click', function (e) { return _this.OnMapClick(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(m, 'viewchangestart', function (e) { return _this.OnMapViewChangeStart(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(m, 'viewchangeend', function (e) { return _this.OnMapViewChangeEnd(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(this._layer, 'click', function (e) { return _this.OnLayerClick(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'click', function (e) { return _this.OnLayerClick(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'mouseover', function (e) { return _this.OnSpiderMouseOver(e); }));
                this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'mouseout', function (e) { return _this.OnSpiderMouseOut(e); }));
            };
        /**
         * Deletes the clustering layer.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
        BingClusterLayer.prototype.Delete = /**
         * Deletes the clustering layer.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._useSpiderCluster) {
                    this._spiderLayer.clear();
                    ((this._maps)).MapPromise.then(function (m) {
                        m.layers.remove(_this._spiderLayer);
                        _this._spiderLayer = null;
                    });
                    this._events.forEach(function (e) { return Microsoft.Maps.Events.removeHandler(e); });
                    this._events.splice(0);
                    this._useSpiderCluster = false;
                }
                this._markers.splice(0);
                this._spiderMarkers.splice(0);
                this._pendingMarkers.splice(0);
                this._markerLookup.clear();
                this._maps.DeleteLayer(this);
            };
        /**
         * Returns the abstract marker used to wrap the Bing Pushpin.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin
         * @return {?} Marker. The abstract marker object representing the pushpin.
         *
         */
        BingClusterLayer.prototype.GetMarkerFromBingMarker = /**
         * Returns the abstract marker used to wrap the Bing Pushpin.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin
         * @return {?} Marker. The abstract marker object representing the pushpin.
         *
         */
            function (pin) {
                var /** @type {?} */ m = this._markerLookup.get(pin);
                return m;
            };
        /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof BingClusterLayer
         * @return {?} IClusterOptions. The layer options.
         *
         */
        BingClusterLayer.prototype.GetOptions = /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof BingClusterLayer
         * @return {?} IClusterOptions. The layer options.
         *
         */
            function () {
                var /** @type {?} */ o = this._layer.getOptions();
                var /** @type {?} */ options = {
                    id: 0,
                    gridSize: o.gridSize,
                    layerOffset: o.layerOffset,
                    clusteringEnabled: o.clusteringEnabled,
                    callback: o.callback,
                    clusteredPinCallback: o.clusteredPinCallback,
                    visible: o.visible,
                    zIndex: o.zIndex
                };
                return options;
            };
        /**
         * Returns the visibility state of the layer.
         *
         * \@memberof BingClusterLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
        BingClusterLayer.prototype.GetVisible = /**
         * Returns the visibility state of the layer.
         *
         * \@memberof BingClusterLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
            function () {
                return this._layer.getOptions().visible;
            };
        /**
         * Returns the abstract marker used to wrap the Bing Pushpin.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin
         * @return {?} - The abstract marker object representing the pushpin.
         *
         */
        BingClusterLayer.prototype.GetSpiderMarkerFromBingMarker = /**
         * Returns the abstract marker used to wrap the Bing Pushpin.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin
         * @return {?} - The abstract marker object representing the pushpin.
         *
         */
            function (pin) {
                var /** @type {?} */ m = this._spiderMarkerLookup.get(pin);
                return m;
            };
        /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entity Marker - Entity to be removed from the layer.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.RemoveEntity = /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entity Marker - Entity to be removed from the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve && entity.Location) {
                    var /** @type {?} */ j = this._markers.indexOf(entity);
                    var /** @type {?} */ k = this._pendingMarkers.indexOf(entity);
                    if (j > -1) {
                        this._markers.splice(j, 1);
                    }
                    if (k > -1) {
                        this._pendingMarkers.splice(k, 1);
                    }
                    if (this._isClustering) {
                        var /** @type {?} */ p = this._layer.getPushpins();
                        var /** @type {?} */ i = p.indexOf(entity.NativePrimitve);
                        if (i > -1) {
                            p.splice(i, 1);
                            this._layer.setPushpins(p);
                        }
                    }
                    this._markerLookup.delete(entity.NativePrimitve);
                }
            };
        /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entities Array<Marker> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.SetEntities = /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} entities Array<Marker> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                var /** @type {?} */ p = new Array();
                this._markers.splice(0);
                this._markerLookup.clear();
                entities.forEach(function (e) {
                    if (e.NativePrimitve && e.Location) {
                        _this._markers.push(e);
                        _this._markerLookup.set(e.NativePrimitve, e);
                        p.push(/** @type {?} */ (e.NativePrimitve));
                    }
                });
                this._layer.setPushpins(p);
            };
        /**
         * Sets the options for the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.SetOptions = /**
         * Sets the options for the cluster layer.
         *
         * \@memberof BingClusterLayer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = BingConversions.TranslateClusterOptions(options);
                this._layer.setOptions(o);
                if (options.spiderClusterOptions) {
                    this.SetSpiderOptions(options.spiderClusterOptions);
                }
            };
        /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof BingClusterLayer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.SetVisible = /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof BingClusterLayer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
            function (visible) {
                var /** @type {?} */ o = this._layer.getOptions();
                o.visible = visible;
                this._layer.setOptions(o);
            };
        /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
        BingClusterLayer.prototype.StartClustering = /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
            function () {
                if (this._isClustering) {
                    return;
                }
                var /** @type {?} */ p = new Array();
                this._markers.forEach(function (e) {
                    if (e.NativePrimitve && e.Location) {
                        p.push(/** @type {?} */ (e.NativePrimitve));
                    }
                });
                this._pendingMarkers.forEach(function (e) {
                    if (e.NativePrimitve && e.Location) {
                        p.push(/** @type {?} */ (e.NativePrimitve));
                    }
                });
                this._layer.setPushpins(p);
                this._markers = this._markers.concat(this._pendingMarkers.splice(0));
                this._isClustering = true;
            };
        /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
        BingClusterLayer.prototype.StopClustering = /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
            function () {
                if (!this._isClustering) {
                    return;
                }
                this._isClustering = false;
            };
        /**
         * Creates a copy of a pushpins basic options.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin Pushpin to copy options from.
         * @return {?} - A copy of a pushpins basic options.
         *
         */
        BingClusterLayer.prototype.GetBasicPushpinOptions = /**
         * Creates a copy of a pushpins basic options.
         *
         * \@memberof BingClusterLayer
         * @param {?} pin Pushpin to copy options from.
         * @return {?} - A copy of a pushpins basic options.
         *
         */
            function (pin) {
                return /** @type {?} */ ({
                    anchor: pin.getAnchor(),
                    color: pin.getColor(),
                    cursor: pin.getCursor(),
                    icon: pin.getIcon(),
                    roundClickableArea: pin.getRoundClickableArea(),
                    subTitle: pin.getSubTitle(),
                    text: pin.getText(),
                    textOffset: pin.getTextOffset(),
                    title: pin.getTitle()
                });
            };
        /**
         * Hides the spider cluster and resotres the original pin.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
        BingClusterLayer.prototype.HideSpiderCluster = /**
         * Hides the spider cluster and resotres the original pin.
         *
         * \@memberof BingClusterLayer
         * @return {?}
         */
            function () {
                this._mapclicks = 0;
                if (this._currentCluster) {
                    this._spiderLayer.clear();
                    this._spiderMarkers.splice(0);
                    this._spiderMarkerLookup.clear();
                    this._currentCluster = null;
                    this._mapclicks = -1;
                    if (this._spiderOptions.markerUnSelected) {
                        this._spiderOptions.markerUnSelected();
                    }
                }
            };
        /**
         * Click event handler for when a shape in the cluster layer is clicked.
         *
         * \@memberof BingClusterLayer
         * @param {?} e The mouse event argurment from the click event.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.OnLayerClick = /**
         * Click event handler for when a shape in the cluster layer is clicked.
         *
         * \@memberof BingClusterLayer
         * @param {?} e The mouse event argurment from the click event.
         *
         * @return {?}
         */
            function (e) {
                if (e.primitive instanceof Microsoft.Maps.ClusterPushpin) {
                    var /** @type {?} */ cp = (e.primitive);
                    var /** @type {?} */ showNewCluster = cp !== this._currentCluster;
                    this.HideSpiderCluster();
                    if (showNewCluster) {
                        this.ShowSpiderCluster(/** @type {?} */ (e.primitive));
                    }
                }
                else {
                    var /** @type {?} */ pin = (e.primitive);
                    if (pin.metadata && pin.metadata.isClusterMarker) {
                        var /** @type {?} */ m = this.GetSpiderMarkerFromBingMarker(pin);
                        var /** @type {?} */ p = m.ParentMarker;
                        var /** @type {?} */ ppin = p.NativePrimitve;
                        if (this._spiderOptions.markerSelected) {
                            this._spiderOptions.markerSelected(p, new BingMarker(this._currentCluster, null, null));
                        }
                        if (Microsoft.Maps.Events.hasHandler(ppin, 'click')) {
                            Microsoft.Maps.Events.invoke(ppin, 'click', e);
                        }
                        this._mapclicks = 0;
                    }
                    else {
                        if (this._spiderOptions.markerSelected) {
                            this._spiderOptions.markerSelected(this.GetMarkerFromBingMarker(pin), null);
                        }
                        if (Microsoft.Maps.Events.hasHandler(pin, 'click')) {
                            Microsoft.Maps.Events.invoke(pin, 'click', e);
                        }
                    }
                }
            };
        /**
         * Delegate handling the click event on the map (outside a spider cluster). Depending on the
         * spider options, closes the cluster or increments the click counter.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event
         *
         * @return {?}
         */
        BingClusterLayer.prototype.OnMapClick = /**
         * Delegate handling the click event on the map (outside a spider cluster). Depending on the
         * spider options, closes the cluster or increments the click counter.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event
         *
         * @return {?}
         */
            function (e) {
                if (this._mapclicks === -1) {
                    return;
                }
                else if (++this._mapclicks >= this._spiderOptions.collapseClusterOnNthClick) {
                    this.HideSpiderCluster();
                }
            };
        /**
         * Delegate handling the map view changed end event. Hides the spider cluster if the zoom level has changed.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.OnMapViewChangeEnd = /**
         * Delegate handling the map view changed end event. Hides the spider cluster if the zoom level has changed.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event.
         *
         * @return {?}
         */
            function (e) {
                var /** @type {?} */ z = ((e.target)).getZoom();
                var /** @type {?} */ hasZoomChanged = (z !== this._currentZoom);
                this._currentZoom = z;
                if (hasZoomChanged) {
                    this.HideSpiderCluster();
                }
            };
        /**
         * Delegate handling the map view change start event. Depending on the spider options, hides the
         * the exploded spider or does nothing.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.OnMapViewChangeStart = /**
         * Delegate handling the map view change start event. Depending on the spider options, hides the
         * the exploded spider or does nothing.
         *
         * \@memberof BingClusterLayer
         * @param {?} e - Mouse event.
         *
         * @return {?}
         */
            function (e) {
                if (this._spiderOptions.collapseClusterOnMapChange) {
                    this.HideSpiderCluster();
                }
            };
        /**
         * Delegate invoked on mouse out on an exploded spider marker. Resets the hover style on the stick.
         *
         * @param {?} e - Mouse event.
         * @return {?}
         */
        BingClusterLayer.prototype.OnSpiderMouseOut = /**
         * Delegate invoked on mouse out on an exploded spider marker. Resets the hover style on the stick.
         *
         * @param {?} e - Mouse event.
         * @return {?}
         */
            function (e) {
                var /** @type {?} */ pin = (e.primitive);
                if (pin instanceof Microsoft.Maps.Pushpin && pin.metadata && pin.metadata.isClusterMarker) {
                    var /** @type {?} */ m = this.GetSpiderMarkerFromBingMarker(pin);
                    m.Stick.setOptions(this._spiderOptions.stickStyle);
                }
            };
        /**
         * Invoked on mouse over on an exploded spider marker. Sets the hover style on the stick. Also invokes the click event
         * on the underlying original marker dependent on the spider options.
         *
         * @param {?} e - Mouse event.
         * @return {?}
         */
        BingClusterLayer.prototype.OnSpiderMouseOver = /**
         * Invoked on mouse over on an exploded spider marker. Sets the hover style on the stick. Also invokes the click event
         * on the underlying original marker dependent on the spider options.
         *
         * @param {?} e - Mouse event.
         * @return {?}
         */
            function (e) {
                var /** @type {?} */ pin = (e.primitive);
                if (pin instanceof Microsoft.Maps.Pushpin && pin.metadata && pin.metadata.isClusterMarker) {
                    var /** @type {?} */ m = this.GetSpiderMarkerFromBingMarker(pin);
                    m.Stick.setOptions(this._spiderOptions.stickHoverStyle);
                    if (this._spiderOptions.invokeClickOnHover) {
                        var /** @type {?} */ p = m.ParentMarker;
                        var /** @type {?} */ ppin = p.NativePrimitve;
                        if (Microsoft.Maps.Events.hasHandler(ppin, 'click')) {
                            Microsoft.Maps.Events.invoke(ppin, 'click', e);
                        }
                    }
                }
            };
        /**
         * Sets the options for spider behavior.
         *
         * \@memberof BingClusterLayer
         * @param {?} options ISpiderClusterOptions containing the options enumeration controlling the spider cluster behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        BingClusterLayer.prototype.SetSpiderOptions = /**
         * Sets the options for spider behavior.
         *
         * \@memberof BingClusterLayer
         * @param {?} options ISpiderClusterOptions containing the options enumeration controlling the spider cluster behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                if (options) {
                    if (typeof options.circleSpiralSwitchover === 'number') {
                        this._spiderOptions.circleSpiralSwitchover = options.circleSpiralSwitchover;
                    }
                    if (typeof options.collapseClusterOnMapChange === 'boolean') {
                        this._spiderOptions.collapseClusterOnMapChange = options.collapseClusterOnMapChange;
                    }
                    if (typeof options.collapseClusterOnNthClick === 'number') {
                        this._spiderOptions.collapseClusterOnNthClick = options.collapseClusterOnNthClick;
                    }
                    if (typeof options.invokeClickOnHover === 'boolean') {
                        this._spiderOptions.invokeClickOnHover = options.invokeClickOnHover;
                    }
                    if (typeof options.minSpiralAngleSeperation === 'number') {
                        this._spiderOptions.minSpiralAngleSeperation = options.minSpiralAngleSeperation;
                    }
                    if (typeof options.spiralDistanceFactor === 'number') {
                        this._spiderOptions.spiralDistanceFactor = options.spiralDistanceFactor;
                    }
                    if (typeof options.minCircleLength === 'number') {
                        this._spiderOptions.minCircleLength = options.minCircleLength;
                    }
                    if (options.stickHoverStyle) {
                        this._spiderOptions.stickHoverStyle = options.stickHoverStyle;
                    }
                    if (options.stickStyle) {
                        this._spiderOptions.stickStyle = options.stickStyle;
                    }
                    if (options.markerSelected) {
                        this._spiderOptions.markerSelected = options.markerSelected;
                    }
                    if (options.markerUnSelected) {
                        this._spiderOptions.markerUnSelected = options.markerUnSelected;
                    }
                    if (typeof options.visible === 'boolean') {
                        this._spiderOptions.visible = options.visible;
                    }
                    this.SetOptions(/** @type {?} */ (options));
                }
            };
        /**
         * Expands a cluster into it's open spider layout.
         *
         * \@memberof BingClusterLayer
         * @param {?} cluster The cluster to show in it's open spider layout..
         *
         * @return {?}
         */
        BingClusterLayer.prototype.ShowSpiderCluster = /**
         * Expands a cluster into it's open spider layout.
         *
         * \@memberof BingClusterLayer
         * @param {?} cluster The cluster to show in it's open spider layout..
         *
         * @return {?}
         */
            function (cluster) {
                this.HideSpiderCluster();
                this._currentCluster = cluster;
                if (cluster && cluster.containedPushpins) {
                    // Create spider data.
                    var /** @type {?} */ m = ((this._maps)).MapInstance;
                    var /** @type {?} */ pins = cluster.containedPushpins;
                    var /** @type {?} */ center = cluster.getLocation();
                    var /** @type {?} */ centerPoint = (m.tryLocationToPixel(center, Microsoft.Maps.PixelReference.control));
                    var /** @type {?} */ stick = void 0;
                    var /** @type {?} */ angle = 0;
                    var /** @type {?} */ makeSpiral = pins.length > this._spiderOptions.circleSpiralSwitchover;
                    var /** @type {?} */ legPixelLength = void 0;
                    var /** @type {?} */ stepAngle = void 0;
                    var /** @type {?} */ stepLength = void 0;
                    if (makeSpiral) {
                        legPixelLength = this._spiderOptions.minCircleLength / Math.PI;
                        stepLength = 2 * Math.PI * this._spiderOptions.spiralDistanceFactor;
                    }
                    else {
                        stepAngle = 2 * Math.PI / pins.length;
                        legPixelLength = (this._spiderOptions.spiralDistanceFactor / stepAngle / Math.PI / 2) * pins.length;
                        if (legPixelLength < this._spiderOptions.minCircleLength) {
                            legPixelLength = this._spiderOptions.minCircleLength;
                        }
                    }
                    for (var /** @type {?} */ i = 0, /** @type {?} */ len = pins.length; i < len; i++) {
                        // Calculate spider pin location.
                        if (!makeSpiral) {
                            angle = stepAngle * i;
                        }
                        else {
                            angle += this._spiderOptions.minSpiralAngleSeperation / legPixelLength + i * 0.0005;
                            legPixelLength += stepLength / angle;
                        }
                        var /** @type {?} */ point = new Microsoft.Maps.Point(centerPoint.x + legPixelLength * Math.cos(angle), centerPoint.y + legPixelLength * Math.sin(angle));
                        var /** @type {?} */ loc = (m.tryPixelToLocation(point, Microsoft.Maps.PixelReference.control));
                        // Create stick to pin.
                        stick = new Microsoft.Maps.Polyline([center, loc], this._spiderOptions.stickStyle);
                        this._spiderLayer.add(stick);
                        // Create pin in spiral that contains same metadata as parent pin.
                        var /** @type {?} */ pin = new Microsoft.Maps.Pushpin(loc);
                        pin.metadata = pins[i].metadata || {};
                        pin.metadata.isClusterMarker = true;
                        pin.setOptions(this.GetBasicPushpinOptions(pins[i]));
                        this._spiderLayer.add(pin);
                        var /** @type {?} */ spiderMarker = new BingSpiderClusterMarker(pin, null, this._spiderLayer);
                        spiderMarker.Stick = stick;
                        spiderMarker.ParentMarker = /** @type {?} */ (this.GetMarkerFromBingMarker(pins[i]));
                        this._spiderMarkers.push(spiderMarker);
                        this._spiderMarkerLookup.set(pin, spiderMarker);
                    }
                    this._mapclicks = 0;
                }
            };
        return BingClusterLayer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the {\@link InfoWindow} contract for the Bing Maps V8 map architecture.
     *
     * @export
     */
    var /**
     * Concrete implementation of the {\@link InfoWindow} contract for the Bing Maps V8 map architecture.
     *
     * @export
     */ BingInfoWindow = (function () {
        /**
         * Creates an instance of BingInfoWindow.
         * @param _infoBox - A {@link Microsoft.Maps.Infobox} instance underlying the model
         * @memberof BingInfoWindow
         */
        function BingInfoWindow(_infoBox) {
            this._infoBox = _infoBox;
            this._isOpen = false;
        }
        Object.defineProperty(BingInfoWindow.prototype, "IsOpen", {
            get: /**
             * Gets whether the info box is currently open.
             *
             * \@readonly
             * \@memberof BingInfoWindow
             * @return {?}
             */ function () {
                if (this._infoBox && this._infoBox.getOptions().visible === true) {
                    return true;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingInfoWindow.prototype, "NativePrimitve", {
            get: /**
             * Gets native primitve underlying the model.
             *
             * \@memberof BingInfoWindow
             * \@property
             * \@readonly
             * @return {?}
             */ function () {
                return this._infoBox;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener to the InfoWindow.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
        BingInfoWindow.prototype.AddListener = /**
         * Adds an event listener to the InfoWindow.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                var _this = this;
                Microsoft.Maps.Events.addHandler(this._infoBox, eventType, function (e) {
                    if (e.eventName === 'infoboxChanged') {
                        if (_this._infoBox.getOptions().visible === true) {
                            _this._isOpen = true;
                        }
                        else {
                            if (_this._infoBox.getOptions().visible === false && _this._isOpen === true) {
                                _this._isOpen = false;
                                fn(e);
                            }
                        }
                    }
                    else {
                        fn(e);
                    }
                });
            };
        /**
         * Closes the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?}
         */
        BingInfoWindow.prototype.Close = /**
         * Closes the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?}
         */
            function () {
                var /** @type {?} */ o = {};
                o.visible = false;
                this._infoBox.setOptions(o);
            };
        /**
         * Gets the position of the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?} - Returns the geo coordinates of the info window.
         */
        BingInfoWindow.prototype.GetPosition = /**
         * Gets the position of the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?} - Returns the geo coordinates of the info window.
         */
            function () {
                var /** @type {?} */ p = {
                    latitude: this._infoBox.getLocation().latitude,
                    longitude: this._infoBox.getLocation().longitude
                };
                return p;
            };
        /**
         * Opens the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?}
         */
        BingInfoWindow.prototype.Open = /**
         * Opens the info window.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @return {?}
         */
            function () {
                var /** @type {?} */ o = {};
                o.visible = true;
                this._infoBox.setOptions(o);
            };
        /**
         * Sets the info window options.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} options - Info window options to set. The options will be merged with any existing options.
         *
         * @return {?}
         */
        BingInfoWindow.prototype.SetOptions = /**
         * Sets the info window options.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} options - Info window options to set. The options will be merged with any existing options.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = BingConversions.TranslateInfoBoxOptions(options);
                this._infoBox.setOptions(o);
            };
        /**
         * Sets the info window position.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} position - Geo coordinates to move the anchor of the info window to.
         *
         * @return {?}
         */
        BingInfoWindow.prototype.SetPosition = /**
         * Sets the info window position.
         *
         * \@memberof BingInfoWindow
         * \@method
         * @param {?} position - Geo coordinates to move the anchor of the info window to.
         *
         * @return {?}
         */
            function (position) {
                var /** @type {?} */ l = BingConversions.TranslateLocation(position);
                this._infoBox.setLocation(l);
            };
        return BingInfoWindow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract base implementing a label to be placed on the map.
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * Abstract base implementing a label to be placed on the map.
     *
     * @export
     * @abstract
     * @abstract
     */ MapLabel = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new MapLabel
         * @param options Optional properties to set.
         */
        function MapLabel(options) {
            this.Set('fontFamily', 'sans-serif');
            this.Set('fontSize', 12);
            this.Set('fontColor', '#ffffff');
            this.Set('strokeWeight', 4);
            this.Set('strokeColor', '#000000');
            this.Set('align', 'center');
            this.SetValues(options);
        }
        /**
         * Deletes the label from the map. This method does not atually delete the label itself, so
         * it can be readded to map later.
         * \@memberof MapLabel
         * \@method
         * @return {?}
         */
        MapLabel.prototype.Delete = /**
         * Deletes the label from the map. This method does not atually delete the label itself, so
         * it can be readded to map later.
         * \@memberof MapLabel
         * \@method
         * @return {?}
         */
            function () {
                this.SetMap(null);
            };
        /**
         * Delegate called when underlying properties change.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} prop - The property or properties that have changed.
         * @return {?}
         */
        MapLabel.prototype.Changed = /**
         * Delegate called when underlying properties change.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} prop - The property or properties that have changed.
         * @return {?}
         */
            function (prop) {
                var /** @type {?} */ shouldRunDrawCanvas = false;
                var /** @type {?} */ shouldRunDraw = false;
                if (!Array.isArray(prop)) {
                    prop = [prop];
                }
                prop.forEach(function (p) {
                    switch (p) {
                        case 'fontFamily':
                        case 'fontSize':
                        case 'fontColor':
                        case 'strokeWeight':
                        case 'strokeColor':
                        case 'align':
                        case 'text':
                            shouldRunDrawCanvas = true;
                            break;
                        case 'maxZoom':
                        case 'minZoom':
                        case 'offset':
                        case 'hidden':
                        case 'position':
                            shouldRunDraw = true;
                            break;
                    }
                });
                if (shouldRunDrawCanvas) {
                    this.DrawCanvas();
                }
                if (shouldRunDraw) {
                    this.Draw();
                }
            };
        ///
        /// Protected methods
        ///
        /**
         * Get the visibility of the label. Visibility depends on Zoom settings.
         * @returns - blank string if visible, 'hidden' if invisible.
         * @protected
         */
        /**
         * Get the visibility of the label. Visibility depends on Zoom settings.
         * @protected
         * @return {?} - blank string if visible, 'hidden' if invisible.
         */
        MapLabel.prototype.GetVisible = /**
         * Get the visibility of the label. Visibility depends on Zoom settings.
         * @protected
         * @return {?} - blank string if visible, 'hidden' if invisible.
         */
            function () {
                var /** @type {?} */ minZoom = this.Get('minZoom');
                var /** @type {?} */ maxZoom = this.Get('maxZoom');
                var /** @type {?} */ hidden = this.Get('hidden');
                if (hidden) {
                    return 'hidden';
                }
                if (minZoom === undefined && maxZoom === undefined) {
                    return '';
                }
                if (!this.GetMap()) {
                    return '';
                }
                var /** @type {?} */ mapZoom = this.GetMap().getZoom();
                if (mapZoom < minZoom || mapZoom > maxZoom) {
                    return 'hidden';
                }
                return '';
            };
        /**
         * Draws the label to the canvas 2d context.
         * @memberof MapLabel
         * @method
         * @protected
         */
        /**
         * Draws the label to the canvas 2d context.
         * \@memberof MapLabel
         * \@method
         * @protected
         * @return {?}
         */
        MapLabel.prototype.DrawCanvas = /**
         * Draws the label to the canvas 2d context.
         * \@memberof MapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                if (!this._canvas) {
                    return;
                }
                var /** @type {?} */ style = this._canvas.style;
                style.zIndex = this.Get('zIndex');
                var /** @type {?} */ ctx = this._canvas.getContext('2d');
                ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
                ctx.strokeStyle = this.Get('strokeColor');
                ctx.font = this.Get('fontSize') + 'px ' + this.Get('fontFamily');
                var /** @type {?} */ backgroundColor = this.Get('backgroundColor');
                var /** @type {?} */ strokeWeight = Number(this.Get('strokeWeight'));
                var /** @type {?} */ text = this.Get('text');
                var /** @type {?} */ textMeasure = ctx.measureText(text);
                var /** @type {?} */ textWidth = textMeasure.width;
                if (text && strokeWeight && strokeWeight > 0) {
                    ctx.lineWidth = strokeWeight;
                    ctx.strokeText(text, 4, 4);
                }
                if (backgroundColor && backgroundColor !== '') {
                    ctx.fillStyle = backgroundColor;
                    ctx.fillRect(0, 0, textWidth + 8, (parseInt(ctx.font, 10) * 2) - 2);
                }
                ctx.fillStyle = this.Get('fontColor');
                ctx.fillText(text, 4, 4);
                style.marginLeft = this.GetMarginLeft(textWidth) + 'px';
                style.marginTop = '-0.4em';
                style.pointerEvents = 'none';
                // Bring actual text top in line with desired latitude.
                // Cheaper than calculating height of text.
            };
        /**
         * Gets the appropriate margin-left for the canvas.
         * @param textWidth  - The width of the text, in pixels.
         * @returns - The margin-left, in pixels.
         * @protected
         * @method
         * @memberof MapLabel
         */
        /**
         * Gets the appropriate margin-left for the canvas.
         * @protected
         * \@method
         * \@memberof MapLabel
         * @param {?} textWidth  - The width of the text, in pixels.
         * @return {?} - The margin-left, in pixels.
         */
        MapLabel.prototype.GetMarginLeft = /**
         * Gets the appropriate margin-left for the canvas.
         * @protected
         * \@method
         * \@memberof MapLabel
         * @param {?} textWidth  - The width of the text, in pixels.
         * @return {?} - The margin-left, in pixels.
         */
            function (textWidth) {
                switch (this.Get('align')) {
                    case 'left': return 0;
                    case 'right': return -textWidth;
                }
                return textWidth / -2;
            };
        /**
         * Called when the label is removed from the map.
         * @method
         * @protected
         * @memberof MapLabel
         */
        /**
         * Called when the label is removed from the map.
         * \@method
         * @protected
         * \@memberof MapLabel
         * @return {?}
         */
        MapLabel.prototype.OnRemove = /**
         * Called when the label is removed from the map.
         * \@method
         * @protected
         * \@memberof MapLabel
         * @return {?}
         */
            function () {
                if (this._canvas && this._canvas.parentNode) {
                    this._canvas.parentNode.removeChild(this._canvas);
                }
            };
        return MapLabel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ id$1 = 0;
    /**
     * Implements map a labled to be placed on the map.
     *
     * @export
     */
    var /**
     * Implements map a labled to be placed on the map.
     *
     * @export
     */ BingMapLabel = (function (_super) {
        __extends(BingMapLabel, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates a new MapLabel
         * @param options Optional properties to set.
         */
        function BingMapLabel(options) {
            var _this = this;
            options["fontSize"] = options["fontSize"] || 12;
            options["fontColor"] = options["fontColor"] || '#ffffff';
            options["strokeWeight"] = options["strokeWeight"] || 2;
            options["strokeColor"] = options["strokeColor"] || '#000000';
            _this = _super.call(this, options) || this;
            ((_this))._options.beneathLabels = false;
            return _this;
        }
        Object.defineProperty(BingMapLabel.prototype, "DefaultLabelStyle", {
            get: /**
             * Returns the default label style for the platform
             *
             * \@readonly
             * @abstract
             * \@memberof BingMapLabel
             * @return {?}
             */ function () {
                return {
                    fontSize: 12,
                    fontFamily: 'sans-serif',
                    fontColor: '#ffffff',
                    strokeWeight: 2,
                    strokeColor: '#000000'
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the value of a setting.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @return {?} - The value of the setting.
         */
        BingMapLabel.prototype.Get = /**
         * Gets the value of a setting.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @return {?} - The value of the setting.
         */
            function (key) {
                return ((this))[key];
            };
        /**
         * Gets the map associted with the label.
         *
         * \@memberof BingMapLabel
         * \@method
         * @return {?}
         */
        BingMapLabel.prototype.GetMap = /**
         * Gets the map associted with the label.
         *
         * \@memberof BingMapLabel
         * \@method
         * @return {?}
         */
            function () {
                return ((this)).getMap();
            };
        /**
         * Set the value for a setting.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @param {?} val - The value to set.
         * @return {?}
         */
        BingMapLabel.prototype.Set = /**
         * Set the value for a setting.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @param {?} val - The value to set.
         * @return {?}
         */
            function (key, val) {
                if (key === 'position' && !val.hasOwnProperty('altitude') && val.hasOwnProperty('latitude') && val.hasOwnProperty('longitude')) {
                    val = new Microsoft.Maps.Location(val.latitude, val.longitude);
                }
                if (this.Get(key) !== val) {
                    ((this))[key] = val;
                    this.Changed(key);
                }
            };
        /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
        BingMapLabel.prototype.SetMap = /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
            function (map) {
                var /** @type {?} */ m = this.GetMap();
                if (map === m) {
                    return;
                }
                if (m) {
                    m.layers.remove(this);
                }
                if (map != null) {
                    map.layers.insert(this);
                }
            };
        /**
         * Applies settings to the object
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} options - An object containing the settings key value pairs.
         * @return {?}
         */
        BingMapLabel.prototype.SetValues = /**
         * Applies settings to the object
         *
         * \@memberof BingMapLabel
         * \@method
         * @param {?} options - An object containing the settings key value pairs.
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ p = new Array();
                for (var /** @type {?} */ key in options) {
                    if (key !== '') {
                        if (key === 'position' && !options[key].hasOwnProperty('altitude') &&
                            options[key].hasOwnProperty('latitude') && options[key].hasOwnProperty('longitude')) {
                            options[key] = new Microsoft.Maps.Location(options[key].latitude, options[key].longitude);
                        }
                        if (this.Get(key) !== options[key]) {
                            ((this))[key] = options[key];
                            p.push(key);
                        }
                    }
                }
                if (p.length > 0) {
                    this.Changed(p);
                }
            };
        ///
        /// Protected methods
        ///
        /**
         * Draws the label on the map.
         * @memberof BingMapLabel
         * @method
         * @protected
         */
        /**
         * Draws the label on the map.
         * \@memberof BingMapLabel
         * \@method
         * @protected
         * @return {?}
         */
        BingMapLabel.prototype.Draw = /**
         * Draws the label on the map.
         * \@memberof BingMapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                var /** @type {?} */ visibility = this.GetVisible();
                var /** @type {?} */ m = this.GetMap();
                if (!this._canvas) {
                    return;
                }
                if (!m) {
                    return;
                }
                var /** @type {?} */ style = this._canvas.style;
                if (visibility !== '') {
                    // label is not visible, don't calculate positions etc.
                    style['visibility'] = visibility;
                    return;
                }
                var /** @type {?} */ offset = this.Get('offset');
                var /** @type {?} */ latLng = this.Get('position');
                if (!latLng) {
                    return;
                }
                if (!offset) {
                    offset = new Microsoft.Maps.Point(0, 0);
                }
                var /** @type {?} */ pos = (m.tryLocationToPixel(latLng, Microsoft.Maps.PixelReference.control));
                style['top'] = (pos.y + offset.y) + 'px';
                style['left'] = (pos.x + offset.x) + 'px';
                style['visibility'] = visibility;
            };
        /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * @memberof BingMapLabel
         * @method
         * @protected
         */
        /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * \@memberof BingMapLabel
         * \@method
         * @protected
         * @return {?}
         */
        BingMapLabel.prototype.OnAdd = /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * \@memberof BingMapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                this._canvas = document.createElement('canvas');
                this._canvas.id = "xMapLabel" + id$1++;
                var /** @type {?} */ style = this._canvas.style;
                style.position = 'absolute';
                var /** @type {?} */ ctx = this._canvas.getContext('2d');
                ctx.lineJoin = 'round';
                ctx.textBaseline = 'top';
                ((this)).setHtmlElement(this._canvas);
            };
        /**
         * Delegate callled when the label is loaded
         * \@memberof BingMapLabel
         * \@method
         * @return {?}
         */
        BingMapLabel.prototype.OnLoad = /**
         * Delegate callled when the label is loaded
         * \@memberof BingMapLabel
         * \@method
         * @return {?}
         */
            function () {
                var _this = this;
                Microsoft.Maps.Events.addHandler(this.GetMap(), 'viewchange', function () {
                    _this.Changed('position');
                });
                this.DrawCanvas();
                this.Draw();
            };
        return BingMapLabel;
    }(MapLabel));
    /**
     * Helper function to extend the CustomOverlay into the MapLabel
     *
     * @export
     * \@method
     * @return {?}
     */
    function MixinMapLabelWithOverlayView() {
        var /** @type {?} */ x = BingMapLabel.prototype;
        BingMapLabel.prototype = /** @type {?} */ (new Microsoft.Maps.CustomOverlay());
        for (var /** @type {?} */ y in x) {
            if (((x))[y] != null) {
                ((BingMapLabel.prototype))[y] = ((x))[y];
            }
        }
        ((BingMapLabel.prototype))['onAdd'] = x['OnAdd'];
        ((BingMapLabel.prototype))['onLoad'] = x['OnLoad'];
        ((BingMapLabel.prototype))['onRemove'] = x['OnRemove'];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation for a polygon model for Bing Maps V8.
     *
     * @export
     */
    var /**
     * Concrete implementation for a polygon model for Bing Maps V8.
     *
     * @export
     */ BingPolygon = (function (_super) {
        __extends(BingPolygon, _super);
        ///
        /// constructor
        ///
        /**
         * Creates an instance of BingPolygon.
         * @param _polygon - The {@link Microsoft.Maps.Polygon} underlying the model.
         * @param _mapService Instance of the Map Service.
         * @param _layer - The context layer.
         * @memberof BingPolygon
         */
        function BingPolygon(_polygon, _mapService, _layer) {
            var _this = _super.call(this) || this;
            _this._polygon = _polygon;
            _this._mapService = _mapService;
            _this._layer = _layer;
            _this._map = null;
            _this._isEditable = false;
            _this._title = '';
            _this._maxZoom = -1;
            _this._minZoom = -1;
            _this._showLabel = false;
            _this._showTooltip = false;
            _this._label = null;
            _this._tooltip = null;
            _this._hasToolTipReceiver = false;
            _this._tooltipVisible = false;
            _this._metadata = new Map();
            _this._map = _this._mapService.MapInstance;
            _this._originalPath = _this.GetPaths();
            return _this;
        }
        Object.defineProperty(BingPolygon.prototype, "LabelMaxZoom", {
            get: /**
             * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.
             *
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._maxZoom; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._maxZoom = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "LabelMinZoom", {
            get: /**
             * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.
             *
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._minZoom; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._minZoom = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "Metadata", {
            get: /**
             * Gets the polygon metadata.
             *
             * \@readonly
             * \@memberof BingPolygon
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the polygon, in this case {\@link Microsoft.Maps.Polygon}
             *
             * \@readonly
             * \@memberof BingPolygon
             * @return {?}
             */ function () { return this._polygon; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "ShowLabel", {
            get: /**
             * Gets or sets whether to show the label
             *
             * @abstract
             * \@memberof BingPolygon
             * \@property
             * @return {?}
             */ function () { return this._showLabel; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showLabel = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "ShowTooltip", {
            get: /**
             * Gets or sets whether to show the tooltip
             *
             * @abstract
             * \@memberof BingPolygon
             * \@property
             * @return {?}
             */ function () { return this._showTooltip; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showTooltip = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolygon.prototype, "Title", {
            get: /**
             * Gets or sets the title off the polygon
             *
             * @abstract
             * \@memberof BingPolygon
             * \@property
             * @return {?}
             */ function () { return this._title; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._title = val;
                this.ManageLabel();
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds a delegate for an event.
         *
         * \@memberof BingPolygon
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
        BingPolygon.prototype.AddListener = /**
         * Adds a delegate for an event.
         *
         * \@memberof BingPolygon
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
            function (eventType, fn) {
                var _this = this;
                var /** @type {?} */ supportedEvents = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup'];
                if (supportedEvents.indexOf(eventType) !== -1) {
                    Microsoft.Maps.Events.addHandler(this._polygon, eventType, function (e) {
                        fn(e);
                    });
                }
                if (eventType === 'mousemove') {
                    var /** @type {?} */ handlerId_1;
                    Microsoft.Maps.Events.addHandler(this._polygon, 'mouseover', function (e) {
                        handlerId_1 = Microsoft.Maps.Events.addHandler(_this._map, 'mousemove', function (m) { return fn(m); });
                    });
                    Microsoft.Maps.Events.addHandler(this._polygon, 'mouseout', function (e) {
                        if (handlerId_1) {
                            Microsoft.Maps.Events.removeHandler(handlerId_1);
                        }
                    });
                }
                if (eventType === 'pathchanged') {
                    this._editingCompleteEmitter = /** @type {?} */ (fn);
                }
            };
        /**
         * Deleted the polygon.
         *
         * \@memberof BingPolygon
         * @return {?}
         */
        BingPolygon.prototype.Delete = /**
         * Deleted the polygon.
         *
         * \@memberof BingPolygon
         * @return {?}
         */
            function () {
                if (this._layer) {
                    this._layer.remove(this.NativePrimitve);
                }
                else {
                    this._map.entities.remove(this.NativePrimitve);
                }
                if (this._label) {
                    this._label.Delete();
                }
                if (this._tooltip) {
                    this._tooltip.Delete();
                }
            };
        /**
         * Gets whether the polygon is draggable.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the polygon is dragable, false otherwise.
         *
         */
        BingPolygon.prototype.GetDraggable = /**
         * Gets whether the polygon is draggable.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the polygon is dragable, false otherwise.
         *
         */
            function () {
                return false;
            };
        /**
         * Gets whether the polygon path can be edited.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
        BingPolygon.prototype.GetEditable = /**
         * Gets whether the polygon path can be edited.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
            function () {
                return this._isEditable;
            };
        /**
         * Gets the polygon path.
         *
         * \@memberof BingPolygon
         * @return {?} - Array of {\@link ILatLong} objects describing the polygon path.
         *
         */
        BingPolygon.prototype.GetPath = /**
         * Gets the polygon path.
         *
         * \@memberof BingPolygon
         * @return {?} - Array of {\@link ILatLong} objects describing the polygon path.
         *
         */
            function () {
                var /** @type {?} */ p = this._polygon.getLocations();
                var /** @type {?} */ path = new Array();
                p.forEach(function (l) { return path.push({ latitude: l.latitude, longitude: l.longitude }); });
                return path;
            };
        /**
         * Gets the polygon paths.
         *
         * \@memberof BingPolygon
         * @return {?} - Array of Array of {\@link ILatLong} objects describing multiple polygon paths.
         *
         */
        BingPolygon.prototype.GetPaths = /**
         * Gets the polygon paths.
         *
         * \@memberof BingPolygon
         * @return {?} - Array of Array of {\@link ILatLong} objects describing multiple polygon paths.
         *
         */
            function () {
                var /** @type {?} */ p = this._polygon.getRings();
                var /** @type {?} */ paths = new Array();
                p.forEach(function (x) {
                    var /** @type {?} */ path = new Array();
                    x.forEach(function (y) { return path.push({ latitude: y.latitude, longitude: y.longitude }); });
                    paths.push(path);
                });
                return paths;
            };
        /**
         * Gets whether the polygon is visible.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the polygon is visible, false otherwise.
         *
         */
        BingPolygon.prototype.GetVisible = /**
         * Gets whether the polygon is visible.
         *
         * \@memberof BingPolygon
         * @return {?} - True if the polygon is visible, false otherwise.
         *
         */
            function () {
                return this._polygon.getVisible();
            };
        /**
         * Sets whether the polygon is dragable.
         *
         * \@memberof BingPolygon
         * @param {?} draggable - True to make the polygon dragable, false otherwise.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetDraggable = /**
         * Sets whether the polygon is dragable.
         *
         * \@memberof BingPolygon
         * @param {?} draggable - True to make the polygon dragable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                //      ?forum=bingmaps
                throw (new Error('The bing maps implementation currently does not support draggable polygons.'));
            };
        /**
         * Sets wether the polygon path is editable.
         *
         * \@memberof BingPolygon
         * @param {?} editable - True to make polygon path editable, false otherwise.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetEditable = /**
         * Sets wether the polygon path is editable.
         *
         * \@memberof BingPolygon
         * @param {?} editable - True to make polygon path editable, false otherwise.
         *
         * @return {?}
         */
            function (editable) {
                var _this = this;
                var /** @type {?} */ isChanged = this._isEditable !== editable;
                this._isEditable = editable;
                if (!isChanged) {
                    return;
                }
                if (this._isEditable) {
                    this._originalPath = this.GetPaths();
                    this._mapService.GetDrawingTools().then(function (t) {
                        t.edit(_this._polygon);
                    });
                }
                else {
                    this._mapService.GetDrawingTools().then(function (t) {
                        t.finish(function (editedPolygon) {
                            if (editedPolygon !== _this._polygon || !_this._editingCompleteEmitter) {
                                return;
                            }
                            var /** @type {?} */ newPath = _this.GetPaths();
                            var /** @type {?} */ originalPath = _this._originalPath;
                            _this.SetPaths(newPath);
                            // this is necessary for the new path to persist it appears.
                            // this is necessary for the new path to persist it appears.
                            _this._editingCompleteEmitter({
                                Click: null,
                                Polygon: _this,
                                OriginalPath: originalPath,
                                NewPath: newPath
                            });
                        });
                    });
                }
            };
        /**
         * Sets the polygon options
         *
         * \@memberof Polygon
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetOptions = /**
         * Sets the polygon options
         *
         * \@memberof Polygon
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = BingConversions.TranslatePolygonOptions(options);
                this._polygon.setOptions(o);
                if (options.visible != null && this._showLabel && this._label) {
                    this._label.Set('hidden', !options.visible);
                }
                if (typeof options.editable !== 'undefined') {
                    this.SetEditable(options.editable);
                }
            };
        /**
         * Sets the polygon path.
         *
         * \@memberof BingPolygon
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polygons path.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetPath = /**
         * Sets the polygon path.
         *
         * \@memberof BingPolygon
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polygons path.
         *
         * @return {?}
         */
            function (path) {
                var /** @type {?} */ p = new Array();
                path.forEach(function (x) { return p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)); });
                this._originalPath = [path];
                this._polygon.setLocations(p);
                if (this._label) {
                    this._centroid = null;
                    this.ManageLabel();
                }
            };
        /**
         * Set the polygon path or paths.
         *
         * \@memberof BingPolygon
         * @param {?} paths
         * An Array of {\@link ILatLong} (or array of arrays) describing the polygons path(s).
         *
         * @return {?}
         */
        BingPolygon.prototype.SetPaths = /**
         * Set the polygon path or paths.
         *
         * \@memberof BingPolygon
         * @param {?} paths
         * An Array of {\@link ILatLong} (or array of arrays) describing the polygons path(s).
         *
         * @return {?}
         */
            function (paths) {
                if (paths == null) {
                    return;
                }
                if (!Array.isArray(paths)) {
                    return;
                }
                if (paths.length === 0) {
                    this._polygon.setRings(new Array());
                    if (this._label) {
                        this._label.Delete();
                        this._label = null;
                    }
                    return;
                }
                if (Array.isArray(paths[0])) {
                    // parameter is an array or arrays
                    var /** @type {?} */ p_1 = new Array();
                    ((paths)).forEach(function (path) {
                        var /** @type {?} */ _p = new Array();
                        path.forEach(function (x) { return _p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)); });
                        p_1.push(_p);
                    });
                    this._originalPath = /** @type {?} */ (paths);
                    this._polygon.setRings(p_1);
                    if (this._label) {
                        this._centroid = null;
                        this.ManageLabel();
                    }
                }
                else {
                    // parameter is a simple array....
                    this.SetPath(/** @type {?} */ (paths));
                }
            };
        /**
         * Sets whether the polygon is visible.
         *
         * \@memberof BingPolygon
         * @param {?} visible - True to set the polygon visible, false otherwise.
         *
         * @return {?}
         */
        BingPolygon.prototype.SetVisible = /**
         * Sets whether the polygon is visible.
         *
         * \@memberof BingPolygon
         * @param {?} visible - True to set the polygon visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._polygon.setOptions(/** @type {?} */ ({ visible: visible }));
                if (this._showLabel && this._label) {
                    this._label.Set('hidden', !visible);
                }
            };
        /**
         * Configures the label for the polygon
         * \@memberof Polygon
         * @return {?}
         */
        BingPolygon.prototype.ManageLabel = /**
         * Configures the label for the polygon
         * \@memberof Polygon
         * @return {?}
         */
            function () {
                if (this.GetPath == null || this.GetPath().length === 0) {
                    return;
                }
                if (this._showLabel && this._title != null && this._title !== '') {
                    var /** @type {?} */ o = {
                        text: this._title,
                        position: BingConversions.TranslateLocation(this.Centroid)
                    };
                    if (o["position"] == null) {
                        return;
                    }
                    if (this._minZoom !== -1) {
                        o["minZoom"] = this._minZoom;
                    }
                    if (this._maxZoom !== -1) {
                        o["maxZoom"] = this._maxZoom;
                    }
                    if (this._label == null) {
                        this._label = new BingMapLabel(o);
                        this._label.SetMap(this._map);
                    }
                    else {
                        this._label.SetValues(o);
                    }
                    this._label.Set('hidden', !this.GetVisible());
                }
                else {
                    if (this._label) {
                        this._label.SetMap(null);
                        this._label = null;
                    }
                }
            };
        /**
         * Configures the tooltip for the polygon
         * \@memberof Polygon
         * @return {?}
         */
        BingPolygon.prototype.ManageTooltip = /**
         * Configures the tooltip for the polygon
         * \@memberof Polygon
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._showTooltip && this._title != null && this._title !== '') {
                    var /** @type {?} */ o = {
                        text: this._title,
                        align: 'left',
                        offset: new Microsoft.Maps.Point(0, 25),
                        backgroundColor: 'bisque',
                        hidden: true,
                        fontSize: 12,
                        fontColor: '#000000',
                        strokeWeight: 0
                    };
                    if (this._tooltip == null) {
                        this._tooltip = new BingMapLabel(o);
                        this._tooltip.SetMap(this._map);
                    }
                    else {
                        this._tooltip.SetValues(o);
                    }
                    if (!this._hasToolTipReceiver) {
                        this._mouseOverListener = Microsoft.Maps.Events.addHandler(this._polygon, 'mouseover', function (e) {
                            _this._tooltip.Set('position', e.location);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                            _this._mouseMoveListener = Microsoft.Maps.Events.addHandler(_this._map, 'mousemove', function (m) {
                                if (_this._tooltipVisible && m.location && m.primitive === _this._polygon) {
                                    _this._tooltip.Set('position', m.location);
                                }
                            });
                        });
                        this._mouseOutListener = Microsoft.Maps.Events.addHandler(this._polygon, 'mouseout', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', true);
                                _this._tooltipVisible = false;
                            }
                            if (_this._mouseMoveListener) {
                                Microsoft.Maps.Events.removeHandler(_this._mouseMoveListener);
                            }
                        });
                        this._hasToolTipReceiver = true;
                    }
                }
                if ((!this._showTooltip || this._title === '' || this._title == null)) {
                    if (this._hasToolTipReceiver) {
                        if (this._mouseOutListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseOutListener);
                        }
                        if (this._mouseOverListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseOverListener);
                        }
                        if (this._mouseMoveListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseMoveListener);
                        }
                        this._hasToolTipReceiver = false;
                    }
                    if (this._tooltip) {
                        this._tooltip.SetMap(null);
                        this._tooltip = null;
                    }
                }
            };
        return BingPolygon;
    }(Polygon));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation for a polyline model for Bing Maps V8.
     *
     * @export
     */
    var /**
     * Concrete implementation for a polyline model for Bing Maps V8.
     *
     * @export
     */ BingPolyline = (function (_super) {
        __extends(BingPolyline, _super);
        ///
        /// constructor
        ///
        /**
         * Creates an instance of BingPolygon.
         * @param _polyline - The {@link Microsoft.Maps.Polyline} underlying the model.
         * @param _map - The context map.
         * @param _layer - The context layer.
         * @memberof BingPolyline
         */
        function BingPolyline(_polyline, _map, _layer) {
            var _this = _super.call(this) || this;
            _this._polyline = _polyline;
            _this._map = _map;
            _this._layer = _layer;
            _this._isEditable = true;
            _this._title = '';
            _this._showTooltip = false;
            _this._tooltip = null;
            _this._hasToolTipReceiver = false;
            _this._tooltipVisible = false;
            _this._metadata = new Map();
            return _this;
        }
        Object.defineProperty(BingPolyline.prototype, "Metadata", {
            get: /**
             * Gets the polyline metadata.
             *
             * \@readonly
             * \@memberof BingPolyline
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolyline.prototype, "NativePrimitve", {
            get: /**
             * Gets the Navitve Polyline underlying the model
             *
             * \@readonly
             * \@memberof BingPolyline
             * @return {?}
             */ function () { return this._polyline; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolyline.prototype, "ShowTooltip", {
            get: /**
             * Gets or sets whether to show the tooltip
             *
             * @abstract
             * \@memberof BingPolyline
             * \@property
             * @return {?}
             */ function () { return this._showTooltip; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showTooltip = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingPolyline.prototype, "Title", {
            get: /**
             * Gets or sets the title off the polyline
             *
             * @abstract
             * \@memberof BingPolyline
             * \@property
             * @return {?}
             */ function () { return this._title; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._title = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds a delegate for an event.
         *
         * \@memberof BingPolyline
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
        BingPolyline.prototype.AddListener = /**
         * Adds a delegate for an event.
         *
         * \@memberof BingPolyline
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
            function (eventType, fn) {
                var _this = this;
                var /** @type {?} */ supportedEvents = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup'];
                if (supportedEvents.indexOf(eventType) !== -1) {
                    Microsoft.Maps.Events.addHandler(this._polyline, eventType, function (e) {
                        fn(e);
                    });
                }
                if (eventType === 'mousemove') {
                    var /** @type {?} */ handlerId_1;
                    Microsoft.Maps.Events.addHandler(this._polyline, 'mouseover', function (e) {
                        handlerId_1 = Microsoft.Maps.Events.addHandler(_this._map, 'mousemove', function (m) { return fn(m); });
                    });
                    Microsoft.Maps.Events.addHandler(this._polyline, 'mouseout', function (e) {
                        if (handlerId_1) {
                            Microsoft.Maps.Events.removeHandler(handlerId_1);
                        }
                    });
                }
            };
        /**
         * Deleted the polyline.
         *
         * \@memberof BingPolyline
         * @return {?}
         */
        BingPolyline.prototype.Delete = /**
         * Deleted the polyline.
         *
         * \@memberof BingPolyline
         * @return {?}
         */
            function () {
                if (this._layer) {
                    this._layer.remove(this.NativePrimitve);
                }
                else {
                    this._map.entities.remove(this.NativePrimitve);
                }
                if (this._tooltip) {
                    this._tooltip.Delete();
                }
            };
        /**
         * Gets whether the polyline is draggable.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the polyline is dragable, false otherwise.
         *
         */
        BingPolyline.prototype.GetDraggable = /**
         * Gets whether the polyline is draggable.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the polyline is dragable, false otherwise.
         *
         */
            function () {
                return false;
            };
        /**
         * Gets whether the polyline path can be edited.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
        BingPolyline.prototype.GetEditable = /**
         * Gets whether the polyline path can be edited.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
            function () {
                return this._isEditable;
            };
        /**
         * Gets the polyline path.
         *
         * \@memberof BingPolyline
         * @return {?} - Array of {\@link ILatLong} objects describing the polyline path.
         *
         */
        BingPolyline.prototype.GetPath = /**
         * Gets the polyline path.
         *
         * \@memberof BingPolyline
         * @return {?} - Array of {\@link ILatLong} objects describing the polyline path.
         *
         */
            function () {
                var /** @type {?} */ p = this._polyline.getLocations();
                var /** @type {?} */ path = new Array();
                p.forEach(function (l) { return path.push({ latitude: l.latitude, longitude: l.longitude }); });
                return path;
            };
        /**
         * Gets whether the polyline is visible.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the polyline is visible, false otherwise.
         *
         */
        BingPolyline.prototype.GetVisible = /**
         * Gets whether the polyline is visible.
         *
         * \@memberof BingPolyline
         * @return {?} - True if the polyline is visible, false otherwise.
         *
         */
            function () {
                return this._polyline.getVisible();
            };
        /**
         * Sets whether the polyline is dragable.
         *
         * \@memberof BingPolyline
         * @param {?} draggable - True to make the polyline dragable, false otherwise.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetDraggable = /**
         * Sets whether the polyline is dragable.
         *
         * \@memberof BingPolyline
         * @param {?} draggable - True to make the polyline dragable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                throw (new Error('The bing maps implementation currently does not support draggable polylines.'));
            };
        /**
         * Sets wether the polyline path is editable.
         *
         * \@memberof BingPolyline
         * @param {?} editable - True to make polyline path editable, false otherwise.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetEditable = /**
         * Sets wether the polyline path is editable.
         *
         * \@memberof BingPolyline
         * @param {?} editable - True to make polyline path editable, false otherwise.
         *
         * @return {?}
         */
            function (editable) {
                this._isEditable = editable;
            };
        /**
         * Sets the polyline options
         *
         * \@memberof BingPolyline
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetOptions = /**
         * Sets the polyline options
         *
         * \@memberof BingPolyline
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = BingConversions.TranslatePolylineOptions(options);
                this._polyline.setOptions(o);
                if (options.path) {
                    this.SetPath(/** @type {?} */ (options.path));
                }
            };
        /**
         * Sets the polyline path.
         *
         * \@memberof BingPolyline
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polylines path.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetPath = /**
         * Sets the polyline path.
         *
         * \@memberof BingPolyline
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polylines path.
         *
         * @return {?}
         */
            function (path) {
                var /** @type {?} */ p = new Array();
                path.forEach(function (x) { return p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)); });
                this._polyline.setLocations(p);
            };
        /**
         * Sets whether the polyline is visible.
         *
         * \@memberof BingPolyline
         * @param {?} visible - True to set the polyline visible, false otherwise.
         *
         * @return {?}
         */
        BingPolyline.prototype.SetVisible = /**
         * Sets whether the polyline is visible.
         *
         * \@memberof BingPolyline
         * @param {?} visible - True to set the polyline visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._polyline.setOptions(/** @type {?} */ ({ visible: visible }));
            };
        /**
         * Configures the tooltip for the polygon
         * \@memberof Polygon
         * @return {?}
         */
        BingPolyline.prototype.ManageTooltip = /**
         * Configures the tooltip for the polygon
         * \@memberof Polygon
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._showTooltip && this._title != null && this._title !== '') {
                    var /** @type {?} */ o = {
                        text: this._title,
                        align: 'left',
                        offset: new Microsoft.Maps.Point(0, 25),
                        backgroundColor: 'bisque',
                        hidden: true,
                        fontSize: 12,
                        fontColor: '#000000',
                        strokeWeight: 0
                    };
                    if (this._tooltip == null) {
                        this._tooltip = new BingMapLabel(o);
                        this._tooltip.SetMap(this._map);
                    }
                    else {
                        this._tooltip.SetValues(o);
                    }
                    if (!this._hasToolTipReceiver) {
                        this._mouseOverListener = Microsoft.Maps.Events.addHandler(this._polyline, 'mouseover', function (e) {
                            _this._tooltip.Set('position', e.location);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        });
                        this._mouseMoveListener = Microsoft.Maps.Events.addHandler(this._map, 'mousemove', function (e) {
                            if (_this._tooltipVisible && e.location && e.primitive === _this._polyline) {
                                _this._tooltip.Set('position', e.location);
                            }
                        });
                        this._mouseOutListener = Microsoft.Maps.Events.addHandler(this._polyline, 'mouseout', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', true);
                                _this._tooltipVisible = false;
                            }
                        });
                        this._hasToolTipReceiver = true;
                    }
                }
                if ((!this._showTooltip || this._title === '' || this._title == null)) {
                    if (this._hasToolTipReceiver) {
                        if (this._mouseOutListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseOutListener);
                        }
                        if (this._mouseOverListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseOverListener);
                        }
                        if (this._mouseMoveListener) {
                            Microsoft.Maps.Events.removeHandler(this._mouseMoveListener);
                        }
                        this._hasToolTipReceiver = false;
                    }
                    if (this._tooltip) {
                        this._tooltip.SetMap(null);
                        this._tooltip = null;
                    }
                }
            };
        return BingPolyline;
    }(Polyline));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This contstant translates the abstract map events into their corresponding bing map
     * equivalents.
     */
    var /** @type {?} */ BingMapEventsLookup = {
        click: 'click',
        dblclick: 'dblclick',
        rightclick: 'rightclick',
        resize: 'resize',
        boundschanged: 'viewchangeend',
        centerchanged: 'viewchangeend',
        zoomchanged: 'viewchangeend',
        mouseover: 'mouseover',
        mouseout: 'mouseout',
        mousemove: 'mousemove',
        infowindowclose: 'infoboxChanged'
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementing a canvas overlay to be placed on the map for Bing Maps.
     *
     * @export
     */
    var /**
     * Concrete implementing a canvas overlay to be placed on the map for Bing Maps.
     *
     * @export
     */ BingCanvasOverlay = (function (_super) {
        __extends(BingCanvasOverlay, _super);
        /**
         * Creates a new instance of the BingCanvasOverlay class.
         * @param drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @memberof BingCanvasOverlay
         */
        function BingCanvasOverlay(drawCallback) {
            return _super.call(this, drawCallback) || this;
        }
        /**
         * Obtains geo coordinates for the click location
         *
         * @abstract
         * \@memberof BingCanvasOverlay
         * @param {?} e - The mouse event. Expected to implement {\@link Microsoft.Maps.IMouseEventArgs}.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
        BingCanvasOverlay.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the click location
         *
         * @abstract
         * \@memberof BingCanvasOverlay
         * @param {?} e - The mouse event. Expected to implement {\@link Microsoft.Maps.IMouseEventArgs}.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
            function (e) {
                return { latitude: e.location.latitude, longitude: e.location.longitude };
            };
        /**
         * Gets the map associted with the label.
         *
         * \@memberof BingCanvasOverlay
         * \@method
         * @return {?}
         */
        BingCanvasOverlay.prototype.GetMap = /**
         * Gets the map associted with the label.
         *
         * \@memberof BingCanvasOverlay
         * \@method
         * @return {?}
         */
            function () {
                return ((this)).getMap();
            };
        /**
         * Returns a MapLabel instance for the current platform that can be used as a tooltip.
         * This method only generates the map label. Content and placement is the responsibility
         * of the caller. Note that this method returns null until OnLoad has been called.
         *
         * \@memberof BingCanvasOverlay
         * \@method
         * @return {?} - The label to be used for the tooltip.
         */
        BingCanvasOverlay.prototype.GetToolTipOverlay = /**
         * Returns a MapLabel instance for the current platform that can be used as a tooltip.
         * This method only generates the map label. Content and placement is the responsibility
         * of the caller. Note that this method returns null until OnLoad has been called.
         *
         * \@memberof BingCanvasOverlay
         * \@method
         * @return {?} - The label to be used for the tooltip.
         */
            function () {
                var /** @type {?} */ o = {
                    align: 'left',
                    offset: new Microsoft.Maps.Point(0, 25),
                    backgroundColor: 'bisque',
                    hidden: true,
                    fontSize: 12,
                    fontColor: '#000000',
                    strokeWeight: 0
                };
                var /** @type {?} */ label = new BingMapLabel(o);
                label.SetMap(this.GetMap());
                return label;
            };
        /**
         * CanvasOverlay loaded, attach map events for updating canvas.
         * @abstract
         * \@method
         * \@memberof BingCanvasOverlay
         * @return {?}
         */
        BingCanvasOverlay.prototype.OnLoad = /**
         * CanvasOverlay loaded, attach map events for updating canvas.
         * @abstract
         * \@method
         * \@memberof BingCanvasOverlay
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ map = ((this)).getMap();
                // Get the current map view information.
                this._zoomStart = map.getZoom();
                this._centerStart = /** @type {?} */ (map.getCenter());
                // Redraw the canvas.
                this.Redraw(true);
                // When the map moves, move the canvas accordingly.
                this._viewChangeEvent = Microsoft.Maps.Events.addHandler(map, 'viewchange', function (e) {
                    if (map.getMapTypeId() === Microsoft.Maps.MapTypeId.streetside) {
                        // Don't show the canvas if the map is in Streetside mode.
                        // Don't show the canvas if the map is in Streetside mode.
                        _this._canvas.style.display = 'none';
                    }
                    else {
                        // Re-drawing the canvas as it moves would be too slow. Instead, scale and translate canvas element.
                        var /** @type {?} */ zoomCurrent = map.getZoom();
                        var /** @type {?} */ centerCurrent = map.getCenter();
                        // Calculate map scale based on zoom level difference.
                        var /** @type {?} */ scale = Math.pow(2, zoomCurrent - _this._zoomStart);
                        // Calculate the scaled dimensions of the canvas.
                        var /** @type {?} */ newWidth = map.getWidth() * scale;
                        var /** @type {?} */ newHeight = map.getHeight() * scale;
                        // Calculate offset of canvas based on zoom and center offsets.
                        var /** @type {?} */ pixelPoints = (map.tryLocationToPixel([
                            BingConversions.TranslateLocation(_this._centerStart),
                            centerCurrent
                        ], Microsoft.Maps.PixelReference.control));
                        var /** @type {?} */ centerOffsetX = pixelPoints[1].x - pixelPoints[0].x;
                        var /** @type {?} */ centerOffsetY = pixelPoints[1].y - pixelPoints[0].y;
                        var /** @type {?} */ x = (-(newWidth - map.getWidth()) / 2) - centerOffsetX;
                        var /** @type {?} */ y = (-(newHeight - map.getHeight()) / 2) - centerOffsetY;
                        // Update the canvas CSS position and dimensions.
                        // Update the canvas CSS position and dimensions.
                        _this.UpdatePosition(x, y, newWidth, newHeight);
                    }
                });
                // When the map stops moving, render new data on the canvas.
                this._viewChangeEndEvent = Microsoft.Maps.Events.addHandler(map, 'viewchangeend', function (e) {
                    _this.UpdateCanvas();
                });
                // Update the position of the overlay when the map is resized.
                this._mapResizeEvent = Microsoft.Maps.Events.addHandler(map, 'mapresize', function (e) {
                    _this.UpdateCanvas();
                });
                // set the overlay to ready state
                this._readyResolver(true);
            };
        /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
        BingCanvasOverlay.prototype.SetMap = /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
            function (map) {
                var /** @type {?} */ m = this.GetMap();
                if (map === m) {
                    return;
                }
                if (m) {
                    m.layers.remove(this);
                }
                if (map != null) {
                    map.layers.insert(this);
                }
            };
        ///
        /// Protected methods
        ///
        /**
         * Attaches the canvas to the map.
         * @memberof CanvasOverlay
         * @method
         */
        /**
         * Attaches the canvas to the map.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} el
         * @return {?}
         */
        BingCanvasOverlay.prototype.SetCanvasElement = /**
         * Attaches the canvas to the map.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} el
         * @return {?}
         */
            function (el) {
                ((this)).setHtmlElement(el);
            };
        /**
         * Remove the map event handlers.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Remove the map event handlers.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        BingCanvasOverlay.prototype.RemoveEventHandlers = /**
         * Remove the map event handlers.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                // Remove all event handlers from the map.
                Microsoft.Maps.Events.removeHandler(this._viewChangeEvent);
                Microsoft.Maps.Events.removeHandler(this._viewChangeEndEvent);
                Microsoft.Maps.Events.removeHandler(this._mapResizeEvent);
            };
        /**
         * Updates the Canvas size based on the map size.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Updates the Canvas size based on the map size.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        BingCanvasOverlay.prototype.Resize = /**
         * Updates the Canvas size based on the map size.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                var /** @type {?} */ map = ((this)).getMap();
                // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.
                this._canvas.width = map.getWidth();
                this._canvas.height = map.getHeight();
            };
        /**
         * Updates the Canvas.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Updates the Canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        BingCanvasOverlay.prototype.UpdateCanvas = /**
         * Updates the Canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                var /** @type {?} */ map = ((this)).getMap();
                // Only render the canvas if it isn't in streetside mode.
                if (map.getMapTypeId() !== Microsoft.Maps.MapTypeId.streetside) {
                    this._canvas.style.display = '';
                    // Reset CSS position and dimensions of canvas.
                    this.UpdatePosition(0, 0, map.getWidth(), map.getHeight());
                    // Redraw the canvas.
                    this.Redraw(true);
                    // Get the current map view information.
                    this._zoomStart = map.getZoom();
                    this._centerStart = /** @type {?} */ (map.getCenter());
                }
            };
        return BingCanvasOverlay;
    }(CanvasOverlay));
    /**
     * Helper function to extend the OverlayView into the CanvasOverlay
     *
     * @export
     * \@method
     * @return {?}
     */
    function MixinCanvasOverlay() {
        var /** @type {?} */ x = BingCanvasOverlay.prototype;
        BingCanvasOverlay.prototype = /** @type {?} */ (new Microsoft.Maps.CustomOverlay());
        for (var /** @type {?} */ y in x) {
            if (((x))[y] != null) {
                ((BingCanvasOverlay.prototype))[y] = ((x))[y];
            }
        }
        ((BingCanvasOverlay.prototype))['onAdd'] = x['OnAdd'];
        ((BingCanvasOverlay.prototype))['onLoad'] = x['OnLoad'];
        ((BingCanvasOverlay.prototype))['onRemove'] = x['OnRemove'];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var MapTypeId$1 = {
        /** This map type displays a transparent layer of major streets on satellite images. */
        hybrid: 0,
        /** This map type displays a normal street map. */
        roadmap: 1,
        /** This map type displays satellite images. */
        satellite: 2,
        /** This map type displays maps with physical features such as terrain and vegetation. */
        terrain: 3,
    };
    MapTypeId$1[MapTypeId$1.hybrid] = "hybrid";
    MapTypeId$1[MapTypeId$1.roadmap] = "roadmap";
    MapTypeId$1[MapTypeId$1.satellite] = "satellite";
    MapTypeId$1[MapTypeId$1.terrain] = "terrain";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This class contains helperfunctions to map various interfaces used to represent options and structures into the
     * corresponding Google Maps specific implementations.
     *
     * @export
     */
    var GoogleConversions = (function () {
        function GoogleConversions() {
        }
        /**
         * Maps an IBox object to a GoogleMapTypes.LatLngBoundsLiteral object.
         *
         * \@memberof GoogleConversions
         * @param {?} bounds - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateBounds = /**
         * Maps an IBox object to a GoogleMapTypes.LatLngBoundsLiteral object.
         *
         * \@memberof GoogleConversions
         * @param {?} bounds - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (bounds) {
                var /** @type {?} */ b = {
                    east: bounds.maxLongitude,
                    north: bounds.maxLatitude,
                    south: bounds.minLatitude,
                    west: bounds.minLongitude,
                };
                return b;
            };
        /**
         * Maps an IInfoWindowOptions object to a GoogleMapTypes.InfoWindowOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateInfoWindowOptions = /**
         * Maps an IInfoWindowOptions object to a GoogleMapTypes.InfoWindowOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._infoWindowOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'htmlContent') {
                        o.content = ((options))[k];
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                if (o.content == null || o.content === '') {
                    if (options.title !== '' && options.description !== '') {
                        o.content = options.title + ": " + options.description;
                    }
                    else if (options.description !== '') {
                        o.content = options.description;
                    }
                    else {
                        o.content = options.title;
                    }
                }
                return o;
            };
        /**
         * Maps an ILatLong object to a GoogleMapTypes.LatLngLiteral object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLocation = /**
         * Maps an ILatLong object to a GoogleMapTypes.LatLngLiteral object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlong) {
                var /** @type {?} */ l = { lat: latlong.latitude, lng: latlong.longitude };
                return l;
            };
        /**
         * Maps an GoogleMapTypes.LatLngLiteral object to a ILatLong object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlng - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLatLng = /**
         * Maps an GoogleMapTypes.LatLngLiteral object to a ILatLong object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlng - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlng) {
                var /** @type {?} */ l = { latitude: latlng.lat, longitude: latlng.lng };
                return l;
            };
        /**
         * Maps an ILatLong object to a GoogleMapTypes.LatLng object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLocationObject = /**
         * Maps an ILatLong object to a GoogleMapTypes.LatLng object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlong - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlong) {
                var /** @type {?} */ l = new google.maps.LatLng(latlong.latitude, latlong.longitude);
                return l;
            };
        /**
         * Maps an GoogleMapTypes.LatLng object to a ILatLong object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlng - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLatLngObject = /**
         * Maps an GoogleMapTypes.LatLng object to a ILatLong object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlng - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlng) {
                var /** @type {?} */ l = { latitude: latlng.lat(), longitude: latlng.lng() };
                return l;
            };
        /**
         * Maps an ILatLong array to a array of GoogleMapTypes.LatLng object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlongArray - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateLocationObjectArray = /**
         * Maps an ILatLong array to a array of GoogleMapTypes.LatLng object.
         *
         * \@memberof GoogleConversions
         * @param {?} latlongArray - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (latlongArray) {
                // use for loop for performance in case we deal with large numbers of points and paths...
                var /** @type {?} */ p = new Array();
                for (var /** @type {?} */ i = 0; i < latlongArray.length; i++) {
                    p.push(GoogleConversions.TranslateLocationObject(latlongArray[i]));
                }
                return p;
            };
        /**
         * Maps a MapTypeId object to a Google maptype string.
         *
         * \@memberof GoogleConversions
         * @param {?} mapTypeId - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateMapTypeId = /**
         * Maps a MapTypeId object to a Google maptype string.
         *
         * \@memberof GoogleConversions
         * @param {?} mapTypeId - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (mapTypeId) {
                switch (mapTypeId) {
                    case MapTypeId.road: return MapTypeId$1[MapTypeId$1.roadmap];
                    case MapTypeId.grayscale: return MapTypeId$1[MapTypeId$1.terrain];
                    case MapTypeId.hybrid: return MapTypeId$1[MapTypeId$1.hybrid];
                    case MapTypeId.ordnanceSurvey: return MapTypeId$1[MapTypeId$1.terrain];
                    default: return MapTypeId$1[MapTypeId$1.satellite];
                }
            };
        /**
         * Maps an IMarkerOptions object to a GoogleMapTypes.MarkerOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Promise that when resolved contains the mapped object.
         *
         */
        GoogleConversions.TranslateMarkerOptions = /**
         * Maps an IMarkerOptions object to a GoogleMapTypes.MarkerOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Promise that when resolved contains the mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._markerOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'position') {
                        var /** @type {?} */ latlng = GoogleConversions.TranslateLocationObject(options[k]);
                        o.position = latlng;
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Maps an IMapOptions object to a GoogleMapTypes.MapOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslateOptions = /**
         * Maps an IMapOptions object to a GoogleMapTypes.MapOptions object.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._mapOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'center') {
                        o.center = GoogleConversions.TranslateLocation(options.center);
                    }
                    else if (k === 'mapTypeId') {
                        o.mapTypeId = GoogleConversions.TranslateMapTypeId(options.mapTypeId);
                    }
                    else if (k === 'disableZooming') {
                        o.gestureHandling = 'none';
                        o.zoomControl = false;
                    }
                    else if (k === 'showMapTypeSelector') {
                        o.mapTypeControl = false;
                    }
                    else {
                        ((o))[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
         *
         * \@memberof GoogleConversions
         * @param {?} paths - ILatLong based locations to convert.
         * @return {?} - converted locations.
         *
         */
        GoogleConversions.TranslatePaths = /**
         * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations
         *
         * \@memberof GoogleConversions
         * @param {?} paths - ILatLong based locations to convert.
         * @return {?} - converted locations.
         *
         */
            function (paths) {
                var /** @type {?} */ p = new Array();
                if (paths == null || !Array.isArray(paths) || paths.length === 0) {
                    p.push(new Array());
                }
                else if (Array.isArray(paths[0])) {
                    // parameter is an array or arrays
                    // use for loop for performance in case we deal with large numbers of points and paths...
                    var /** @type {?} */ p1 = (paths);
                    for (var /** @type {?} */ i = 0; i < p1.length; i++) {
                        p.push(GoogleConversions.TranslateLocationObjectArray(p1[i]));
                    }
                }
                else {
                    // parameter is a simple array....
                    p.push(GoogleConversions.TranslateLocationObjectArray(/** @type {?} */ (paths)));
                }
                return p;
            };
        /**
         *  Maps an IPolygonOptions object to a GoogleMapTypes.PolygonOptions.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslatePolygonOptions = /**
         *  Maps an IPolygonOptions object to a GoogleMapTypes.PolygonOptions.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._polygonOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    if (k === 'paths') {
                        if (!Array.isArray(options.paths)) {
                            return;
                        }
                        if (options.paths.length === 0) {
                            o.paths = new Array();
                        }
                        else if (Array.isArray(options.paths[0])) {
                            o.paths = new Array();
                            // use for loop for performance in case we deal with large numbers of points and paths..
                            var /** @type {?} */ p1 = (options.paths);
                            for (var /** @type {?} */ i = 0; i < p1.length; i++) {
                                o.paths[i] = new Array();
                                for (var /** @type {?} */ j = 0; j < p1[i].length; j++) {
                                    o.paths[i][j] = { lat: p1[i][j].latitude, lng: p1[i][j].longitude };
                                }
                            }
                        }
                        else {
                            o.paths = new Array();
                            // use for loop for performance in case we deal with large numbers of points and paths..
                            var /** @type {?} */ p1 = (options.paths);
                            for (var /** @type {?} */ i = 0; i < p1.length; i++) {
                                o.paths[i] = { lat: p1[i].latitude, lng: p1[i].longitude };
                            }
                        }
                    }
                    else {
                        o[k] = ((options))[k];
                    }
                });
                return o;
            };
        /**
         *  Maps an IPolylineOptions object to a GoogleMapTypes.PolylineOptions.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
        GoogleConversions.TranslatePolylineOptions = /**
         *  Maps an IPolylineOptions object to a GoogleMapTypes.PolylineOptions.
         *
         * \@memberof GoogleConversions
         * @param {?} options - Object to be mapped.
         * @return {?} - Mapped object.
         *
         */
            function (options) {
                var /** @type {?} */ o = {};
                Object.keys(options)
                    .filter(function (k) { return GoogleConversions._polylineOptionsAttributes.indexOf(k) !== -1; })
                    .forEach(function (k) {
                    o[k] = ((options))[k];
                });
                return o;
            };
        /**
         * Map option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._mapOptionsAttributes = [
            'backgroundColor',
            'center',
            'clickableIcons',
            'disableDefaultUI',
            'disableDoubleClickZoom',
            'draggable',
            'draggableCursor',
            'draggingCursor',
            'disableZooming',
            'fullscreenControl',
            'fullscreenControlOptions',
            'gestureHandling',
            'heading',
            'keyboardShortcuts',
            'mapTypeControl',
            'mapTypeControlOptions',
            'mapTypeId',
            'maxZoom',
            'minZoom',
            'noClear',
            'panControl',
            'panControlOptions',
            'rotateControl',
            'rotateControlOptions',
            'scaleControl',
            'scaleControlOptions',
            'scrollwheel',
            'showMapTypeSelector',
            'streetView',
            'streetViewControl',
            'streetViewControlOptions',
            'styles',
            'tilt',
            'zoom',
            'zoomControl',
            'zoomControlOptions'
        ];
        /**
         * InfoWindow option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._infoWindowOptionsAttributes = [
            'actions',
            'description',
            'htmlContent',
            'id',
            'position',
            'pixelOffset',
            'showCloseButton',
            'showPointer',
            'pushpin',
            'title',
            'titleClickHandler',
            'typeName',
            'visible',
            'width',
            'height'
        ];
        /**
         * Marker option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._markerOptionsAttributes = [
            'anchor',
            'position',
            'title',
            'text',
            'label',
            'draggable',
            'icon',
            'width',
            'height',
            'iconInfo',
            'metadata',
            'visible'
        ];
        /**
         * Cluster option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._clusterOptionsAttributes = [
            'callback',
            'clusteredPinCallback',
            'clusteringEnabled',
            'gridSize',
            'layerOffset',
            'placementMode',
            'visible',
            'zIndex'
        ];
        /**
         * Polygon option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._polygonOptionsAttributes = [
            'clickable',
            'draggable',
            'editable',
            'fillColor',
            'fillOpacity',
            'geodesic',
            'paths',
            'strokeColor',
            'strokeOpacity',
            'strokeWeight',
            'visible',
            'zIndex'
        ];
        /**
         * Polyline option attributes that are supported for conversion to Google Map properties
         *
         * \@memberof GoogleConversions
         */
        GoogleConversions._polylineOptionsAttributes = [
            'clickable',
            'draggable',
            'editable',
            'geodesic',
            'strokeColor',
            'strokeOpacity',
            'strokeWeight',
            'visible',
            'zIndex'
        ];
        return GoogleConversions;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation for a {\@link InfoWindow}} model for Google Maps.
     *
     * @export
     */
    var /**
     * Concrete implementation for a {\@link InfoWindow}} model for Google Maps.
     *
     * @export
     */ GoogleInfoWindow = (function () {
        ///
        /// constructor
        ///
        /**
         * Creates an instance of GoogleInfoWindow.
         * @param _infoWindow - A {@link GoogleMapTypes.InfoWindow} instance underlying the model.
         * @param _mapService - An instance of the {@link GoogleMapService}.
         * @memberof GoogleInfoWindow
         */
        function GoogleInfoWindow(_infoWindow, _mapService) {
            this._infoWindow = _infoWindow;
            this._mapService = _mapService;
        }
        Object.defineProperty(GoogleInfoWindow.prototype, "IsOpen", {
            get: /**
             * Gets whether the info box is currently open.
             *
             * \@readonly
             * \@memberof InfoWGoogleInfoWindowindow
             * @return {?}
             */ function () {
                if (this._isOpen === true) {
                    return true;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleInfoWindow.prototype, "NativePrimitve", {
            get: /**
             * Gets the underlying native object.
             *
             * \@property
             * \@readonly
             * @return {?}
             */ function () {
                return this._infoWindow;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener to the InfoWindow.
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
        GoogleInfoWindow.prototype.AddListener = /**
         * Adds an event listener to the InfoWindow.
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                var _this = this;
                this._infoWindow.addListener(eventType, function (e) {
                    if (eventType === 'closeclick') {
                        _this._isOpen = false;
                    }
                    fn(e);
                });
            };
        /**
         *
         * Closes the info window.
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @return {?}
         */
        GoogleInfoWindow.prototype.Close = /**
         *
         * Closes the info window.
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @return {?}
         */
            function () {
                this._isOpen = false;
                this._infoWindow.close();
            };
        /**
         * Gets the position of the info window
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @return {?} - The geo coordinates of the info window.
         *
         */
        GoogleInfoWindow.prototype.GetPosition = /**
         * Gets the position of the info window
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @return {?} - The geo coordinates of the info window.
         *
         */
            function () {
                return GoogleConversions.TranslateLatLngObject(this._infoWindow.getPosition());
            };
        /**
         * Opens the info window
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?=} anchor
         * @return {?}
         */
        GoogleInfoWindow.prototype.Open = /**
         * Opens the info window
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?=} anchor
         * @return {?}
         */
            function (anchor) {
                var _this = this;
                this._mapService.MapPromise.then(function (m) {
                    _this._isOpen = true;
                    _this._infoWindow.open(m, anchor);
                });
            };
        /**
         * Sets the info window options
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} options - The options to set. This object will be merged with the existing options.
         *
         * @return {?}
         */
        GoogleInfoWindow.prototype.SetOptions = /**
         * Sets the info window options
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} options - The options to set. This object will be merged with the existing options.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = GoogleConversions.TranslateInfoWindowOptions(options);
                this._infoWindow.setOptions(o);
            };
        /**
         * Sets the info window position
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} position - Geo coordinates at which to anchor the info window.
         *
         * @return {?}
         */
        GoogleInfoWindow.prototype.SetPosition = /**
         * Sets the info window position
         *
         * \@memberof GoogleInfoWindow
         * \@method
         * @param {?} position - Geo coordinates at which to anchor the info window.
         *
         * @return {?}
         */
            function (position) {
                var /** @type {?} */ l = GoogleConversions.TranslateLocation(position);
                this._infoWindow.setPosition(l);
            };
        return GoogleInfoWindow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the {\@link Marker} contract for the Google Maps map architecture.
     *
     * @export
     */
    var /**
     * Concrete implementation of the {\@link Marker} contract for the Google Maps map architecture.
     *
     * @export
     */ GoogleMarker = (function () {
        ///
        /// Constructors
        ///
        /**
         * Creates an instance of GoogleMarker.
         * @param _marker
         *
         * @memberof GoogleMarker
         */
        function GoogleMarker(_marker) {
            this._marker = _marker;
            this._metadata = new Map();
            this._isFirst = false;
            this._isLast = true;
        }
        Object.defineProperty(GoogleMarker.prototype, "IsFirst", {
            get: /**
             * Indicates that the marker is the first marker in a set.
             *
             * \@memberof Marker
             * @return {?}
             */ function () { return this._isFirst; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._isFirst = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMarker.prototype, "IsLast", {
            get: /**
             * Indicates that the marker is the last marker in the set.
             *
             * \@memberof Marker
             * @return {?}
             */ function () { return this._isLast; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._isLast = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMarker.prototype, "Metadata", {
            get: /**
             * Gets the marker metadata.
             *
             * \@readonly
             * \@memberof BingMarker
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMarker.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the marker, in this case {\@link Microsoft.Maps.Pushpin}
             *
             * \@readonly
             * @abstract
             * \@memberof BingMarker
             * @return {?}
             */ function () { return this._marker; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMarker.prototype, "Location", {
            get: /**
             * Gets the Location of the marker
             *
             * \@readonly
             * @abstract
             * \@memberof BingMarker
             * @return {?}
             */ function () {
                var /** @type {?} */ l = this._marker.getPosition();
                return {
                    latitude: l.lat(),
                    longitude: l.lng()
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener to the marker.
         *
         * \@memberof GoogleMarker
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
        GoogleMarker.prototype.AddListener = /**
         * Adds an event listener to the marker.
         *
         * \@memberof GoogleMarker
         * @param {?} eventType - String containing the event for which to register the listener (e.g. "click")
         * @param {?} fn - Delegate invoked when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                this._marker.addListener(eventType, fn);
            };
        /**
         * Deletes the marker.
         *
         *
         * \@memberof GoogleMarker
         * @return {?}
         */
        GoogleMarker.prototype.DeleteMarker = /**
         * Deletes the marker.
         *
         *
         * \@memberof GoogleMarker
         * @return {?}
         */
            function () {
                this._marker.setMap(null);
            };
        /**
         * Gets the marker label
         *
         * \@memberof GoogleMarker
         * @return {?}
         */
        GoogleMarker.prototype.GetLabel = /**
         * Gets the marker label
         *
         * \@memberof GoogleMarker
         * @return {?}
         */
            function () {
                return this._marker.getLabel().text;
            };
        /**
         * Gets whether the marker is visible.
         *
         * \@memberof GoogleMarker
         * @return {?} - True if the marker is visible, false otherwise.
         *
         */
        GoogleMarker.prototype.GetVisible = /**
         * Gets whether the marker is visible.
         *
         * \@memberof GoogleMarker
         * @return {?} - True if the marker is visible, false otherwise.
         *
         */
            function () {
                return this._marker.getVisible();
            };
        /**
         * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.
         *
         * \@memberof GoogleMarker
         * @param {?} anchor - Point coordinates for the marker anchor.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetAnchor = /**
         * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.
         *
         * \@memberof GoogleMarker
         * @param {?} anchor - Point coordinates for the marker anchor.
         *
         * @return {?}
         */
            function (anchor) {
                // not implemented
                // TODO: we need to switch the model to complex icons for google to
                // support anchors, sizes and origins.
                // https://developers.google.com/maps/documentation/javascript/markers
            };
        /**
         * Sets the draggability of a marker.
         *
         * \@memberof GoogleMarker
         * @param {?} draggable - True to mark the marker as draggable, false otherwise.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetDraggable = /**
         * Sets the draggability of a marker.
         *
         * \@memberof GoogleMarker
         * @param {?} draggable - True to mark the marker as draggable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                this._marker.setDraggable(draggable);
            };
        /**
         * Sets the icon for the marker.
         *
         * \@memberof GoogleMarker
         * @param {?} icon - String containing the icon in various forms (url, data url, etc.)
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetIcon = /**
         * Sets the icon for the marker.
         *
         * \@memberof GoogleMarker
         * @param {?} icon - String containing the icon in various forms (url, data url, etc.)
         *
         * @return {?}
         */
            function (icon) {
                this._marker.setIcon(icon);
            };
        /**
         * Sets the marker label.
         *
         * \@memberof GoogleMarker
         * @param {?} label - String containing the label to set.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetLabel = /**
         * Sets the marker label.
         *
         * \@memberof GoogleMarker
         * @param {?} label - String containing the label to set.
         *
         * @return {?}
         */
            function (label) {
                this._marker.setLabel(label);
            };
        /**
         * Sets the marker position.
         *
         * \@memberof GoogleMarker
         * @param {?} latLng - Geo coordinates to set the marker position to.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetPosition = /**
         * Sets the marker position.
         *
         * \@memberof GoogleMarker
         * @param {?} latLng - Geo coordinates to set the marker position to.
         *
         * @return {?}
         */
            function (latLng) {
                var /** @type {?} */ p = GoogleConversions.TranslateLocationObject(latLng);
                this._marker.setPosition(p);
            };
        /**
         * Sets the marker title.
         *
         * \@memberof GoogleMarker
         * @param {?} title - String containing the title to set.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetTitle = /**
         * Sets the marker title.
         *
         * \@memberof GoogleMarker
         * @param {?} title - String containing the title to set.
         *
         * @return {?}
         */
            function (title) {
                this._marker.setTitle(title);
            };
        /**
         * Sets the marker options.
         *
         * \@memberof GoogleMarker
         * @param {?} options - {\@link IMarkerOptions} object containing the marker options to set. The supplied options are
         * merged with the underlying marker options.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetOptions = /**
         * Sets the marker options.
         *
         * \@memberof GoogleMarker
         * @param {?} options - {\@link IMarkerOptions} object containing the marker options to set. The supplied options are
         * merged with the underlying marker options.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = GoogleConversions.TranslateMarkerOptions(options);
                this._marker.setOptions(o);
            };
        /**
         * Sets whether the marker is visible.
         *
         * \@memberof GoogleMarker
         * @param {?} visible - True to set the marker visible, false otherwise.
         *
         * @return {?}
         */
        GoogleMarker.prototype.SetVisible = /**
         * Sets whether the marker is visible.
         *
         * \@memberof GoogleMarker
         * @param {?} visible - True to set the marker visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._marker.setVisible(visible);
            };
        return GoogleMarker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements map a labled to be placed on the map.
     *
     * @export
     */
    var /**
     * Implements map a labled to be placed on the map.
     *
     * @export
     */ GoogleMapLabel = (function (_super) {
        __extends(GoogleMapLabel, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates a new MapLabel
         * @param options Optional properties to set.
         */
        function GoogleMapLabel(options) {
            var _this = this;
            options["fontSize"] = options["fontSize"] || 12;
            options["fontColor"] = options["fontColor"] || '#ffffff';
            options["strokeWeight"] = options["strokeWeight"] || 3;
            options["strokeColor"] = options["strokeColor"] || '#000000';
            _this = _super.call(this, options) || this;
            return _this;
        }
        Object.defineProperty(GoogleMapLabel.prototype, "DefaultLabelStyle", {
            get: /**
             * Returns the default label style for the platform
             *
             * \@readonly
             * @abstract
             * \@memberof GoogleMapLabel
             * @return {?}
             */ function () {
                return {
                    fontSize: 12,
                    fontFamily: 'sans-serif',
                    fontColor: '#ffffff',
                    strokeWeight: 3,
                    strokeColor: '#000000'
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the value of a setting.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @return {?} - The value of the setting.
         */
        GoogleMapLabel.prototype.Get = /**
         * Gets the value of a setting.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @return {?} - The value of the setting.
         */
            function (key) {
                return ((this)).get(key);
            };
        /**
         * Gets the map associted with the label.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @return {?}
         */
        GoogleMapLabel.prototype.GetMap = /**
         * Gets the map associted with the label.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @return {?}
         */
            function () {
                return ((this)).getMap();
            };
        /**
         * Set the value for a setting.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @param {?} val - The value to set.
         * @return {?}
         */
        GoogleMapLabel.prototype.Set = /**
         * Set the value for a setting.
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} key - Key specifying the setting.
         * @param {?} val - The value to set.
         * @return {?}
         */
            function (key, val) {
                if (key === 'position' && val.hasOwnProperty('latitude') && val.hasOwnProperty('longitude')) {
                    val = new google.maps.LatLng(val.latitude, val.longitude);
                }
                if (this.Get(key) !== val) {
                    ((this)).set(key, val);
                }
            };
        /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
        GoogleMapLabel.prototype.SetMap = /**
         * Sets the map for the label. Settings this to null remove the label from hte map.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @param {?} map - Map to associated with the label.
         * @return {?}
         */
            function (map) {
                ((this)).setMap(map);
            };
        /**
         * Applies settings to the object
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} options - An object containing the settings key value pairs.
         * @return {?}
         */
        GoogleMapLabel.prototype.SetValues = /**
         * Applies settings to the object
         *
         * \@memberof MapLabel
         * \@method
         * @param {?} options - An object containing the settings key value pairs.
         * @return {?}
         */
            function (options) {
                for (var /** @type {?} */ key in options) {
                    if (key !== '') {
                        if (key === 'position' && options[key].hasOwnProperty('latitude') && options[key].hasOwnProperty('longitude')) {
                            options[key] = new google.maps.LatLng(options[key].latitude, options[key].longitude);
                        }
                        if (this.Get(key) === options[key]) {
                            delete options[key];
                        }
                    }
                }
                ((this)).setValues(options);
            };
        ///
        /// Protected methods
        ///
        /**
         * Draws the label on the map.
         * @memberof GoogleMapLabel
         * @method
         * @protected
         */
        /**
         * Draws the label on the map.
         * \@memberof GoogleMapLabel
         * \@method
         * @protected
         * @return {?}
         */
        GoogleMapLabel.prototype.Draw = /**
         * Draws the label on the map.
         * \@memberof GoogleMapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                var /** @type {?} */ projection = ((this)).getProjection();
                var /** @type {?} */ visibility = this.GetVisible();
                if (!projection) {
                    // The map projection is not ready yet so do nothing
                    return;
                }
                if (!this._canvas) {
                    // onAdd has not been called yet.
                    return;
                }
                var /** @type {?} */ style = this._canvas.style;
                if (visibility !== '') {
                    // label is not visible, don't calculate positions etc.
                    style['visibility'] = visibility;
                    return;
                }
                var /** @type {?} */ offset = this.Get('offset');
                var /** @type {?} */ latLng = this.Get('position');
                if (!latLng) {
                    return;
                }
                if (!(latLng instanceof google.maps.LatLng)) {
                    latLng = new google.maps.LatLng(latLng.lat, latLng.lng);
                }
                if (!offset) {
                    offset = new google.maps.Point(0, 0);
                }
                var /** @type {?} */ pos = projection.fromLatLngToDivPixel(latLng);
                style['top'] = (pos.y + offset.y) + 'px';
                style['left'] = (pos.x + offset.x) + 'px';
                style['visibility'] = visibility;
            };
        /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * @memberof GoogleMapLabel
         * @method
         * @protected
         */
        /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @protected
         * @return {?}
         */
        GoogleMapLabel.prototype.OnAdd = /**
         * Delegate called when the label is added to the map. Generates and configures
         * the canvas.
         *
         * \@memberof GoogleMapLabel
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                this._canvas = document.createElement('canvas');
                var /** @type {?} */ style = this._canvas.style;
                style.position = 'absolute';
                var /** @type {?} */ ctx = this._canvas.getContext('2d');
                ctx.lineJoin = 'round';
                ctx.textBaseline = 'top';
                this.DrawCanvas();
                var /** @type {?} */ panes = ((this)).getPanes();
                if (panes) {
                    panes.overlayLayer.appendChild(this._canvas);
                    // 4: floatPane (infowindow)
                    // 3: overlayMouseTarget (mouse events)
                    // 2: markerLayer (marker images)
                    // 1: overlayLayer (polygons, polylines, ground overlays, tile layer overlays)
                    // 0: mapPane (lowest pane above the map tiles)
                }
            };
        return GoogleMapLabel;
    }(MapLabel));
    /**
     * Helper function to extend the OverlayView into the MapLabel
     *
     * @export
     * \@method
     * @return {?}
     */
    function MixinMapLabelWithOverlayView$1() {
        var /** @type {?} */ x = GoogleMapLabel.prototype;
        GoogleMapLabel.prototype = new google.maps.OverlayView;
        for (var /** @type {?} */ y in x) {
            if (((x))[y] != null) {
                ((GoogleMapLabel.prototype))[y] = ((x))[y];
            }
        }
        ((GoogleMapLabel.prototype))['changed'] = x['Changed'];
        ((GoogleMapLabel.prototype))['onAdd'] = x['OnAdd'];
        ((GoogleMapLabel.prototype))['draw'] = x['Draw'];
        ((GoogleMapLabel.prototype))['onRemove'] = x['OnRemove'];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation for a polygon model for Google Maps.
     *
     * @export
     */
    var /**
     * Concrete implementation for a polygon model for Google Maps.
     *
     * @export
     */ GooglePolygon = (function (_super) {
        __extends(GooglePolygon, _super);
        ///
        /// constructor
        ///
        /**
         * Creates an instance of GooglePolygon.
         * @param _polygon - The {@link GoogleMapTypes.Polygon} underlying the model.
         *
         * @memberof GooglePolygon
         */
        function GooglePolygon(_polygon) {
            var _this = _super.call(this) || this;
            _this._polygon = _polygon;
            _this._title = '';
            _this._showLabel = false;
            _this._showTooltip = false;
            _this._maxZoom = -1;
            _this._minZoom = -1;
            _this._label = null;
            _this._tooltip = null;
            _this._tooltipVisible = false;
            _this._hasToolTipReceiver = false;
            _this._mouseOverListener = null;
            _this._mouseOutListener = null;
            _this._mouseMoveListener = null;
            _this._metadata = new Map();
            _this._editingCompleteEmitter = null;
            _this._originalPath = _this.GetPaths();
            return _this;
        }
        Object.defineProperty(GooglePolygon.prototype, "LabelMaxZoom", {
            get: /**
             * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.
             *
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._maxZoom; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._maxZoom = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "LabelMinZoom", {
            get: /**
             * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.
             *
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._minZoom; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._minZoom = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "Metadata", {
            get: /**
             * Gets the polygon metadata.
             *
             * \@readonly
             * \@memberof GoolePolygon
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the polygon, in this case {\@link GoogleMapTypes.Polygon}
             *
             * \@readonly
             * \@memberof GooglePolygon
             * @return {?}
             */ function () { return this._polygon; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "ShowLabel", {
            get: /**
             * Gets or sets whether to show the label
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._showLabel; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showLabel = val;
                this.ManageLabel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "ShowTooltip", {
            get: /**
             * Gets or sets whether to show the tooltip
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._showTooltip; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showTooltip = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolygon.prototype, "Title", {
            get: /**
             * Gets or sets the title off the polygon
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._title; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._title = val;
                this.ManageLabel();
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds a delegate for an event.
         *
         * \@memberof GooglePolygon
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
        GooglePolygon.prototype.AddListener = /**
         * Adds a delegate for an event.
         *
         * \@memberof GooglePolygon
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
            function (eventType, fn) {
                var /** @type {?} */ supportedEvents = [
                    'click',
                    'dblclick',
                    'drag', 'dragend',
                    'dragstart',
                    'mousedown',
                    'mousemove',
                    'mouseout',
                    'mouseover',
                    'mouseup',
                    'rightclick'
                ];
                if (supportedEvents.indexOf(eventType) !== -1) {
                    this._polygon.addListener(eventType, fn);
                }
                if (eventType === 'pathchanged') {
                    this._editingCompleteEmitter = /** @type {?} */ (fn);
                }
            };
        /**
         * Deleted the polygon.
         *
         * \@memberof GooglePolygon
         * @return {?}
         */
        GooglePolygon.prototype.Delete = /**
         * Deleted the polygon.
         *
         * \@memberof GooglePolygon
         * @return {?}
         */
            function () {
                this._polygon.setMap(null);
                if (this._label) {
                    this._label.Delete();
                }
                if (this._tooltip) {
                    this._tooltip.Delete();
                }
            };
        /**
         * Gets whether the polygon is draggable.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the polygon is dragable, false otherwise.
         *
         */
        GooglePolygon.prototype.GetDraggable = /**
         * Gets whether the polygon is draggable.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the polygon is dragable, false otherwise.
         *
         */
            function () {
                return this._polygon.getDraggable();
            };
        /**
         * Gets whether the polygon path can be edited.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
        GooglePolygon.prototype.GetEditable = /**
         * Gets whether the polygon path can be edited.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
            function () {
                return this._polygon.getEditable();
            };
        /**
         * Gets the polygon path.
         *
         * \@memberof GooglePolygon
         * @return {?} - Array of {\@link ILatLong} objects describing the polygon path.
         *
         */
        GooglePolygon.prototype.GetPath = /**
         * Gets the polygon path.
         *
         * \@memberof GooglePolygon
         * @return {?} - Array of {\@link ILatLong} objects describing the polygon path.
         *
         */
            function () {
                var /** @type {?} */ p = this._polygon.getPath();
                var /** @type {?} */ path = new Array();
                p.forEach(function (x) { return path.push({ latitude: x.lat(), longitude: x.lng() }); });
                return path;
            };
        /**
         * Gets the polygon paths.
         *
         * \@memberof GooglePolygon
         * @return {?} - Array of Array of {\@link ILatLong} objects describing multiple polygon paths.
         *
         */
        GooglePolygon.prototype.GetPaths = /**
         * Gets the polygon paths.
         *
         * \@memberof GooglePolygon
         * @return {?} - Array of Array of {\@link ILatLong} objects describing multiple polygon paths.
         *
         */
            function () {
                var /** @type {?} */ p = this._polygon.getPaths();
                var /** @type {?} */ paths = new Array();
                p.forEach(function (x) {
                    var /** @type {?} */ path = new Array();
                    x.forEach(function (y) { return path.push({ latitude: y.lat(), longitude: y.lng() }); });
                    paths.push(path);
                });
                return paths;
            };
        /**
         * Gets whether the polygon is visible.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the polygon is visible, false otherwise.
         *
         */
        GooglePolygon.prototype.GetVisible = /**
         * Gets whether the polygon is visible.
         *
         * \@memberof GooglePolygon
         * @return {?} - True if the polygon is visible, false otherwise.
         *
         */
            function () {
                return this._polygon.getVisible();
            };
        /**
         * Sets whether the polygon is dragable.
         *
         * \@memberof GooglePolygon
         * @param {?} draggable - True to make the polygon dragable, false otherwise.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetDraggable = /**
         * Sets whether the polygon is dragable.
         *
         * \@memberof GooglePolygon
         * @param {?} draggable - True to make the polygon dragable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                this._polygon.setDraggable(draggable);
            };
        /**
         * Sets wether the polygon path is editable.
         *
         * \@memberof GooglePolygon
         * @param {?} editable - True to make polygon path editable, false otherwise.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetEditable = /**
         * Sets wether the polygon path is editable.
         *
         * \@memberof GooglePolygon
         * @param {?} editable - True to make polygon path editable, false otherwise.
         *
         * @return {?}
         */
            function (editable) {
                var /** @type {?} */ previous = this._polygon.getEditable();
                this._polygon.setEditable(editable);
                if (previous && !editable && this._editingCompleteEmitter) {
                    this._editingCompleteEmitter({
                        Click: null,
                        Polygon: this,
                        OriginalPath: this._originalPath,
                        NewPath: this.GetPaths()
                    });
                    this._originalPath = this.GetPaths();
                }
            };
        /**
         * Sets the polygon options
         *
         * \@memberof GooglePolygon
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetOptions = /**
         * Sets the polygon options
         *
         * \@memberof GooglePolygon
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = GoogleConversions.TranslatePolygonOptions(options);
                if (typeof o.editable !== 'undefined') {
                    this.SetEditable(o.editable);
                    delete o.editable;
                }
                this._polygon.setOptions(o);
                if (options.visible != null && this._showLabel && this._label) {
                    this._label.Set('hidden', !options.visible);
                }
            };
        /**
         * Sets the polygon path.
         *
         * \@memberof GooglePolygon
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polygons path.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetPath = /**
         * Sets the polygon path.
         *
         * \@memberof GooglePolygon
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polygons path.
         *
         * @return {?}
         */
            function (path) {
                var /** @type {?} */ p = new Array();
                path.forEach(function (x) { return p.push(new google.maps.LatLng(x.latitude, x.longitude)); });
                this._polygon.setPath(p);
                this._originalPath = [path];
                if (this._label) {
                    this._centroid = null;
                    this.ManageLabel();
                }
            };
        /**
         * Set the polygon path or paths.
         *
         * \@memberof GooglePolygon
         * @param {?} paths An Array of {\@link ILatLong}
         * (or array of arrays) describing the polygons path(s).
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetPaths = /**
         * Set the polygon path or paths.
         *
         * \@memberof GooglePolygon
         * @param {?} paths An Array of {\@link ILatLong}
         * (or array of arrays) describing the polygons path(s).
         *
         * @return {?}
         */
            function (paths) {
                if (paths == null) {
                    return;
                }
                if (!Array.isArray(paths)) {
                    return;
                }
                if (paths.length === 0) {
                    this._polygon.setPaths(new Array());
                    if (this._label) {
                        this._label.Delete();
                        this._label = null;
                    }
                    return;
                }
                if (Array.isArray(paths[0])) {
                    // parameter is an array or arrays
                    var /** @type {?} */ p_1 = new Array();
                    ((paths)).forEach(function (path) {
                        var /** @type {?} */ _p = new Array();
                        path.forEach(function (x) { return _p.push(new google.maps.LatLng(x.latitude, x.longitude)); });
                        p_1.push(_p);
                    });
                    this._polygon.setPaths(p_1);
                    this._originalPath = /** @type {?} */ (paths);
                    if (this._label) {
                        this._centroid = null;
                        this.ManageLabel();
                    }
                }
                else {
                    // parameter is a simple array....
                    this.SetPath(/** @type {?} */ (paths));
                }
            };
        /**
         * Sets whether the polygon is visible.
         *
         * \@memberof GooglePolygon
         * @param {?} visible - True to set the polygon visible, false otherwise.
         *
         * @return {?}
         */
        GooglePolygon.prototype.SetVisible = /**
         * Sets whether the polygon is visible.
         *
         * \@memberof GooglePolygon
         * @param {?} visible - True to set the polygon visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._polygon.setVisible(visible);
                if (this._showLabel && this._label) {
                    this._label.Set('hidden', !visible);
                }
            };
        /**
         * Configures the label for the polygon
         * \@memberof GooglePolygon
         * @return {?}
         */
        GooglePolygon.prototype.ManageLabel = /**
         * Configures the label for the polygon
         * \@memberof GooglePolygon
         * @return {?}
         */
            function () {
                if (this.GetPath == null || this.GetPath().length === 0) {
                    return;
                }
                if (this._showLabel && this._title != null && this._title !== '') {
                    var /** @type {?} */ o = {
                        text: this._title,
                        position: GoogleConversions.TranslateLocationObject(this.Centroid)
                    };
                    if (o["position"] == null) {
                        return;
                    }
                    if (this._minZoom !== -1) {
                        o["minZoom"] = this._minZoom;
                    }
                    if (this._maxZoom !== -1) {
                        o["maxZoom"] = this._maxZoom;
                    }
                    if (this._label == null) {
                        o["map"] = this.NativePrimitve.getMap();
                        o["zIndex"] = this.NativePrimitve.zIndex ? this.NativePrimitve.zIndex + 1 : 100;
                        this._label = new GoogleMapLabel(o);
                    }
                    else {
                        this._label.SetValues(o);
                    }
                    this._label.Set('hidden', !this.GetVisible());
                }
                else {
                    if (this._label) {
                        this._label.SetMap(null);
                        this._label = null;
                    }
                }
            };
        /**
         * Configures the tooltip for the polygon
         * \@memberof GooglePolygon
         * @return {?}
         */
        GooglePolygon.prototype.ManageTooltip = /**
         * Configures the tooltip for the polygon
         * \@memberof GooglePolygon
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._showTooltip && this._title != null && this._title !== '') {
                    var /** @type {?} */ o = {
                        text: this._title,
                        align: 'left',
                        offset: new google.maps.Point(0, 25),
                        backgroundColor: 'bisque',
                        hidden: true,
                        fontSize: 12,
                        fontColor: '#000000',
                        strokeWeight: 0
                    };
                    if (this._tooltip == null) {
                        o["map"] = this.NativePrimitve.getMap();
                        o["zIndex"] = 100000;
                        this._tooltip = new GoogleMapLabel(o);
                    }
                    else {
                        this._tooltip.SetValues(o);
                    }
                    if (!this._hasToolTipReceiver) {
                        this._mouseOverListener = this.NativePrimitve.addListener('mouseover', function (e) {
                            _this._tooltip.Set('position', e.latLng);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        });
                        this._mouseMoveListener = this.NativePrimitve.addListener('mousemove', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('position', e.latLng);
                            }
                        });
                        this._mouseOutListener = this.NativePrimitve.addListener('mouseout', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', true);
                                _this._tooltipVisible = false;
                            }
                        });
                        this._hasToolTipReceiver = true;
                    }
                }
                if ((!this._showTooltip || this._title === '' || this._title == null)) {
                    if (this._hasToolTipReceiver) {
                        if (this._mouseOutListener) {
                            google.maps.event.removeListener(this._mouseOutListener);
                        }
                        if (this._mouseOverListener) {
                            google.maps.event.removeListener(this._mouseOverListener);
                        }
                        if (this._mouseMoveListener) {
                            google.maps.event.removeListener(this._mouseMoveListener);
                        }
                        this._hasToolTipReceiver = false;
                    }
                    if (this._tooltip) {
                        this._tooltip.SetMap(null);
                        this._tooltip = null;
                    }
                }
            };
        return GooglePolygon;
    }(Polygon));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation for a polyline model for Google Maps.
     *
     * @export
     */
    var /**
     * Concrete implementation for a polyline model for Google Maps.
     *
     * @export
     */ GooglePolyline = (function (_super) {
        __extends(GooglePolyline, _super);
        ///
        /// constructor
        ///
        /**
        * Creates an instance of GooglePolygon.
        * @param _polyline - The {@link GoogleMApTypes.Polyline} underlying the model.
        *
        * @memberof GooglePolyline
        */
        function GooglePolyline(_polyline) {
            var _this = _super.call(this) || this;
            _this._polyline = _polyline;
            _this._title = '';
            _this._showTooltip = false;
            _this._tooltip = null;
            _this._tooltipVisible = false;
            _this._hasToolTipReceiver = false;
            _this._mouseOverListener = null;
            _this._mouseOutListener = null;
            _this._mouseMoveListener = null;
            _this._metadata = new Map();
            return _this;
        }
        Object.defineProperty(GooglePolyline.prototype, "Metadata", {
            get: /**
             * Gets the polyline metadata.
             *
             * \@readonly
             * \@memberof GooglePolyline
             * @return {?}
             */ function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolyline.prototype, "NativePrimitve", {
            get: /**
             * Gets the native primitve implementing the marker, in this case {\@link GoogleMApTypes.Polyline}
             *
             * \@readonly
             * \@memberof GooglePolygon
             * @return {?}
             */ function () { return this._polyline; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolyline.prototype, "ShowTooltip", {
            get: /**
             * Gets or sets whether to show the tooltip
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._showTooltip; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._showTooltip = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GooglePolyline.prototype, "Title", {
            get: /**
             * Gets or sets the title off the polygon
             *
             * @abstract
             * \@memberof GooglePolygon
             * \@property
             * @return {?}
             */ function () { return this._title; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._title = val;
                this.ManageTooltip();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds a delegate for an event.
         *
         * \@memberof Polyline
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
        GooglePolyline.prototype.AddListener = /**
         * Adds a delegate for an event.
         *
         * \@memberof Polyline
         * @param {?} eventType - String containing the event name.
         * @param {?} fn - Delegate function to execute when the event occurs.
         * @return {?}
         */
            function (eventType, fn) {
                var /** @type {?} */ supportedEvents = [
                    'click',
                    'dblclick',
                    'drag', 'dragend',
                    'dragstart',
                    'mousedown',
                    'mousemove',
                    'mouseout',
                    'mouseover',
                    'mouseup',
                    'rightclick'
                ];
                if (supportedEvents.indexOf(eventType) !== -1) {
                    this._polyline.addListener(eventType, fn);
                }
            };
        /**
         * Deleted the polyline.
         *
         *
         * \@memberof Polyline
         * @return {?}
         */
        GooglePolyline.prototype.Delete = /**
         * Deleted the polyline.
         *
         *
         * \@memberof Polyline
         * @return {?}
         */
            function () {
                this._polyline.setMap(null);
                if (this._tooltip) {
                    this._tooltip.Delete();
                }
            };
        /**
         * Gets whether the polyline is draggable.
         *
         * \@memberof Polyline
         * @return {?} - True if the polyline is dragable, false otherwise.
         *
         */
        GooglePolyline.prototype.GetDraggable = /**
         * Gets whether the polyline is draggable.
         *
         * \@memberof Polyline
         * @return {?} - True if the polyline is dragable, false otherwise.
         *
         */
            function () {
                return this._polyline.getDraggable();
            };
        /**
         * Gets whether the polyline path can be edited.
         *
         * \@memberof Polyline
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
        GooglePolyline.prototype.GetEditable = /**
         * Gets whether the polyline path can be edited.
         *
         * \@memberof Polyline
         * @return {?} - True if the path can be edited, false otherwise.
         *
         */
            function () {
                return this._polyline.getEditable();
            };
        /**
         * Gets the polyline path.
         *
         * \@memberof Polyline
         * @return {?} - Array of {\@link ILatLong} objects describing the polyline path.
         *
         */
        GooglePolyline.prototype.GetPath = /**
         * Gets the polyline path.
         *
         * \@memberof Polyline
         * @return {?} - Array of {\@link ILatLong} objects describing the polyline path.
         *
         */
            function () {
                var /** @type {?} */ p = this._polyline.getPath();
                var /** @type {?} */ path = new Array();
                p.forEach(function (x) { return path.push({ latitude: x.lat(), longitude: x.lng() }); });
                return path;
            };
        /**
         * Gets whether the polyline is visible.
         *
         * \@memberof Polyline
         * @return {?} - True if the polyline is visible, false otherwise.
         *
         */
        GooglePolyline.prototype.GetVisible = /**
         * Gets whether the polyline is visible.
         *
         * \@memberof Polyline
         * @return {?} - True if the polyline is visible, false otherwise.
         *
         */
            function () {
                return this._polyline.getVisible();
            };
        /**
         * Sets whether the polyline is dragable.
         *
         * \@memberof Polyline
         * @param {?} draggable - True to make the polyline dragable, false otherwise.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetDraggable = /**
         * Sets whether the polyline is dragable.
         *
         * \@memberof Polyline
         * @param {?} draggable - True to make the polyline dragable, false otherwise.
         *
         * @return {?}
         */
            function (draggable) {
                this._polyline.setDraggable(draggable);
            };
        /**
         * Sets wether the polyline path is editable.
         *
         * \@memberof Polyline
         * @param {?} editable - True to make polyline path editable, false otherwise.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetEditable = /**
         * Sets wether the polyline path is editable.
         *
         * \@memberof Polyline
         * @param {?} editable - True to make polyline path editable, false otherwise.
         *
         * @return {?}
         */
            function (editable) {
                this._polyline.setEditable(editable);
            };
        /**
         * Sets the polyline options
         *
         * \@memberof Polyline
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetOptions = /**
         * Sets the polyline options
         *
         * \@memberof Polyline
         * @param {?} options - {\@link ILatLong} object containing the options. The options are merged with hte ones
         * already on the underlying model.
         *
         * @return {?}
         */
            function (options) {
                var /** @type {?} */ o = GoogleConversions.TranslatePolylineOptions(options);
                this._polyline.setOptions(o);
                if (options.path) {
                    this.SetPath(/** @type {?} */ (options.path));
                }
            };
        /**
         * Sets the polyline path.
         *
         * \@memberof Polyline
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polylines path.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetPath = /**
         * Sets the polyline path.
         *
         * \@memberof Polyline
         * @param {?} path - An Array of {\@link ILatLong} (or array of arrays) describing the polylines path.
         *
         * @return {?}
         */
            function (path) {
                var /** @type {?} */ p = new Array();
                path.forEach(function (x) { return p.push(new google.maps.LatLng(x.latitude, x.longitude)); });
                this._polyline.setPath(p);
            };
        /**
         * Sets whether the polyline is visible.
         *
         * \@memberof Polyline
         * @param {?} visible - True to set the polyline visible, false otherwise.
         *
         * @return {?}
         */
        GooglePolyline.prototype.SetVisible = /**
         * Sets whether the polyline is visible.
         *
         * \@memberof Polyline
         * @param {?} visible - True to set the polyline visible, false otherwise.
         *
         * @return {?}
         */
            function (visible) {
                this._polyline.setVisible(visible);
            };
        /**
         * Configures the tooltip for the polyline
         * \@memberof GooglePolyline
         * @return {?}
         */
        GooglePolyline.prototype.ManageTooltip = /**
         * Configures the tooltip for the polyline
         * \@memberof GooglePolyline
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._showTooltip && this._title != null && this._title !== '') {
                    var /** @type {?} */ o = {
                        text: this._title,
                        align: 'left',
                        offset: new google.maps.Point(0, 25),
                        backgroundColor: 'bisque',
                        hidden: true,
                        fontSize: 12,
                        fontColor: '#000000',
                        strokeWeight: 0
                    };
                    if (this._tooltip == null) {
                        o["map"] = this.NativePrimitve.getMap();
                        o["zIndex"] = 100000;
                        this._tooltip = new GoogleMapLabel(o);
                    }
                    else {
                        this._tooltip.SetValues(o);
                    }
                    if (!this._hasToolTipReceiver) {
                        this._mouseOverListener = this.NativePrimitve.addListener('mouseover', function (e) {
                            _this._tooltip.Set('position', e.latLng);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        });
                        this._mouseMoveListener = this.NativePrimitve.addListener('mousemove', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('position', e.latLng);
                            }
                        });
                        this._mouseOutListener = this.NativePrimitve.addListener('mouseout', function (e) {
                            if (_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', true);
                                _this._tooltipVisible = false;
                            }
                        });
                        this._hasToolTipReceiver = true;
                    }
                }
                if ((!this._showTooltip || this._title === '' || this._title == null)) {
                    if (this._hasToolTipReceiver) {
                        if (this._mouseOutListener) {
                            google.maps.event.removeListener(this._mouseOutListener);
                        }
                        if (this._mouseOverListener) {
                            google.maps.event.removeListener(this._mouseOverListener);
                        }
                        if (this._mouseMoveListener) {
                            google.maps.event.removeListener(this._mouseMoveListener);
                        }
                        this._hasToolTipReceiver = false;
                    }
                    if (this._tooltip) {
                        this._tooltip.SetMap(null);
                        this._tooltip = null;
                    }
                }
            };
        return GooglePolyline;
    }(Polyline));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This contstant translates the abstract map events into their corresponding google map
     * equivalents.
     */
    var /** @type {?} */ GoogleMapEventsLookup = {
        click: 'click',
        dblclick: 'dblclick',
        rightclick: 'rightclick',
        resize: 'resize',
        boundschanged: 'bounds_changed',
        centerchanged: 'center_changed',
        zoomchanged: 'zoom_changed',
        mouseover: 'mouseover',
        mouseout: 'mouseout',
        mousemove: 'mousemove',
        infowindowclose: 'closeclick'
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementing a canvas overlay to be placed on the map for Google Maps.
     *
     * @export
     */
    var /**
     * Concrete implementing a canvas overlay to be placed on the map for Google Maps.
     *
     * @export
     */ GoogleCanvasOverlay = (function (_super) {
        __extends(GoogleCanvasOverlay, _super);
        /**
         * Creates a new instance of the GoogleCanvasOverlay class.
         * @param drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @memberof GoogleCanvasOverlay
         */
        function GoogleCanvasOverlay(drawCallback) {
            return _super.call(this, drawCallback) || this;
        }
        /**
         * Obtains geo coordinates for the click location
         *
         * \@memberof GoogleCanvasOverlay
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
        GoogleCanvasOverlay.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the click location
         *
         * \@memberof GoogleCanvasOverlay
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.latLng) {
                    return null;
                }
                if (!e.latLng.lat || !e.latLng.lng) {
                    return null;
                }
                return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };
            };
        /**
         * Gets the map associted with the label.
         *
         * \@memberof GoogleCanvasOverlay
         * \@method
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.GetMap = /**
         * Gets the map associted with the label.
         *
         * \@memberof GoogleCanvasOverlay
         * \@method
         * @return {?}
         */
            function () {
                return ((this)).getMap();
            };
        /**
         * Returns a MapLabel instance for the current platform that can be used as a tooltip.
         * This method only generates the map label. Content and placement is the responsibility
         * of the caller.
         *
         * \@memberof GoogleCanvasOverlay
         * \@method
         * @return {?} - The label to be used for the tooltip.
         */
        GoogleCanvasOverlay.prototype.GetToolTipOverlay = /**
         * Returns a MapLabel instance for the current platform that can be used as a tooltip.
         * This method only generates the map label. Content and placement is the responsibility
         * of the caller.
         *
         * \@memberof GoogleCanvasOverlay
         * \@method
         * @return {?} - The label to be used for the tooltip.
         */
            function () {
                var /** @type {?} */ o = {
                    align: 'left',
                    offset: new google.maps.Point(0, 25),
                    backgroundColor: 'bisque',
                    hidden: true,
                    fontSize: 12,
                    fontColor: '#000000',
                    strokeWeight: 0
                };
                o["zIndex"] = 100000;
                var /** @type {?} */ label = new GoogleMapLabel(o);
                label.SetMap(this.GetMap());
                return label;
            };
        /**
         * Called when the custom overlay is added to the map. Triggers Onload....
         * \@memberof GoogleCanvasOverlay
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.OnAdd = /**
         * Called when the custom overlay is added to the map. Triggers Onload....
         * \@memberof GoogleCanvasOverlay
         * @return {?}
         */
            function () {
                _super.prototype.OnAdd.call(this);
                this.OnLoad();
                this._canvas.style.zIndex = '100';
                // move the canvas above primitives such as polygons.
                // set the overlay to ready state
                this._readyResolver(true);
            };
        /**
         * Called whenever the canvas needs to be redrawn. This method does not do the actual
         * update, it simply scales the canvas. The actual redraw happens once the map is idle.
         * \@memberof GoogleCanvasOverly
         * \@method
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.OnDraw = /**
         * Called whenever the canvas needs to be redrawn. This method does not do the actual
         * update, it simply scales the canvas. The actual redraw happens once the map is idle.
         * \@memberof GoogleCanvasOverly
         * \@method
         * @return {?}
         */
            function () {
                var /** @type {?} */ map = this.GetMap();
                {
                    // Re-drawing the canvas as it moves would be too slow. Instead, scale and translate canvas element.
                    // Upon idle or drag end, we can then redraw the canvas....
                    var /** @type {?} */ zoomCurrent = map.getZoom();
                    var /** @type {?} */ centerCurrent = map.getCenter();
                    // Calculate map scale based on zoom level difference.
                    var /** @type {?} */ scale = Math.pow(2, zoomCurrent - this._zoomStart);
                    // Calculate the scaled dimensions of the canvas.
                    var /** @type {?} */ el = map.getDiv();
                    var /** @type {?} */ w = el.offsetWidth;
                    var /** @type {?} */ h = el.offsetHeight;
                    var /** @type {?} */ newWidth = w * scale;
                    var /** @type {?} */ newHeight = h * scale;
                    // Calculate offset of canvas based on zoom and center offsets.
                    var /** @type {?} */ projection = ((this)).getProjection();
                    var /** @type {?} */ cc = projection.fromLatLngToDivPixel(centerCurrent);
                    // Update the canvas CSS position and dimensions.
                    this.UpdatePosition(cc.x - newWidth / 2, cc.y - newHeight / 2, newWidth, newHeight);
                }
            };
        /**
         * CanvasOverlay loaded, attach map events for updating canvas.
         * \@method
         * \@memberof GoogleCanvasOverlay
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.OnLoad = /**
         * CanvasOverlay loaded, attach map events for updating canvas.
         * \@method
         * \@memberof GoogleCanvasOverlay
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ map = ((this)).getMap();
                // Get the current map view information.
                this._zoomStart = map.getZoom();
                var /** @type {?} */ c = map.getCenter();
                this._centerStart = {
                    latitude: c.lat(),
                    longitude: c.lng()
                };
                // When the map stops moving, render new data on the canvas.
                this._viewChangeEndEvent = google.maps.event.addListener(map, 'idle', function (e) {
                    _this.UpdateCanvas();
                });
                // Update the position of the overlay when the map is resized.
                this._mapResizeEvent = google.maps.event.addListener(map, 'resize', function (e) {
                    _this.UpdateCanvas();
                });
            };
        /**
         * Associates the cnavas overlay with a map.
         * \@method
         * \@memberof GoogleCanvasOverlay
         * @param {?} map
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.SetMap = /**
         * Associates the cnavas overlay with a map.
         * \@method
         * \@memberof GoogleCanvasOverlay
         * @param {?} map
         * @return {?}
         */
            function (map) {
                ((this)).setMap(map);
            };
        ///
        /// Protected methods
        ///
        /**
         * Attaches the canvas to the map.
         * @memberof CanvasOverlay
         * @method
         */
        /**
         * Attaches the canvas to the map.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} el
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.SetCanvasElement = /**
         * Attaches the canvas to the map.
         * \@memberof CanvasOverlay
         * \@method
         * @param {?} el
         * @return {?}
         */
            function (el) {
                var /** @type {?} */ panes = ((this)).getPanes();
                if (panes) {
                    if (el != null) {
                        panes.overlayLayer.appendChild(el);
                        // 4: floatPane (infowindow)
                        // 3: overlayMouseTarget (mouse events)
                        // 2: markerLayer (marker images)
                        // 1: overlayLayer (polygons, polylines, ground overlays, tile layer overlays)
                        // 0: mapPane (lowest pane above the map tiles)
                    }
                    else {
                        panes.overlayLayer.removeChild(this._canvas);
                    }
                }
            };
        /**
         * Remove the map event handlers.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Remove the map event handlers.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.RemoveEventHandlers = /**
         * Remove the map event handlers.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                // Remove all event handlers from the map.
                if (this._viewChangeEndEvent) {
                    google.maps.event.removeListener(this._viewChangeEndEvent);
                }
                if (this._mapResizeEvent) {
                    google.maps.event.removeListener(this._mapResizeEvent);
                }
            };
        /**
         * Updates the Canvas size based on the map size.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Updates the Canvas size based on the map size.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.Resize = /**
         * Updates the Canvas size based on the map size.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                var /** @type {?} */ map = ((this)).getMap();
                // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.
                var /** @type {?} */ el = map.getDiv();
                this._canvas.width = el.offsetWidth;
                this._canvas.height = el.offsetHeight;
            };
        /**
         * Updates the Canvas.
         * @memberof CanvasOverlay
         * @method
         * @protected
         */
        /**
         * Updates the Canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
        GoogleCanvasOverlay.prototype.UpdateCanvas = /**
         * Updates the Canvas.
         * \@memberof CanvasOverlay
         * \@method
         * @protected
         * @return {?}
         */
            function () {
                var /** @type {?} */ map = ((this)).getMap();
                // Only render the canvas if it isn't in streetside mode.
                {
                    this._canvas.style.display = '';
                    // Reset CSS position and dimensions of canvas.
                    var /** @type {?} */ el = map.getDiv();
                    var /** @type {?} */ w = el.offsetWidth;
                    var /** @type {?} */ h = el.offsetHeight;
                    var /** @type {?} */ centerPoint = ((this)).getProjection().fromLatLngToDivPixel(map.getCenter());
                    this.UpdatePosition((centerPoint.x - w / 2), (centerPoint.y - h / 2), w, h);
                    // Redraw the canvas.
                    this.Redraw(true);
                    // Get the current map view information.
                    this._zoomStart = map.getZoom();
                    var /** @type {?} */ c = map.getCenter();
                    this._centerStart = {
                        latitude: c.lat(),
                        longitude: c.lng()
                    };
                }
            };
        return GoogleCanvasOverlay;
    }(CanvasOverlay));
    /**
     * Helper function to extend the OverlayView into the CanvasOverlay
     *
     * @export
     * \@method
     * @return {?}
     */
    function MixinCanvasOverlay$1() {
        var /** @type {?} */ x = GoogleCanvasOverlay.prototype;
        GoogleCanvasOverlay.prototype = /** @type {?} */ (new google.maps.OverlayView());
        for (var /** @type {?} */ y in x) {
            if (((x))[y] != null) {
                ((GoogleCanvasOverlay.prototype))[y] = ((x))[y];
            }
        }
        ((GoogleCanvasOverlay.prototype))['onAdd'] = x['OnAdd'];
        ((GoogleCanvasOverlay.prototype))['draw'] = x['OnDraw'];
        ((GoogleCanvasOverlay.prototype))['onRemove'] = x['OnRemove'];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements a factory to create all the implementation specifc services for a map implementation
     *
     * @export
     * @abstract
     * @abstract
     */
    var MapServiceFactory = (function () {
        function MapServiceFactory() {
        }
        MapServiceFactory.decorators = [
            { type: core.Injectable },
        ];
        return MapServiceFactory;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract class to implement map api. A concrete implementation should be created for each
     * Map provider supported (e.g. Bing, Goolge, ESRI)
     *
     * @export
     * @abstract
     * @abstract
     */
    var MapService = (function () {
        function MapService() {
        }
        /**
         * Gets a random geo locations filling the bounding box.
         *
         * \@memberof MapService
         * @param {?} count - number of locations to return
         * @param {?} bounds  - bounding box.
         * @return {?} - Array of geo locations.
         */
        MapService.GetRandonLocations = /**
         * Gets a random geo locations filling the bounding box.
         *
         * \@memberof MapService
         * @param {?} count - number of locations to return
         * @param {?} bounds  - bounding box.
         * @return {?} - Array of geo locations.
         */
            function (count, bounds) {
                var /** @type {?} */ a = [];
                var /** @type {?} */ _getRandomLocation = function (b) {
                    var /** @type {?} */ lat = Math.random() * (b.maxLatitude - b.minLatitude) + b.minLatitude;
                    var /** @type {?} */ lng = 0;
                    if (crossesDateLine) {
                        lng = Math.random() * (b.minLongitude + 360 - b.maxLongitude) + b.maxLongitude;
                        if (lng > 180) {
                            lng = lng - 360;
                        }
                    }
                    else {
                        lng = Math.random() * (b.maxLongitude - b.minLongitude) + b.minLongitude;
                    }
                    var /** @type {?} */ p = { latitude: lat, longitude: lng };
                    return p;
                };
                var /** @type {?} */ crossesDateLine = false;
                if (bounds == null) {
                    bounds = /** @type {?} */ ({
                        maxLatitude: 360,
                        minLatitude: 0,
                        maxLongitude: 170,
                        minLongitude: 0
                    });
                }
                if (bounds.center.longitude < bounds.minLongitude || bounds.center.longitude > bounds.maxLongitude) {
                    crossesDateLine = true;
                }
                if (!count || count <= 0) {
                    return [_getRandomLocation(bounds)];
                }
                for (var /** @type {?} */ r = 0; r < count; r++) {
                    a.push(_getRandomLocation(bounds));
                }
                return a;
            };
        MapService.decorators = [
            { type: core.Injectable },
        ];
        return MapService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * The abstract class represents the contract defintions for a marker service to be implemented by an acutaly underlying
     * map architecture.
     *
     * @export
     * @abstract
     * @abstract
     */
    var MarkerService = (function () {
        function MarkerService() {
        }
        MarkerService.decorators = [
            { type: core.Injectable },
        ];
        return MarkerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This class defines the contract for an InfoBoxService. Each Map Architecture provider is expected the furnish a concrete implementation.
     *
     * @export
     * @abstract
     * @abstract
     */
    var InfoBoxService = (function () {
        function InfoBoxService() {
        }
        InfoBoxService.decorators = [
            { type: core.Injectable },
        ];
        return InfoBoxService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract class to to define the layer service contract. Must be realized by implementing provider.
     *
     * @export
     * @abstract
     * @abstract
     */
    var LayerService = (function () {
        function LayerService() {
        }
        LayerService.decorators = [
            { type: core.Injectable },
        ];
        return LayerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * The abstract class represents the contract defintions for a polygon service to be implemented by an acutaly underlying
     * map architecture.
     *
     * @export
     * @abstract
     * @abstract
     */
    var PolygonService = (function () {
        function PolygonService() {
        }
        PolygonService.decorators = [
            { type: core.Injectable },
        ];
        return PolygonService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * The abstract class represents the contract defintions for a polyline service to be implemented by an acutaly underlying
     * map architecture.
     *
     * @export
     * @abstract
     * @abstract
     */
    var PolylineService = (function () {
        function PolylineService() {
        }
        PolylineService.decorators = [
            { type: core.Injectable },
        ];
        return PolylineService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract class to to define teh cluster layer service contract. Must be realized by implementing provider.
     *
     * @export
     * @abstract
     * @abstract
     */
    var ClusterService = (function (_super) {
        __extends(ClusterService, _super);
        function ClusterService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ClusterService.decorators = [
            { type: core.Injectable },
        ];
        return ClusterService;
    }(LayerService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * InfoBoxAction renders an action in an info window {\@link InfoBox}
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective, InfoBoxComponent, InfoBoxActionDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *    .map-container { height: 300px; }
     *  `],
     *  template: `
     *    <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-marker [Latitude]="lat" [Longitude]="lng" [Label]="'M'">
     *        <x-info-box>
     *          <x-info-box-action [Label]="actionlabel" (ActionClicked)="actionClicked(this)"></x-info-box-action>
     *        </x-info-box>
     *      </x-map-marker>
     *    </x-map>
     *  `
     * })
     * ```
     *
     * @export
     */
    var InfoBoxActionDirective = (function () {
        function InfoBoxActionDirective() {
            /**
             * Emits an event when the action has been clicked
             *
             * \@memberof InfoBoxActionDirective
             */
            this.ActionClicked = new core.EventEmitter();
        }
        InfoBoxActionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-info-box-action'
                    },] },
        ];
        InfoBoxActionDirective.propDecorators = {
            Label: [{ type: core.Input }],
            ActionClicked: [{ type: core.Output }]
        };
        return InfoBoxActionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * internal counter to use as ids for multiple infoboxes.
     */
    var /** @type {?} */ infoBoxId = 0;
    /**
     * InfoBox renders a info window inside a {\@link MapMarkerDirective} or standalone.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective, InfoBoxComponent, InfoBoxActionDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *    .map-container { height: 300px; }
     * `],
     *  template: `
     *    <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-marker [Latitude]="lat" [Longitude]="lng" [Label]="'M'">
     *        <x-info-box [DisableAutoPan]="true">
     *          Hi, this is the content of the <strong>info window</strong>
     *         </x-info-box>
     *       </x-map-marker>
     *     </x-map>
     *  `
     * })
     * ```
     *
     * @export
     */
    var InfoBoxComponent = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of InfoBoxComponent.
         * @param _infoBoxService - Concrete {@link InfoBoxService} implementation for underlying Map architecture.
         *
         * @memberof InfoBoxComponent
         */
        function InfoBoxComponent(_infoBoxService) {
            this._infoBoxService = _infoBoxService;
            this._infoBoxAddedToManager = false;
            this._id = (infoBoxId++).toString();
            /**
             * Determine whether only one infobox can be open at a time. Note that ANY info box settings.
             *
             * \@memberof InfoBoxComponent
             */
            this.Modal = true;
            /**
             * Determines visibility of infobox
             *
             * \@memberof InfoBoxComponent
             */
            this.Visible = false;
            /**
             * Determines if other info boxes should be closed before opening this one
             *
             * \@memberof InfoBoxComponent
             */
            this.CloseInfoBoxesOnOpen = true;
            /**
             * Emits an event when the info window is closed.
             *
             * \@memberof InfoBoxComponent
             */
            this.InfoBoxClose = new core.EventEmitter();
        }
        Object.defineProperty(InfoBoxComponent.prototype, "HtmlContent", {
            get: /**
             * Gets the HTML content of the info box.
             *
             * \@readonly
             * \@memberof InfoBoxComponent
             * @return {?}
             */ function () {
                if (this._content.nativeElement && this._content.nativeElement.innerText && this._content.nativeElement.innerText.trim() !== '') {
                    return this._content.nativeElement.outerHTML;
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InfoBoxComponent.prototype, "Id", {
            get: /**
             * Gets the Id of the info box as a string.
             *
             * \@readonly
             * \@memberof InfoBoxComponent
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Closes the Infobox.
         *
         * \@memberof InfoBoxComponent
         * @return {?}
         */
        InfoBoxComponent.prototype.Close = /**
         * Closes the Infobox.
         *
         * \@memberof InfoBoxComponent
         * @return {?}
         */
            function () {
                var _this = this;
                return this._infoBoxService.Close(this).then(function () {
                    _this.InfoBoxClose.emit(_this._id);
                });
            };
        /**
         * Called on after component view as been initialized. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @return {?}
         */
        InfoBoxComponent.prototype.ngAfterViewInit = /**
         * Called on after component view as been initialized. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @return {?}
         */
            function () {
                this._infoBoxService.AddInfoWindow(this);
                this._infoBoxAddedToManager = true;
                this.HandleEvents();
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        InfoBoxComponent.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._infoBoxAddedToManager) {
                    return;
                }
                if ((changes['latitude'] || changes['longitude']) && typeof this.Latitude === 'number' &&
                    typeof this.Longitude === 'number') {
                    this._infoBoxService.SetPosition(this, {
                        latitude: changes['latitude'].currentValue,
                        longitude: changes['longitude'].currentValue
                    });
                }
                this.SetInfoWindowOptions(changes);
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @return {?}
         */
        InfoBoxComponent.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof Map
         * @return {?}
         */
            function () { this._infoBoxService.DeleteInfoWindow(this); };
        /**
         * Opens a closed info window.
         *
         * \@memberof InfoBoxComponent
         * @param {?=} loc
         * @return {?} - Promise that is fullfilled when the infobox has been opened.
         *
         */
        InfoBoxComponent.prototype.Open = /**
         * Opens a closed info window.
         *
         * \@memberof InfoBoxComponent
         * @param {?=} loc
         * @return {?} - Promise that is fullfilled when the infobox has been opened.
         *
         */
            function (loc) {
                return this._infoBoxService.Open(this, loc);
            };
        /**
         * Returns a string representation of the info box.
         *
         * \@memberof InfoBoxComponent
         * @return {?} - string representation of the info box.
         *
         */
        InfoBoxComponent.prototype.ToString = /**
         * Returns a string representation of the info box.
         *
         * \@memberof InfoBoxComponent
         * @return {?} - string representation of the info box.
         *
         */
            function () { return 'InfoBoxComponent-' + this._id; };
        /**
         * Delegate handling the map click events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        InfoBoxComponent.prototype.HandleEvents = /**
         * Delegate handling the map click events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._infoBoxService.CreateEventObservable('infowindowclose', this).subscribe(function (e) {
                    _this.InfoBoxClose.emit(_this._id);
                });
            };
        /**
         * Sets the info window options
         *
         * \@memberof InfoBoxComponent
         * @param {?} changes
         *
         * @return {?}
         */
        InfoBoxComponent.prototype.SetInfoWindowOptions = /**
         * Sets the info window options
         *
         * \@memberof InfoBoxComponent
         * @param {?} changes
         *
         * @return {?}
         */
            function (changes) {
                var /** @type {?} */ options = {};
                if (changes['title']) {
                    options.title = this.Title;
                }
                if (changes['description']) {
                    options.description = this.Description;
                }
                if (changes['disableAutoPan']) {
                    options.disableAutoPan = this.DisableAutoPan;
                }
                if (changes['visible']) {
                    options.visible = this.Visible;
                }
                if (changes['xOffset'] || changes['yOffset']) {
                    if (options.pixelOffset == null) {
                        options.pixelOffset = { x: 0, y: 0 };
                    }
                    options.pixelOffset.x = this.xOffset;
                    options.pixelOffset.y = this.yOffset;
                }
                this._infoBoxService.SetOptions(this, options);
            };
        InfoBoxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'x-info-box',
                        template: "\n        <div #infoBoxContent class='info-box-content'>\n            <ng-content></ng-content>\n        </div>",
                        styles: ["\n        x-map .MicrosoftMap .Infobox .infobox-title { padding: 10px 10px 5px 10px }\n        x-map .MicrosoftMap .Infobox .infobox-info { padding: 3px 10px 10px 10px }\n        x-map .MicrosoftMap .Infobox .infobox-actions { height: auto }\n    "],
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        InfoBoxComponent.ctorParameters = function () {
            return [
                { type: InfoBoxService }
            ];
        };
        InfoBoxComponent.propDecorators = {
            _content: [{ type: core.ViewChild, args: ['infoBoxContent',] }],
            InfoWindowActions: [{ type: core.ContentChildren, args: [InfoBoxActionDirective,] }],
            Latitude: [{ type: core.Input }],
            Longitude: [{ type: core.Input }],
            Title: [{ type: core.Input }],
            Description: [{ type: core.Input }],
            DisableAutoPan: [{ type: core.Input }],
            MaxWidth: [{ type: core.Input }],
            Modal: [{ type: core.Input }],
            HostMarker: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            xOffset: [{ type: core.Input }],
            yOffset: [{ type: core.Input }],
            CloseInfoBoxesOnOpen: [{ type: core.Input }],
            InfoBoxClose: [{ type: core.Output }]
        };
        return InfoBoxComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * internal counter to use as ids for marker.
     */
    var /** @type {?} */ markerId = 0;
    /**
     * MapMarkerDirective renders a map marker inside a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-marker [Latitude]="lat" [Longitude]="lng" [Label]="'M'"></x-map-marker>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapMarkerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapMarkerDirective.
         * @param _markerService - Concreate implementation of a {@link MarkerService}.
         * @param _containerRef - View container hosting the marker.
         * Used to determine parent layer through markup.
         *
         * @memberof MapMarkerDirective
         */
        function MapMarkerDirective(_markerService, _containerRef) {
            this._markerService = _markerService;
            this._containerRef = _containerRef;
            this._clickTimeout = null;
            this._events = [];
            this._inClusterLayer = false;
            this._inCustomLayer = false;
            this._markerAddedToManger = false;
            /**
             * This event is fired when the DOM dblclick event is fired on the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.DblClick = new core.EventEmitter();
            /**
             * This event is repeatedly fired while the user drags the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.Drag = new core.EventEmitter();
            /**
             * This event is fired when the user stops dragging the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.DragEnd = new core.EventEmitter();
            /**
             * If true, the marker can be dragged. Default value is false.
             *
             * \@memberof MapMarkerDirective
             */
            this.Draggable = false;
            /**
             * This event is fired when the user starts dragging the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.DragStart = new core.EventEmitter();
            /**
             * This event emitter gets emitted when a marker icon is being created.
             *
             * \@memberof MapMarkerDirective
             */
            this.DynamicMarkerCreated = new core.EventEmitter();
            /**
             * True to indiciate whether this is the first marker in a set.
             * Use this for bulk operations (particularily clustering) to ensure performance.
             *
             * \@memberof MapMarkerDirective
             */
            this.IsFirstInSet = false;
            /**
             * True to indiciate whether this is the last marker in a set.
             * Use this for bulk operations (particularily clustering) to ensure performance.
             *
             * \@memberof MapMarkerDirective
             */
            this.IsLastInSet = true;
            /**
             * This event emitter gets emitted when the user clicks on the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.MarkerClick = new core.EventEmitter();
            /**
             * Arbitary metadata to assign to the Marker. This is useful for events
             *
             * \@memberof MapMarkerDirective
             */
            this.Metadata = new Map();
            /**
             * This event is fired when the DOM mousedown event is fired on the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseDown = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on the marker.
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseMove = new core.EventEmitter();
            /**
             * This event is fired on marker mouseout.
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseOut = new core.EventEmitter();
            /**
             * This event is fired on marker mouseover.
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseOver = new core.EventEmitter();
            /**
             * This event is fired whe the DOM mouseup event is fired on the marker
             *
             * \@memberof MapMarkerDirective
             */
            this.MouseUp = new core.EventEmitter();
            /**
             * This even is fired when the marker is right-clicked on.
             *
             * \@memberof MapMarkerDirective
             */
            this.RightClick = new core.EventEmitter();
            this._id = (markerId++).toString();
        }
        Object.defineProperty(MapMarkerDirective.prototype, "AddedToManager", {
            get: /**
             * Getswhether the marker has already been added to the marker service and is ready for use.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._markerAddedToManger; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerDirective.prototype, "Id", {
            get: /**
             * Gets the id of the marker as a string.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerDirective.prototype, "InClusterLayer", {
            get: /**
             * Gets whether the marker is in a cluster layer. See {\@link ClusterLayer}.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._inClusterLayer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerDirective.prototype, "InCustomLayer", {
            get: /**
             * Gets whether the marker is in a custom layer. See {\@link MapLayer}.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._inCustomLayer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerDirective.prototype, "LayerId", {
            get: /**
             * gets the id of the Layer the marker belongs to.
             *
             * \@readonly
             * \@memberof MapMarkerDirective
             * @return {?}
             */ function () { return this._layerId; },
            enumerable: true,
            configurable: true
        });
        /**
         * Translates a marker geo location to a pixel location relative to the map viewport.
         *
         * \@memberof MapMarkerDirective
         * @param {?=} loc
         * @return {?} - A promise that when fullfilled contains an {\@link IPoint} representing the pixel coordinates.
         *
         */
        MapMarkerDirective.prototype.LocationToPixel = /**
         * Translates a marker geo location to a pixel location relative to the map viewport.
         *
         * \@memberof MapMarkerDirective
         * @param {?=} loc
         * @return {?} - A promise that when fullfilled contains an {\@link IPoint} representing the pixel coordinates.
         *
         */
            function (loc) {
                return this._markerService.LocationToPoint(loc ? loc : this);
            };
        /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
        MapMarkerDirective.prototype.ngAfterContentInit = /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
            function () {
                if (this._infoBox != null) {
                    this._infoBox.HostMarker = this;
                }
                if (this._containerRef.element.nativeElement.parentElement) {
                    var /** @type {?} */ parentName = this._containerRef.element.nativeElement.parentElement.tagName;
                    if (parentName.toLowerCase() === 'x-cluster-layer') {
                        this._inClusterLayer = true;
                    }
                    else if (parentName.toLowerCase() === 'x-map-layer') {
                        this._inCustomLayer = true;
                    }
                    this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);
                }
                if (!this._markerAddedToManger) {
                    this._markerService.AddMarker(this);
                    this._markerAddedToManger = true;
                    this.AddEventListeners();
                }
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapMarkerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
        MapMarkerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapMarkerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
            function (changes) {
                if (typeof this.Latitude !== 'number' || typeof this.Longitude !== 'number') {
                    return;
                }
                if (!this._markerAddedToManger) {
                    return;
                }
                if (changes['Latitude'] || changes['Longitude']) {
                    this._markerService.UpdateMarkerPosition(this);
                }
                if (changes['Title']) {
                    this._markerService.UpdateTitle(this);
                }
                if (changes['Label']) {
                    this._markerService.UpdateLabel(this);
                }
                if (changes['Draggable']) {
                    this._markerService.UpdateDraggable(this);
                }
                if (changes['IconUrl'] || changes['IconInfo']) {
                    this._markerService.UpdateIcon(this);
                }
                if (changes['Anchor']) {
                    this._markerService.UpdateAnchor(this);
                }
                if (changes['Visible']) {
                    this._markerService.UpdateVisible(this);
                }
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
        MapMarkerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
            function () {
                this._markerService.DeleteMarker(this);
                this._events.forEach(function (s) { return s.unsubscribe(); });
            };
        /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapMarkerDirective
         * @return {?} - string representation of the marker id.
         */
        MapMarkerDirective.prototype.toString = /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapMarkerDirective
         * @return {?} - string representation of the marker id.
         */
            function () { return 'MapMarker-' + this._id.toString(); };
        /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
        MapMarkerDirective.prototype.AddEventListeners = /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapMarkerDirective
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ _getEventArg = function (e) {
                    return {
                        Marker: _this,
                        Click: e,
                        Location: _this._markerService.GetCoordinatesFromClick(e),
                        Pixels: _this._markerService.GetPixelsFromClick(e)
                    };
                };
                this._events.push(this._markerService.CreateEventObservable('click', this).subscribe(function (e) {
                    ///
                    /// this is necessary since map will treat a doubleclick first as two clicks...'
                    ///
                    _this._clickTimeout = rxjs.timer(300).subscribe(function (n) {
                        if (_this._infoBox != null) {
                            _this._infoBox.Open(_this._markerService.GetCoordinatesFromClick(e));
                        }
                        _this.MarkerClick.emit(_getEventArg(e));
                    });
                }));
                this._events.push(this._markerService.CreateEventObservable('dblclick', this).subscribe(function (e) {
                    if (_this._clickTimeout) {
                        _this._clickTimeout.unsubscribe();
                        _this._clickTimeout = null;
                    }
                    _this.DblClick.emit(_getEventArg(e));
                }));
                var /** @type {?} */ handlers = [
                    { name: 'drag', handler: function (ev) { return _this.Drag.emit(_getEventArg(ev)); } },
                    { name: 'dragend', handler: function (ev) { return _this.DragEnd.emit(_getEventArg(ev)); } },
                    { name: 'dragstart', handler: function (ev) { return _this.DragStart.emit(_getEventArg(ev)); } },
                    { name: 'mousedown', handler: function (ev) { return _this.MouseDown.emit(_getEventArg(ev)); } },
                    { name: 'mousemove', handler: function (ev) { return _this.MouseMove.emit(_getEventArg(ev)); } },
                    { name: 'mouseout', handler: function (ev) { return _this.MouseOut.emit(_getEventArg(ev)); } },
                    { name: 'mouseover', handler: function (ev) { return _this.MouseOver.emit(_getEventArg(ev)); } },
                    { name: 'mouseup', handler: function (ev) { return _this.MouseUp.emit(_getEventArg(ev)); } },
                    { name: 'rightclick', handler: function (ev) { return _this.RightClick.emit(_getEventArg(ev)); } },
                ];
                handlers.forEach(function (obj) {
                    var /** @type {?} */ os = _this._markerService.CreateEventObservable(obj.name, _this).subscribe(obj.handler);
                    _this._events.push(os);
                });
            };
        MapMarkerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-marker'
                    },] },
        ];
        /** @nocollapse */
        MapMarkerDirective.ctorParameters = function () {
            return [
                { type: MarkerService },
                { type: core.ViewContainerRef }
            ];
        };
        MapMarkerDirective.propDecorators = {
            _infoBox: [{ type: core.ContentChild, args: [InfoBoxComponent,] }],
            Anchor: [{ type: core.Input }],
            DblClick: [{ type: core.Output }],
            Drag: [{ type: core.Output }],
            DragEnd: [{ type: core.Output }],
            Draggable: [{ type: core.Input }],
            DragStart: [{ type: core.Output }],
            DynamicMarkerCreated: [{ type: core.Output }],
            Height: [{ type: core.Input }],
            IconInfo: [{ type: core.Input }],
            IconUrl: [{ type: core.Input }],
            IsFirstInSet: [{ type: core.Input }],
            IsLastInSet: [{ type: core.Input }],
            Label: [{ type: core.Input }],
            Latitude: [{ type: core.Input }],
            Longitude: [{ type: core.Input }],
            MarkerClick: [{ type: core.Output }],
            Metadata: [{ type: core.Input }],
            MouseDown: [{ type: core.Output }],
            MouseMove: [{ type: core.Output }],
            MouseOut: [{ type: core.Output }],
            MouseOver: [{ type: core.Output }],
            MouseUp: [{ type: core.Output }],
            RightClick: [{ type: core.Output }],
            Title: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            Width: [{ type: core.Input }]
        };
        return MapMarkerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Renders a map based on a given provider.
     * **Important note**: To be able see a map in the browser, you have to define a height for the CSS
     * class `map-container`.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent} from '...';
     *
     * \@Component({
     *  selector: 'my-map',
     *  styles: [`
     *    .map-container { height: 300px; }
     * `],
     *  template: `
     *    <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom"></x-map>
     *  `
     * })
     * ```
     *
     * @export
     */
    var MapComponent = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapComponent.
         *
         * @param _mapService - Concreted implementation of a map service for the underlying maps implementations.
         *                                   Generally provided via injections.
         * @memberof MapComponent
         */
        function MapComponent(_mapService, _zone) {
            this._mapService = _mapService;
            this._zone = _zone;
            this._longitude = 0;
            this._latitude = 0;
            this._zoom = 0;
            this._options = {};
            this._box = null;
            this._containerClass = true;
            /**
             * This event emitter is fired when the map bounding box changes.
             *
             * \@memberof MapComponent
             */
            this.BoundsChange = new core.EventEmitter();
            /**
             * This event emitter is fired when the map center changes.
             *
             * \@memberof MapComponent
             */
            this.CenterChange = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user clicks on the map (but not when they click on a
             * marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapClick = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user double-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapDblClick = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user right-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapRightClick = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user double-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapMouseOver = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user double-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapMouseOut = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user double-clicks on the map (but not when they click
             * on a marker or infoWindow).
             *
             * \@memberof MapComponent
             */
            this.MapMouseMove = new core.EventEmitter();
            /**
             * The event emitter is fired when the map service is available and the maps has been
             * Initialized (but not necessarily created). It contains a Promise that when fullfilled returns
             * the main map object of the underlying platform.
             *
             * \@memberof MapComponent
             */
            this.MapPromise = new core.EventEmitter();
            /**
             * This event emiiter is fired when the map zoom changes
             *
             * \@memberof MapComponent
             */
            this.ZoomChange = new core.EventEmitter();
            /**
             * This event emitter is fired when the map service is available and the maps has been
             * Initialized
             * \@memberOf MapComponent
             */
            this.MapService = new core.EventEmitter();
        }
        Object.defineProperty(MapComponent.prototype, "Box", {
            ///
            /// Property declarations
            ///
            /**
             * Get or sets the maximum and minimum bounding box for map.
             *
             * @memberof MapComponent
             */
            get: /**
             * Get or sets the maximum and minimum bounding box for map.
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._box; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._box = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapComponent.prototype, "Latitude", {
            /**
             * Gets or sets the latitude that sets the center of the map.
             *
             * @memberof MapComponent
             */
            get: /**
             * Gets or sets the latitude that sets the center of the map.
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._longitude; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._latitude = this.ConvertToDecimal(value);
                this.UpdateCenter();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapComponent.prototype, "Longitude", {
            /**
             * Gets or sets the longitude that sets the center of the map.
             *
             * @memberof MapComponent
             */
            get: /**
             * Gets or sets the longitude that sets the center of the map.
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._longitude; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._longitude = this.ConvertToDecimal(value);
                this.UpdateCenter();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapComponent.prototype, "Options", {
            /**
             * Gets or sets general map Options
             *
             * @memberof MapComponent
             */
            get: /**
             * Gets or sets general map Options
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._options; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._options = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapComponent.prototype, "Zoom", {
            /**
             * Gets or sets the zoom level of the map. The default value is `8`.
             *
             * @memberof MapComponent
             */
            get: /**
             * Gets or sets the zoom level of the map. The default value is `8`.
             *
             * \@memberof MapComponent
             * @return {?}
             */ function () { return this._zoom; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._zoom = this.ConvertToDecimal(value, 8);
                if (typeof this._zoom === 'number') {
                    this._mapService.SetZoom(this._zoom);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Called on Component initialization. Part of ng Component life cycle.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.ngOnInit = /**
         * Called on Component initialization. Part of ng Component life cycle.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                this.InitMapInstance(this._container.nativeElement);
                this.MapPromise.emit(this._mapService.MapPromise);
                this.MapService.emit(this._mapService);
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapComponent
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        MapComponent.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapComponent
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (this._mapPromise) {
                    if (changes['Box']) {
                        if (this._box != null) {
                            this._mapService.SetViewOptions(/** @type {?} */ ({
                                bounds: this._box
                            }));
                        }
                    }
                    if (changes['Options']) {
                        this._mapService.SetMapOptions(this._options);
                    }
                }
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                this._mapService.DisposeMap();
            };
        /**
         * Triggers a resize event on the map instance.
         *
         * \@memberof MapComponent
         * @return {?} - A promise that gets resolved after the event was triggered.
         *
         */
        MapComponent.prototype.TriggerResize = /**
         * Triggers a resize event on the map instance.
         *
         * \@memberof MapComponent
         * @return {?} - A promise that gets resolved after the event was triggered.
         *
         */
            function () {
                var _this = this;
                // Note: When we would trigger the resize event and show the map in the same turn (which is a
                // common case for triggering a resize event), then the resize event would not
                // work (to show the map), so we trigger the event in a timeout.
                return new Promise(function (resolve) {
                    setTimeout(function () { return _this._mapService.TriggerMapEvent('resize').then(function () { return resolve(); }); });
                });
            };
        /**
         * Converts a number-ish value to a number.
         *
         * \@memberof MapComponent
         * @param {?} value - The value to convert.
         * @param {?=} defaultValue
         * @return {?} - Converted number of the default.
         *
         */
        MapComponent.prototype.ConvertToDecimal = /**
         * Converts a number-ish value to a number.
         *
         * \@memberof MapComponent
         * @param {?} value - The value to convert.
         * @param {?=} defaultValue
         * @return {?} - Converted number of the default.
         *
         */
            function (value, defaultValue) {
                if (defaultValue === void 0) {
                    defaultValue = null;
                }
                if (typeof value === 'string') {
                    return parseFloat(value);
                }
                else if (typeof value === 'number') {
                    return /** @type {?} */ (value);
                }
                return defaultValue;
            };
        /**
         * Delegate handling the map click events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.HandleMapClickEvents = /**
         * Delegate handling the map click events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._mapService.SubscribeToMapEvent('click').subscribe(function (e) {
                    //
                    // this is necessary since bing will treat a doubleclick first as two clicks...'
                    //
                    // this is necessary since bing will treat a doubleclick first as two clicks...'
                    ///
                    _this._clickTimeout = setTimeout(function () {
                        _this.MapClick.emit(/** @type {?} */ (e));
                    }, 300);
                });
                this._mapService.SubscribeToMapEvent('dblclick').subscribe(function (e) {
                    if (_this._clickTimeout) {
                        clearTimeout(/** @type {?} */ (_this._clickTimeout));
                    }
                    _this.MapDblClick.emit(/** @type {?} */ (e));
                });
                this._mapService.SubscribeToMapEvent('rightclick').subscribe(function (e) {
                    _this.MapRightClick.emit(/** @type {?} */ (e));
                });
                this._mapService.SubscribeToMapEvent('mouseover').subscribe(function (e) {
                    _this.MapMouseOver.emit(/** @type {?} */ (e));
                });
                this._mapService.SubscribeToMapEvent('mouseout').subscribe(function (e) {
                    _this.MapMouseOut.emit(/** @type {?} */ (e));
                });
                this._mapService.SubscribeToMapEvent('mousemove').subscribe(function (e) {
                    _this.MapMouseMove.emit(/** @type {?} */ (e));
                });
            };
        /**
         * Delegate handling map center change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.HandleMapBoundsChange = /**
         * Delegate handling map center change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._mapService.SubscribeToMapEvent('boundschanged').subscribe(function () {
                    _this._mapService.GetBounds().then(function (bounds) {
                        _this.BoundsChange.emit(bounds);
                    });
                });
            };
        /**
         * Delegate handling map center change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.HandleMapCenterChange = /**
         * Delegate handling map center change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._mapService.SubscribeToMapEvent('centerchanged').subscribe(function () {
                    _this._mapService.GetCenter().then(function (center) {
                        if (_this._latitude !== center.latitude || _this._longitude !== center.longitude) {
                            _this._latitude = center.latitude;
                            _this._longitude = center.longitude;
                            _this.CenterChange.emit(/** @type {?} */ ({ latitude: _this._latitude, longitude: _this._longitude }));
                        }
                    });
                });
            };
        /**
         * Delegate handling map zoom change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.HandleMapZoomChange = /**
         * Delegate handling map zoom change events.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                var _this = this;
                this._mapService.SubscribeToMapEvent('zoomchanged').subscribe(function () {
                    _this._mapService.GetZoom().then(function (z) {
                        if (_this._zoom !== z) {
                            _this._zoom = z;
                            _this.ZoomChange.emit(z);
                        }
                    });
                });
            };
        /**
         * Initializes the map.
         *
         * \@memberof MapComponent
         * @param {?} el - Html elements which will host the map canvas.
         *
         * @return {?}
         */
        MapComponent.prototype.InitMapInstance = /**
         * Initializes the map.
         *
         * \@memberof MapComponent
         * @param {?} el - Html elements which will host the map canvas.
         *
         * @return {?}
         */
            function (el) {
                var _this = this;
                this._zone.runOutsideAngular(function () {
                    if (_this._options.center == null) {
                        _this._options.center = { latitude: _this._latitude, longitude: _this._longitude };
                    }
                    if (_this._options.zoom == null) {
                        _this._options.zoom = _this._zoom;
                    }
                    if (_this._options.mapTypeId == null) {
                        _this._options.mapTypeId = MapTypeId.hybrid;
                    }
                    if (_this._box != null) {
                        _this._options.bounds = _this._box;
                    }
                    _this._mapPromise = _this._mapService.CreateMap(el, _this._options);
                    _this.HandleMapCenterChange();
                    _this.HandleMapBoundsChange();
                    _this.HandleMapZoomChange();
                    _this.HandleMapClickEvents();
                });
            };
        /**
         * Updates the map center based on the geo properties of the component.
         *
         * \@memberof MapComponent
         * @return {?}
         */
        MapComponent.prototype.UpdateCenter = /**
         * Updates the map center based on the geo properties of the component.
         *
         * \@memberof MapComponent
         * @return {?}
         */
            function () {
                if (typeof this._latitude !== 'number' || typeof this._longitude !== 'number') {
                    return;
                }
                this._mapService.SetCenter({
                    latitude: this._latitude,
                    longitude: this._longitude,
                });
            };
        MapComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'x-map',
                        providers: [
                            { provide: MapService, deps: [MapServiceFactory], useFactory: MapServiceCreator },
                            { provide: MarkerService, deps: [MapServiceFactory, MapService, LayerService, ClusterService], useFactory: MarkerServiceFactory },
                            {
                                provide: InfoBoxService, deps: [MapServiceFactory, MapService,
                                    MarkerService], useFactory: InfoBoxServiceFactory
                            },
                            { provide: LayerService, deps: [MapServiceFactory, MapService], useFactory: LayerServiceFactory },
                            { provide: ClusterService, deps: [MapServiceFactory, MapService], useFactory: ClusterServiceFactory },
                            { provide: PolygonService, deps: [MapServiceFactory, MapService, LayerService], useFactory: PolygonServiceFactory },
                            { provide: PolylineService, deps: [MapServiceFactory, MapService, LayerService], useFactory: PolylineServiceFactory }
                        ],
                        template: "\n        <div #container class='map-container-inner'></div>\n        <div class='map-content'>\n            <ng-content></ng-content>\n        </div>\n    ",
                        styles: ["\n        .map-container-inner { width: inherit; height: inherit; }\n        .map-container-inner div { background-repeat: no-repeat; }\n        .map-content { display:none; }\n    "],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MapComponent.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        MapComponent.propDecorators = {
            _containerClass: [{ type: core.HostBinding, args: ['class.map-container',] }],
            _container: [{ type: core.ViewChild, args: ['container',] }],
            _markers: [{ type: core.ContentChildren, args: [MapMarkerDirective,] }],
            Box: [{ type: core.Input }],
            Latitude: [{ type: core.Input }],
            Longitude: [{ type: core.Input }],
            Options: [{ type: core.Input }],
            Zoom: [{ type: core.Input }],
            BoundsChange: [{ type: core.Output }],
            CenterChange: [{ type: core.Output }],
            MapClick: [{ type: core.Output }],
            MapDblClick: [{ type: core.Output }],
            MapRightClick: [{ type: core.Output }],
            MapMouseOver: [{ type: core.Output }],
            MapMouseOut: [{ type: core.Output }],
            MapMouseMove: [{ type: core.Output }],
            MapPromise: [{ type: core.Output }],
            ZoomChange: [{ type: core.Output }],
            MapService: [{ type: core.Output }]
        };
        return MapComponent;
    }());
    /**
     * Factory function to generate a cluster service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @return {?} - A concrete instance of a Cluster Service based on the underlying map architecture
     */
    function ClusterServiceFactory(f, m) { return f.CreateClusterService(m); }
    /**
     * Factory function to generate a infobox service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @param {?} ma
     * @return {?} - A concrete instance of a InfoBox Service based on the underlying map architecture.
     */
    function InfoBoxServiceFactory(f, m, ma) { return f.CreateInfoBoxService(m, ma); }
    /**
     * Factory function to generate a layer service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @return {?} - A concrete instance of a Layer Service based on the underlying map architecture.
     */
    function LayerServiceFactory(f, m) { return f.CreateLayerService(m); }
    /**
     * Factory function to generate a map service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @return {?} - A concrete instance of a MapService based on the underlying map architecture.
     */
    function MapServiceCreator(f) { return f.Create(); }
    /**
     * Factory function to generate a marker service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @param {?} l - A {\@link LayerService} instance.
     * @param {?} c - A {\@link ClusterService} instance.
     * @return {?} - A concrete instance of a Marker Service based on the underlying map architecture.
     */
    function MarkerServiceFactory(f, m, l, c) {
        return f.CreateMarkerService(m, l, c);
    }
    /**
     * Factory function to generate a polygon service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @param {?} l - A {\@link LayerService} instance.
     * @return {?} - A concrete instance of a Polygon Service based on the underlying map architecture.
     */
    function PolygonServiceFactory(f, m, l) {
        return f.CreatePolygonService(m, l);
    }
    /**
     * Factory function to generate a polyline service instance. This is necessary because of constraints with AOT that do no allow
     * us to use lamda functions inline.
     *
     * @export
     * @param {?} f - The {\@link MapServiceFactory} implementation.
     * @param {?} m - A {\@link MapService} instance.
     * @param {?} l - A {\@link LayerService} instance.
     * @return {?} - A concrete instance of a Polyline Service based on the underlying map architecture.
     */
    function PolylineServiceFactory(f, m, l) {
        return f.CreatePolylineService(m, l);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * internal counter to use as ids for multiple layers.
     */
    var /** @type {?} */ layerId = 0;
    /**
     * MapLayerDirective creates a layer on a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]='lat' [Longitude]='lng' [Zoom]='zoom'>
     *     <x-map-layer [Visible]='visible'>
     *         <x-map-marker [Latitude]='lat' [Longitude]='lng' [Label]=''M''></x-map-marker>
     *     </x-map-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapLayerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapLayerDirective.
         * @param _layerService - Concreted implementation of a layer service for the underlying maps implementations.
         * Generally provided via injections.
         * @param _containerRef - Reference to the container hosting the map canvas. Generally provided via injection.
         *
         * @memberof MapLayerDirective
         */
        function MapLayerDirective(_layerService, _containerRef) {
            this._layerService = _layerService;
            this._containerRef = _containerRef;
            this._visible = true;
            this._addedToManager = false;
            this._id = layerId++;
        }
        Object.defineProperty(MapLayerDirective.prototype, "Visible", {
            ///
            /// Property declarations
            ///
            /**
             * Gets or sets the layer visibility.
             *
             * @memberof MapLayerDirective
             */
            get: /**
             * Gets or sets the layer visibility.
             *
             * \@memberof MapLayerDirective
             * @return {?}
             */ function () { return this._visible; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._visible = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapLayerDirective.prototype, "Id", {
            get: /**
             * Gets the layer id.
             *
             * \@readonly
             * \@memberof MapLayerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Called on Component initialization. Part of ng Component life cycle.
         *
         * \@memberof MapLayerDirective
         * @return {?}
         */
        MapLayerDirective.prototype.ngOnInit = /**
         * Called on Component initialization. Part of ng Component life cycle.
         *
         * \@memberof MapLayerDirective
         * @return {?}
         */
            function () {
                this._containerRef.element.nativeElement.attributes['layerId'] = this._id.toString();
                this._layerService.AddLayer(this);
                this._addedToManager = true;
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapLayerDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        MapLayerDirective.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapLayerDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._addedToManager) {
                    return;
                }
                if (changes['Visible']) {
                    this._layerService.GetNativeLayer(this).then(function (l) {
                        l.SetVisible(!l.GetVisible());
                    });
                }
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapLayerDirective
         * @return {?}
         */
        MapLayerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapLayerDirective
         * @return {?}
         */
            function () {
                this._layerService.DeleteLayer(this);
            };
        MapLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-layer'
                    },] },
        ];
        /** @nocollapse */
        MapLayerDirective.ctorParameters = function () {
            return [
                { type: LayerService },
                { type: core.ViewContainerRef }
            ];
        };
        MapLayerDirective.propDecorators = {
            _markers: [{ type: core.ContentChildren, args: [MapMarkerDirective,] }],
            Visible: [{ type: core.Input }]
        };
        return MapLayerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Creates a cluster layer on a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]='lat' [Longitude]='lng' [Zoom]='zoom'>
     *     <x-cluster-layer [Visible]='visible'>
     *         <x-map-marker [Latitude]='lat' [Longitude]='lng' [Label]=''M''></x-map-marker>
     *     </x-cluster-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var ClusterLayerDirective = (function (_super) {
        __extends(ClusterLayerDirective, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of ClusterLayerDirective.
         *
         * @param _layerService - Concreted implementation of a cluster layer service for the underlying maps
         * implementations. Generally provided via injections.
         * @param _containerRef - A reference to the view container of the layer. Generally provided via injection.
         *
         * @memberof ClusterLayerDirective
         */
        function ClusterLayerDirective(_layerService, _containerRef) {
            var _this = _super.call(this, _layerService, _containerRef) || this;
            _this._clusteringEnabled = true;
            _this._clusterPlacementMode = ClusterPlacementMode.MeanValue;
            _this._clusterClickAction = ClusterClickAction.ZoomIntoCluster;
            _this._useDynamicSizeMarker = false;
            _this._dynamicMarkerBaseSize = 18;
            _this._dynamicMarkerRanges = new Map([
                [10, 'rgba(20, 180, 20, 0.5)'],
                [100, 'rgba(255, 210, 40, 0.5)'],
                [Number.MAX_SAFE_INTEGER, 'rgba(255, 40, 40, 0.5)']
            ]);
            _this._zoomOnClick = true;
            return _this;
        }
        Object.defineProperty(ClusterLayerDirective.prototype, "ClusterClickAction", {
            ///
            /// Property defintions
            ///
            /**
             * Gets or sets the the Cluster Click Action {@link ClusterClickAction}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the the Cluster Click Action {\@link ClusterClickAction}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._clusterClickAction; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._clusterClickAction = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "ClusteringEnabled", {
            /**
             * Gets or sets whether the clustering layer enables clustering. When set to false, the layer
             * behaves like a generic layer. This is handy if you want to prevent clustering at certain zoom levels.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets whether the clustering layer enables clustering. When set to false, the layer
             * behaves like a generic layer. This is handy if you want to prevent clustering at certain zoom levels.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._clusteringEnabled; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._clusteringEnabled = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "ClusterPlacementMode", {
            /**
             * Gets or sets the cluster placement mode. {@link ClusterPlacementMode}
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the cluster placement mode. {\@link ClusterPlacementMode}
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._clusterPlacementMode; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._clusterPlacementMode = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "CustomMarkerCallback", {
            /**
             * Gets or sets the callback invoked to create a custom cluster marker. Note that when {@link UseDynamicSizeMarkers} is enabled,
             * you cannot set a custom marker callback.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the callback invoked to create a custom cluster marker. Note that when {\@link UseDynamicSizeMarkers} is enabled,
             * you cannot set a custom marker callback.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._iconCreationCallback; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._useDynamicSizeMarker) {
                    throw (new Error("You cannot set a custom marker callback when UseDynamicSizeMarkers is set to true.\n                    Set UseDynamicSizeMakers to false."));
                }
                this._iconCreationCallback = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "DynamicMarkerBaseSize", {
            /**
             * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.
             * See {@link UseDynamicSizeMarkers}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.
             * See {\@link UseDynamicSizeMarkers}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._dynamicMarkerBaseSize; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._dynamicMarkerBaseSize = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "DynamicMarkerRanges", {
            /**
             * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.
             * The map contains key/value pairs, with the keys being
             * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {@link UseDynamicSizeMarkers}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.
             * The map contains key/value pairs, with the keys being
             * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {\@link UseDynamicSizeMarkers}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._dynamicMarkerRanges; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._dynamicMarkerRanges = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "GridSize", {
            /**
             * Gets or sets the grid size to be used for clustering.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the grid size to be used for clustering.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._gridSize; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._gridSize = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "IconInfo", {
            /**
             * Gets or sets the IconInfo to be used to create a custom cluster marker. Supports font-based, SVG, graphics and more.
             * See {@link IMarkerIconInfo}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the IconInfo to be used to create a custom cluster marker. Supports font-based, SVG, graphics and more.
             * See {\@link IMarkerIconInfo}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._iconInfo; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._iconInfo = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "LayerOffset", {
            /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._layerOffset; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._layerOffset = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "MinimumClusterSize", {
            /**
             * Gets or sets the minimum pins required to form a cluster
             *
             * @readonly
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the minimum pins required to form a cluster
             *
             * \@readonly
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._minimumClusterSize; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._minimumClusterSize = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "SpiderClusterOptions", {
            /**
             * Gets or sets the options for spider clustering behavior. See {@link ISpiderClusterOptions}
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the options for spider clustering behavior. See {\@link ISpiderClusterOptions}
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._spiderClusterOptions; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._spiderClusterOptions = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "Styles", {
            /**
             * Gets or sets the cluster styles
             *
             * @readonly
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the cluster styles
             *
             * \@readonly
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._styles; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._styles = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "UseDynamicSizeMarkers", {
            /**
             * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of
             * pins in the cluster. If set to true, this will take precendence over any custom marker creation.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of
             * pins in the cluster. If set to true, this will take precendence over any custom marker creation.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._useDynamicSizeMarker; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                var _this = this;
                this._useDynamicSizeMarker = val;
                if (val) {
                    this._iconCreationCallback = function (m, info) {
                        return ClusterLayerDirective.CreateDynamicSizeMarker(m.length, info, _this._dynamicMarkerBaseSize, _this._dynamicMarkerRanges);
                    };
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "ZIndex", {
            /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._zIndex; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._zIndex = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClusterLayerDirective.prototype, "ZoomOnClick", {
            /**
             * Gets or sets whether the cluster should zoom in on click
             *
             * @readonly
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets whether the cluster should zoom in on click
             *
             * \@readonly
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._zoomOnClick; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._zoomOnClick = val; },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates the dynamic size marker to be used for cluster markers if UseDynamicSizeMarkers is set to true.
         *
         * \@memberof ClusterLayerDirective
         * @param {?} size - The number of markers in the cluster.
         * @param {?} info  - The icon info to be used. This will be hydrated with
         * the actualy dimensions of the created markers and is used by the underlying model/services
         * to correctly offset the marker for correct positioning.
         * @param {?} baseMarkerSize - The base size for dynmic markers.
         * @param {?} ranges - The ranges to use to calculate breakpoints and colors for dynamic markers.
         * The map contains key/value pairs, with the keys being
         * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range.
         * @return {?} - An string containing the SVG for the marker.
         *
         */
        ClusterLayerDirective.CreateDynamicSizeMarker = /**
         * Creates the dynamic size marker to be used for cluster markers if UseDynamicSizeMarkers is set to true.
         *
         * \@memberof ClusterLayerDirective
         * @param {?} size - The number of markers in the cluster.
         * @param {?} info  - The icon info to be used. This will be hydrated with
         * the actualy dimensions of the created markers and is used by the underlying model/services
         * to correctly offset the marker for correct positioning.
         * @param {?} baseMarkerSize - The base size for dynmic markers.
         * @param {?} ranges - The ranges to use to calculate breakpoints and colors for dynamic markers.
         * The map contains key/value pairs, with the keys being
         * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range.
         * @return {?} - An string containing the SVG for the marker.
         *
         */
            function (size, info, baseMarkerSize, ranges) {
                var /** @type {?} */ mr = baseMarkerSize;
                var /** @type {?} */ outline = mr * 0.35;
                var /** @type {?} */ total = size;
                var /** @type {?} */ r = Math.log(total) / Math.log(10) * 5 + mr;
                var /** @type {?} */ d = r * 2;
                var /** @type {?} */ fillColor;
                ranges.forEach(function (v, k) {
                    if (total <= k && !fillColor) {
                        fillColor = v;
                    }
                });
                if (!fillColor) {
                    fillColor = 'rgba(20, 180, 20, 0.5)';
                }
                // Create an SVG string of two circles, one on top of the other, with the specified radius and color.
                var /** @type {?} */ svg = ["<svg xmlns='http://www.w3.org/2000/svg' width='" + d + "' height='" + d + "'>",
                    "<circle cx='" + r + "' cy='" + r + "' r='" + r + "' fill='" + fillColor + "'/>",
                    "<circle cx='" + r + "' cy='" + r + "' r='" + (r - outline) + "' fill='" + fillColor + "'/>",
                    "</svg>"];
                info.size = { width: d, height: d };
                info.markerOffsetRatio = { x: 0.5, y: 0.5 };
                info.textOffset = { x: 0, y: r - 8 };
                return svg.join('');
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof ClusterLayerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
        ClusterLayerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof ClusterLayerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._addedToManager) {
                    return;
                }
                if (changes['ClusterClickAction']) {
                    throw (new Error('You cannot change the ClusterClickAction after the layer has been added to the layerservice.'));
                }
                var /** @type {?} */ options = { id: this._id };
                if (changes['ClusteringEnabled']) {
                    options.clusteringEnabled = this._clusteringEnabled;
                }
                if (changes['GridSize']) {
                    options.gridSize = this._gridSize;
                }
                if (changes['LayerOffset']) {
                    options.layerOffset = this._layerOffset;
                }
                if (changes['SpiderClusterOptions']) {
                    options.spiderClusterOptions = this._spiderClusterOptions;
                }
                if (changes['ZIndex']) {
                    options.zIndex = this._zIndex;
                }
                if (changes['Visible']) {
                    options.visible = this._visible;
                }
                this._layerService.GetNativeLayer(this).then(function (l) {
                    l.SetOptions(options);
                });
            };
        ClusterLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-cluster-layer'
                    },] },
        ];
        /** @nocollapse */
        ClusterLayerDirective.ctorParameters = function () {
            return [
                { type: ClusterService },
                { type: core.ViewContainerRef }
            ];
        };
        ClusterLayerDirective.propDecorators = {
            ClusterClickAction: [{ type: core.Input }],
            ClusteringEnabled: [{ type: core.Input }],
            ClusterPlacementMode: [{ type: core.Input }],
            CustomMarkerCallback: [{ type: core.Input }],
            DynamicMarkerBaseSize: [{ type: core.Input }],
            DynamicMarkerRanges: [{ type: core.Input }],
            GridSize: [{ type: core.Input }],
            IconInfo: [{ type: core.Input }],
            LayerOffset: [{ type: core.Input }],
            MinimumClusterSize: [{ type: core.Input }],
            SpiderClusterOptions: [{ type: core.Input }],
            Styles: [{ type: core.Input }],
            UseDynamicSizeMarkers: [{ type: core.Input }],
            ZIndex: [{ type: core.Input }],
            ZoomOnClick: [{ type: core.Input }]
        };
        return ClusterLayerDirective;
    }(MapLayerDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ polygonId = 0;
    /**
     *
     * MapPolygonDirective renders a polygon inside a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapPolygonDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map,
     *  styles: [`
     *   .map-container { height: 300px; }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-polygon [Paths]="path"></x-map-polygon>
     *   </x-map>
     * `
     * })
     * ```
     *
     *
     * @export
     */
    var MapPolygonDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapPolygonDirective.
         * @param _polygonManager
         *
         * @memberof MapPolygonDirective
         */
        function MapPolygonDirective(_polygonService, _containerRef) {
            this._polygonService = _polygonService;
            this._containerRef = _containerRef;
            this._inCustomLayer = false;
            this._addedToService = false;
            this._events = [];
            /**
             * Gets or sets whether this Polygon handles mouse events.
             *
             * \@memberof MapPolygonDirective
             */
            this.Clickable = true;
            /**
             * If set to true, the user can drag this shape over the map.
             *
             * \@memberof MapPolygonDirective
             */
            this.Draggable = false;
            /**
             * If set to true, the user can edit this shape by dragging the control
             * points shown at the vertices and on each segment.
             *
             * \@memberof MapPolygonDirective
             */
            this.Editable = false;
            /**
             * When true, edges of the polygon are interpreted as geodesic and will
             * follow the curvature of the Earth. When false, edges of the polygon are
             * rendered as straight lines in screen space. Note that the shape of a
             * geodesic polygon may appear to change when dragged, as the dimensions
             * are maintained relative to the surface of the earth. Defaults to false.
             *
             * \@memberof MapPolygonDirective
             */
            this.Geodesic = false;
            /**
             * Arbitary metadata to assign to the Polygon. This is useful for events
             *
             * \@memberof MapPolygonDirective
             */
            this.Metadata = new Map();
            /**
             * The ordered sequence of coordinates that designates a closed loop.
             * Unlike polylines, a polygon may consist of one or more paths.
             * As a result, the paths property may specify one or more arrays of
             * LatLng coordinates. Paths are closed automatically; do not repeat the
             * first vertex of the path as the last vertex. Simple polygons may be
             * defined using a single array of LatLngs. More complex polygons may
             * specify an array of arrays (for inner loops ). Any simple arrays are converted into Arrays.
             * Inserting or removing LatLngs from the Array will automatically update
             * the polygon on the map.
             *
             * \@memberof MapPolygonDirective
             */
            this.Paths = [];
            /**
             * Whether to show the title of the polygon as the tooltip on the polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.ShowTooltip = true;
            /**
             * This event is fired when the DOM click event is fired on the Polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.Click = new core.EventEmitter();
            /**
             * This event is fired when the DOM dblclick event is fired on the Polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.DblClick = new core.EventEmitter();
            /**
             * This event is repeatedly fired while the user drags the polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.Drag = new core.EventEmitter();
            /**
             * This event is fired when the user stops dragging the polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.DragEnd = new core.EventEmitter();
            /**
             * This event is fired when the user starts dragging the polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.DragStart = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousedown event is fired on the Polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseDown = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on the Polygon.
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseMove = new core.EventEmitter();
            /**
             * This event is fired on Polygon mouseout.
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseOut = new core.EventEmitter();
            /**
             * This event is fired on Polygon mouseover.
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseOver = new core.EventEmitter();
            /**
             * This event is fired whe the DOM mouseup event is fired on the Polygon
             *
             * \@memberof MapPolygonDirective
             */
            this.MouseUp = new core.EventEmitter();
            /**
             * This event is fired when the Polygon is right-clicked on.
             *
             * \@memberof MapPolygonDirective
             */
            this.RightClick = new core.EventEmitter();
            /**
             * This event is fired when editing has completed.
             *
             * \@memberof MapPolygonDirective
             */
            this.PathChanged = new core.EventEmitter();
            this._id = polygonId++;
        }
        Object.defineProperty(MapPolygonDirective.prototype, "AddedToService", {
            get: /**
             * Gets whether the polygon has been registered with the service.
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._addedToService; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonDirective.prototype, "Id", {
            get: /**
             * Get the id of the polygon.
             *
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonDirective.prototype, "IdAsString", {
            get: /**
             * Gets the id of the polygon as a string.
             *
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._id.toString(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonDirective.prototype, "InCustomLayer", {
            get: /**
             * Gets whether the polygon is in a custom layer. See {\@link MapLayer}.
             *
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._inCustomLayer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonDirective.prototype, "LayerId", {
            get: /**
             * gets the id of the Layer the polygon belongs to.
             *
             * \@readonly
             * \@memberof MapPolygonDirective
             * @return {?}
             */ function () { return this._layerId; },
            enumerable: true,
            configurable: true
        });
        ///
        /// Public methods
        ///
        /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * @memberof MapPolygonDirective
         */
        /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
        MapPolygonDirective.prototype.ngAfterContentInit = /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
            function () {
                if (this._containerRef.element.nativeElement.parentElement) {
                    var /** @type {?} */ parentName = this._containerRef.element.nativeElement.parentElement.tagName;
                    if (parentName.toLowerCase() === 'x-map-layer') {
                        this._inCustomLayer = true;
                        this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);
                    }
                }
                if (!this._addedToService) {
                    this._polygonService.AddPolygon(this);
                    this._addedToService = true;
                    this.AddEventListeners();
                }
                return;
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * @param changes - Changes that have occured.
         *
         * @memberof MapPolygonDirective
         */
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        MapPolygonDirective.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._addedToService) {
                    return;
                }
                var /** @type {?} */ o = this.GeneratePolygonChangeSet(changes);
                if (o != null) {
                    this._polygonService.SetOptions(this, o);
                }
                if (changes['Paths'] && !changes['Paths'].isFirstChange()) {
                    this._polygonService.UpdatePolygon(this);
                }
            };
        /**
         * Called when the poygon is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * @memberof MapPolygonDirective
         */
        /**
         * Called when the poygon is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
        MapPolygonDirective.prototype.ngOnDestroy = /**
         * Called when the poygon is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
            function () {
                this._polygonService.DeletePolygon(this);
                this._events.forEach(function (s) { return s.unsubscribe(); });
            };
        /**
         * Wires up the event receivers.
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
        MapPolygonDirective.prototype.AddEventListeners = /**
         * Wires up the event receivers.
         *
         * \@memberof MapPolygonDirective
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ _getEventArg = function (e) {
                    return {
                        Polygon: _this,
                        Click: e
                    };
                };
                this._events.push(this._polygonService.CreateEventObservable('click', this).subscribe(function (ev) {
                    if (_this._infoBox != null) {
                        _this._infoBox.Open(_this._polygonService.GetCoordinatesFromClick(ev));
                    }
                    _this.Click.emit(_getEventArg(ev));
                }));
                var /** @type {?} */ handlers = [
                    { name: 'dblclick', handler: function (ev) { return _this.DblClick.emit(_getEventArg(ev)); } },
                    { name: 'drag', handler: function (ev) { return _this.Drag.emit(_getEventArg(ev)); } },
                    { name: 'dragend', handler: function (ev) { return _this.DragEnd.emit(_getEventArg(ev)); } },
                    { name: 'dragstart', handler: function (ev) { return _this.DragStart.emit(_getEventArg(ev)); } },
                    { name: 'mousedown', handler: function (ev) { return _this.MouseDown.emit(_getEventArg(ev)); } },
                    { name: 'mousemove', handler: function (ev) { return _this.MouseMove.emit(_getEventArg(ev)); } },
                    { name: 'mouseout', handler: function (ev) { return _this.MouseOut.emit(_getEventArg(ev)); } },
                    { name: 'mouseover', handler: function (ev) { return _this.MouseOver.emit(_getEventArg(ev)); } },
                    { name: 'mouseup', handler: function (ev) { return _this.MouseUp.emit(_getEventArg(ev)); } },
                    { name: 'rightclick', handler: function (ev) { return _this.RightClick.emit(_getEventArg(ev)); } },
                    { name: 'pathchanged', handler: function (ev) { return _this.PathChanged.emit(ev); } }
                ];
                handlers.forEach(function (obj) {
                    var /** @type {?} */ os = _this._polygonService.CreateEventObservable(obj.name, _this).subscribe(obj.handler);
                    _this._events.push(os);
                });
            };
        /**
         * Generates IPolygon option changeset from directive settings.
         *
         * \@memberof MapPolygonDirective
         * @param {?} changes - {\@link SimpleChanges} identifying the changes that occured.
         * @return {?} - {\@link IPolygonOptions} containing the polygon options.
         *
         */
        MapPolygonDirective.prototype.GeneratePolygonChangeSet = /**
         * Generates IPolygon option changeset from directive settings.
         *
         * \@memberof MapPolygonDirective
         * @param {?} changes - {\@link SimpleChanges} identifying the changes that occured.
         * @return {?} - {\@link IPolygonOptions} containing the polygon options.
         *
         */
            function (changes) {
                var /** @type {?} */ options = { id: this._id };
                var /** @type {?} */ hasOptions = false;
                if (changes['Clickable']) {
                    options.clickable = this.Clickable;
                    hasOptions = true;
                }
                if (changes['Draggable']) {
                    options.draggable = this.Draggable;
                    hasOptions = true;
                }
                if (changes['Editable']) {
                    options.editable = this.Editable;
                    hasOptions = true;
                }
                if (changes['FillColor'] || changes['FillOpacity']) {
                    options.fillColor = this.FillColor;
                    options.fillOpacity = this.FillOpacity;
                    hasOptions = true;
                }
                if (changes['Geodesic']) {
                    options.geodesic = this.Geodesic;
                    hasOptions = true;
                }
                if (changes['LabelMaxZoom']) {
                    options.labelMaxZoom = this.LabelMaxZoom;
                    hasOptions = true;
                }
                if (changes['LabelMinZoom']) {
                    options.labelMinZoom = this.LabelMinZoom;
                    hasOptions = true;
                }
                if (changes['ShowTooltip']) {
                    options.showTooltip = this.ShowTooltip;
                    hasOptions = true;
                }
                if (changes['ShowLabel']) {
                    options.showLabel = this.ShowLabel;
                    hasOptions = true;
                }
                if (changes['StrokeColor'] || changes['StrokeOpacity']) {
                    options.strokeColor = this.StrokeColor;
                    options.strokeOpacity = this.StrokeOpacity;
                    hasOptions = true;
                }
                if (changes['StrokeWeight']) {
                    options.strokeWeight = this.StrokeWeight;
                    hasOptions = true;
                }
                if (changes['Title']) {
                    options.title = this.Title;
                    hasOptions = true;
                }
                if (changes['Visible']) {
                    options.visible = this.Visible;
                    hasOptions = true;
                }
                if (changes['zIndex']) {
                    options.zIndex = this.zIndex;
                    hasOptions = true;
                }
                return hasOptions ? options : null;
            };
        MapPolygonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-polygon'
                    },] },
        ];
        /** @nocollapse */
        MapPolygonDirective.ctorParameters = function () {
            return [
                { type: PolygonService },
                { type: core.ViewContainerRef }
            ];
        };
        MapPolygonDirective.propDecorators = {
            _infoBox: [{ type: core.ContentChild, args: [InfoBoxComponent,] }],
            Clickable: [{ type: core.Input }],
            Draggable: [{ type: core.Input }],
            Editable: [{ type: core.Input }],
            FillColor: [{ type: core.Input }],
            FillOpacity: [{ type: core.Input }],
            Geodesic: [{ type: core.Input }],
            LabelMaxZoom: [{ type: core.Input }],
            LabelMinZoom: [{ type: core.Input }],
            Metadata: [{ type: core.Input }],
            Paths: [{ type: core.Input }],
            ShowLabel: [{ type: core.Input }],
            ShowTooltip: [{ type: core.Input }],
            StrokeColor: [{ type: core.Input }],
            StrokeOpacity: [{ type: core.Input }],
            StrokeWeight: [{ type: core.Input }],
            Title: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            zIndex: [{ type: core.Input }],
            Click: [{ type: core.Output }],
            DblClick: [{ type: core.Output }],
            Drag: [{ type: core.Output }],
            DragEnd: [{ type: core.Output }],
            DragStart: [{ type: core.Output }],
            MouseDown: [{ type: core.Output }],
            MouseMove: [{ type: core.Output }],
            MouseOut: [{ type: core.Output }],
            MouseOver: [{ type: core.Output }],
            MouseUp: [{ type: core.Output }],
            RightClick: [{ type: core.Output }],
            PathChanged: [{ type: core.Output }]
        };
        return MapPolygonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ polylineId = 0;
    /**
     *
     * MapPolylineDirective renders a polyline inside a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapPolylineDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map,
     *  styles: [`
     *   .map-container { height: 300px; }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-polyline [Paths]="path"></x-map-polyline>
     *   </x-map>
     * `
     * })
     * ```
     *
     *
     * @export
     */
    var MapPolylineDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapPolylineDirective.
         * @param _polylineManager
         *
         * @memberof MapPolylineDirective
         */
        function MapPolylineDirective(_polylineService, _containerRef) {
            this._polylineService = _polylineService;
            this._containerRef = _containerRef;
            this._inCustomLayer = false;
            this._addedToService = false;
            this._events = [];
            /**
             * Gets or sets whether this Polyline handles mouse events.
             *
             * \@memberof MapPolylineDirective
             */
            this.Clickable = true;
            /**
             * If set to true, the user can drag this shape over the map.
             *
             * \@memberof MapPolylineDirective
             */
            this.Draggable = false;
            /**
             * If set to true, the user can edit this shape by dragging the control
             * points shown at the vertices and on each segment.
             *
             * \@memberof MapPolylineDirective
             */
            this.Editable = false;
            /**
             * When true, edges of the polyline are interpreted as geodesic and will
             * follow the curvature of the Earth. When false, edges of the polyline are
             * rendered as straight lines in screen space. Note that the shape of a
             * geodesic polyline may appear to change when dragged, as the dimensions
             * are maintained relative to the surface of the earth. Defaults to false.
             *
             * \@memberof MapPolylineDirective
             */
            this.Geodesic = false;
            /**
             * Arbitary metadata to assign to the Polyline. This is useful for events
             *
             * \@memberof MapPolylineDirective
             */
            this.Metadata = new Map();
            /**
             * The ordered sequence of coordinates that designates a polyline.
             * Simple polylines may be defined using a single array of LatLngs. More
             * complex polylines may specify an array of arrays.
             *
             * \@memberof MapPolylineDirective
             */
            this.Path = [];
            /**
             * Whether to show the title of the polyline as the tooltip on the polygon.
             *
             * \@memberof MapPolylineDirective
             */
            this.ShowTooltip = true;
            /**
             * This event is fired when the DOM click event is fired on the Polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.Click = new core.EventEmitter();
            /**
             * This event is fired when the DOM dblclick event is fired on the Polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.DblClick = new core.EventEmitter();
            /**
             * This event is repeatedly fired while the user drags the polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.Drag = new core.EventEmitter();
            /**
             * This event is fired when the user stops dragging the polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.DragEnd = new core.EventEmitter();
            /**
             * This event is fired when the user starts dragging the polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.DragStart = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousedown event is fired on the Polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseDown = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on the Polyline.
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseMove = new core.EventEmitter();
            /**
             * This event is fired on Polyline mouseout.
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseOut = new core.EventEmitter();
            /**
             * This event is fired on Polyline mouseover.
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseOver = new core.EventEmitter();
            /**
             * This event is fired whe the DOM mouseup event is fired on the Polyline
             *
             * \@memberof MapPolylineDirective
             */
            this.MouseUp = new core.EventEmitter();
            /**
             * This even is fired when the Polyline is right-clicked on.
             *
             * \@memberof MapPolylineDirective
             */
            this.RightClick = new core.EventEmitter();
            this._id = polylineId++;
        }
        Object.defineProperty(MapPolylineDirective.prototype, "AddedToService", {
            get: /**
             * Gets whether the polyline has been registered with the service.
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._addedToService; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineDirective.prototype, "Id", {
            get: /**
             * Get the id of the polyline.
             *
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineDirective.prototype, "IdAsString", {
            get: /**
             * Gets the id of the polyline as a string.
             *
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._id.toString(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineDirective.prototype, "InCustomLayer", {
            get: /**
             * Gets whether the polyline is in a custom layer. See {\@link MapLayer}.
             *
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._inCustomLayer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineDirective.prototype, "LayerId", {
            get: /**
             * gets the id of the Layer the polyline belongs to.
             *
             * \@readonly
             * \@memberof MapPolylineDirective
             * @return {?}
             */ function () { return this._layerId; },
            enumerable: true,
            configurable: true
        });
        ///
        /// Public methods
        ///
        /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * @memberof MapPolylineDirective
         */
        /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
        MapPolylineDirective.prototype.ngAfterContentInit = /**
         * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
            function () {
                if (this._containerRef.element.nativeElement.parentElement) {
                    var /** @type {?} */ parentName = this._containerRef.element.nativeElement.parentElement.tagName;
                    if (parentName.toLowerCase() === 'x-map-layer') {
                        this._inCustomLayer = true;
                        this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);
                    }
                }
                if (!this._addedToService) {
                    this._polylineService.AddPolyline(this);
                    this._addedToService = true;
                    this.AddEventListeners();
                }
                return;
            };
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * @param changes - Changes that have occured.
         *
         * @memberof MapPolylineDirective
         */
        /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
        MapPolylineDirective.prototype.ngOnChanges = /**
         * Called when changes to the databoud properties occur. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineDirective
         * @param {?} changes - Changes that have occured.
         *
         * @return {?}
         */
            function (changes) {
                if (!this._addedToService) {
                    return;
                }
                var /** @type {?} */ o = this.GeneratePolylineChangeSet(changes);
                if (o != null) {
                    this._polylineService.SetOptions(this, o);
                }
                if (changes['Path'] && !changes['Path'].isFirstChange()) {
                    this._polylineService.UpdatePolyline(this);
                }
            };
        /**
         * Called when the polyline is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * @memberof MapPolylineDirective
         */
        /**
         * Called when the polyline is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
        MapPolylineDirective.prototype.ngOnDestroy = /**
         * Called when the polyline is being destroyed. Part of the ng Component life cycle. Release resources.
         *
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
            function () {
                this._polylineService.DeletePolyline(this);
                this._events.forEach(function (s) { return s.unsubscribe(); });
            };
        /**
         * Wires up the event receivers.
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
        MapPolylineDirective.prototype.AddEventListeners = /**
         * Wires up the event receivers.
         *
         * \@memberof MapPolylineDirective
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ _getEventArg = function (e) {
                    return {
                        Polyline: _this,
                        Click: e
                    };
                };
                this._polylineService.CreateEventObservable('click', this).subscribe(function (ev) {
                    if (_this._infoBox != null) {
                        _this._infoBox.Open(_this._polylineService.GetCoordinatesFromClick(ev));
                    }
                    _this.Click.emit(_getEventArg(ev));
                });
                var /** @type {?} */ handlers = [
                    { name: 'dblclick', handler: function (ev) { return _this.DblClick.emit(_getEventArg(ev)); } },
                    { name: 'drag', handler: function (ev) { return _this.Drag.emit(_getEventArg(ev)); } },
                    { name: 'dragend', handler: function (ev) { return _this.DragEnd.emit(_getEventArg(ev)); } },
                    { name: 'dragstart', handler: function (ev) { return _this.DragStart.emit(_getEventArg(ev)); } },
                    { name: 'mousedown', handler: function (ev) { return _this.MouseDown.emit(_getEventArg(ev)); } },
                    { name: 'mousemove', handler: function (ev) { return _this.MouseMove.emit(_getEventArg(ev)); } },
                    { name: 'mouseout', handler: function (ev) { return _this.MouseOut.emit(_getEventArg(ev)); } },
                    { name: 'mouseover', handler: function (ev) { return _this.MouseOver.emit(_getEventArg(ev)); } },
                    { name: 'mouseup', handler: function (ev) { return _this.MouseUp.emit(_getEventArg(ev)); } },
                    { name: 'rightclick', handler: function (ev) { return _this.RightClick.emit(_getEventArg(ev)); } },
                ];
                handlers.forEach(function (obj) {
                    var /** @type {?} */ os = _this._polylineService.CreateEventObservable(obj.name, _this).subscribe(obj.handler);
                    _this._events.push(os);
                });
            };
        /**
         * Generates IPolyline option changeset from directive settings.
         *
         * \@memberof MapPolylineDirective
         * @param {?} changes - {\@link SimpleChanges} identifying the changes that occured.
         * @return {?} - {\@link IPolylineOptions} containing the polyline options.
         *
         */
        MapPolylineDirective.prototype.GeneratePolylineChangeSet = /**
         * Generates IPolyline option changeset from directive settings.
         *
         * \@memberof MapPolylineDirective
         * @param {?} changes - {\@link SimpleChanges} identifying the changes that occured.
         * @return {?} - {\@link IPolylineOptions} containing the polyline options.
         *
         */
            function (changes) {
                var /** @type {?} */ options = { id: this._id };
                var /** @type {?} */ hasOptions = false;
                if (changes['Clickable']) {
                    options.clickable = this.Clickable;
                    hasOptions = true;
                }
                if (changes['Draggable']) {
                    options.draggable = this.Draggable;
                    hasOptions = true;
                }
                if (changes['Editable']) {
                    options.editable = this.Editable;
                    hasOptions = true;
                }
                if (changes['Geodesic']) {
                    options.geodesic = this.Geodesic;
                    hasOptions = true;
                }
                if (changes['ShowTooltip']) {
                    options.showTooltip = this.ShowTooltip;
                    hasOptions = true;
                }
                if (changes['StrokeColor']) {
                    options.strokeColor = this.StrokeColor;
                    hasOptions = true;
                }
                if (changes['StrokeOpacity']) {
                    options.strokeOpacity = this.StrokeOpacity;
                    hasOptions = true;
                }
                if (changes['StrokeWeight']) {
                    options.strokeWeight = this.StrokeWeight;
                    hasOptions = true;
                }
                if (changes['Title']) {
                    options.title = this.Title;
                    hasOptions = true;
                }
                if (changes['Visible']) {
                    options.visible = this.Visible;
                    hasOptions = true;
                }
                if (changes['zIndex']) {
                    options.zIndex = this.zIndex;
                    hasOptions = true;
                }
                return hasOptions ? options : null;
            };
        MapPolylineDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-polyline'
                    },] },
        ];
        /** @nocollapse */
        MapPolylineDirective.ctorParameters = function () {
            return [
                { type: PolylineService },
                { type: core.ViewContainerRef }
            ];
        };
        MapPolylineDirective.propDecorators = {
            _infoBox: [{ type: core.ContentChild, args: [InfoBoxComponent,] }],
            Clickable: [{ type: core.Input }],
            Draggable: [{ type: core.Input }],
            Editable: [{ type: core.Input }],
            Geodesic: [{ type: core.Input }],
            Metadata: [{ type: core.Input }],
            Path: [{ type: core.Input }],
            ShowTooltip: [{ type: core.Input }],
            StrokeColor: [{ type: core.Input }],
            StrokeOpacity: [{ type: core.Input }],
            StrokeWeight: [{ type: core.Input }],
            Title: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            zIndex: [{ type: core.Input }],
            Click: [{ type: core.Output }],
            DblClick: [{ type: core.Output }],
            Drag: [{ type: core.Output }],
            DragEnd: [{ type: core.Output }],
            DragStart: [{ type: core.Output }],
            MouseDown: [{ type: core.Output }],
            MouseMove: [{ type: core.Output }],
            MouseOut: [{ type: core.Output }],
            MouseOver: [{ type: core.Output }],
            MouseUp: [{ type: core.Output }],
            RightClick: [{ type: core.Output }]
        };
        return MapPolylineDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * internal counter to use as ids for marker.
     */
    var /** @type {?} */ layerId$1 = 1000000;
    /**
     * MapMarkerLayerDirective performantly renders a large set of map marker inside a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent, MapMarkerDirective} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-marker-layer [MarkerOptions]="_markers"></x-map-marker-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapMarkerLayerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapMarkerLayerDirective.
         * @param _markerService - Concreate implementation of a {@link MarkerService}.
         * @param _layerService - Concreate implementation of a {@link LayerService}.
         * @param _clusterService - Concreate implementation of a {@link ClusterService}.
         * @param _mapService - Concreate implementation of a {@link MapService}.
         * @param _zone - Concreate implementation of a {@link NgZone} service.
         *
         * @memberof MapMarkerLayerDirective
         */
        function MapMarkerLayerDirective(_markerService, _layerService, _clusterService, _mapService, _zone) {
            this._markerService = _markerService;
            this._layerService = _layerService;
            this._clusterService = _clusterService;
            this._mapService = _mapService;
            this._zone = _zone;
            this._useDynamicSizeMarker = false;
            this._dynamicMarkerBaseSize = 18;
            this._dynamicMarkerRanges = new Map([
                [10, 'rgba(20, 180, 20, 0.5)'],
                [100, 'rgba(255, 210, 40, 0.5)'],
                [Number.MAX_SAFE_INTEGER, 'rgba(255, 40, 40, 0.5)']
            ]);
            this._streaming = false;
            this._markers = new Array();
            this._markersLast = new Array();
            /**
             * Gets or sets the the Cluster Click Action {\@link ClusterClickAction}.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.ClusterClickAction = ClusterClickAction.ZoomIntoCluster;
            /**
             * Gets or sets the cluster placement mode. {\@link ClusterPlacementMode}
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.ClusterPlacementMode = ClusterPlacementMode.MeanValue;
            /**
             * Determines whether the layer clusters. This property can only be set on creation of the layer.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.EnableClustering = false;
            /**
             * Gets or sets the grid size to be used for clustering.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.GridSize = 150;
            /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.LayerOffset = null;
            /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.ZIndex = 0;
            /**
             * Gets or sets whether the cluster should zoom in on click
             *
             * \@readonly
             * \@memberof MapMarkerLayerDirective
             */
            this.ZoomOnClick = true;
            /**
             * This event emitter gets emitted when the dynamic icon for a marker is being created.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.DynamicMarkerCreated = new core.EventEmitter();
            /**
             * This event emitter gets emitted when the user clicks a marker in the layer.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.MarkerClick = new core.EventEmitter();
            /**
             * This event is fired when the user stops dragging a marker.
             *
             * \@memberof MapMarkerLayerDirective
             */
            this.DragEnd = new core.EventEmitter();
            this._id = layerId$1++;
        }
        Object.defineProperty(MapMarkerLayerDirective.prototype, "CustomMarkerCallback", {
            /**
             * Gets or sets the callback invoked to create a custom cluster marker. Note that when {@link UseDynamicSizeMarkers} is enabled,
             * you cannot set a custom marker callback.
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             * Gets or sets the callback invoked to create a custom cluster marker. Note that when {\@link UseDynamicSizeMarkers} is enabled,
             * you cannot set a custom marker callback.
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._iconCreationCallback; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._useDynamicSizeMarker) {
                    throw (new Error("You cannot set a custom marker callback when UseDynamicSizeMarkers is set to true.\n                    Set UseDynamicSizeMakers to false."));
                }
                this._iconCreationCallback = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "DynamicMarkerBaseSize", {
            /**
             * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.
             * See {@link UseDynamicSizeMarkers}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.
             * See {\@link UseDynamicSizeMarkers}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._dynamicMarkerBaseSize; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._dynamicMarkerBaseSize = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "DynamicMarkerRanges", {
            /**
             * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.
             * The map contains key/value pairs, with the keys being
             * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {@link UseDynamicSizeMarkers}.
             *
             * @memberof ClusterLayerDirective
             */
            get: /**
             * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.
             * The map contains key/value pairs, with the keys being
             * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {\@link UseDynamicSizeMarkers}.
             *
             * \@memberof ClusterLayerDirective
             * @return {?}
             */ function () { return this._dynamicMarkerRanges; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._dynamicMarkerRanges = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "MarkerOptions", {
            /**
             *  IMarkerOptions array holding the marker info.
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             *  IMarkerOptions array holding the marker info.
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._markers; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._streaming) {
                    (_a = this._markersLast).push.apply(_a, __spread(val.slice(0)));
                    (_b = this._markers).push.apply(_b, __spread(val));
                }
                else {
                    this._markers = val.slice(0);
                }
                var _a, _b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "Styles", {
            /**
             * Gets or sets the cluster styles
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             * Gets or sets the cluster styles
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._styles; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._styles = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "TreatNewMarkerOptionsAsStream", {
            /**
             * Sets whether to treat changes in the MarkerOptions as streams of new markers. In thsi mode, changing the
             * Array supplied in MarkerOptions will be incrementally drawn on the map as opposed to replace the markers on the map.
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             * Sets whether to treat changes in the MarkerOptions as streams of new markers. In thsi mode, changing the
             * Array supplied in MarkerOptions will be incrementally drawn on the map as opposed to replace the markers on the map.
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._streaming; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._streaming = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "UseDynamicSizeMarkers", {
            /**
             * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of
             * pins in the cluster. If set to true, this will take precendence over any custom marker creation.
             *
             * @memberof MapMarkerLayerDirective
             */
            get: /**
             * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of
             * pins in the cluster. If set to true, this will take precendence over any custom marker creation.
             *
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._useDynamicSizeMarker; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                var _this = this;
                this._useDynamicSizeMarker = val;
                if (val) {
                    this._iconCreationCallback = function (m, info) {
                        return ClusterLayerDirective.CreateDynamicSizeMarker(m.length, info, _this._dynamicMarkerBaseSize, _this._dynamicMarkerRanges);
                    };
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapMarkerLayerDirective.prototype, "Id", {
            get: /**
             * Gets the id of the marker layer.
             *
             * \@readonly
             * \@memberof MapMarkerLayerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Translates a geo location to a pixel location relative to the map viewport.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} loc
         * @return {?} - A promise that when fullfilled contains an {\@link IPoint} representing the pixel coordinates.
         *
         */
        MapMarkerLayerDirective.prototype.LocationToPixel = /**
         * Translates a geo location to a pixel location relative to the map viewport.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} loc
         * @return {?} - A promise that when fullfilled contains an {\@link IPoint} representing the pixel coordinates.
         *
         */
            function (loc) {
                return this._markerService.LocationToPoint(loc);
            };
        /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapMarkerLayerDirective
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.ngAfterContentInit = /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapMarkerLayerDirective
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ layerOptions = {
                    id: this._id
                };
                this._zone.runOutsideAngular(function () {
                    var /** @type {?} */ fakeLayerDirective = {
                        Id: _this._id,
                        Visible: _this.Visible
                    };
                    if (!_this.EnableClustering) {
                        _this._layerService.AddLayer(fakeLayerDirective);
                        _this._layerPromise = _this._layerService.GetNativeLayer(fakeLayerDirective);
                        _this._service = _this._layerService;
                    }
                    else {
                        fakeLayerDirective.LayerOffset = _this.LayerOffset;
                        fakeLayerDirective.ZIndex = _this.ZIndex;
                        fakeLayerDirective.ClusteringEnabled = _this.EnableClustering;
                        fakeLayerDirective.ClusterPlacementMode = _this.ClusterPlacementMode;
                        fakeLayerDirective.GridSize = _this.GridSize;
                        fakeLayerDirective.ClusterClickAction = _this.ClusterClickAction;
                        fakeLayerDirective.IconInfo = _this.ClusterIconInfo;
                        fakeLayerDirective.CustomMarkerCallback = _this.CustomMarkerCallback;
                        fakeLayerDirective.UseDynamicSizeMarkers = _this.UseDynamicSizeMarkers;
                        _this._clusterService.AddLayer(fakeLayerDirective);
                        _this._layerPromise = _this._clusterService.GetNativeLayer(fakeLayerDirective);
                        _this._service = _this._clusterService;
                    }
                    _this._layerPromise.then(function (l) {
                        l.SetVisible(_this.Visible);
                        if (_this.MarkerOptions) {
                            _this._zone.runOutsideAngular(function () { return _this.UpdateMarkers(); });
                        }
                    });
                });
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapMarkerLayerDirective
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         *
         * \@memberof MapMarkerLayerDirective
         * @return {?}
         */
            function () {
                this._layerPromise.then(function (l) {
                    l.Delete();
                });
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} changes - collection of changes.
         *
         * @return {?}
         */
            function (changes) {
                var _this = this;
                var /** @type {?} */ shouldSetOptions = false;
                var /** @type {?} */ o = {
                    id: this._id
                };
                if (changes['MarkerOptions']) {
                    this._zone.runOutsideAngular(function () {
                        _this.UpdateMarkers();
                    });
                }
                if (changes['Visible'] && !changes['Visible'].firstChange) {
                    this._zone.runOutsideAngular(function () {
                        _this._layerPromise.then(function (l) { return l.SetVisible(_this.Visible); });
                    });
                }
                if (changes['EnableClustering'] && !changes['EnableClustering'].firstChange) {
                    if ('StopClustering' in this._service) {
                        o.clusteringEnabled = this.EnableClustering;
                        shouldSetOptions = true;
                    }
                    else {
                        throw (new Error('You cannot change EnableClustering after the layer has been created.'));
                    }
                }
                if (changes['ClusterPlacementMode'] && !changes['ClusterPlacementMode'].firstChange && 'StopClustering' in this._service) {
                    o.placementMode = this.ClusterPlacementMode;
                    shouldSetOptions = true;
                }
                if (changes['GridSize'] && !changes['GridSize'].firstChange && 'StopClustering' in this._service) {
                    o.gridSize = this.GridSize;
                    shouldSetOptions = true;
                }
                if (changes['ClusterClickAction'] && !changes['ClusterClickAction'].firstChange && 'StopClustering' in this._service) {
                    o.zoomOnClick = this.ClusterClickAction === ClusterClickAction.ZoomIntoCluster;
                    shouldSetOptions = true;
                }
                if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||
                    (changes['LayerOffset'] && !changes['LayerOffset'].firstChange) ||
                    (changes['IconInfo'] && !changes['IconInfo'].firstChange)) {
                    throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));
                }
                if (shouldSetOptions) {
                    this._zone.runOutsideAngular(function () {
                        var /** @type {?} */ fakeLayerDirective = { Id: _this._id };
                        _this._layerPromise.then(function (l) { return l.SetOptions(o); });
                    });
                }
            };
        /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapMarkerLayerDirective
         * @return {?} - string representation of the marker id.
         */
        MapMarkerLayerDirective.prototype.toString = /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapMarkerLayerDirective
         * @return {?} - string representation of the marker id.
         */
            function () { return 'MapMarkerLayer-' + this._id.toString(); };
        /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} m - the marker for which to add the event.
         *
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.AddEventListeners = /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapMarkerLayerDirective
         * @param {?} m - the marker for which to add the event.
         *
         * @return {?}
         */
            function (m) {
                var _this = this;
                m.AddListener('click', function (e) {
                    return _this.MarkerClick.emit({
                        Marker: m,
                        Click: e,
                        Location: _this._markerService.GetCoordinatesFromClick(e),
                        Pixels: _this._markerService.GetPixelsFromClick(e)
                    });
                });
                m.AddListener('dragend', function (e) {
                    return _this.DragEnd.emit({
                        Marker: m,
                        Click: e,
                        Location: _this._markerService.GetCoordinatesFromClick(e),
                        Pixels: _this._markerService.GetPixelsFromClick(e)
                    });
                });
            };
        /**
         * Sets or updates the markers based on the marker options. This will place the markers on the map
         * and register the associated events.
         *
         * \@memberof MapMarkerLayerDirective
         * \@method
         * @return {?}
         */
        MapMarkerLayerDirective.prototype.UpdateMarkers = /**
         * Sets or updates the markers based on the marker options. This will place the markers on the map
         * and register the associated events.
         *
         * \@memberof MapMarkerLayerDirective
         * \@method
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._layerPromise == null) {
                    return;
                }
                this._layerPromise.then(function (l) {
                    var /** @type {?} */ markers = _this._streaming ? _this._markersLast.splice(0) : _this._markers;
                    // generate the promise for the markers
                    var /** @type {?} */ mp = _this._service.CreateMarkers(markers, _this.IconInfo);
                    // set markers once promises are fullfilled.
                    mp.then(function (m) {
                        m.forEach(function (marker) {
                            _this.AddEventListeners(marker);
                        });
                        _this._streaming ? l.AddEntities(m) : l.SetEntities(m);
                    });
                });
            };
        MapMarkerLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-marker-layer'
                    },] },
        ];
        /** @nocollapse */
        MapMarkerLayerDirective.ctorParameters = function () {
            return [
                { type: MarkerService },
                { type: LayerService },
                { type: ClusterService },
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        MapMarkerLayerDirective.propDecorators = {
            ClusterClickAction: [{ type: core.Input }],
            ClusterIconInfo: [{ type: core.Input }],
            ClusterPlacementMode: [{ type: core.Input }],
            CustomMarkerCallback: [{ type: core.Input }],
            DynamicMarkerBaseSize: [{ type: core.Input }],
            DynamicMarkerRanges: [{ type: core.Input }],
            EnableClustering: [{ type: core.Input }],
            GridSize: [{ type: core.Input }],
            IconInfo: [{ type: core.Input }],
            LayerOffset: [{ type: core.Input }],
            MarkerOptions: [{ type: core.Input }],
            Styles: [{ type: core.Input }],
            TreatNewMarkerOptionsAsStream: [{ type: core.Input }],
            UseDynamicSizeMarkers: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            ZIndex: [{ type: core.Input }],
            ZoomOnClick: [{ type: core.Input }],
            DynamicMarkerCreated: [{ type: core.Output }],
            MarkerClick: [{ type: core.Output }],
            DragEnd: [{ type: core.Output }]
        };
        return MapMarkerLayerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * internal counter to use as ids for polygons.
     */
    var /** @type {?} */ layerId$2 = 1000000;
    /**
     * MapPolygonLayerDirective performantly renders a large set of polygons on a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-polygon-layer [PolygonOptions]="_polygons"></x-map-polygon-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapPolygonLayerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapPolygonLayerDirective.
         * @param _layerService - Concreate implementation of a {@link LayerService}.
         * @param _mapService - Concreate implementation of a {@link MapService}.
         * @param _zone - Concreate implementation of a {@link NgZone} service.
         * @memberof MapPolygonLayerDirective
         */
        function MapPolygonLayerDirective(_layerService, _mapService, _zone) {
            this._layerService = _layerService;
            this._mapService = _mapService;
            this._zone = _zone;
            this._labels = new Array();
            this._tooltipSubscriptions = new Array();
            this._tooltipVisible = false;
            this._defaultOptions = {
                fontSize: 11,
                fontFamily: 'sans-serif',
                strokeWeight: 2,
                strokeColor: '#000000',
                fontColor: '#ffffff'
            };
            this._streaming = false;
            this._polygons = new Array();
            this._polygonsLast = new Array();
            /**
             * Set the maximum zoom at which the polygon labels are visible. Ignored if ShowLabel is false.
             * \@memberof MapPolygonLayerDirective
             */
            this.LabelMaxZoom = Number.MAX_SAFE_INTEGER;
            /**
             * Set the minimum zoom at which the polygon labels are visible. Ignored if ShowLabel is false.
             * \@memberof MapPolygonLayerDirective
             */
            this.LabelMinZoom = -1;
            /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.LayerOffset = null;
            /**
             * Whether to show the polygon titles as the labels on the polygons.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.ShowLabels = false;
            /**
             * Whether to show the titles of the polygosn as the tooltips on the polygons.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.ShowTooltips = true;
            /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.ZIndex = 0;
            /**
             * This event emitter gets emitted when the user clicks a polygon in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonClick = new core.EventEmitter();
            /**
             * This event is fired when the DOM dblclick event is fired on a polygon in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonDblClick = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on a polygon in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonMouseMove = new core.EventEmitter();
            /**
             * This event is fired on mouseout on a polygon in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonMouseOut = new core.EventEmitter();
            /**
             * This event is fired on mouseover on a polygon in a layer.
             *
             * \@memberof MapPolygonLayerDirective
             */
            this.PolygonMouseOver = new core.EventEmitter();
            this._id = layerId$2++;
        }
        Object.defineProperty(MapPolygonLayerDirective.prototype, "PolygonOptions", {
            /**
             * An array of polygon options representing the polygons in the layer.
             *
             * @memberof MapPolygonLayerDirective
             */
            get: /**
             * An array of polygon options representing the polygons in the layer.
             *
             * \@memberof MapPolygonLayerDirective
             * @return {?}
             */ function () { return this._polygons; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._streaming) {
                    (_a = this._polygonsLast).push.apply(_a, __spread(val.slice(0)));
                    (_b = this._polygons).push.apply(_b, __spread(val));
                }
                else {
                    this._polygons = val.slice(0);
                }
                var _a, _b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonLayerDirective.prototype, "TreatNewPolygonOptionsAsStream", {
            /**
             * Sets whether to treat changes in the PolygonOptions as streams of new markers. In this mode, changing the
             * Array supplied in PolygonOptions will be incrementally drawn on the map as opposed to replace the polygons on the map.
             *
             * @memberof MapPolygonLayerDirective
             */
            get: /**
             * Sets whether to treat changes in the PolygonOptions as streams of new markers. In this mode, changing the
             * Array supplied in PolygonOptions will be incrementally drawn on the map as opposed to replace the polygons on the map.
             *
             * \@memberof MapPolygonLayerDirective
             * @return {?}
             */ function () { return this._streaming; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._streaming = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolygonLayerDirective.prototype, "Id", {
            get: /**
             * Gets the id of the marker layer.
             *
             * \@readonly
             * \@memberof MapPolygonLayerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapPolygonLayerDirective
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.ngAfterContentInit = /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapPolygonLayerDirective
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ layerOptions = {
                    id: this._id
                };
                this._zone.runOutsideAngular(function () {
                    var /** @type {?} */ fakeLayerDirective = {
                        Id: _this._id,
                        Visible: _this.Visible,
                        LayerOffset: _this.LayerOffset,
                        ZIndex: _this.ZIndex
                    };
                    _this._layerService.AddLayer(fakeLayerDirective);
                    _this._layerPromise = _this._layerService.GetNativeLayer(fakeLayerDirective);
                    Promise.all([
                        _this._layerPromise,
                        _this._mapService.CreateCanvasOverlay(function (el) { return _this.DrawLabels(el); })
                    ]).then(function (values) {
                        values[0].SetVisible(_this.Visible);
                        _this._canvas = values[1];
                        _this._canvas._canvasReady.then(function (b) {
                            _this._tooltip = _this._canvas.GetToolTipOverlay();
                            _this.ManageTooltip(_this.ShowTooltips);
                        });
                        if (_this.PolygonOptions) {
                            _this._zone.runOutsideAngular(function () { return _this.UpdatePolygons(); });
                        }
                    });
                    _this._service = _this._layerService;
                });
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonLayerDirective
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapPolygonLayerDirective
         * @return {?}
         */
            function () {
                this._tooltipSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                this._layerPromise.then(function (l) {
                    l.Delete();
                });
                if (this._canvas) {
                    this._canvas.Delete();
                }
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} changes - collection of changes.
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} changes - collection of changes.
         * @return {?}
         */
            function (changes) {
                var _this = this;
                if (changes['PolygonOptions']) {
                    this._zone.runOutsideAngular(function () {
                        _this.UpdatePolygons();
                    });
                }
                if (changes['Visible'] && !changes['Visible'].firstChange) {
                    this._layerPromise.then(function (l) { return l.SetVisible(_this.Visible); });
                }
                if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||
                    (changes['LayerOffset'] && !changes['LayerOffset'].firstChange)) {
                    throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));
                }
                if ((changes['ShowLabels'] && !changes['ShowLabels'].firstChange) ||
                    (changes['LabelMinZoom'] && !changes['LabelMinZoom'].firstChange) ||
                    (changes['LabelMaxZoom'] && !changes['LabelMaxZoom'].firstChange)) {
                    if (this._canvas) {
                        this._canvas.Redraw(true);
                    }
                }
                if (changes['ShowTooltips'] && this._tooltip) {
                    this.ManageTooltip(changes['ShowTooltips'].currentValue);
                }
            };
        /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapPolygonLayerDirective
         * @return {?} - string representation of the marker id.
         */
        MapPolygonLayerDirective.prototype.toString = /**
         * Obtains a string representation of the Marker Id.
         * \@memberof MapPolygonLayerDirective
         * @return {?} - string representation of the marker id.
         */
            function () { return 'MapPolygonLayer-' + this._id.toString(); };
        /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} p - the polygon for which to add the event.
         *
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.AddEventListeners = /**
         * Adds various event listeners for the marker.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} p - the polygon for which to add the event.
         *
         * @return {?}
         */
            function (p) {
                var _this = this;
                var /** @type {?} */ handlers = [
                    { name: 'click', handler: function (ev) { return _this.PolygonClick.emit({ Polygon: p, Click: ev }); } },
                    { name: 'dblclick', handler: function (ev) { return _this.PolygonDblClick.emit({ Polygon: p, Click: ev }); } },
                    { name: 'mousemove', handler: function (ev) { return _this.PolygonMouseMove.emit({ Polygon: p, Click: ev }); } },
                    { name: 'mouseout', handler: function (ev) { return _this.PolygonMouseOut.emit({ Polygon: p, Click: ev }); } },
                    { name: 'mouseover', handler: function (ev) { return _this.PolygonMouseOver.emit({ Polygon: p, Click: ev }); } }
                ];
                handlers.forEach(function (obj) { return p.AddListener(obj.name, obj.handler); });
            };
        /**
         * Draws the polygon labels. Called by the Canvas overlay.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} el - The canvas on which to draw the labels.
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.DrawLabels = /**
         * Draws the polygon labels. Called by the Canvas overlay.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} el - The canvas on which to draw the labels.
         * @return {?}
         */
            function (el) {
                var _this = this;
                if (this.ShowLabels) {
                    this._mapService.GetZoom().then(function (z) {
                        if (_this.LabelMinZoom <= z && _this.LabelMaxZoom >= z) {
                            var /** @type {?} */ ctx_1 = el.getContext('2d');
                            var /** @type {?} */ labels_1 = _this._labels.map(function (x) { return x.title; });
                            _this._mapService.LocationsToPoints(_this._labels.map(function (x) { return x.loc; })).then(function (locs) {
                                var /** @type {?} */ size = _this._mapService.MapSize;
                                for (var /** @type {?} */ i = 0, /** @type {?} */ len = locs.length; i < len; i++) {
                                    // Don't draw the point if it is not in view. This greatly improves performance when zoomed in.
                                    if (locs[i].x >= 0 && locs[i].y >= 0 && locs[i].x <= size.width && locs[i].y <= size.height) {
                                        _this.DrawText(ctx_1, locs[i], labels_1[i]);
                                    }
                                }
                            });
                        }
                    });
                }
            };
        /**
         * Draws the label text at the appropriate place on the canvas.
         * @param {?} ctx - Canvas drawing context.
         * @param {?} loc - Pixel location on the canvas where to center the text.
         * @param {?} text - Text to draw.
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.DrawText = /**
         * Draws the label text at the appropriate place on the canvas.
         * @param {?} ctx - Canvas drawing context.
         * @param {?} loc - Pixel location on the canvas where to center the text.
         * @param {?} text - Text to draw.
         * @return {?}
         */
            function (ctx, loc, text) {
                var /** @type {?} */ lo = this.LabelOptions;
                if (lo == null && this._tooltip) {
                    lo = this._tooltip.DefaultLabelStyle;
                }
                if (lo == null) {
                    lo = this._defaultOptions;
                }
                ctx.strokeStyle = lo.strokeColor;
                ctx.font = lo.fontSize + "px " + lo.fontFamily;
                ctx.textAlign = 'center';
                var /** @type {?} */ strokeWeight = lo.strokeWeight;
                if (text && strokeWeight && strokeWeight > 0) {
                    ctx.lineWidth = strokeWeight;
                    ctx.strokeText(text, loc.x, loc.y);
                }
                ctx.fillStyle = lo.fontColor;
                ctx.fillText(text, loc.x, loc.y);
            };
        /**
         * Manages the tooltip and the attachment of the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} show - True to enable the tooltip, false to disable.
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.ManageTooltip = /**
         * Manages the tooltip and the attachment of the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} show - True to enable the tooltip, false to disable.
         * @return {?}
         */
            function (show) {
                var _this = this;
                if (show && this._canvas) {
                    // add tooltip subscriptions
                    this._tooltip.Set('hidden', true);
                    this._tooltipVisible = false;
                    this._tooltipSubscriptions.push(this.PolygonMouseMove.asObservable().subscribe(function (e) {
                        if (_this._tooltipVisible) {
                            var /** @type {?} */ loc = _this._canvas.GetCoordinatesFromClick(e.Click);
                            _this._tooltip.Set('position', loc);
                        }
                    }));
                    this._tooltipSubscriptions.push(this.PolygonMouseOver.asObservable().subscribe(function (e) {
                        if (e.Polygon.Title && e.Polygon.Title.length > 0) {
                            var /** @type {?} */ loc = _this._canvas.GetCoordinatesFromClick(e.Click);
                            _this._tooltip.Set('text', e.Polygon.Title);
                            _this._tooltip.Set('position', loc);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        }
                    }));
                    this._tooltipSubscriptions.push(this.PolygonMouseOut.asObservable().subscribe(function (e) {
                        if (_this._tooltipVisible) {
                            _this._tooltip.Set('hidden', true);
                            _this._tooltipVisible = false;
                        }
                    }));
                }
                else {
                    // remove tooltip subscriptions
                    this._tooltipSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                    this._tooltipSubscriptions.splice(0);
                    this._tooltip.Set('hidden', true);
                    this._tooltipVisible = false;
                }
            };
        /**
         * Sets or updates the polygons based on the polygon options. This will place the polygons on the map
         * and register the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * \@method
         * @return {?}
         */
        MapPolygonLayerDirective.prototype.UpdatePolygons = /**
         * Sets or updates the polygons based on the polygon options. This will place the polygons on the map
         * and register the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * \@method
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._layerPromise == null) {
                    return;
                }
                this._layerPromise.then(function (l) {
                    var /** @type {?} */ polygons = _this._streaming ? _this._polygonsLast.splice(0) : _this._polygons;
                    if (!_this._streaming) {
                        _this._labels.splice(0);
                    }
                    // generate the promise for the markers
                    var /** @type {?} */ lp = _this._service.CreatePolygons(l.GetOptions().id, polygons);
                    // set markers once promises are fullfilled.
                    lp.then(function (p) {
                        p.forEach(function (poly) {
                            if (poly.Title != null && poly.Title.length > 0) {
                                _this._labels.push({ loc: poly.Centroid, title: poly.Title });
                            }
                            _this.AddEventListeners(poly);
                        });
                        _this._streaming ? l.AddEntities(p) : l.SetEntities(p);
                        if (_this._canvas) {
                            _this._canvas.Redraw(!_this._streaming);
                        }
                    });
                });
            };
        MapPolygonLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-polygon-layer'
                    },] },
        ];
        /** @nocollapse */
        MapPolygonLayerDirective.ctorParameters = function () {
            return [
                { type: LayerService },
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        MapPolygonLayerDirective.propDecorators = {
            LabelMaxZoom: [{ type: core.Input }],
            LabelMinZoom: [{ type: core.Input }],
            LabelOptions: [{ type: core.Input }],
            LayerOffset: [{ type: core.Input }],
            PolygonOptions: [{ type: core.Input }],
            ShowLabels: [{ type: core.Input }],
            ShowTooltips: [{ type: core.Input }],
            TreatNewPolygonOptionsAsStream: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            ZIndex: [{ type: core.Input }],
            PolygonClick: [{ type: core.Output }],
            PolygonDblClick: [{ type: core.Output }],
            PolygonMouseMove: [{ type: core.Output }],
            PolygonMouseOut: [{ type: core.Output }],
            PolygonMouseOver: [{ type: core.Output }]
        };
        return MapPolygonLayerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * internal counter to use as ids for polylines.
     */
    var /** @type {?} */ layerId$3 = 1000000;
    /**
     * MapPolylineLayerDirective performantly renders a large set of polyline on a {\@link MapComponent}.
     *
     * ### Example
     * ```typescript
     * import {Component} from '\@angular/core';
     * import {MapComponent} from '...';
     *
     * \@Component({
     *  selector: 'my-map-cmp',
     *  styles: [`
     *   .map-container {
     *     height: 300px;
     *   }
     * `],
     * template: `
     *   <x-map [Latitude]="lat" [Longitude]="lng" [Zoom]="zoom">
     *      <x-map-polyline-layer [PolygonOptions]="_polyline"></x-map-polyline-layer>
     *   </x-map>
     * `
     * })
     * ```
     *
     * @export
     */
    var MapPolylineLayerDirective = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of MapPolylineLayerDirective.
         * @param _layerService - Concreate implementation of a {@link LayerService}.
         * @param _mapService - Concreate implementation of a {@link MapService}.
         * @param _zone - Concreate implementation of a {@link NgZone} service.
         * @memberof MapPolylineLayerDirective
         */
        function MapPolylineLayerDirective(_layerService, _mapService, _zone) {
            this._layerService = _layerService;
            this._mapService = _mapService;
            this._zone = _zone;
            this._labels = new Array();
            this._tooltipSubscriptions = new Array();
            this._tooltipVisible = false;
            this._defaultOptions = {
                fontSize: 11,
                fontFamily: 'sans-serif',
                strokeWeight: 2,
                strokeColor: '#000000',
                fontColor: '#ffffff'
            };
            this._streaming = false;
            this._polylines = new Array();
            this._polylinesLast = new Array();
            /**
             * Set the maximum zoom at which the polyline labels are visible. Ignored if ShowLabel is false.
             * \@memberof MapPolylineLayerDirective
             */
            this.LabelMaxZoom = Number.MAX_SAFE_INTEGER;
            /**
             * Set the minimum zoom at which the polyline labels are visible. Ignored if ShowLabel is false.
             * \@memberof MapPolylineLayerDirective
             */
            this.LabelMinZoom = -1;
            /**
             * Gets or sets An offset applied to the positioning of the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.LayerOffset = null;
            /**
             * Whether to show the polylines titles as the labels on the polylines.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.ShowLabels = false;
            /**
             * Whether to show the titles of the polylines as the tooltips on the polylines.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.ShowTooltips = true;
            /**
             * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.ZIndex = 0;
            /**
             * This event emitter gets emitted when the user clicks a polyline in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineClick = new core.EventEmitter();
            /**
             * This event is fired when the DOM dblclick event is fired on a polyline in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineDblClick = new core.EventEmitter();
            /**
             * This event is fired when the DOM mousemove event is fired on a polyline in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineMouseMove = new core.EventEmitter();
            /**
             * This event is fired on mouseout on a polyline in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineMouseOut = new core.EventEmitter();
            /**
             * This event is fired on mouseover on a polyline in a layer.
             *
             * \@memberof MapPolylineLayerDirective
             */
            this.PolylineMouseOver = new core.EventEmitter();
            this._id = layerId$3++;
        }
        Object.defineProperty(MapPolylineLayerDirective.prototype, "PolylineOptions", {
            /**
             * An array of polyline options representing the polylines in the layer.
             *
             * @memberof MapPolylineLayerDirective
             */
            get: /**
             * An array of polyline options representing the polylines in the layer.
             *
             * \@memberof MapPolylineLayerDirective
             * @return {?}
             */ function () { return this._polylines; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (this._streaming) {
                    (_a = this._polylinesLast).push.apply(_a, __spread(val.slice(0)));
                    (_b = this._polylines).push.apply(_b, __spread(val));
                }
                else {
                    this._polylines = val.slice(0);
                }
                var _a, _b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineLayerDirective.prototype, "TreatNewPolylineOptionsAsStream", {
            /**
             * Sets whether to treat changes in the PolylineOptions as streams of new markers. In this mode, changing the
             * Array supplied in PolylineOptions will be incrementally drawn on the map as opposed to replace the polylines on the map.
             *
             * @memberof MapPolylineLayerDirective
             */
            get: /**
             * Sets whether to treat changes in the PolylineOptions as streams of new markers. In this mode, changing the
             * Array supplied in PolylineOptions will be incrementally drawn on the map as opposed to replace the polylines on the map.
             *
             * \@memberof MapPolylineLayerDirective
             * @return {?}
             */ function () { return this._streaming; },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) { this._streaming = val; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MapPolylineLayerDirective.prototype, "Id", {
            get: /**
             * Gets the id of the polyline layer.
             *
             * \@readonly
             * \@memberof MapPolylineLayerDirective
             * @return {?}
             */ function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapPolylineLayerDirective
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.ngAfterContentInit = /**
         * Called after Component content initialization. Part of ng Component life cycle.
         *
         * \@memberof MapPolylineLayerDirective
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ layerOptions = {
                    id: this._id
                };
                this._zone.runOutsideAngular(function () {
                    var /** @type {?} */ fakeLayerDirective = {
                        Id: _this._id,
                        Visible: _this.Visible,
                        LayerOffset: _this.LayerOffset,
                        ZIndex: _this.ZIndex
                    };
                    _this._layerService.AddLayer(fakeLayerDirective);
                    _this._layerPromise = _this._layerService.GetNativeLayer(fakeLayerDirective);
                    Promise.all([
                        _this._layerPromise,
                        _this._mapService.CreateCanvasOverlay(function (el) { return _this.DrawLabels(el); })
                    ]).then(function (values) {
                        values[0].SetVisible(_this.Visible);
                        _this._canvas = values[1];
                        _this._canvas._canvasReady.then(function (b) {
                            _this._tooltip = _this._canvas.GetToolTipOverlay();
                            _this.ManageTooltip(_this.ShowTooltips);
                        });
                        if (_this.PolylineOptions) {
                            _this._zone.runOutsideAngular(function () { return _this.UpdatePolylines(); });
                        }
                    });
                    _this._service = _this._layerService;
                });
            };
        /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineLayerDirective
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.ngOnDestroy = /**
         * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.
         *
         * \@memberof MapPolylineLayerDirective
         * @return {?}
         */
            function () {
                this._tooltipSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                this._layerPromise.then(function (l) {
                    l.Delete();
                });
                if (this._canvas) {
                    this._canvas.Delete();
                }
            };
        /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} changes - collection of changes.
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.ngOnChanges = /**
         * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} changes - collection of changes.
         * @return {?}
         */
            function (changes) {
                var _this = this;
                if (changes['PolylineOptions']) {
                    this._zone.runOutsideAngular(function () {
                        _this.UpdatePolylines();
                    });
                }
                if (changes['Visible'] && !changes['Visible'].firstChange) {
                    this._layerPromise.then(function (l) { return l.SetVisible(_this.Visible); });
                }
                if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||
                    (changes['LayerOffset'] && !changes['LayerOffset'].firstChange)) {
                    throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));
                }
                if ((changes['ShowLabels'] && !changes['ShowLabels'].firstChange) ||
                    (changes['LabelMinZoom'] && !changes['LabelMinZoom'].firstChange) ||
                    (changes['LabelMaxZoom'] && !changes['LabelMaxZoom'].firstChange)) {
                    if (this._canvas) {
                        this._canvas.Redraw(true);
                    }
                }
                if (changes['ShowTooltips'] && this._tooltip) {
                    this.ManageTooltip(changes['ShowTooltips'].currentValue);
                }
            };
        /**
         * Obtains a string representation of the Layer Id.
         * \@memberof MapPolylineLayerDirective
         * @return {?} - string representation of the layer id.
         */
        MapPolylineLayerDirective.prototype.toString = /**
         * Obtains a string representation of the Layer Id.
         * \@memberof MapPolylineLayerDirective
         * @return {?} - string representation of the layer id.
         */
            function () { return 'MapPolylineLayer-' + this._id.toString(); };
        /**
         * Adds various event listeners for the polylines.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} p - the polyline for which to add the event.
         *
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.AddEventListeners = /**
         * Adds various event listeners for the polylines.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} p - the polyline for which to add the event.
         *
         * @return {?}
         */
            function (p) {
                var _this = this;
                var /** @type {?} */ handlers = [
                    { name: 'click', handler: function (ev) { return _this.PolylineClick.emit({ Polyline: p, Click: ev }); } },
                    { name: 'dblclick', handler: function (ev) { return _this.PolylineDblClick.emit({ Polyline: p, Click: ev }); } },
                    { name: 'mousemove', handler: function (ev) { return _this.PolylineMouseMove.emit({ Polyline: p, Click: ev }); } },
                    { name: 'mouseout', handler: function (ev) { return _this.PolylineMouseOut.emit({ Polyline: p, Click: ev }); } },
                    { name: 'mouseover', handler: function (ev) { return _this.PolylineMouseOver.emit({ Polyline: p, Click: ev }); } }
                ];
                handlers.forEach(function (obj) { return p.AddListener(obj.name, obj.handler); });
            };
        /**
         * Draws the polyline labels. Called by the Canvas overlay.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} el - The canvas on which to draw the labels.
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.DrawLabels = /**
         * Draws the polyline labels. Called by the Canvas overlay.
         *
         * \@memberof MapPolylineLayerDirective
         * @param {?} el - The canvas on which to draw the labels.
         * @return {?}
         */
            function (el) {
                var _this = this;
                if (this.ShowLabels) {
                    this._mapService.GetZoom().then(function (z) {
                        if (_this.LabelMinZoom <= z && _this.LabelMaxZoom >= z) {
                            var /** @type {?} */ ctx_1 = el.getContext('2d');
                            var /** @type {?} */ labels_1 = _this._labels.map(function (x) { return x.title; });
                            _this._mapService.LocationsToPoints(_this._labels.map(function (x) { return x.loc; })).then(function (locs) {
                                var /** @type {?} */ size = _this._mapService.MapSize;
                                for (var /** @type {?} */ i = 0, /** @type {?} */ len = locs.length; i < len; i++) {
                                    // Don't draw the point if it is not in view. This greatly improves performance when zoomed in.
                                    if (locs[i].x >= 0 && locs[i].y >= 0 && locs[i].x <= size.width && locs[i].y <= size.height) {
                                        _this.DrawText(ctx_1, locs[i], labels_1[i]);
                                    }
                                }
                            });
                        }
                    });
                }
            };
        /**
         * Draws the label text at the appropriate place on the canvas.
         * @param {?} ctx - Canvas drawing context.
         * @param {?} loc - Pixel location on the canvas where to center the text.
         * @param {?} text - Text to draw.
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.DrawText = /**
         * Draws the label text at the appropriate place on the canvas.
         * @param {?} ctx - Canvas drawing context.
         * @param {?} loc - Pixel location on the canvas where to center the text.
         * @param {?} text - Text to draw.
         * @return {?}
         */
            function (ctx, loc, text) {
                var /** @type {?} */ lo = this.LabelOptions;
                if (lo == null && this._tooltip) {
                    lo = this._tooltip.DefaultLabelStyle;
                }
                if (lo == null) {
                    lo = this._defaultOptions;
                }
                ctx.strokeStyle = lo.strokeColor;
                ctx.font = lo.fontSize + "px " + lo.fontFamily;
                ctx.textAlign = 'center';
                var /** @type {?} */ strokeWeight = lo.strokeWeight;
                if (text && strokeWeight && strokeWeight > 0) {
                    ctx.lineWidth = strokeWeight;
                    ctx.strokeText(text, loc.x, loc.y);
                }
                ctx.fillStyle = lo.fontColor;
                ctx.fillText(text, loc.x, loc.y);
            };
        /**
         * Manages the tooltip and the attachment of the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} show - True to enable the tooltip, false to disable.
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.ManageTooltip = /**
         * Manages the tooltip and the attachment of the associated events.
         *
         * \@memberof MapPolygonLayerDirective
         * @param {?} show - True to enable the tooltip, false to disable.
         * @return {?}
         */
            function (show) {
                var _this = this;
                if (show && this._canvas) {
                    // add tooltip subscriptions
                    this._tooltip.Set('hidden', true);
                    this._tooltipVisible = false;
                    this._tooltipSubscriptions.push(this.PolylineMouseMove.asObservable().subscribe(function (e) {
                        if (_this._tooltipVisible) {
                            var /** @type {?} */ loc = _this._canvas.GetCoordinatesFromClick(e.Click);
                            _this._tooltip.Set('position', loc);
                        }
                    }));
                    this._tooltipSubscriptions.push(this.PolylineMouseOver.asObservable().subscribe(function (e) {
                        if (e.Polyline.Title && e.Polyline.Title.length > 0) {
                            var /** @type {?} */ loc = _this._canvas.GetCoordinatesFromClick(e.Click);
                            _this._tooltip.Set('text', e.Polyline.Title);
                            _this._tooltip.Set('position', loc);
                            if (!_this._tooltipVisible) {
                                _this._tooltip.Set('hidden', false);
                                _this._tooltipVisible = true;
                            }
                        }
                    }));
                    this._tooltipSubscriptions.push(this.PolylineMouseOut.asObservable().subscribe(function (e) {
                        if (_this._tooltipVisible) {
                            _this._tooltip.Set('hidden', true);
                            _this._tooltipVisible = false;
                        }
                    }));
                }
                else {
                    // remove tooltip subscriptions
                    this._tooltipSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                    this._tooltipSubscriptions.splice(0);
                    this._tooltip.Set('hidden', true);
                    this._tooltipVisible = false;
                }
            };
        /**
         * Sets or updates the polyliness based on the polyline options. This will place the polylines on the map
         * and register the associated events.
         *
         * \@memberof MapPolylineLayerDirective
         * \@method
         * @return {?}
         */
        MapPolylineLayerDirective.prototype.UpdatePolylines = /**
         * Sets or updates the polyliness based on the polyline options. This will place the polylines on the map
         * and register the associated events.
         *
         * \@memberof MapPolylineLayerDirective
         * \@method
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._layerPromise == null) {
                    return;
                }
                this._layerPromise.then(function (l) {
                    var /** @type {?} */ polylines = _this._streaming ? _this._polylinesLast.splice(0) : _this._polylines;
                    if (!_this._streaming) {
                        _this._labels.splice(0);
                    }
                    // generate the promise for the polylines
                    var /** @type {?} */ lp = _this._service.CreatePolylines(l.GetOptions().id, polylines);
                    // set polylines once promises are fullfilled.
                    lp.then(function (p) {
                        var /** @type {?} */ y = new Array();
                        p.forEach(function (poly) {
                            if (Array.isArray(poly)) {
                                var /** @type {?} */ title_1 = '';
                                var /** @type {?} */ centroids_1 = new Array();
                                poly.forEach(function (x) {
                                    y.push(x);
                                    _this.AddEventListeners(x);
                                    centroids_1.push(x.Centroid);
                                    if (x.Title != null && x.Title.length > 0 && title_1.length === 0) {
                                        title_1 = x.Title;
                                    }
                                });
                                _this._labels.push({ loc: Polyline.GetPolylineCentroid(centroids_1), title: title_1 });
                            }
                            else {
                                y.push(poly);
                                if (poly.Title != null && poly.Title.length > 0) {
                                    _this._labels.push({ loc: poly.Centroid, title: poly.Title });
                                }
                                _this.AddEventListeners(poly);
                            }
                        });
                        _this._streaming ? l.AddEntities(y) : l.SetEntities(y);
                        if (_this._canvas) {
                            _this._canvas.Redraw(!_this._streaming);
                        }
                    });
                });
            };
        MapPolylineLayerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'x-map-polyline-layer'
                    },] },
        ];
        /** @nocollapse */
        MapPolylineLayerDirective.ctorParameters = function () {
            return [
                { type: LayerService },
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        MapPolylineLayerDirective.propDecorators = {
            LabelMaxZoom: [{ type: core.Input }],
            LabelMinZoom: [{ type: core.Input }],
            LabelOptions: [{ type: core.Input }],
            LayerOffset: [{ type: core.Input }],
            PolylineOptions: [{ type: core.Input }],
            ShowLabels: [{ type: core.Input }],
            ShowTooltips: [{ type: core.Input }],
            TreatNewPolylineOptionsAsStream: [{ type: core.Input }],
            Visible: [{ type: core.Input }],
            ZIndex: [{ type: core.Input }],
            PolylineClick: [{ type: core.Output }],
            PolylineDblClick: [{ type: core.Output }],
            PolylineMouseMove: [{ type: core.Output }],
            PolylineMouseOut: [{ type: core.Output }],
            PolylineMouseOver: [{ type: core.Output }]
        };
        return MapPolylineLayerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Abstract implementation. USed for defintion only and as a base to implement your
     * own provider.
     *
     * @export
     * @abstract
     * @abstract
     */
    var MapAPILoader = (function () {
        function MapAPILoader() {
        }
        MapAPILoader.decorators = [
            { type: core.Injectable },
        ];
        return MapAPILoader;
    }());
    /**
     * Document Reference service to assist with abstracting the availability of document. Needed for AOT and
     * Server Side rendering
     *
     * @export
     */
    var DocumentRef = (function () {
        function DocumentRef() {
        }
        Object.defineProperty(DocumentRef.prototype, "IsAvailable", {
            get: /**
             * Gets whether a document implementation is available. Generally will be true in the browser and false otherwise, unless there
             * there is a browser-less implementation in the current non-browser environment.
             *
             * \@readonly
             * \@memberof DocumentRef
             * @return {?}
             */ function () {
                return !(typeof (document) === 'undefined');
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the document object of the current environment.
         *
         * \@memberof DocumentRef
         * @return {?} - The document object.
         *
         */
        DocumentRef.prototype.GetNativeDocument = /**
         * Returns the document object of the current environment.
         *
         * \@memberof DocumentRef
         * @return {?} - The document object.
         *
         */
            function () {
                if (typeof (document) === 'undefined') {
                    return null;
                }
                return document;
            };
        DocumentRef.decorators = [
            { type: core.Injectable },
        ];
        return DocumentRef;
    }());
    /**
     * Window Reference service to assist with abstracting the availability of window. Needed for AOT and
     * Server Side rendering
     *
     * @export
     */
    var WindowRef = (function () {
        function WindowRef() {
        }
        Object.defineProperty(WindowRef.prototype, "IsAvailable", {
            get: /**
             * Gets whether a window implementation is available. Generally will be true in the browser and false otherwise, unless there
             * there is a browser-less implementation in the current non-browser environment.
             *
             * \@readonly
             * \@memberof WindowRef
             * @return {?}
             */ function () {
                return !(typeof (window) === 'undefined');
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the window object of the current environment.
         *
         * \@memberof WindowRef
         * @return {?} - The window object.
         *
         */
        WindowRef.prototype.GetNativeWindow = /**
         * Returns the window object of the current environment.
         *
         * \@memberof WindowRef
         * @return {?} - The window object.
         *
         */
            function () {
                if (typeof (window) === 'undefined') {
                    return null;
                }
                return window;
            };
        WindowRef.decorators = [
            { type: core.Injectable },
        ];
        return WindowRef;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var ScriptProtocol = {
        HTTP: 0,
        HTTPS: 1,
        AUTO: 2,
    };
    ScriptProtocol[ScriptProtocol.HTTP] = "HTTP";
    ScriptProtocol[ScriptProtocol.HTTPS] = "HTTPS";
    ScriptProtocol[ScriptProtocol.AUTO] = "AUTO";
    /**
     * Bing Maps V8 specific loader configuration to be used with the {\@link BingMapAPILoader}
     *
     * @export
     */
    var BingMapAPILoaderConfig = (function () {
        function BingMapAPILoaderConfig() {
            this.apiKey = '';
            this.hostAndPath = 'www.bing.com/api/maps/mapcontrol';
            this.protocol = ScriptProtocol.HTTPS;
            this.branch = '';
        }
        BingMapAPILoaderConfig.decorators = [
            { type: core.Injectable },
        ];
        return BingMapAPILoaderConfig;
    }());
    /**
     * Default loader configuration.
     */
    var /** @type {?} */ DEFAULT_CONFIGURATION = new BingMapAPILoaderConfig();
    /**
     * Bing Maps V8 implementation for the {\@link MapAPILoader} service.
     *
     * @export
     */
    var BingMapAPILoader = (function (_super) {
        __extends(BingMapAPILoader, _super);
        /**
         * Creates an instance of BingMapAPILoader.
         * @param _config  - The loader configuration.
         * @param _windowRef - An instance of {@link WindowRef}. Necessary because Bing Map V8 interacts with the window object.
         * @param _documentRef - An instance of {@link DocumentRef}.
         * Necessary because Bing Map V8 interacts with the document object.
         *
         * @memberof BingMapAPILoader
         */
        function BingMapAPILoader(_config, _windowRef, _documentRef) {
            var _this = _super.call(this) || this;
            _this._config = _config;
            _this._windowRef = _windowRef;
            _this._documentRef = _documentRef;
            if (_this._config === null || _this._config === undefined) {
                _this._config = DEFAULT_CONFIGURATION;
            }
            return _this;
        }
        Object.defineProperty(BingMapAPILoader.prototype, "Config", {
            get: /**
             * Gets the loader configuration.
             *
             * \@readonly
             * \@memberof BingMapAPILoader
             * @return {?}
             */ function () { return this._config; },
            enumerable: true,
            configurable: true
        });
        /**
         * Loads the necessary resources for Bing Maps V8.
         *
         * \@memberof BingMapAPILoader
         * @return {?}
         */
        BingMapAPILoader.prototype.Load = /**
         * Loads the necessary resources for Bing Maps V8.
         *
         * \@memberof BingMapAPILoader
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._scriptLoadingPromise) {
                    return this._scriptLoadingPromise;
                }
                var /** @type {?} */ script = this._documentRef.GetNativeDocument().createElement('script');
                script.type = 'text/javascript';
                script.async = true;
                script.defer = true;
                var /** @type {?} */ callbackName = "angular2bingmaps" + new Date().getMilliseconds();
                script.src = this.GetScriptSrc(callbackName);
                this._scriptLoadingPromise = new Promise(function (resolve, reject) {
                    ((_this._windowRef.GetNativeWindow()))[callbackName] = function () {
                        resolve();
                    };
                    script.onerror = function (error) { reject(error); };
                });
                this._documentRef.GetNativeDocument().head.appendChild(script);
                return this._scriptLoadingPromise;
            };
        /**
         * Gets the Bing Map V8 scripts url for injections into the header.
         *
         * \@memberof BingMapAPILoader
         * @param {?} callbackName - Name of the function to be called when the Bing Maps V8 scripts are loaded.
         * @return {?} - The url to be used to load the Bing Map scripts.
         *
         */
        BingMapAPILoader.prototype.GetScriptSrc = /**
         * Gets the Bing Map V8 scripts url for injections into the header.
         *
         * \@memberof BingMapAPILoader
         * @param {?} callbackName - Name of the function to be called when the Bing Maps V8 scripts are loaded.
         * @return {?} - The url to be used to load the Bing Map scripts.
         *
         */
            function (callbackName) {
                var /** @type {?} */ protocolType = (this._config && this._config.protocol) || DEFAULT_CONFIGURATION.protocol;
                var /** @type {?} */ protocol;
                switch (protocolType) {
                    case ScriptProtocol.AUTO:
                        protocol = '';
                        break;
                    case ScriptProtocol.HTTP:
                        protocol = 'http:';
                        break;
                    case ScriptProtocol.HTTPS:
                        protocol = 'https:';
                        break;
                }
                var /** @type {?} */ hostAndPath = this._config.hostAndPath || DEFAULT_CONFIGURATION.hostAndPath;
                var /** @type {?} */ queryParams = {
                    callback: callbackName
                };
                if (this._config.branch !== '') {
                    queryParams['branch'] = this._config.branch;
                }
                var /** @type {?} */ params = Object.keys(queryParams)
                    .map(function (k, i) {
                    var /** @type {?} */ param = (i === 0) ? '?' : '&';
                    return param += k + "=" + queryParams[k];
                })
                    .join('');
                return protocol + "//" + hostAndPath + params;
            };
        BingMapAPILoader.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingMapAPILoader.ctorParameters = function () {
            return [
                { type: BingMapAPILoaderConfig, decorators: [{ type: core.Optional }] },
                { type: WindowRef },
                { type: DocumentRef }
            ];
        };
        return BingMapAPILoader;
    }(MapAPILoader));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the {\@link InfoBoxService} contract for the Bing Maps V8 architecture.
     *
     * @export
     */
    var BingInfoBoxService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingInfoBoxService.
         * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.
         * @param _zone - An instance of NgZone to provide zone aware promises.
         *
         * @memberof BingInfoBoxService
         */
        function BingInfoBoxService(_mapService, _zone) {
            this._mapService = _mapService;
            this._zone = _zone;
            this._boxes = new Map();
        }
        /**
         * Adds an info window to the map or layer.
         *
         * \@memberof BingInfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         *
         * @return {?}
         */
        BingInfoBoxService.prototype.AddInfoWindow = /**
         * Adds an info window to the map or layer.
         *
         * \@memberof BingInfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         *
         * @return {?}
         */
            function (info) {
                var /** @type {?} */ options = {};
                if (typeof info.Latitude === 'number' && typeof info.Longitude === 'number') {
                    options.position = {
                        latitude: info.Latitude,
                        longitude: info.Longitude
                    };
                }
                if (typeof info.InfoWindowActions !== 'undefined' && info.InfoWindowActions.length > 0) {
                    options.actions = [];
                    info.InfoWindowActions.forEach(function (action) {
                        options.actions.push({
                            label: action.Label,
                            eventHandler: function () { action.ActionClicked.emit(null); }
                        });
                    });
                }
                if (info.HtmlContent !== '') {
                    options.htmlContent = info.HtmlContent;
                }
                else {
                    options.title = info.Title;
                    options.description = info.Description;
                }
                if (info.xOffset || info.yOffset) {
                    if (options.pixelOffset == null) {
                        options.pixelOffset = { x: 0, y: 0 };
                    }
                    if (info.xOffset) {
                        options.pixelOffset.x = info.xOffset;
                    }
                    if (info.yOffset) {
                        options.pixelOffset.y = info.yOffset;
                    }
                }
                options.visible = info.Visible;
                var /** @type {?} */ infoPromise = this._mapService.CreateInfoWindow(options);
                this._boxes.set(info, infoPromise);
            };
        /**
         * Closes an InfoBoxComponent that is open.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox has been closed.
         *
         */
        BingInfoBoxService.prototype.Close = /**
         * Closes an InfoBoxComponent that is open.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox has been closed.
         *
         */
            function (info) {
                return this._boxes.get(info).then(function (w) { return w.Close(); });
            };
        /**
         * Registers an event delegate for an info window.
         *
         * \@memberof GoogleInfoBoxService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} infoComponent - The {\@link InfoBoxComponent} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        BingInfoBoxService.prototype.CreateEventObservable = /**
         * Registers an event delegate for an info window.
         *
         * \@memberof GoogleInfoBoxService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} infoComponent - The {\@link InfoBoxComponent} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, infoComponent) {
                var _this = this;
                var /** @type {?} */ eventNameTranslated = BingMapEventsLookup[eventName];
                return rxjs.Observable.create(function (observer) {
                    _this._boxes.get(infoComponent).then(function (b) {
                        b.AddListener(eventNameTranslated, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes an infobox.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox has been deleted.
         *
         */
        BingInfoBoxService.prototype.DeleteInfoWindow = /**
         * Deletes an infobox.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox has been deleted.
         *
         */
            function (info) {
                var _this = this;
                var /** @type {?} */ w = this._boxes.get(info);
                if (w == null) {
                    return Promise.resolve();
                }
                return w.then(function (i) {
                    return _this._zone.run(function () {
                        i.Close();
                        _this._boxes.delete(info);
                    });
                });
            };
        /**
         * Opens an infobox that is closed.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @param {?=} loc
         * @return {?} - A promise that is fullfilled when the infobox has been opened.
         *
         */
        BingInfoBoxService.prototype.Open = /**
         * Opens an infobox that is closed.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @param {?=} loc
         * @return {?} - A promise that is fullfilled when the infobox has been opened.
         *
         */
            function (info, loc) {
                if (info.CloseInfoBoxesOnOpen || info.Modal) {
                    // close all open info boxes.
                    this._boxes.forEach(function (v, i) {
                        if (info.Id !== i.Id) {
                            v.then(function (w) {
                                if (w.IsOpen) {
                                    w.Close();
                                    i.Close();
                                }
                            });
                        }
                    });
                }
                return this._boxes.get(info).then(function (w) {
                    var /** @type {?} */ options = {};
                    if (info.HtmlContent !== '') {
                        options.htmlContent = info.HtmlContent;
                    }
                    else {
                        options.title = info.Title;
                        options.description = info.Description;
                    }
                    w.SetOptions(options);
                    if (info.Latitude && info.Longitude) {
                        w.SetPosition({ latitude: info.Latitude, longitude: info.Longitude });
                    }
                    else if (loc) {
                        w.SetPosition(loc);
                    }
                    else if (info.HostMarker) {
                        w.SetPosition({ latitude: info.HostMarker.Latitude, longitude: info.HostMarker.Longitude });
                    }
                    w.Open();
                });
            };
        /**
         * Sets the infobox options.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @param {?} options - {\@link IInfoWindowOptions} object containing the options to set. Options provided are
         * merged with the existing options of the underlying infobox.
         * @return {?} - A promise that is fullfilled when the infobox options have been updated.
         *
         */
        BingInfoBoxService.prototype.SetOptions = /**
         * Sets the infobox options.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @param {?} options - {\@link IInfoWindowOptions} object containing the options to set. Options provided are
         * merged with the existing options of the underlying infobox.
         * @return {?} - A promise that is fullfilled when the infobox options have been updated.
         *
         */
            function (info, options) {
                return this._boxes.get(info).then(function (i) { return i.SetOptions(options); });
            };
        /**
         * Set the position of the infobox based on the properties set on the InfoBox component.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox position has been updated.
         *
         */
        BingInfoBoxService.prototype.SetPosition = /**
         * Set the position of the infobox based on the properties set on the InfoBox component.
         *
         * @abstract
         * \@memberof InfoBoxService
         * @param {?} info - {\@link InfoBoxComponent} component object representing the infobox.
         * @return {?} - A promise that is fullfilled when the infobox position has been updated.
         *
         */
            function (info) {
                return this._boxes.get(info).then(function (i) {
                    return i.SetPosition({
                        latitude: info.Latitude,
                        longitude: info.Longitude
                    });
                });
            };
        BingInfoBoxService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingInfoBoxService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return BingInfoBoxService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the MarkerService abstract class for Bing Maps V8.
     *
     * @export
     */
    var BingMarkerService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingMarkerService.
         * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.
         * @param _layerService - {@link LayerService} instance.
         * The concrete {@link BingLayerService} implementation is expected.
         * @param _clusterService - {@link ClusterService} instance.
         * The concrete {@link BingClusterService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof BingMarkerService
         */
        function BingMarkerService(_mapService, _layerService, _clusterService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._clusterService = _clusterService;
            this._zone = _zone;
            this._markers = new Map();
        }
        /**
         * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} to be added.
         *
         * @return {?}
         */
        BingMarkerService.prototype.AddMarker = /**
         * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} to be added.
         *
         * @return {?}
         */
            function (marker) {
                var /** @type {?} */ o = {
                    position: { latitude: marker.Latitude, longitude: marker.Longitude },
                    title: marker.Title,
                    label: marker.Label,
                    draggable: marker.Draggable,
                    icon: marker.IconUrl,
                    iconInfo: marker.IconInfo,
                    isFirst: marker.IsFirstInSet,
                    isLast: marker.IsLastInSet
                };
                if (marker.Width) {
                    o.width = marker.Width;
                }
                if (marker.Height) {
                    o.height = marker.Height;
                }
                if (marker.Anchor) {
                    o.anchor = marker.Anchor;
                }
                if (marker.Metadata) {
                    o.metadata = marker.Metadata;
                }
                // create marker via promise.
                var /** @type {?} */ markerPromise = null;
                if (marker.InClusterLayer) {
                    markerPromise = this._clusterService.CreateMarker(marker.LayerId, o);
                }
                else if (marker.InCustomLayer) {
                    markerPromise = this._layerService.CreateMarker(marker.LayerId, o);
                }
                else {
                    markerPromise = this._mapService.CreateMarker(o);
                }
                this._markers.set(marker, markerPromise);
                if (marker.IconInfo) {
                    markerPromise.then(function (m) {
                        // update iconInfo to provide hook to do post icon creation activities and
                        // also re-anchor the marker
                        marker.DynamicMarkerCreated.emit(o.iconInfo);
                        var /** @type {?} */ p = {
                            x: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.width * o.iconInfo.markerOffsetRatio.x) : 0,
                            y: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.height * o.iconInfo.markerOffsetRatio.y) : 0,
                        };
                        m.SetAnchor(p);
                    });
                }
            };
        /**
         * Registers an event delegate for a marker.
         *
         * \@memberof BingMarkerService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} marker - The {\@link MapMarker} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        BingMarkerService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a marker.
         *
         * \@memberof BingMarkerService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} marker - The {\@link MapMarker} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, marker) {
                var _this = this;
                var /** @type {?} */ b = new rxjs.Subject();
                if (eventName === 'mousemove') {
                    return b.asObservable();
                }
                if (eventName === 'rightclick') {
                    return b.asObservable();
                }
                return rxjs.Observable.create(function (observer) {
                    _this._markers.get(marker).then(function (m) {
                        m.AddListener(eventName, function (e) {
                            return _this._zone.run(function () {
                                return observer.next(e);
                            });
                        });
                    });
                });
            };
        /**
         * Deletes a marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - {\@link MapMarker} to be deleted.
         * @return {?} - A promise fullfilled once the marker has been deleted.
         *
         */
        BingMarkerService.prototype.DeleteMarker = /**
         * Deletes a marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - {\@link MapMarker} to be deleted.
         * @return {?} - A promise fullfilled once the marker has been deleted.
         *
         */
            function (marker) {
                var _this = this;
                var /** @type {?} */ m = this._markers.get(marker);
                var /** @type {?} */ p = Promise.resolve();
                if (m != null) {
                    p = m.then(function (ma) {
                        if (marker.InClusterLayer) {
                            _this._clusterService.GetNativeLayer(marker.LayerId).then(function (l) { l.RemoveEntity(ma); });
                        }
                        if (marker.InCustomLayer) {
                            _this._layerService.GetNativeLayer(marker.LayerId).then(function (l) { l.RemoveEntity(ma); });
                        }
                        return _this._zone.run(function () {
                            ma.DeleteMarker();
                            _this._markers.delete(marker);
                        });
                    });
                }
                return p;
            };
        /**
         * Obtains geo coordinates for the marker on the click location
         *
         * \@memberof BingMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
        BingMarkerService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the marker on the click location
         *
         * \@memberof BingMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.primitive) {
                    return null;
                }
                if (!(e.primitive instanceof Microsoft.Maps.Pushpin)) {
                    return null;
                }
                var /** @type {?} */ p = e.primitive;
                var /** @type {?} */ loc = p.getLocation();
                return { latitude: loc.latitude, longitude: loc.longitude };
            };
        /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - The {\@link MapMarker} for which to obtain the marker model.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} implementation of the underlying platform.
         *
         */
        BingMarkerService.prototype.GetNativeMarker = /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof BingMarkerService
         * @param {?} marker - The {\@link MapMarker} for which to obtain the marker model.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} implementation of the underlying platform.
         *
         */
            function (marker) {
                return this._markers.get(marker);
            };
        /**
         * Obtains the marker pixel location for the marker on the click location
         *
         * \@memberof BingMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the pixels of the marker on the map canvas.
         *
         */
        BingMarkerService.prototype.GetPixelsFromClick = /**
         * Obtains the marker pixel location for the marker on the click location
         *
         * \@memberof BingMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the pixels of the marker on the map canvas.
         *
         */
            function (e) {
                var /** @type {?} */ loc = this.GetCoordinatesFromClick(e);
                if (loc == null) {
                    return null;
                }
                var /** @type {?} */ l = BingConversions.TranslateLocation(loc);
                var /** @type {?} */ p = (((this._mapService)).MapInstance.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control));
                if (p == null) {
                    return null;
                }
                return { x: p.x, y: p.y };
            };
        /**
         * Converts a geo location to a pixel location relative to the map canvas.
         *
         * \@memberof BingMarkerService
         * @param {?} target - Either a {\@link MapMarker} or a {\@link ILatLong} for the basis of translation.
         * @return {?} - A promise that when fullfilled contains a {\@link IPoint}
         * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.
         *
         */
        BingMarkerService.prototype.LocationToPoint = /**
         * Converts a geo location to a pixel location relative to the map canvas.
         *
         * \@memberof BingMarkerService
         * @param {?} target - Either a {\@link MapMarker} or a {\@link ILatLong} for the basis of translation.
         * @return {?} - A promise that when fullfilled contains a {\@link IPoint}
         * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.
         *
         */
            function (target) {
                var _this = this;
                if (target == null) {
                    return Promise.resolve(null);
                }
                if (target instanceof MapMarkerDirective) {
                    return this._markers.get(target).then(function (m) {
                        var /** @type {?} */ l = m.Location;
                        var /** @type {?} */ p = _this._mapService.LocationToPoint(l);
                        return p;
                    });
                }
                return this._mapService.LocationToPoint(target);
            };
        /**
         * Updates the anchor position for the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the anchor position has been updated.
         *
         */
        BingMarkerService.prototype.UpdateAnchor = /**
         * Updates the anchor position for the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the anchor position has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    m.SetAnchor(marker.Anchor);
                });
            };
        /**
         * Updates whether the marker is draggable.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the marker has been updated.
         *
         */
        BingMarkerService.prototype.UpdateDraggable = /**
         * Updates whether the marker is draggable.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the marker has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetDraggable(marker.Draggable); });
            };
        /**
         * Updates the Icon on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the icon information has been updated.
         *
         */
        BingMarkerService.prototype.UpdateIcon = /**
         * Updates the Icon on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the icon information has been updated.
         *
         */
            function (marker) {
                var /** @type {?} */ payload = function (m, icon, iconInfo) {
                    if (icon && icon !== '') {
                        m.SetIcon(icon);
                        marker.DynamicMarkerCreated.emit(iconInfo);
                    }
                };
                return this._markers.get(marker).then(function (m) {
                    if (marker.IconInfo) {
                        var /** @type {?} */ s = Marker.CreateMarker(marker.IconInfo);
                        if (typeof (s) === 'string') {
                            return (payload(m, s, marker.IconInfo));
                        }
                        else {
                            return s.then(function (x) {
                                return (payload(m, x.icon, x.iconInfo));
                            });
                        }
                    }
                    else {
                        return (m.SetIcon(marker.IconUrl));
                    }
                });
            };
        /**
         * Updates the label on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the label has been updated.
         *
         */
        BingMarkerService.prototype.UpdateLabel = /**
         * Updates the label on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the label has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { m.SetLabel(marker.Label); });
            };
        /**
         * Updates the geo coordinates for the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the position has been updated.
         *
         */
        BingMarkerService.prototype.UpdateMarkerPosition = /**
         * Updates the geo coordinates for the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the position has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    return m.SetPosition({
                        latitude: marker.Latitude,
                        longitude: marker.Longitude
                    });
                });
            };
        /**
         * Updates the title on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         *
         */
        BingMarkerService.prototype.UpdateTitle = /**
         * Updates the title on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetTitle(marker.Title); });
            };
        /**
         * Updates the visibility on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the visibility has been updated.
         *
         */
        BingMarkerService.prototype.UpdateVisible = /**
         * Updates the visibility on the marker.
         *
         * \@memberof BingMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the visibility has been updated.
         *
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetVisible(marker.Visible); });
            };
        BingMarkerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingMarkerService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: ClusterService },
                { type: core.NgZone }
            ];
        };
        return BingMarkerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the MapService abstract implementing a Bin Map V8 provider
     *
     * @export
     */
    var BingMapService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingMapService.
         * @param _loader MapAPILoader instance implemented for Bing Maps. This instance will generally be injected.
         * @param _zone NgZone object to enable zone aware promises. This will generally be injected.
         *
         * @memberof BingMapService
         */
        function BingMapService(_loader, _zone) {
            var _this = this;
            this._loader = _loader;
            this._zone = _zone;
            this._modules = new Map();
            this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
            this._config = ((this._loader)).Config;
        }
        Object.defineProperty(BingMapService.prototype, "LoadedModules", {
            get: /**
             * Gets an array of loaded Bong modules.
             *
             * \@readonly
             * \@memberof BingMapService
             * @return {?}
             */ function () { return this._modules; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMapService.prototype, "MapInstance", {
            get: /**
             * Gets the Bing Map control instance underlying the implementation
             *
             * \@readonly
             * \@memberof BingMapService
             * @return {?}
             */ function () { return this._mapInstance; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMapService.prototype, "MapPromise", {
            get: /**
             * Gets a Promise for a Bing Map control instance underlying the implementation. Use this instead of {\@link MapInstance} if you
             * are not sure if and when the instance will be created.
             * \@readonly
             * \@memberof BingMapService
             * @return {?}
             */ function () { return this._map; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BingMapService.prototype, "MapSize", {
            get: /**
             * Gets the maps physical size.
             *
             * \@readonly
             * @abstract
             * \@memberof BingMapService
             * @return {?}
             */ function () {
                if (this.MapInstance) {
                    var /** @type {?} */ s = { width: this.MapInstance.getWidth(), height: this.MapInstance.getHeight() };
                    return s;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates a canvas overlay layer to perform custom drawing over the map with out
         * some of the overhead associated with going through the Map objects.
         * \@memberof BingMapService
         * @param {?} drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @return {?} - Promise of a {\@link CanvasOverlay} object.
         */
        BingMapService.prototype.CreateCanvasOverlay = /**
         * Creates a canvas overlay layer to perform custom drawing over the map with out
         * some of the overhead associated with going through the Map objects.
         * \@memberof BingMapService
         * @param {?} drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @return {?} - Promise of a {\@link CanvasOverlay} object.
         */
            function (drawCallback) {
                return this._map.then(function (map) {
                    var /** @type {?} */ overlay = new BingCanvasOverlay(drawCallback);
                    map.layers.insert(overlay);
                    return overlay;
                });
            };
        /**
         * Creates a Bing map cluster layer within the map context
         *
         * \@memberof BingMapService
         * @param {?} options - Options for the layer. See {\@link IClusterOptions}.
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.ClusterLayer object.
         *
         */
        BingMapService.prototype.CreateClusterLayer = /**
         * Creates a Bing map cluster layer within the map context
         *
         * \@memberof BingMapService
         * @param {?} options - Options for the layer. See {\@link IClusterOptions}.
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.ClusterLayer object.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    var /** @type {?} */ p = new Promise(function (resolve) {
                        _this.LoadModule('Microsoft.Maps.Clustering', function () {
                            var /** @type {?} */ o = BingConversions.TranslateClusterOptions(options);
                            var /** @type {?} */ layer = new Microsoft.Maps.ClusterLayer(new Array(), o);
                            var /** @type {?} */ bl;
                            map.layers.insert(layer);
                            bl = new BingClusterLayer(layer, _this);
                            bl.SetOptions(options);
                            resolve(bl);
                        });
                    });
                    return p;
                });
            };
        /**
         * Creates an information window for a map position
         *
         * \@memberof BingMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.
         *
         */
        BingMapService.prototype.CreateInfoWindow = /**
         * Creates an information window for a map position
         *
         * \@memberof BingMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.
         *
         */
            function (options) {
                return this._map.then(function (map) {
                    var /** @type {?} */ loc;
                    if (options.position == null) {
                        loc = map.getCenter();
                    }
                    else {
                        loc = new Microsoft.Maps.Location(options.position.latitude, options.position.longitude);
                    }
                    var /** @type {?} */ infoBox = new Microsoft.Maps.Infobox(loc, BingConversions.TranslateInfoBoxOptions(options));
                    infoBox.setMap(map);
                    return new BingInfoWindow(infoBox);
                });
            };
        /**
         * Creates a map layer within the map context
         *
         * \@memberof BingMapService
         * @param {?} options - Options for the layer. See {\@link ILayerOptions}
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.Layer object.
         *
         */
        BingMapService.prototype.CreateLayer = /**
         * Creates a map layer within the map context
         *
         * \@memberof BingMapService
         * @param {?} options - Options for the layer. See {\@link ILayerOptions}
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.Layer object.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    var /** @type {?} */ layer = new Microsoft.Maps.Layer(options.id.toString());
                    map.layers.insert(layer);
                    return new BingLayer(layer, _this);
                });
            };
        /**
         * Creates a map instance
         *
         * \@memberof BingMapService
         * @param {?} el - HTML element to host the map.
         * @param {?} mapOptions - Map options
         * @return {?} - Promise fullfilled once the map has been created.
         *
         */
        BingMapService.prototype.CreateMap = /**
         * Creates a map instance
         *
         * \@memberof BingMapService
         * @param {?} el - HTML element to host the map.
         * @param {?} mapOptions - Map options
         * @return {?} - Promise fullfilled once the map has been created.
         *
         */
            function (el, mapOptions) {
                var _this = this;
                return this._loader.Load().then(function () {
                    // apply mixins
                    MixinMapLabelWithOverlayView();
                    MixinCanvasOverlay();
                    // map startup...
                    if (_this._mapInstance != null) {
                        _this.DisposeMap();
                    }
                    var /** @type {?} */ o = BingConversions.TranslateLoadOptions(mapOptions);
                    if (!o.credentials) {
                        o.credentials = _this._config.apiKey;
                    }
                    var /** @type {?} */ map = new Microsoft.Maps.Map(el, o);
                    _this._mapInstance = map;
                    _this._mapResolver(map);
                });
            };
        /**
         * Creates a Bing map marker within the map context
         *
         * \@memberof BingMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.
         *
         */
        BingMapService.prototype.CreateMarker = /**
         * Creates a Bing map marker within the map context
         *
         * \@memberof BingMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.
         *
         */
            function (options) {
                if (options === void 0) {
                    options = /** @type {?} */ ({});
                }
                var /** @type {?} */ payload = function (icon, map) {
                    var /** @type {?} */ loc = BingConversions.TranslateLocation(options.position);
                    var /** @type {?} */ o = BingConversions.TranslateMarkerOptions(options);
                    if (icon && icon !== '') {
                        o.icon = icon;
                    }
                    var /** @type {?} */ pushpin = new Microsoft.Maps.Pushpin(loc, o);
                    var /** @type {?} */ marker = new BingMarker(pushpin, map, null);
                    if (options.metadata) {
                        options.metadata.forEach(function (v, k) { return marker.Metadata.set(k, v); });
                    }
                    map.entities.push(pushpin);
                    return marker;
                };
                return this._map.then(function (map) {
                    if (options.iconInfo && options.iconInfo.markerType) {
                        var /** @type {?} */ s = Marker.CreateMarker(options.iconInfo);
                        if (typeof (s) === 'string') {
                            return (payload(s, map));
                        }
                        else {
                            return s.then(function (x) {
                                return (payload(x.icon, map));
                            });
                        }
                    }
                    else {
                        return (payload(null, map));
                    }
                });
            };
        /**
         * Creates a polygon within the Bing Maps V8 map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polygon. See {\@link IPolygonOptions}.
         * @return {?} - Promise of a {\@link Polygon} object, which models the underlying native polygon.
         *
         */
        BingMapService.prototype.CreatePolygon = /**
         * Creates a polygon within the Bing Maps V8 map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polygon. See {\@link IPolygonOptions}.
         * @return {?} - Promise of a {\@link Polygon} object, which models the underlying native polygon.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    var /** @type {?} */ locs = BingConversions.TranslatePaths(options.paths);
                    var /** @type {?} */ o = BingConversions.TranslatePolygonOptions(options);
                    var /** @type {?} */ poly = new Microsoft.Maps.Polygon(locs, o);
                    map.entities.push(poly);
                    var /** @type {?} */ p = new BingPolygon(poly, _this, null);
                    if (options.metadata) {
                        options.metadata.forEach(function (v, k) { return p.Metadata.set(k, v); });
                    }
                    if (options.title && options.title !== '') {
                        p.Title = options.title;
                    }
                    if (options.showLabel != null) {
                        p.ShowLabel = options.showLabel;
                    }
                    if (options.showTooltip != null) {
                        p.ShowTooltip = options.showTooltip;
                    }
                    if (options.labelMaxZoom != null) {
                        p.LabelMaxZoom = options.labelMaxZoom;
                    }
                    if (options.labelMinZoom != null) {
                        p.LabelMinZoom = options.labelMinZoom;
                    }
                    if (options.editable) {
                        p.SetEditable(options.editable);
                    }
                    return p;
                });
            };
        /**
         * Creates a polyline within the Bing Maps V8 map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polyline. See {\@link IPolylineOptions}.
         * @return {?} - Promise of a {\@link Polyline} object (or an array thereof for complex paths),
         * which models the underlying native polygon.
         *
         */
        BingMapService.prototype.CreatePolyline = /**
         * Creates a polyline within the Bing Maps V8 map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polyline. See {\@link IPolylineOptions}.
         * @return {?} - Promise of a {\@link Polyline} object (or an array thereof for complex paths),
         * which models the underlying native polygon.
         *
         */
            function (options) {
                var /** @type {?} */ polyline;
                return this._map.then(function (map) {
                    var /** @type {?} */ o = BingConversions.TranslatePolylineOptions(options);
                    var /** @type {?} */ locs = BingConversions.TranslatePaths(options.path);
                    if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {
                        polyline = new Microsoft.Maps.Polyline(locs[0], o);
                        map.entities.push(polyline);
                        var /** @type {?} */ pl_1 = new BingPolyline(polyline, map, null);
                        if (options.metadata) {
                            options.metadata.forEach(function (v, k) { return pl_1.Metadata.set(k, v); });
                        }
                        if (options.title && options.title !== '') {
                            pl_1.Title = options.title;
                        }
                        if (options.showTooltip != null) {
                            pl_1.ShowTooltip = options.showTooltip;
                        }
                        return pl_1;
                    }
                    else {
                        var /** @type {?} */ lines_1 = new Array();
                        locs.forEach(function (p) {
                            polyline = new Microsoft.Maps.Polyline(p, o);
                            map.entities.push(polyline);
                            var /** @type {?} */ pl = new BingPolyline(polyline, map, null);
                            if (options.metadata) {
                                options.metadata.forEach(function (v, k) { return pl.Metadata.set(k, v); });
                            }
                            if (options.title && options.title !== '') {
                                pl.Title = options.title;
                            }
                            if (options.showTooltip != null) {
                                pl.ShowTooltip = options.showTooltip;
                            }
                            lines_1.push(pl);
                        });
                        return lines_1;
                    }
                });
            };
        /**
         * Deletes a layer from the map.
         *
         * \@memberof BingMapService
         * @param {?} layer - Layer to delete. See {\@link Layer}. This method expects the Bing specific Layer model implementation.
         * @return {?} - Promise fullfilled when the layer has been removed.
         *
         */
        BingMapService.prototype.DeleteLayer = /**
         * Deletes a layer from the map.
         *
         * \@memberof BingMapService
         * @param {?} layer - Layer to delete. See {\@link Layer}. This method expects the Bing specific Layer model implementation.
         * @return {?} - Promise fullfilled when the layer has been removed.
         *
         */
            function (layer) {
                return this._map.then(function (map) {
                    map.layers.remove(layer.NativePrimitve);
                });
            };
        /**
         * Dispaose the map and associated resoures.
         *
         * \@memberof BingMapService
         * @return {?}
         */
        BingMapService.prototype.DisposeMap = /**
         * Dispaose the map and associated resoures.
         *
         * \@memberof BingMapService
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._map == null && this._mapInstance == null) {
                    return;
                }
                if (this._mapInstance != null) {
                    this._mapInstance.dispose();
                    this._mapInstance = null;
                    this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
                }
            };
        /**
         * Gets the geo coordinates of the map center
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the center. See {\@link ILatLong}.
         *
         */
        BingMapService.prototype.GetCenter = /**
         * Gets the geo coordinates of the map center
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the center. See {\@link ILatLong}.
         *
         */
            function () {
                return this._map.then(function (map) {
                    var /** @type {?} */ center = map.getCenter();
                    return /** @type {?} */ ({
                        latitude: center.latitude,
                        longitude: center.longitude
                    });
                });
            };
        /**
         * Gets the geo coordinates of the map bounding box
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the bounding box. See {\@link IBox}.
         *
         */
        BingMapService.prototype.GetBounds = /**
         * Gets the geo coordinates of the map bounding box
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the bounding box. See {\@link IBox}.
         *
         */
            function () {
                return this._map.then(function (map) {
                    var /** @type {?} */ box = map.getBounds();
                    return /** @type {?} */ ({
                        maxLatitude: box.getNorth(),
                        maxLongitude: box.crossesInternationalDateLine() ? box.getWest() : box.getEast(),
                        minLatitude: box.getSouth(),
                        minLongitude: box.crossesInternationalDateLine() ? box.getEast() : box.getWest(),
                        center: { latitude: box.center.latitude, longitude: box.center.longitude },
                        padding: 0
                    });
                });
            };
        /**
         * Gets a shared or private instance of the map drawing tools.
         *
         * \@memberof BingMapService
         * @param {?=} useSharedInstance
         * @return {?} - Promise that when resolved containst an instance of the drawing tools.
         */
        BingMapService.prototype.GetDrawingTools = /**
         * Gets a shared or private instance of the map drawing tools.
         *
         * \@memberof BingMapService
         * @param {?=} useSharedInstance
         * @return {?} - Promise that when resolved containst an instance of the drawing tools.
         */
            function (useSharedInstance) {
                var _this = this;
                if (useSharedInstance === void 0) {
                    useSharedInstance = true;
                }
                return new Promise(function (resolve, reject) {
                    _this.LoadModuleInstance('Microsoft.Maps.DrawingTools', useSharedInstance).then(function (o) {
                        resolve(o);
                    });
                });
            };
        /**
         * Gets the current zoom level of the map.
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the zoom level.
         *
         */
        BingMapService.prototype.GetZoom = /**
         * Gets the current zoom level of the map.
         *
         * \@memberof BingMapService
         * @return {?} - A promise that when fullfilled contains the zoom level.
         *
         */
            function () {
                return this._map.then(function (map) { return map.getZoom(); });
            };
        /**
         * Loads a module into the Map.
         *
         * \@method
         * \@memberof BingMapService
         * @param {?} moduleName - The module to load.
         * @param {?} callback - Callback to call once loading is complete.
         * @return {?}
         */
        BingMapService.prototype.LoadModule = /**
         * Loads a module into the Map.
         *
         * \@method
         * \@memberof BingMapService
         * @param {?} moduleName - The module to load.
         * @param {?} callback - Callback to call once loading is complete.
         * @return {?}
         */
            function (moduleName, callback) {
                var _this = this;
                if (this._modules.has(moduleName)) {
                    callback();
                }
                else {
                    Microsoft.Maps.loadModule(moduleName, function () {
                        _this._modules.set(moduleName, null);
                        callback();
                    });
                }
            };
        /**
         * Loads a module into the Map and delivers and instance of the module payload.
         *
         * \@method
         * \@memberof BingMapService
         * @param {?} moduleName - The module to load.
         * @param {?=} useSharedInstance
         * @return {?}
         */
        BingMapService.prototype.LoadModuleInstance = /**
         * Loads a module into the Map and delivers and instance of the module payload.
         *
         * \@method
         * \@memberof BingMapService
         * @param {?} moduleName - The module to load.
         * @param {?=} useSharedInstance
         * @return {?}
         */
            function (moduleName, useSharedInstance) {
                var _this = this;
                if (useSharedInstance === void 0) {
                    useSharedInstance = true;
                }
                var /** @type {?} */ s = moduleName.substr(moduleName.lastIndexOf('.') + 1);
                if (this._modules.has(moduleName)) {
                    var /** @type {?} */ o = null;
                    if (!useSharedInstance) {
                        o = new ((Microsoft.Maps))[s](this._mapInstance);
                    }
                    else if (this._modules.get(moduleName) != null) {
                        o = this._modules.get(moduleName);
                    }
                    else {
                        o = new ((Microsoft.Maps))[s](this._mapInstance);
                        this._modules.set(moduleName, o);
                    }
                    return Promise.resolve(o);
                }
                else {
                    return new Promise(function (resolve, reject) {
                        try {
                            Microsoft.Maps.loadModule(moduleName, function () {
                                var /** @type {?} */ o = new ((Microsoft.Maps))[s](_this._mapInstance);
                                if (useSharedInstance) {
                                    _this._modules.set(moduleName, o);
                                }
                                else {
                                    _this._modules.set(moduleName, null);
                                }
                                resolve(o);
                            });
                        }
                        catch (e) {
                            reject('Could not load module or create instance.');
                        }
                    });
                }
            };
        /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} loc - The geo coordinates to translate.
         * @return {?} - Promise of an {\@link IPoint} interface representing the pixels. This promise resolves to null
         * if the goe coordinates are not in the view port.
         *
         */
        BingMapService.prototype.LocationToPoint = /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} loc - The geo coordinates to translate.
         * @return {?} - Promise of an {\@link IPoint} interface representing the pixels. This promise resolves to null
         * if the goe coordinates are not in the view port.
         *
         */
            function (loc) {
                return this._map.then(function (m) {
                    var /** @type {?} */ l = BingConversions.TranslateLocation(loc);
                    var /** @type {?} */ p = (m.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control));
                    if (p != null) {
                        return { x: p.x, y: p.y };
                    }
                    return null;
                });
            };
        /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} locs
         * @return {?} - Promise of an {\@link IPoint} interface array representing the pixels.
         *
         */
        BingMapService.prototype.LocationsToPoints = /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} locs
         * @return {?} - Promise of an {\@link IPoint} interface array representing the pixels.
         *
         */
            function (locs) {
                return this._map.then(function (m) {
                    var /** @type {?} */ l = locs.map(function (loc) { return BingConversions.TranslateLocation(loc); });
                    var /** @type {?} */ p = (m.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control));
                    return p ? p : new Array();
                });
            };
        /**
         * Centers the map on a geo location.
         *
         * \@memberof BingMapService
         * @param {?} latLng - GeoCoordinates around which to center the map. See {\@link ILatLong}
         * @return {?} - Promise that is fullfilled when the center operations has been completed.
         *
         */
        BingMapService.prototype.SetCenter = /**
         * Centers the map on a geo location.
         *
         * \@memberof BingMapService
         * @param {?} latLng - GeoCoordinates around which to center the map. See {\@link ILatLong}
         * @return {?} - Promise that is fullfilled when the center operations has been completed.
         *
         */
            function (latLng) {
                return this._map.then(function (map) {
                    return map.setView({
                        center: BingConversions.TranslateLocation(latLng)
                    });
                });
            };
        /**
         * Sets the generic map options.
         *
         * \@memberof BingMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
        BingMapService.prototype.SetMapOptions = /**
         * Sets the generic map options.
         *
         * \@memberof BingMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
            function (options) {
                this._map.then(function (m) {
                    var /** @type {?} */ o = BingConversions.TranslateOptions(options);
                    m.setOptions(o);
                });
            };
        /**
         * Sets the view options of the map.
         *
         * \@memberof BingMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
        BingMapService.prototype.SetViewOptions = /**
         * Sets the view options of the map.
         *
         * \@memberof BingMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
            function (options) {
                this._map.then(function (m) {
                    var /** @type {?} */ o = BingConversions.TranslateViewOptions(options);
                    m.setView(o);
                });
            };
        /**
         * Sets the zoom level of the map.
         *
         * \@memberof BingMapService
         * @param {?} zoom - Zoom level to set.
         * @return {?} - A Promise that is fullfilled once the zoom operation is complete.
         *
         */
        BingMapService.prototype.SetZoom = /**
         * Sets the zoom level of the map.
         *
         * \@memberof BingMapService
         * @param {?} zoom - Zoom level to set.
         * @return {?} - A Promise that is fullfilled once the zoom operation is complete.
         *
         */
            function (zoom) {
                return this._map.then(function (map) {
                    return map.setView({
                        zoom: zoom
                    });
                });
            };
        /**
         * Creates an event subscription
         *
         * \@memberof BingMapService
         * @template E
         * @param {?} eventName - The name of the event (e.g. 'click')
         * @return {?} - An observable of tpye E that fires when the event occurs.
         *
         */
        BingMapService.prototype.SubscribeToMapEvent = /**
         * Creates an event subscription
         *
         * \@memberof BingMapService
         * @template E
         * @param {?} eventName - The name of the event (e.g. 'click')
         * @return {?} - An observable of tpye E that fires when the event occurs.
         *
         */
            function (eventName) {
                var _this = this;
                var /** @type {?} */ eventNameTranslated = BingMapEventsLookup[eventName];
                return rxjs.Observable.create(function (observer) {
                    _this._map.then(function (m) {
                        Microsoft.Maps.Events.addHandler(m, eventNameTranslated, function (e) {
                            _this._zone.run(function () { return observer.next(e); });
                        });
                    });
                });
            };
        /**
         * Triggers the given event name on the map instance.
         *
         * \@memberof BingMapService
         * @param {?} eventName - Event to trigger.
         * @return {?} - A promise that is fullfilled once the event is triggered.
         *
         */
        BingMapService.prototype.TriggerMapEvent = /**
         * Triggers the given event name on the map instance.
         *
         * \@memberof BingMapService
         * @param {?} eventName - Event to trigger.
         * @return {?} - A promise that is fullfilled once the event is triggered.
         *
         */
            function (eventName) {
                return this._map.then(function (m) { return Microsoft.Maps.Events.invoke(m, eventName, null); });
            };
        BingMapService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingMapService.ctorParameters = function () {
            return [
                { type: MapAPILoader },
                { type: core.NgZone }
            ];
        };
        return BingMapService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This abstract partially implements the contract for the {\@link LayerService}
     * and {\@link ClusterService} for the Bing Maps V8 archtiecture. It serves
     * as the base class for basic layer ({\@link BingLayerService}) and cluster layer ({\@link BingClusterLayer}).
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * This abstract partially implements the contract for the {\@link LayerService}
     * and {\@link ClusterService} for the Bing Maps V8 archtiecture. It serves
     * as the base class for basic layer ({\@link BingLayerService}) and cluster layer ({\@link BingClusterLayer}).
     *
     * @export
     * @abstract
     * @abstract
     */ BingLayerBase = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingLayerBase.
         * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.
         *
         * @memberof BingLayerBase
         */
        function BingLayerBase(_mapService, _zone) {
            this._mapService = _mapService;
            this._zone = _zone;
            this._layers = new Map();
        }
        /**
         * Creates a marker in the layer.
         *
         * \@memberof BingLayerBase
         * @param {?} layer - The Id of the layer in which to create the marker.
         * @param {?} options - {\@link IMarkerOptions} object containing the marker properties.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} model for the created marker.
         *
         */
        BingLayerBase.prototype.CreateMarker = /**
         * Creates a marker in the layer.
         *
         * \@memberof BingLayerBase
         * @param {?} layer - The Id of the layer in which to create the marker.
         * @param {?} options - {\@link IMarkerOptions} object containing the marker properties.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} model for the created marker.
         *
         */
            function (layer, options) {
                var /** @type {?} */ payload = function (icon, l) {
                    var /** @type {?} */ loc = BingConversions.TranslateLocation(options.position);
                    var /** @type {?} */ o = BingConversions.TranslateMarkerOptions(options);
                    if (icon && icon !== '') {
                        o.icon = icon;
                    }
                    var /** @type {?} */ pushpin = new Microsoft.Maps.Pushpin(loc, o);
                    var /** @type {?} */ marker = new BingMarker(pushpin, null, l.NativePrimitve);
                    marker.IsFirst = options.isFirst;
                    marker.IsLast = options.isLast;
                    if (options.metadata) {
                        options.metadata.forEach(function (v, k) { return marker.Metadata.set(k, v); });
                    }
                    l.AddEntity(marker);
                    return marker;
                };
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    if (options.iconInfo && options.iconInfo.markerType) {
                        var /** @type {?} */ s = Marker.CreateMarker(options.iconInfo);
                        if (typeof (s) === 'string') {
                            return (payload(s, l));
                        }
                        else {
                            return s.then(function (x) {
                                return (payload(x.icon, l));
                            });
                        }
                    }
                    else {
                        return (payload(null, l));
                    }
                });
            };
        /**
         * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk
         * operations.
         *
         * \@memberof BingLayerBase
         * @param {?} options - Marker options defining the markers.
         * @param {?=} markerIcon - Optional information to generate custom markers. This will be applied to all markers.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Marker models.
         *
         */
        BingLayerBase.prototype.CreateMarkers = /**
         * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk
         * operations.
         *
         * \@memberof BingLayerBase
         * @param {?} options - Marker options defining the markers.
         * @param {?=} markerIcon - Optional information to generate custom markers. This will be applied to all markers.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Marker models.
         *
         */
            function (options, markerIcon) {
                var /** @type {?} */ payload = function (icon, op) {
                    var /** @type {?} */ markers = op.map(function (mo) {
                        var /** @type {?} */ s;
                        var /** @type {?} */ o = BingConversions.TranslateMarkerOptions(mo);
                        if (icon && icon !== '') {
                            s = icon;
                        }
                        else if (o.icon) {
                            s = o.icon;
                        }
                        if (o.icon) {
                            delete o.icon;
                        }
                        var /** @type {?} */ loc = BingConversions.TranslateLocation(mo.position);
                        var /** @type {?} */ pushpin = new Microsoft.Maps.Pushpin(loc, o);
                        var /** @type {?} */ img = Marker.GetImageForMarker(s);
                        if (img != null) {
                            ((pushpin)).image = img;
                        }
                        var /** @type {?} */ marker = new BingMarker(pushpin, null, null);
                        marker.IsFirst = mo.isFirst;
                        marker.IsLast = mo.isLast;
                        if (mo.metadata) {
                            mo.metadata.forEach(function (v, k) { return marker.Metadata.set(k, v); });
                        }
                        return marker;
                    });
                    return markers;
                };
                var /** @type {?} */ p = new Promise(function (resolve, reject) {
                    if (markerIcon && markerIcon.markerType) {
                        var /** @type {?} */ s = Marker.CreateMarker(markerIcon);
                        if (typeof (s) === 'string') {
                            resolve(payload(s, options));
                        }
                        else {
                            return s.then(function (x) {
                                resolve(payload(x.icon, options));
                            });
                        }
                    }
                    else {
                        resolve(payload(null, options));
                    }
                });
                return p;
            };
        /**
         * Deletes the layer
         *
         * \@memberof BingLayerBase
         * @param {?} layer - MapLayerDirective component object for which to retrieve the layer.
         * @return {?} - A promise that is fullfilled when the layer has been removed.
         *
         */
        BingLayerBase.prototype.DeleteLayer = /**
         * Deletes the layer
         *
         * \@memberof BingLayerBase
         * @param {?} layer - MapLayerDirective component object for which to retrieve the layer.
         * @return {?} - A promise that is fullfilled when the layer has been removed.
         *
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ l = this._layers.get(layer.Id);
                if (l == null) {
                    return Promise.resolve();
                }
                return l.then(function (l1) {
                    return _this._zone.run(function () {
                        l1.Delete();
                        _this._layers.delete(layer.Id);
                    });
                });
            };
        /**
         * Returns the Layer model represented by this layer.
         *
         * \@memberof BingLayerBase
         * @param {?} layer - MapLayerDirective component object or Layer Id for which to retrieve the layer model.
         * @return {?} - A promise that when resolved contains the Layer model.
         *
         */
        BingLayerBase.prototype.GetNativeLayer = /**
         * Returns the Layer model represented by this layer.
         *
         * \@memberof BingLayerBase
         * @param {?} layer - MapLayerDirective component object or Layer Id for which to retrieve the layer model.
         * @return {?} - A promise that when resolved contains the Layer model.
         *
         */
            function (layer) {
                var /** @type {?} */ p = null;
                if (typeof (layer) === 'number') {
                    p = this._layers.get(layer);
                }
                else {
                    p = this._layers.get(((layer)).Id);
                }
                return p;
            };
        ///
        /// Protected methods
        ///
        /**
         * Gets the layer based on its id.
         *
         * @protected
         * @param id - Layer Id.
         * @returns - A promise that when fullfilled contains the {@link Layer} model for the layer.
         *
         * @memberof BingLayerBase
         */
        /**
         * Gets the layer based on its id.
         *
         * @protected
         * \@memberof BingLayerBase
         * @param {?} id - Layer Id.
         * @return {?} - A promise that when fullfilled contains the {\@link Layer} model for the layer.
         *
         */
        BingLayerBase.prototype.GetLayerById = /**
         * Gets the layer based on its id.
         *
         * @protected
         * \@memberof BingLayerBase
         * @param {?} id - Layer Id.
         * @return {?} - A promise that when fullfilled contains the {\@link Layer} model for the layer.
         *
         */
            function (id) {
                var /** @type {?} */ p;
                this._layers.forEach(function (l, k) {
                    if (k === id) {
                        p = l;
                    }
                });
                return p;
            };
        return BingLayerBase;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements the {\@link LayerService} contract for a  Bing Maps V8 specific implementation.
     *
     * @export
     */
    var BingLayerService = (function (_super) {
        __extends(BingLayerService, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingLayerService.
         * @param _mapService - Instance of the Bing Maps Service. Will generally be injected.
         * @param _zone - NgZone instance to provide zone aware promises.
         *
         * @memberof BingLayerService
         */
        function BingLayerService(_mapService, _zone) {
            return _super.call(this, _mapService, _zone) || this;
        }
        /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - MapLayerDirective component object.
         * Generally, MapLayerDirective will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
        BingLayerService.prototype.AddLayer = /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - MapLayerDirective component object.
         * Generally, MapLayerDirective will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
            function (layer) {
                var /** @type {?} */ layerPromise = this._mapService.CreateLayer({ id: layer.Id });
                this._layers.set(layer.Id, layerPromise);
                layerPromise.then(function (l) { return l.SetVisible(layer.Visible); });
            };
        /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
        BingLayerService.prototype.CreatePolygon = /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
            function (layer, options) {
                var _this = this;
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    var /** @type {?} */ locs = BingConversions.TranslatePaths(options.paths);
                    var /** @type {?} */ o = BingConversions.TranslatePolygonOptions(options);
                    var /** @type {?} */ poly = new Microsoft.Maps.Polygon(locs, o);
                    var /** @type {?} */ polygon = new BingPolygon(poly, /** @type {?} */ (_this._mapService), l.NativePrimitve);
                    if (options.metadata) {
                        options.metadata.forEach(function (v, k) { return polygon.Metadata.set(k, v); });
                    }
                    if (options.title && options.title !== '') {
                        polygon.Title = options.title;
                    }
                    if (options.showLabel != null) {
                        polygon.ShowLabel = options.showLabel;
                    }
                    if (options.showTooltip != null) {
                        polygon.ShowTooltip = options.showTooltip;
                    }
                    if (options.labelMaxZoom != null) {
                        polygon.LabelMaxZoom = options.labelMaxZoom;
                    }
                    if (options.labelMinZoom != null) {
                        polygon.LabelMinZoom = options.labelMinZoom;
                    }
                    l.AddEntity(polygon);
                    return polygon;
                });
            };
        /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
        BingLayerService.prototype.CreatePolygons = /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
            function (layer, options) {
                var _this = this;
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    var /** @type {?} */ polygons = new Promise(function (resolve, reject) {
                        var /** @type {?} */ polys = options.map(function (o) {
                            var /** @type {?} */ locs = BingConversions.TranslatePaths(o.paths);
                            var /** @type {?} */ op = BingConversions.TranslatePolygonOptions(o);
                            var /** @type {?} */ poly = new Microsoft.Maps.Polygon(locs, op);
                            var /** @type {?} */ polygon = new BingPolygon(poly, /** @type {?} */ (_this._mapService), l.NativePrimitve);
                            if (o.title && o.title !== '') {
                                polygon.Title = o.title;
                            }
                            if (o.metadata) {
                                o.metadata.forEach(function (v, k) { return polygon.Metadata.set(k, v); });
                            }
                            return polygon;
                        });
                        resolve(polys);
                    });
                    return polygons;
                });
            };
        /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
        BingLayerService.prototype.CreatePolyline = /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
            function (layer, options) {
                var _this = this;
                var /** @type {?} */ p = this.GetLayerById(layer);
                var /** @type {?} */ polyline;
                var /** @type {?} */ line;
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    var /** @type {?} */ locs = BingConversions.TranslatePaths(options.path);
                    var /** @type {?} */ o = BingConversions.TranslatePolylineOptions(options);
                    if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {
                        polyline = new Microsoft.Maps.Polyline(locs[0], o);
                        line = new BingPolyline(polyline, _this._mapService.MapInstance, l.NativePrimitve);
                        l.AddEntity(line);
                        if (options.metadata) {
                            options.metadata.forEach(function (v, k) { return line.Metadata.set(k, v); });
                        }
                        if (options.title && options.title !== '') {
                            line.Title = options.title;
                        }
                        if (options.showTooltip != null) {
                            line.ShowTooltip = options.showTooltip;
                        }
                        return line;
                    }
                    else {
                        var /** @type {?} */ lines_1 = new Array();
                        locs.forEach(function (x) {
                            polyline = new Microsoft.Maps.Polyline(x, o);
                            line = new BingPolyline(polyline, _this._mapService.MapInstance, l.NativePrimitve);
                            l.AddEntity(line);
                            if (options.metadata) {
                                options.metadata.forEach(function (v, k) { return line.Metadata.set(k, v); });
                            }
                            if (options.title && options.title !== '') {
                                line.Title = options.title;
                            }
                            if (options.showTooltip != null) {
                                line.ShowTooltip = options.showTooltip;
                            }
                            lines_1.push(line);
                        });
                        return lines_1;
                    }
                });
            };
        /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
        BingLayerService.prototype.CreatePolylines = /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof BingLayerService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
            function (layer, options) {
                var _this = this;
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    var /** @type {?} */ polylines = new Promise(function (resolve, reject) {
                        var /** @type {?} */ polys = options.map(function (o) {
                            var /** @type {?} */ locs = BingConversions.TranslatePaths(o.path);
                            var /** @type {?} */ op = BingConversions.TranslatePolylineOptions(o);
                            if (locs && locs.length > 0 && !Array.isArray(locs[0])) {
                                var /** @type {?} */ poly = new Microsoft.Maps.Polyline(locs[0], op);
                                var /** @type {?} */ polyline_1 = new BingPolyline(poly, _this._mapService.MapInstance, l.NativePrimitve);
                                if (o.title && o.title !== '') {
                                    polyline_1.Title = o.title;
                                }
                                if (o.metadata) {
                                    o.metadata.forEach(function (v, k) { return polyline_1.Metadata.set(k, v); });
                                }
                                return polyline_1;
                            }
                            else {
                                var /** @type {?} */ lines_2 = new Array();
                                locs.forEach(function (x) {
                                    var /** @type {?} */ poly = new Microsoft.Maps.Polyline(x, op);
                                    var /** @type {?} */ polyline = new BingPolyline(poly, _this._mapService.MapInstance, l.NativePrimitve);
                                    if (o.metadata) {
                                        o.metadata.forEach(function (v, k) { return polyline.Metadata.set(k, v); });
                                    }
                                    if (o.title && o.title !== '') {
                                        polyline.Title = o.title;
                                    }
                                    lines_2.push(polyline);
                                });
                                return lines_2;
                            }
                        });
                        resolve(polys);
                    });
                    return polylines;
                });
            };
        BingLayerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingLayerService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return BingLayerService;
    }(BingLayerBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements the {\@link ClusterService} contract for a  Bing Maps V8 specific implementation.
     *
     * @export
     */
    var BingClusterService = (function (_super) {
        __extends(BingClusterService, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingClusterService.
         * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.
         * @param _zone - NgZone instance to provide zone aware promises.
         *
         * @memberof BingClusterService
         */
        function BingClusterService(_mapService, _zone) {
            return _super.call(this, _mapService, _zone) || this;
        }
        /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object.
         * Generally, MapLayer will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
        BingClusterService.prototype.AddLayer = /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object.
         * Generally, MapLayer will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ options = {
                    id: layer.Id,
                    visible: layer.Visible,
                    clusteringEnabled: layer.ClusteringEnabled,
                    placementMode: layer.ClusterPlacementMode
                };
                if (layer.GridSize) {
                    options.gridSize = layer.GridSize;
                }
                if (layer.LayerOffset) {
                    options.layerOffset = layer.LayerOffset;
                }
                if (layer.ZIndex) {
                    options.zIndex = layer.ZIndex;
                }
                if (layer.IconInfo) {
                    options.clusteredPinCallback = function (pin) { _this.CreateClusterPushPin(pin, layer); };
                }
                if (layer.CustomMarkerCallback) {
                    options.clusteredPinCallback = function (pin) { _this.CreateCustomClusterPushPin(pin, layer); };
                }
                if (layer.SpiderClusterOptions) {
                    options.spiderClusterOptions = layer.SpiderClusterOptions;
                }
                var /** @type {?} */ layerPromise = this._mapService.CreateClusterLayer(options);
                ((this._mapService)).MapPromise.then(function (m) {
                    Microsoft.Maps.Events.addHandler(m, 'viewchangeend', function (e) {
                        if (layer.ClusteringEnabled && m.getZoom() === 19) {
                            layerPromise.then(function (l) {
                                l.SetOptions({ id: layer.Id, clusteringEnabled: false });
                            });
                        }
                        if (layer.ClusteringEnabled && m.getZoom() < 19) {
                            layerPromise.then(function (l) {
                                if (!l.GetOptions().clusteringEnabled) {
                                    l.SetOptions({ id: layer.Id, clusteringEnabled: true });
                                }
                            });
                        }
                    });
                });
                this._layers.set(layer.Id, layerPromise);
            };
        /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
        BingClusterService.prototype.CreatePolygon = /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
            function (layer, options) {
                throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
        BingClusterService.prototype.CreatePolygons = /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
            function (layer, options) {
                throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
        BingClusterService.prototype.CreatePolyline = /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
            function (layer, options) {
                throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
        BingClusterService.prototype.CreatePolylines = /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof BingClusterService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
            function (layer, options) {
                throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object for which to retrieve the layer.
         *
         * @return {?}
         */
        BingClusterService.prototype.StartClustering = /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object for which to retrieve the layer.
         *
         * @return {?}
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ l = this._layers.get(layer.Id);
                if (l == null) {
                    return Promise.resolve();
                }
                return l.then(function (l1) {
                    return _this._zone.run(function () {
                        l1.StartClustering();
                    });
                });
            };
        /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object for which to retrieve the layer.
         *
         * @return {?}
         */
        BingClusterService.prototype.StopClustering = /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof BingClusterService
         * @param {?} layer - ClusterLayerDirective component object for which to retrieve the layer.
         *
         * @return {?}
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ l = this._layers.get(layer.Id);
                if (l == null) {
                    return Promise.resolve();
                }
                return l.then(function (l1) {
                    return _this._zone.run(function () {
                        l1.StopClustering();
                    });
                });
            };
        /**
         * Creates the default cluster pushpin as a callback from BingMaps when clustering occurs. The {\@link ClusterLayerDirective} model
         * can provide an IconInfo property that would govern the apparenace of the pin. This method will assign the same pin to all
         * clusters in the layer.
         *
         * \@memberof BingClusterService
         * @param {?} cluster - The cluster for which to create the pushpin.
         * @param {?} layer - The {\@link ClusterLayerDirective} component representing the layer.
         *
         * @return {?}
         */
        BingClusterService.prototype.CreateClusterPushPin = /**
         * Creates the default cluster pushpin as a callback from BingMaps when clustering occurs. The {\@link ClusterLayerDirective} model
         * can provide an IconInfo property that would govern the apparenace of the pin. This method will assign the same pin to all
         * clusters in the layer.
         *
         * \@memberof BingClusterService
         * @param {?} cluster - The cluster for which to create the pushpin.
         * @param {?} layer - The {\@link ClusterLayerDirective} component representing the layer.
         *
         * @return {?}
         */
            function (cluster, layer) {
                var _this = this;
                this._layers.get(layer.Id).then(function (l) {
                    if (layer.IconInfo) {
                        var /** @type {?} */ o_1 = {};
                        var /** @type {?} */ payload_1 = function (ico, info) {
                            o_1.icon = ico;
                            o_1.anchor = new Microsoft.Maps.Point((info.size && info.markerOffsetRatio) ? (info.size.width * info.markerOffsetRatio.x) : 0, (info.size && info.markerOffsetRatio) ? (info.size.height * info.markerOffsetRatio.y) : 0);
                            cluster.setOptions(o_1);
                        };
                        var /** @type {?} */ icon = Marker.CreateMarker(layer.IconInfo);
                        if (typeof (icon) === 'string') {
                            payload_1(icon, layer.IconInfo);
                        }
                        else {
                            icon.then(function (x) {
                                payload_1(x.icon, x.iconInfo);
                            });
                        }
                    }
                    if (layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster) {
                        Microsoft.Maps.Events.addHandler(cluster, 'click', function (e) { return _this.ZoomIntoCluster(e); });
                    }
                    if (layer.ClusterClickAction === ClusterClickAction.Spider) {
                        Microsoft.Maps.Events.addHandler(cluster, 'dblclick', function (e) { return _this.ZoomIntoCluster(e); });
                        l.InitializeSpiderClusterSupport();
                    }
                });
            };
        /**
         * Provides a hook for consumers to provide a custom function to create cluster bins for a cluster. This is particuarily useful
         * in situation where the pin should differ to represent information about the pins in the cluster.
         *
         * \@memberof BingClusterService
         * @param {?} cluster - The cluster for which to create the pushpin.
         * @param {?} layer - The {\@link ClusterLayerDirective} component
         * representing the layer. Set the {\@link ClusterLayerDirective.CustomMarkerCallback}
         * property to define the callback generating the pin.
         *
         * @return {?}
         */
        BingClusterService.prototype.CreateCustomClusterPushPin = /**
         * Provides a hook for consumers to provide a custom function to create cluster bins for a cluster. This is particuarily useful
         * in situation where the pin should differ to represent information about the pins in the cluster.
         *
         * \@memberof BingClusterService
         * @param {?} cluster - The cluster for which to create the pushpin.
         * @param {?} layer - The {\@link ClusterLayerDirective} component
         * representing the layer. Set the {\@link ClusterLayerDirective.CustomMarkerCallback}
         * property to define the callback generating the pin.
         *
         * @return {?}
         */
            function (cluster, layer) {
                var _this = this;
                this._layers.get(layer.Id).then(function (l) {
                    // assemble markers for callback
                    var /** @type {?} */ m = new Array();
                    cluster.containedPushpins.forEach(function (p) {
                        var /** @type {?} */ marker = l.GetMarkerFromBingMarker(p);
                        if (marker) {
                            m.push(marker);
                        }
                    });
                    var /** @type {?} */ iconInfo = { markerType: MarkerTypeId.None };
                    var /** @type {?} */ o = {};
                    o.icon = layer.CustomMarkerCallback(m, iconInfo);
                    if (o.icon !== '') {
                        o.anchor = new Microsoft.Maps.Point((iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.width * iconInfo.markerOffsetRatio.x) : 0, (iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.height * iconInfo.markerOffsetRatio.y) : 0);
                        if (iconInfo.textOffset) {
                            o.textOffset = new Microsoft.Maps.Point(iconInfo.textOffset.x, iconInfo.textOffset.y);
                        }
                        cluster.setOptions(o);
                    }
                    if (layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster) {
                        Microsoft.Maps.Events.addHandler(cluster, 'click', function (e) { return _this.ZoomIntoCluster(e); });
                    }
                    if (layer.ClusterClickAction === ClusterClickAction.Spider) {
                        Microsoft.Maps.Events.addHandler(cluster, 'dblclick', function (e) { return _this.ZoomIntoCluster(e); });
                        l.InitializeSpiderClusterSupport();
                    }
                });
            };
        /**
         * Zooms into the cluster on click so that the members of the cluster comfortable fit into the zommed area.
         *
         * \@memberof BingClusterService
         * @param {?} e - Mouse Event.
         *
         * @return {?}
         */
        BingClusterService.prototype.ZoomIntoCluster = /**
         * Zooms into the cluster on click so that the members of the cluster comfortable fit into the zommed area.
         *
         * \@memberof BingClusterService
         * @param {?} e - Mouse Event.
         *
         * @return {?}
         */
            function (e) {
                var /** @type {?} */ pin = (e.target);
                if (pin && pin.containedPushpins) {
                    var /** @type {?} */ bounds_1;
                    var /** @type {?} */ locs_1 = new Array();
                    pin.containedPushpins.forEach(function (p) { return locs_1.push(p.getLocation()); });
                    bounds_1 = Microsoft.Maps.LocationRect.fromLocations(locs_1);
                    // Zoom into the bounding box of the cluster.
                    // Add a padding to compensate for the pixel area of the pushpins.
                    ((this._mapService)).MapPromise.then(function (m) {
                        m.setView({ bounds: bounds_1, padding: 75 });
                    });
                }
            };
        BingClusterService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingClusterService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return BingClusterService;
    }(BingLayerBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the Polygon Service abstract class for Bing Maps V8.
     *
     * @export
     */
    var BingPolygonService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingPolygonService.
         * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.
         * @param _layerService - {@link BingLayerService} instance.
         * The concrete {@link BingLayerService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof BingPolygonService
         */
        function BingPolygonService(_mapService, _layerService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._zone = _zone;
            this._polygons = new Map();
        }
        /**
         * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} to be added.
         *
         * @return {?}
         */
        BingPolygonService.prototype.AddPolygon = /**
         * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} to be added.
         *
         * @return {?}
         */
            function (polygon) {
                var /** @type {?} */ o = {
                    id: polygon.Id,
                    clickable: polygon.Clickable,
                    draggable: polygon.Draggable,
                    editable: polygon.Editable,
                    fillColor: polygon.FillColor,
                    fillOpacity: polygon.FillOpacity,
                    geodesic: polygon.Geodesic,
                    labelMaxZoom: polygon.LabelMaxZoom,
                    labelMinZoom: polygon.LabelMinZoom,
                    paths: polygon.Paths,
                    showLabel: polygon.ShowLabel,
                    showTooltip: polygon.ShowTooltip,
                    strokeColor: polygon.StrokeColor,
                    strokeOpacity: polygon.StrokeOpacity,
                    strokeWeight: polygon.StrokeWeight,
                    title: polygon.Title,
                    visible: polygon.Visible,
                    zIndex: polygon.zIndex,
                };
                var /** @type {?} */ polygonPromise;
                if (polygon.InCustomLayer) {
                    polygonPromise = this._layerService.CreatePolygon(polygon.LayerId, o);
                }
                else {
                    polygonPromise = this._mapService.CreatePolygon(o);
                }
                this._polygons.set(polygon, polygonPromise);
            };
        /**
         * Registers an event delegate for a polygon.
         *
         * \@memberof BingPolygonService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        BingPolygonService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a polygon.
         *
         * \@memberof BingPolygonService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, polygon) {
                var _this = this;
                var /** @type {?} */ b = new rxjs.Subject();
                if (eventName === 'mousemove') {
                    return b.asObservable();
                }
                if (eventName === 'rightclick') {
                    return b.asObservable();
                }
                return rxjs.Observable.create(function (observer) {
                    _this._polygons.get(polygon).then(function (p) {
                        p.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes a polygon.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polygon has been deleted.
         *
         */
        BingPolygonService.prototype.DeletePolygon = /**
         * Deletes a polygon.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polygon has been deleted.
         *
         */
            function (polygon) {
                var _this = this;
                var /** @type {?} */ m = this._polygons.get(polygon);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        l.Delete();
                        _this._polygons.delete(polygon);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the polygon on the click location
         *
         * @abstract
         * \@memberof BingPolygonService
         * @param {?} e - The mouse event. Expected to implement {\@link Microsoft.Maps.IMouseEventArgs}.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
        BingPolygonService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the polygon on the click location
         *
         * @abstract
         * \@memberof BingPolygonService
         * @param {?} e - The mouse event. Expected to implement {\@link Microsoft.Maps.IMouseEventArgs}.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
            function (e) {
                var /** @type {?} */ x = (e);
                return { latitude: x.location.latitude, longitude: x.location.longitude };
            };
        /**
         * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to obtain the polygon model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polygon} implementation of the underlying platform.
         *
         */
        BingPolygonService.prototype.GetNativePolygon = /**
         * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to obtain the polygon model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polygon} implementation of the underlying platform.
         *
         */
            function (polygon) {
                return this._polygons.get(polygon);
            };
        /**
         * Set the polygon options.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @param {?} options - {\@link IPolygonOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polygon options have been set.
         *
         */
        BingPolygonService.prototype.SetOptions = /**
         * Set the polygon options.
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @param {?} options - {\@link IPolygonOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polygon options have been set.
         *
         */
            function (polygon, options) {
                return this._polygons.get(polygon).then(function (l) { l.SetOptions(options); });
            };
        /**
         * Updates the Polygon path
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @return {?} - A promise fullfilled once the polygon has been updated.
         *
         */
        BingPolygonService.prototype.UpdatePolygon = /**
         * Updates the Polygon path
         *
         * \@memberof BingPolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @return {?} - A promise fullfilled once the polygon has been updated.
         *
         */
            function (polygon) {
                var /** @type {?} */ m = this._polygons.get(polygon);
                if (m == null || polygon.Paths == null || !Array.isArray(polygon.Paths) || polygon.Paths.length === 0) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    if (Array.isArray(polygon.Paths[0])) {
                        l.SetPaths(polygon.Paths);
                    }
                    else {
                        l.SetPath(/** @type {?} */ (polygon.Paths));
                    }
                });
            };
        BingPolygonService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingPolygonService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: core.NgZone }
            ];
        };
        return BingPolygonService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the Polyline Service abstract class for Bing Maps V8.
     *
     * @export
     */
    var BingPolylineService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingPolylineService.
         * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.
         * @param _layerService - {@link LayerService} instance.
         * The concrete {@link BingLayerService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof BingPolylineService
         */
        function BingPolylineService(_mapService, _layerService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._zone = _zone;
            this._polylines = new Map();
        }
        /**
         * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a
         * corresponding layer.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} to be added.
         *
         * @return {?}
         */
        BingPolylineService.prototype.AddPolyline = /**
         * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a
         * corresponding layer.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} to be added.
         *
         * @return {?}
         */
            function (polyline) {
                var /** @type {?} */ o = {
                    id: polyline.Id,
                    clickable: polyline.Clickable,
                    draggable: polyline.Draggable,
                    editable: polyline.Editable,
                    geodesic: polyline.Geodesic,
                    path: polyline.Path,
                    showTooltip: polyline.ShowTooltip,
                    strokeColor: polyline.StrokeColor,
                    strokeOpacity: polyline.StrokeOpacity,
                    strokeWeight: polyline.StrokeWeight,
                    title: polyline.Title,
                    visible: polyline.Visible,
                    zIndex: polyline.zIndex,
                };
                var /** @type {?} */ polylinePromise;
                if (polyline.InCustomLayer) {
                    polylinePromise = this._layerService.CreatePolyline(polyline.LayerId, o);
                }
                else {
                    polylinePromise = this._mapService.CreatePolyline(o);
                }
                this._polylines.set(polyline, polylinePromise);
            };
        /**
         * Registers an event delegate for a line.
         *
         * \@memberof BingPolylineService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        BingPolylineService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a line.
         *
         * \@memberof BingPolylineService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, polyline) {
                var _this = this;
                var /** @type {?} */ b = new rxjs.Subject();
                if (eventName === 'mousemove') {
                    return b.asObservable();
                }
                if (eventName === 'rightclick') {
                    return b.asObservable();
                }
                return rxjs.Observable.create(function (observer) {
                    _this._polylines.get(polyline).then(function (p) {
                        var /** @type {?} */ x = Array.isArray(p) ? p : [p];
                        x.forEach(function (line) { return line.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); }); });
                    });
                });
            };
        /**
         * Deletes a polyline.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polyline has been deleted.
         *
         */
        BingPolylineService.prototype.DeletePolyline = /**
         * Deletes a polyline.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polyline has been deleted.
         *
         */
            function (polyline) {
                var _this = this;
                var /** @type {?} */ m = this._polylines.get(polyline);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        var /** @type {?} */ x = Array.isArray(l) ? l : [l];
                        x.forEach(function (line) { return line.Delete(); });
                        _this._polylines.delete(polyline);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the marker on the click location
         *
         * @abstract
         * \@memberof BingPolylineService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
        BingPolylineService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the marker on the click location
         *
         * @abstract
         * \@memberof BingPolylineService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.location) {
                    return null;
                }
                return { latitude: e.location.latitude, longitude: e.location.longitude };
            };
        /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to obtain the polyline model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polyline}
         * implementation of the underlying platform. For complex paths, returns an array of polylines.
         *
         */
        BingPolylineService.prototype.GetNativePolyline = /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to obtain the polyline model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polyline}
         * implementation of the underlying platform. For complex paths, returns an array of polylines.
         *
         */
            function (polyline) {
                return this._polylines.get(polyline);
            };
        /**
         * Set the polyline options.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @param {?} options - {\@link IPolylineOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polyline options have been set.
         *
         */
        BingPolylineService.prototype.SetOptions = /**
         * Set the polyline options.
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @param {?} options - {\@link IPolylineOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polyline options have been set.
         *
         */
            function (polyline, options) {
                return this._polylines.get(polyline).then(function (l) {
                    var /** @type {?} */ x = Array.isArray(l) ? l : [l];
                    x.forEach(function (line) { return line.SetOptions(options); });
                });
            };
        /**
         * Updates the Polyline path
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @return {?} - A promise fullfilled once the polyline has been updated.
         *
         */
        BingPolylineService.prototype.UpdatePolyline = /**
         * Updates the Polyline path
         *
         * \@memberof BingPolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @return {?} - A promise fullfilled once the polyline has been updated.
         *
         */
            function (polyline) {
                var _this = this;
                var /** @type {?} */ m = this._polylines.get(polyline);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        var /** @type {?} */ x = Array.isArray(l) ? l : [l];
                        var /** @type {?} */ p = polyline.Path.length > 0 && Array.isArray(polyline.Path[0]) ? /** @type {?} */ (polyline.Path) : /** @type {?} */ ([polyline.Path]);
                        x.forEach(function (line, index) {
                            if (p.length > index) {
                                line.SetPath(p[index]);
                            }
                        });
                        if (Array.isArray(l) && l.length > p.length) {
                            l.splice(p.length - 1).forEach(function (line) { return line.Delete(); });
                        }
                    });
                });
            };
        BingPolylineService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingPolylineService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: core.NgZone }
            ];
        };
        return BingPolylineService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements a factory to create thre necessary Bing Maps V8 specific service instances.
     *
     * @export
     */
    var BingMapServiceFactory = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of BingMapServiceFactory.
         * @param _loader - {@link MapAPILoader} implementation for the Bing Map V8 provider.
         * @param _zone - NgZone object to implement zone aware promises.
         *
         * @memberof BingMapServiceFactory
         */
        function BingMapServiceFactory(_loader, _zone) {
            this._loader = _loader;
            this._zone = _zone;
        }
        /**
         * Creates the map service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @return {?} - {\@link MapService}. A concreted instance of the {\@link BingMapService}.
         *
         */
        BingMapServiceFactory.prototype.Create = /**
         * Creates the map service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @return {?} - {\@link MapService}. A concreted instance of the {\@link BingMapService}.
         *
         */
            function () {
                return new BingMapService(this._loader, this._zone);
            };
        /**
         * Creates the cluster service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link ClusterService}. A concreted instance of the {\@link BingClusterService}.
         *
         */
        BingMapServiceFactory.prototype.CreateClusterService = /**
         * Creates the cluster service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link ClusterService}. A concreted instance of the {\@link BingClusterService}.
         *
         */
            function (_mapService) {
                return new BingClusterService(_mapService, this._zone);
            };
        /**
         * Creates thh info box service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link InfoBoxService}. A concreted instance of the {\@link BingInfoBoxService}.
         *
         */
        BingMapServiceFactory.prototype.CreateInfoBoxService = /**
         * Creates thh info box service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link InfoBoxService}. A concreted instance of the {\@link BingInfoBoxService}.
         *
         */
            function (_mapService) {
                return new BingInfoBoxService(_mapService, this._zone);
            };
        /**
         * Creates the layer service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link LayerService}. A concreted instance of the {\@link BingLayerService}.
         *
         */
        BingMapServiceFactory.prototype.CreateLayerService = /**
         * Creates the layer service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link LayerService}. A concreted instance of the {\@link BingLayerService}.
         *
         */
            function (_mapService) {
                return new BingLayerService(_mapService, this._zone);
            };
        /**
         * Creates the marker service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @param {?} _layerService
         * @param {?} _clusterService
         * @return {?} - {\@link MarkerService}. A concreted instance of the {\@link BingMarkerService}.
         *
         */
        BingMapServiceFactory.prototype.CreateMarkerService = /**
         * Creates the marker service for the Bing Maps V8 implementation.
         *
         * \@memberof BingMapServiceFactory
         * @param {?} _mapService
         * @param {?} _layerService
         * @param {?} _clusterService
         * @return {?} - {\@link MarkerService}. A concreted instance of the {\@link BingMarkerService}.
         *
         */
            function (_mapService, _layerService, _clusterService) {
                return new BingMarkerService(_mapService, _layerService, _clusterService, this._zone);
            };
        /**
         * Creates the polygon service for the Bing Maps V8 implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolygonService} implementation for the underlying map architecture.
         *
         */
        BingMapServiceFactory.prototype.CreatePolygonService = /**
         * Creates the polygon service for the Bing Maps V8 implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolygonService} implementation for the underlying map architecture.
         *
         */
            function (map, layers) {
                return new BingPolygonService(map, layers, this._zone);
            };
        /**
         * Creates the polyline service for the Bing Maps V8 implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolylineService} implementation for the underlying map architecture.
         *
         */
        BingMapServiceFactory.prototype.CreatePolylineService = /**
         * Creates the polyline service for the Bing Maps V8 implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolylineService} implementation for the underlying map architecture.
         *
         */
            function (map, layers) {
                return new BingPolylineService(map, layers, this._zone);
            };
        BingMapServiceFactory.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BingMapServiceFactory.ctorParameters = function () {
            return [
                { type: MapAPILoader },
                { type: core.NgZone }
            ];
        };
        return BingMapServiceFactory;
    }());
    /**
     * Creates a new instance of a plaform specific MapServiceFactory.
     *
     * @export
     * @param {?} apiLoader - An {\@link MapAPILoader} instance. This is expected to the a {\@link BingMapAPILoader}.
     * @param {?} zone - An NgZone instance to provide zone aware promises.
     *
     * @return {?} -  A {\@link MapServiceFactory} instance.
     */
    function BingMapServiceFactoryFactory(apiLoader, zone) {
        return new BingMapServiceFactory(apiLoader, zone);
    }
    /**
     * Creates a new instance of a plaform specific MapLoaderFactory.
     *
     * @export
     * @return {?} - A {\@link MapAPILoader} instance.
     */
    function BingMapLoaderFactory() {
        return new BingMapAPILoader(new BingMapAPILoaderConfig(), new WindowRef(), new DocumentRef());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This abstract partially implements the contract for the {\@link LayerService}
     * and {\@link ClusterService} for the Google Maps archtiecture. It serves
     * as the base class for basic layer ({\@link GoogleLayerService}) and cluster layer ({\@link GoogleClusterLayer}).
     *
     * @export
     * @abstract
     * @abstract
     */
    var /**
     * This abstract partially implements the contract for the {\@link LayerService}
     * and {\@link ClusterService} for the Google Maps archtiecture. It serves
     * as the base class for basic layer ({\@link GoogleLayerService}) and cluster layer ({\@link GoogleClusterLayer}).
     *
     * @export
     * @abstract
     * @abstract
     */ GoogleLayerBase = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleLayerBase.
         * @param _mapService - Concrete {@link MapService} implementation for Google Maps.
         * An instance of {@link GoogleMapService}.
         * @param _zone - NgZone instance to provide zone aware promises.
         *
         * @memberof GoogleLayerBase
         */
        function GoogleLayerBase(_mapService, _zone) {
            this._mapService = _mapService;
            this._zone = _zone;
        }
        /**
         * Deletes the layer
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - MapLayerDirective component object for which to retrieve the layer.
         * @return {?} - A promise that is fullfilled when the layer has been removed.
         *
         */
        GoogleLayerBase.prototype.DeleteLayer = /**
         * Deletes the layer
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - MapLayerDirective component object for which to retrieve the layer.
         * @return {?} - A promise that is fullfilled when the layer has been removed.
         *
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ l = this._layers.get(layer.Id);
                if (l == null) {
                    return Promise.resolve();
                }
                return l.then(function (l1) {
                    return _this._zone.run(function () {
                        l1.Delete();
                        _this._layers.delete(layer.Id);
                    });
                });
            };
        /**
         * Returns the Layer model represented by this layer.
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - MapLayerDirective component object or layer id for which to retrieve the layer model.
         * @return {?} - A promise that when resolved contains the Layer model.
         *
         */
        GoogleLayerBase.prototype.GetNativeLayer = /**
         * Returns the Layer model represented by this layer.
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - MapLayerDirective component object or layer id for which to retrieve the layer model.
         * @return {?} - A promise that when resolved contains the Layer model.
         *
         */
            function (layer) {
                var /** @type {?} */ p = null;
                if (typeof (layer) === 'number') {
                    p = this._layers.get(layer);
                }
                else {
                    p = this._layers.get(((layer)).Id);
                }
                return p;
            };
        /**
         * Creates a marker in the layer.
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - The Id of the layer in which to create the marker.
         * @param {?} options - {\@link IMarkerOptions} object containing the marker properties.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} model for the created marker.
         *
         */
        GoogleLayerBase.prototype.CreateMarker = /**
         * Creates a marker in the layer.
         *
         * \@memberof GoogleLayerBase
         * @param {?} layer - The Id of the layer in which to create the marker.
         * @param {?} options - {\@link IMarkerOptions} object containing the marker properties.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} model for the created marker.
         *
         */
            function (layer, options) {
                var /** @type {?} */ mp = this._mapService.MapPromise;
                var /** @type {?} */ lp = this._layers.get(layer);
                return Promise.all([mp, lp]).then(function (_a) {
                    var _b = __read(_a, 2), map = _b[0], l = _b[1];
                    var /** @type {?} */ payload = function (x) {
                        var /** @type {?} */ marker = new google.maps.Marker(x);
                        if (options.metadata) {
                            options.metadata.forEach(function (val, key) { return marker.Metadata.set(key, val); });
                        }
                        marker.setMap(map);
                        var /** @type {?} */ m = new GoogleMarker(marker);
                        m.IsFirst = options.isFirst;
                        m.IsLast = options.isLast;
                        if (options.metadata) {
                            options.metadata.forEach(function (val, key) { return m.Metadata.set(key, val); });
                        }
                        l.AddEntity(m);
                        return m;
                    };
                    var /** @type {?} */ o = GoogleConversions.TranslateMarkerOptions(options);
                    if (options.iconInfo && options.iconInfo.markerType) {
                        var /** @type {?} */ s = Marker.CreateMarker(options.iconInfo);
                        if (typeof (s) === 'string') {
                            o.icon = s;
                            return payload(o);
                        }
                        else {
                            return s.then(function (x) {
                                o.icon = x.icon;
                                return payload(o);
                            });
                        }
                    }
                    else {
                        return payload(o);
                    }
                });
            };
        /**
         * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerBase
         * @param {?} options - Marker options defining the markers.
         * @param {?=} markerIcon - Optional information to generate custom markers. This will be applied to all markers.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Marker models.
         *
         */
        GoogleLayerBase.prototype.CreateMarkers = /**
         * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerBase
         * @param {?} options - Marker options defining the markers.
         * @param {?=} markerIcon - Optional information to generate custom markers. This will be applied to all markers.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Marker models.
         *
         */
            function (options, markerIcon) {
                var /** @type {?} */ payload = function (icon) {
                    var /** @type {?} */ markers = options.map(function (mo) {
                        var /** @type {?} */ o = GoogleConversions.TranslateMarkerOptions(mo);
                        if (icon && icon !== '') {
                            o.icon = icon;
                        }
                        var /** @type {?} */ pushpin = new google.maps.Marker(o);
                        var /** @type {?} */ marker = new GoogleMarker(pushpin);
                        marker.IsFirst = mo.isFirst;
                        marker.IsLast = mo.isLast;
                        if (mo.metadata) {
                            mo.metadata.forEach(function (val, key) { return marker.Metadata.set(key, val); });
                        }
                        return marker;
                    });
                    return markers;
                };
                var /** @type {?} */ p = new Promise(function (resolve, reject) {
                    if (markerIcon && markerIcon.markerType) {
                        var /** @type {?} */ s = Marker.CreateMarker(markerIcon);
                        if (typeof (s) === 'string') {
                            resolve(payload(s));
                        }
                        else {
                            return s.then(function (x) {
                                resolve(payload(x.icon));
                            });
                        }
                    }
                    else {
                        resolve(payload(null));
                    }
                });
                return p;
            };
        ///
        /// Protected methods
        ///
        /**
         * Gets the layer based on its id.
         *
         * @protected
         * @param id - Layer Id.
         * @returns - A promise that when fullfilled contains the {@link Layer} model for the layer.
         *
         * @memberof GoogleLayerBase
         */
        /**
         * Gets the layer based on its id.
         *
         * @protected
         * \@memberof GoogleLayerBase
         * @param {?} id - Layer Id.
         * @return {?} - A promise that when fullfilled contains the {\@link Layer} model for the layer.
         *
         */
        GoogleLayerBase.prototype.GetLayerById = /**
         * Gets the layer based on its id.
         *
         * @protected
         * \@memberof GoogleLayerBase
         * @param {?} id - Layer Id.
         * @return {?} - A promise that when fullfilled contains the {\@link Layer} model for the layer.
         *
         */
            function (id) {
                var /** @type {?} */ p;
                this._layers.forEach(function (l, k) {
                    if (k === id) {
                        p = l;
                    }
                });
                return p;
            };
        return GoogleLayerBase;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var GoogleClusterService = (function (_super) {
        __extends(GoogleClusterService, _super);
        ///
        /// Constructors
        ///
        /**
         * Creates an instance of GoogleClusterService.
         * @param _mapService
         * @param _zone
         * @memberof GoogleClusterService
         */
        function GoogleClusterService(_mapService, _zone) {
            var _this = _super.call(this, _mapService, _zone) || this;
            _this._layers = new Map();
            _this._layerStyles = new Map();
            return _this;
        }
        /**
         * Creates the cluster icon from the styles
         *
         * \@memberof GoogleClusterService
         * @param {?} styles
         * @return {?} - Promise that when resolved contains an Array of IClusterIconInfo objects
         * containing the hydrated cluster icons.
         */
        GoogleClusterService.CreateClusterIcons = /**
         * Creates the cluster icon from the styles
         *
         * \@memberof GoogleClusterService
         * @param {?} styles
         * @return {?} - Promise that when resolved contains an Array of IClusterIconInfo objects
         * containing the hydrated cluster icons.
         */
            function (styles) {
                var /** @type {?} */ i = new Promise(function (resolve, reject) {
                    var /** @type {?} */ pa = new Array();
                    styles.forEach(function (style, index) {
                        if (style.iconInfo) {
                            var /** @type {?} */ s = Marker.CreateMarker(style.iconInfo);
                            if (typeof (s) === 'string') {
                                style.url = s;
                                if (style.width == null) {
                                    style.width = style.iconInfo.size.width;
                                    style.height = style.iconInfo.size.height;
                                }
                                if (style.iconInfo.markerOffsetRatio && style.iconInfo.size && style.anchor == null) {
                                    var /** @type {?} */ o = style.iconInfo;
                                    style.anchor = [
                                        o.size.width * o.markerOffsetRatio.x,
                                        o.size.height * o.markerOffsetRatio.y
                                    ];
                                }
                                delete style.iconInfo;
                            }
                            else {
                                s.then(function (x) {
                                    style.url = x.icon;
                                    if (style.width == null) {
                                        style.width = x.iconInfo.size.width;
                                        style.height = x.iconInfo.size.height;
                                    }
                                    if (x.iconInfo.markerOffsetRatio && x.iconInfo.size && style.anchor == null) {
                                        var /** @type {?} */ o = x.iconInfo;
                                        style.anchor = [
                                            o.size.width * o.markerOffsetRatio.x,
                                            o.size.height * o.markerOffsetRatio.y
                                        ];
                                    }
                                    delete style.iconInfo;
                                });
                                pa.push(s);
                            }
                        }
                    });
                    if (pa.length === 0) {
                        resolve(styles);
                    }
                    else {
                        Promise.all(pa).then(function () {
                            resolve(styles);
                        });
                    }
                });
                return i;
            };
        /**
         * Adds the cluster layer to the map
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
        GoogleClusterService.prototype.AddLayer = /**
         * Adds the cluster layer to the map
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ options = {
                    id: layer.Id,
                    visible: layer.Visible,
                    clusteringEnabled: layer.ClusteringEnabled,
                    zoomOnClick: layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster
                };
                if (layer.GridSize) {
                    options.gridSize = layer.GridSize;
                }
                if (layer.MinimumClusterSize) {
                    options.minimumClusterSize = layer.MinimumClusterSize;
                }
                if (layer.Styles) {
                    options.styles = layer.Styles;
                }
                if (layer.UseDynamicSizeMarkers) {
                    options.styles = null;
                    // do not to attempt to setup styles here as the dynamic call back will generate them.
                }
                else {
                    options.styles = [{
                            height: 30,
                            width: 35,
                            textColor: 'white',
                            textSize: 11,
                            backgroundPosition: 'center',
                            iconInfo: {
                                markerType: MarkerTypeId.FontMarker,
                                fontName: 'FontAwesome',
                                fontSize: 30,
                                color: 'green',
                                text: '\uF111'
                            }
                        }];
                }
                var /** @type {?} */ dynamicClusterCallback = function (markers, numStyles, clusterer) {
                    // dynamically ensure that the necessary style for this cluster icon exists and
                    // the clusterer is already hooked up to the styles array via pointer, so we only
                    // need to update the style. Since the clusterer re-renders a cluster icon is the
                    // the marker count changes, we will only need to retain the current icon as opposed
                    // to all cluster icon.
                    var /** @type {?} */ styles = _this._layerStyles.get(layer.Id);
                    var /** @type {?} */ iconInfo = {
                        markerType: MarkerTypeId.None
                    };
                    var /** @type {?} */ icon = layer.CustomMarkerCallback(/** @type {?} */ (markers), iconInfo);
                    styles[0] = {
                        url: "\"data:image/svg+xml;utf8," + icon + "\"",
                        height: iconInfo.size.height,
                        width: iconInfo.size.width,
                        textColor: 'white',
                        textSize: 11,
                        backgroundPosition: 'center',
                    };
                    return {
                        text: markers.length.toString(),
                        index: 1
                    };
                };
                var /** @type {?} */ resetStyles = function (clusterer) {
                    if (_this._layerStyles.has(layer.Id)) {
                        _this._layerStyles.get(layer.Id).splice(0);
                    }
                    else {
                        var /** @type {?} */ styles = new Array();
                        styles.push({});
                        _this._layerStyles.set(layer.Id, styles);
                        clusterer.setStyles(styles);
                        // this is important for dynamic styles as the pointer to this array gets passed
                        // around key objects in the clusterer. Therefore, it must be initialized here in order for
                        // updates to the styles to be visible.
                        // also, we need to add at least one style to prevent the default styles from being picked up.
                    }
                };
                var /** @type {?} */ layerPromise = this._mapService.CreateClusterLayer(options);
                this._layers.set(layer.Id, layerPromise);
                layerPromise.then(function (l) {
                    var /** @type {?} */ clusterer = (l.NativePrimitve);
                    if (options.styles) {
                        var /** @type {?} */ s = GoogleClusterService.CreateClusterIcons(options.styles);
                        s.then(function (x) {
                            clusterer.setStyles(/** @type {?} */ (x));
                        });
                    }
                    else {
                        resetStyles(clusterer);
                        _this._mapService.MapPromise.then(function (m) {
                            m.addListener('zoom_changed', function () {
                                resetStyles(clusterer);
                            });
                        });
                        clusterer.setCalculator(function (m, n) {
                            return dynamicClusterCallback(m, n, clusterer);
                        });
                    }
                });
            };
        /**
         * Create a marker in the cluster
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @param {?} options
         * @return {?}
         */
        GoogleClusterService.prototype.CreateMarker = /**
         * Create a marker in the cluster
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @param {?} options
         * @return {?}
         */
            function (layer, options) {
                var _this = this;
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    return _this._mapService.CreateMarker(options)
                        .then(function (marker) {
                        marker.IsFirst = options.isFirst;
                        marker.IsLast = options.isLast;
                        l.AddEntity(marker);
                        return marker;
                    });
                });
            };
        /**
         * Starts the clustering
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
        GoogleClusterService.prototype.StartClustering = /**
         * Starts the clustering
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                return Promise.resolve();
            };
        /**
         * Stops the clustering
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
        GoogleClusterService.prototype.StopClustering = /**
         * Stops the clustering
         *
         * \@memberof GoogleClusterService
         * @param {?} layer
         * @return {?}
         */
            function (layer) {
                return Promise.resolve();
            };
        /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
        GoogleClusterService.prototype.CreatePolygon = /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
            function (layer, options) {
                throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
        GoogleClusterService.prototype.CreatePolygons = /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
            function (layer, options) {
                throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an
         * array of polygons for complex paths) model.
         *
         */
        GoogleClusterService.prototype.CreatePolyline = /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the line.
         * @param {?} options - Polyline options defining the line.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an
         * array of polygons for complex paths) model.
         *
         */
            function (layer, options) {
                throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
            };
        /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
        GoogleClusterService.prototype.CreatePolylines = /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof GoogleClusterService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
            function (layer, options) {
                throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));
            };
        GoogleClusterService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleClusterService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return GoogleClusterService;
    }(GoogleLayerBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var GoogleInfoBoxService = (function (_super) {
        __extends(GoogleInfoBoxService, _super);
        ///
        /// Constructors
        ///
        /**
         * Creates an instance of GoogleInfoBoxService.
         * @param _mapService
         * @param _markerService
         * @param _zone
         *
         * @memberof GoogleInfoBoxService
         */
        function GoogleInfoBoxService(_mapService, _markerService, _zone) {
            var _this = _super.call(this) || this;
            _this._mapService = _mapService;
            _this._markerService = _markerService;
            _this._zone = _zone;
            _this._boxes = new Map();
            return _this;
        }
        /**
         * Creates a new instance of an info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         *
         * @return {?}
         */
        GoogleInfoBoxService.prototype.AddInfoWindow = /**
         * Creates a new instance of an info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         *
         * @return {?}
         */
            function (info) {
                var /** @type {?} */ options = {};
                if (info.HtmlContent !== '') {
                    options.htmlContent = info.HtmlContent;
                }
                else {
                    options.title = info.Title;
                    options.description = info.Description;
                }
                if (info.xOffset || info.yOffset) {
                    if (options.pixelOffset == null) {
                        options.pixelOffset = { x: 0, y: 0 };
                    }
                    if (info.xOffset) {
                        options.pixelOffset.x = info.xOffset;
                    }
                    if (info.yOffset) {
                        options.pixelOffset.y = info.yOffset;
                    }
                }
                options.disableAutoPan = info.DisableAutoPan;
                options.visible = info.Visible;
                if (typeof info.Latitude === 'number' && typeof info.Longitude === 'number') {
                    options.position = { latitude: info.Latitude, longitude: info.Longitude };
                }
                var /** @type {?} */ infoWindowPromise = this._mapService.CreateInfoWindow(options);
                this._boxes.set(info, infoWindowPromise);
            };
        /**
         * Closes the info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @return {?} -  A promise that is resolved when the info box is closed.
         *
         */
        GoogleInfoBoxService.prototype.Close = /**
         * Closes the info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @return {?} -  A promise that is resolved when the info box is closed.
         *
         */
            function (info) {
                return this._boxes.get(info).then(function (w) {
                    w.Close();
                });
            };
        /**
         * Registers an event delegate for an info window.
         *
         * \@memberof GoogleInfoBoxService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} infoComponent - The {\@link InfoBoxComponent} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        GoogleInfoBoxService.prototype.CreateEventObservable = /**
         * Registers an event delegate for an info window.
         *
         * \@memberof GoogleInfoBoxService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} infoComponent - The {\@link InfoBoxComponent} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, infoComponent) {
                var _this = this;
                var /** @type {?} */ googleEventName = GoogleMapEventsLookup[eventName];
                return rxjs.Observable.create(function (observer) {
                    _this._boxes.get(infoComponent).then(function (b) {
                        b.AddListener(googleEventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes the info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         *
         * @return {?}
         */
        GoogleInfoBoxService.prototype.DeleteInfoWindow = /**
         * Deletes the info window
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         *
         * @return {?}
         */
            function (info) {
                return Promise.resolve();
            };
        /**
         * Opens the info window. Window opens on a marker, if supplied, or a specific location if given
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?=} loc
         * @return {?}
         */
        GoogleInfoBoxService.prototype.Open = /**
         * Opens the info window. Window opens on a marker, if supplied, or a specific location if given
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?=} loc
         * @return {?}
         */
            function (info, loc) {
                var _this = this;
                if (info.CloseInfoBoxesOnOpen || info.Modal) {
                    // close all open info boxes
                    this._boxes.forEach(function (box, i) {
                        if (info.Id !== i.Id) {
                            box.then(function (w) {
                                if (w.IsOpen) {
                                    w.Close();
                                    i.Close();
                                }
                            });
                        }
                    });
                }
                return this._boxes.get(info).then(function (w) {
                    var /** @type {?} */ options = {};
                    if (info.HtmlContent !== '') {
                        options.htmlContent = info.HtmlContent;
                    }
                    else {
                        options.title = info.Title;
                        options.description = info.Description;
                    }
                    w.SetOptions(options);
                    if (info.HostMarker != null) {
                        return _this._markerService.GetNativeMarker(info.HostMarker).then(function (marker) {
                            return _this._mapService.MapPromise.then(function (map) { return ((w)).Open(((marker)).NativePrimitve); });
                        });
                    }
                    return _this._mapService.MapPromise.then(function (map) {
                        if (loc) {
                            w.SetPosition(loc);
                        }
                        w.Open();
                    });
                });
            };
        /**
         * Sets the info window options
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?} options
         *
         * @return {?}
         */
        GoogleInfoBoxService.prototype.SetOptions = /**
         * Sets the info window options
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?} options
         *
         * @return {?}
         */
            function (info, options) {
                return this._boxes.get(info).then(function (w) {
                    w.SetOptions(options);
                });
            };
        /**
         * Sets the info window position
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?} latlng
         *
         * @return {?}
         */
        GoogleInfoBoxService.prototype.SetPosition = /**
         * Sets the info window position
         *
         * \@memberof GoogleInfoBoxService
         * @param {?} info
         * @param {?} latlng
         *
         * @return {?}
         */
            function (info, latlng) {
                this._boxes.get(info).then(function (w) {
                    w.SetPosition(latlng);
                });
                return Promise.resolve();
            };
        GoogleInfoBoxService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleInfoBoxService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: MarkerService },
                { type: core.NgZone }
            ];
        };
        return GoogleInfoBoxService;
    }(InfoBoxService));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of a layer for the Google Map Provider.
     *
     * @export
     */
    var /**
     * Concrete implementation of a layer for the Google Map Provider.
     *
     * @export
     */ GoogleLayer = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new instance of the GoogleMarkerClusterer class.
         *
         * @param _layer GoogleMapTypes.MarkerClusterer. Native Google Maps Marker Clusterer supporting the cluster layer.
         * @param _maps MapService. MapService implementation to leverage for the layer.
         *
         * @memberof GoogleLayer
         */
        function GoogleLayer(_layer, _maps, _id) {
            this._layer = _layer;
            this._maps = _maps;
            this._id = _id;
            this._entities = new Array();
            this._visible = true;
        }
        Object.defineProperty(GoogleLayer.prototype, "NativePrimitve", {
            get: /**
             * Get the native primitive underneath the abstraction layer. Google does not have the concept of a custom layer,
             * so we are returning the Map as the native object because it hosts all the markers.
             *
             * \@memberof GoogleLayer
             * @return {?} GoogleMapTypes.GoogleMap.
             *
             */ function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener for the layer.
         *
         * \@memberof GoogleLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
        GoogleLayer.prototype.AddListener = /**
         * Adds an event listener for the layer.
         *
         * \@memberof GoogleLayer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                throw (new Error('Events are not supported on Google Layers. You can still add events to individual markers.'));
            };
        /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof GoogleLAyer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.
         *
         * @return {?}
         */
        GoogleLayer.prototype.AddEntity = /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof GoogleLAyer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve) {
                    this._entities.push(entity);
                    entity.NativePrimitve.setVisible(this._visible);
                    entity.NativePrimitve.setMap(this.NativePrimitve);
                }
            };
        /**
         * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such
         * as marker, infowindow, polyline, polygon, etc..)
         *
         * \@memberof GoogleLAyer
         * @param {?} entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.
         *
         * @return {?}
         */
        GoogleLayer.prototype.AddEntities = /**
         * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such
         * as marker, infowindow, polyline, polygon, etc..)
         *
         * \@memberof GoogleLAyer
         * @param {?} entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                if (entities != null && Array.isArray(entities) && entities.length !== 0) {
                    (_a = this._entities).push.apply(_a, __spread(entities));
                    async.eachSeries(__spread(entities), function (e, next) {
                        e.NativePrimitve.setVisible(_this._visible);
                        e.NativePrimitve.setMap(_this.NativePrimitve);
                        async.nextTick(function () { return next(); });
                    });
                }
                var _a;
            };
        /**
         * Deletes the layer anbd the markers in it.
         *
         * \@memberof GoogleLayer
         * @return {?}
         */
        GoogleLayer.prototype.Delete = /**
         * Deletes the layer anbd the markers in it.
         *
         * \@memberof GoogleLayer
         * @return {?}
         */
            function () {
                async.eachSeries(this._entities.splice(0), function (e, next) {
                    e.NativePrimitve.setMap(null);
                    async.nextTick(function () { return next(); });
                });
            };
        /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof GoogleLayer
         * @return {?} ILayerOptions. The layer options.
         *
         */
        GoogleLayer.prototype.GetOptions = /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof GoogleLayer
         * @return {?} ILayerOptions. The layer options.
         *
         */
            function () {
                var /** @type {?} */ options = {
                    id: this._id
                };
                return options;
            };
        /**
         * Returns the visibility state of the layer.
         *
         * \@memberof GoogleLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
        GoogleLayer.prototype.GetVisible = /**
         * Returns the visibility state of the layer.
         *
         * \@memberof GoogleLayer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
            function () {
                return this._visible;
            };
        /**
         * Removes an entity from the layer.
         *
         * \@memberof GoogleLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline Entity to be removed from the layer.
         *
         * @return {?}
         */
        GoogleLayer.prototype.RemoveEntity = /**
         * Removes an entity from the layer.
         *
         * \@memberof GoogleLayer
         * @param {?} entity Marker|InfoWindow|Polygon|Polyline Entity to be removed from the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve) {
                    var /** @type {?} */ j = this._entities.indexOf(entity);
                    if (j > -1) {
                        this._entities.splice(j, 1);
                    }
                    entity.NativePrimitve.setMap(null);
                }
            };
        /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof GoogleLayer
         * @param {?} entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
        GoogleLayer.prototype.SetEntities = /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof GoogleLayer
         * @param {?} entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
            function (entities) {
                this.Delete();
                this.AddEntities(entities);
            };
        /**
         * Sets the options for the cluster layer.
         *
         * \@memberof GoogleLayer
         * @param {?} options ILayerOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        GoogleLayer.prototype.SetOptions = /**
         * Sets the options for the cluster layer.
         *
         * \@memberof GoogleLayer
         * @param {?} options ILayerOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                this._id = options.id;
            };
        /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
        GoogleLayer.prototype.SetVisible = /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
            function (visible) {
                async.eachSeries(__spread(this._entities), function (e, next) {
                    e.NativePrimitve.setVisible(visible);
                    async.nextTick(function () { return next(); });
                });
                this._visible = visible;
            };
        return GoogleLayer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements the {\@link LayerService} contract for a Google Maps specific implementation.
     *
     * @export
     */
    var GoogleLayerService = (function (_super) {
        __extends(GoogleLayerService, _super);
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleLayerService.
         * @param _mapService - Instance of the Google Maps Service. Will generally be injected.
         * @param _zone - NgZone instance to provide zone aware promises.
         *
         * @memberof GoogleLayerService
         */
        function GoogleLayerService(_mapService, _zone) {
            var _this = _super.call(this, _mapService, _zone) || this;
            _this._layers = new Map();
            return _this;
        }
        /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - MapLayerDirective component object.
         * Generally, MapLayerDirective will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
        GoogleLayerService.prototype.AddLayer = /**
         * Adds a layer to the map.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - MapLayerDirective component object.
         * Generally, MapLayerDirective will be injected with an instance of the
         * LayerService and then self register on initialization.
         *
         * @return {?}
         */
            function (layer) {
                var _this = this;
                var /** @type {?} */ p = new Promise(function (resolve, reject) {
                    _this._mapService.MapPromise.then(function (m) {
                        var /** @type {?} */ l = new GoogleLayer(m, _this._mapService, layer.Id);
                        l.SetVisible(layer.Visible);
                        resolve(l);
                    });
                });
                this._layers.set(layer.Id, p);
            };
        /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
        GoogleLayerService.prototype.CreatePolygon = /**
         * Adds a polygon to the layer.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygon.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polygon model.
         *
         */
            function (layer, options) {
                var /** @type {?} */ p = this._mapService.CreatePolygon(options);
                var /** @type {?} */ l = this._layers.get(layer);
                Promise.all([p, l]).then(function (x) { return x[1].AddEntity(x[0]); });
                return p;
            };
        /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
        GoogleLayerService.prototype.CreatePolygons = /**
         * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polygon.
         * @param {?} options - Polygon options defining the polygons.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polygon models.
         *
         */
            function (layer, options) {
                //
                // Note: we attempted using data.Polygons in an attempt to improve performance, but either data.Polygon
                // or data.MultiPolygon actually operate significantly slower than generating the polygons this way.
                // the slowness in google as opposed to bing probably comes from the point reduction algorithm uses.
                // Signigicant performance improvements might be possible in google when using a pixel based reduction algorithm
                // prior to setting the polygon path. This will lower to processing overhead of the google algorithm (with is Douglas-Peucker
                // and rather compute intensive)
                //
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    var /** @type {?} */ polygons = new Promise(function (resolve, reject) {
                        var /** @type {?} */ polys = options.map(function (o) {
                            var /** @type {?} */ op = GoogleConversions.TranslatePolygonOptions(o);
                            var /** @type {?} */ poly = new google.maps.Polygon(op);
                            var /** @type {?} */ polygon = new GooglePolygon(poly);
                            if (o.title && o.title !== '') {
                                polygon.Title = o.title;
                            }
                            if (o.metadata) {
                                o.metadata.forEach(function (val, key) { return polygon.Metadata.set(key, val); });
                            }
                            return polygon;
                        });
                        resolve(polys);
                    });
                    return polygons;
                });
            };
        /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polyline.
         * @param {?} options - Polyline options defining the polyline.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
        GoogleLayerService.prototype.CreatePolyline = /**
         * Adds a polyline to the layer.
         *
         * @abstract
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polyline.
         * @param {?} options - Polyline options defining the polyline.
         * @return {?} - A promise that when fullfilled contains the an instance of the Polyline (or an array
         * of polygons for complex paths) model.
         *
         */
            function (layer, options) {
                var /** @type {?} */ p = this._mapService.CreatePolyline(options);
                var /** @type {?} */ l = this._layers.get(layer);
                Promise.all([p, l]).then(function (x) {
                    var /** @type {?} */ p1 = Array.isArray(x[0]) ? /** @type {?} */ (x[0]) : [/** @type {?} */ (x[0])];
                    try {
                        for (var p1_1 = __values(p1), p1_1_1 = p1_1.next(); !p1_1_1.done; p1_1_1 = p1_1.next()) {
                            var p2 = p1_1_1.value;
                            x[1].AddEntity(p2);
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (p1_1_1 && !p1_1_1.done && (_a = p1_1.return))
                                _a.call(p1_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    var e_1, _a;
                });
                return p;
            };
        /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
        GoogleLayerService.prototype.CreatePolylines = /**
         * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk
         * operations.
         *
         * \@memberof GoogleLayerService
         * @param {?} layer - The id of the layer to which to add the polylines.
         * @param {?} options - Polyline options defining the polylines.
         * @return {?} - A promise that when fullfilled contains the an arrays of the Polyline models.
         *
         */
            function (layer, options) {
                var /** @type {?} */ p = this.GetLayerById(layer);
                if (p == null) {
                    throw (new Error("Layer with id " + layer + " not found in Layer Map"));
                }
                return p.then(function (l) {
                    var /** @type {?} */ polylines = new Promise(function (resolve, reject) {
                        var /** @type {?} */ polys = options.map(function (o) {
                            var /** @type {?} */ op = GoogleConversions.TranslatePolylineOptions(o);
                            if (o.path && o.path.length > 0 && !Array.isArray(o.path[0])) {
                                op.path = GoogleConversions.TranslatePaths(o.path)[0];
                                var /** @type {?} */ poly = new google.maps.Polyline(op);
                                var /** @type {?} */ polyline_1 = new GooglePolyline(poly);
                                if (o.title && o.title !== '') {
                                    polyline_1.Title = o.title;
                                }
                                if (o.metadata) {
                                    o.metadata.forEach(function (v, k) { return polyline_1.Metadata.set(k, v); });
                                }
                                return polyline_1;
                            }
                            else {
                                var /** @type {?} */ paths = GoogleConversions.TranslatePaths(o.path);
                                var /** @type {?} */ lines_1 = new Array();
                                paths.forEach(function (x) {
                                    op.path = x;
                                    var /** @type {?} */ poly = new google.maps.Polyline(op);
                                    var /** @type {?} */ polyline = new GooglePolyline(poly);
                                    if (o.metadata) {
                                        o.metadata.forEach(function (v, k) { return polyline.Metadata.set(k, v); });
                                    }
                                    if (o.title && o.title !== '') {
                                        polyline.Title = o.title;
                                    }
                                    lines_1.push(polyline);
                                });
                                return lines_1;
                            }
                        });
                        resolve(polys);
                    });
                    return polylines;
                });
            };
        GoogleLayerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleLayerService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: core.NgZone }
            ];
        };
        return GoogleLayerService;
    }(GoogleLayerBase));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var ScriptProtocol$1 = {
        HTTP: 0,
        HTTPS: 1,
        AUTO: 2,
    };
    ScriptProtocol$1[ScriptProtocol$1.HTTP] = "HTTP";
    ScriptProtocol$1[ScriptProtocol$1.HTTPS] = "HTTPS";
    ScriptProtocol$1[ScriptProtocol$1.AUTO] = "AUTO";
    /**
     * Bing Maps V8 specific loader configuration to be used with the {\@link GoogleMapAPILoader}
     *
     * @export
     */
    var GoogleMapAPILoaderConfig = (function () {
        function GoogleMapAPILoaderConfig() {
        }
        GoogleMapAPILoaderConfig.decorators = [
            { type: core.Injectable },
        ];
        return GoogleMapAPILoaderConfig;
    }());
    /**
     * Default loader configuration.
     */
    var /** @type {?} */ DEFAULT_CONFIGURATION$1 = new GoogleMapAPILoaderConfig();
    /**
     * Bing Maps V8 implementation for the {\@link MapAPILoader} service.
     *
     * @export
     */
    var GoogleMapAPILoader = (function (_super) {
        __extends(GoogleMapAPILoader, _super);
        /**
         * Creates an instance of GoogleMapAPILoader.
         * @param _config - The loader configuration.
         * @param _windowRef - An instance of {@link WindowRef}. Necessary because Bing Map V8 interacts with the window object.
         * @param _documentRef - An instance of {@link DocumentRef}.
         *                                     Necessary because Bing Map V8 interacts with the document object.
         * @memberof GoogleMapAPILoader
         */
        function GoogleMapAPILoader(_config, _windowRef, _documentRef) {
            var _this = _super.call(this) || this;
            _this._config = _config;
            _this._windowRef = _windowRef;
            _this._documentRef = _documentRef;
            if (_this._config === null || _this._config === undefined) {
                _this._config = DEFAULT_CONFIGURATION$1;
            }
            return _this;
        }
        Object.defineProperty(GoogleMapAPILoader.prototype, "Config", {
            get: /**
             * Gets the loader configuration.
             *
             * \@readonly
             * \@memberof GoogleMapAPILoader
             * @return {?}
             */ function () { return this._config; },
            enumerable: true,
            configurable: true
        });
        /**
         * Loads the necessary resources for Bing Maps V8.
         *
         * \@memberof GoogleMapAPILoader
         * @return {?}
         */
        GoogleMapAPILoader.prototype.Load = /**
         * Loads the necessary resources for Bing Maps V8.
         *
         * \@memberof GoogleMapAPILoader
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._scriptLoadingPromise) {
                    return this._scriptLoadingPromise;
                }
                var /** @type {?} */ script = this._documentRef.GetNativeDocument().createElement('script');
                script.type = 'text/javascript';
                script.async = true;
                script.defer = true;
                var /** @type {?} */ callbackName = "Create";
                script.src = this.GetMapsScriptSrc(callbackName);
                this._scriptLoadingPromise = new Promise(function (resolve, reject) {
                    ((_this._windowRef.GetNativeWindow()))[callbackName] = function () {
                        if (_this._config.enableClustering) {
                            // if clustering is enabled then delay the loading until after the cluster library is loaded
                            var /** @type {?} */ clusterScript = _this._documentRef.GetNativeDocument().createElement('script');
                            clusterScript.type = 'text/javascript';
                            clusterScript.src = _this.GetClusterScriptSrc();
                            clusterScript.onload = clusterScript.onreadystatechange = function () {
                                resolve();
                            };
                            _this._documentRef.GetNativeDocument().head.appendChild(clusterScript);
                        }
                        else {
                            resolve();
                        }
                    };
                    script.onerror = function (error) { reject(error); };
                });
                this._documentRef.GetNativeDocument().head.appendChild(script);
                return this._scriptLoadingPromise;
            };
        /**
         * Gets the Google Maps scripts url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @param {?} callbackName - Name of the function to be called when the Google Maps scripts are loaded.
         * @return {?} - The url to be used to load the Google Map scripts.
         *
         */
        GoogleMapAPILoader.prototype.GetMapsScriptSrc = /**
         * Gets the Google Maps scripts url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @param {?} callbackName - Name of the function to be called when the Google Maps scripts are loaded.
         * @return {?} - The url to be used to load the Google Map scripts.
         *
         */
            function (callbackName) {
                var /** @type {?} */ hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';
                var /** @type {?} */ queryParams = {
                    v: this._config.apiVersion,
                    callback: callbackName,
                    key: this._config.apiKey,
                    client: this._config.clientId,
                    channel: this._config.channel,
                    libraries: this._config.libraries,
                    region: this._config.region,
                    language: this._config.language
                };
                return this.GetScriptSrc(hostAndPath, queryParams);
            };
        /**
         * Gets the Google Maps Cluster library url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @return {?} - The url to be used to load the Google Map Cluster library.
         *
         */
        GoogleMapAPILoader.prototype.GetClusterScriptSrc = /**
         * Gets the Google Maps Cluster library url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @return {?} - The url to be used to load the Google Map Cluster library.
         *
         */
            function () {
                var /** @type {?} */ hostAndPath = this._config.clusterHostAndPath ||
                    'developers.google.com/maps/documentation/javascript/examples/markerclusterer/markerclusterer.js';
                return this.GetScriptSrc(hostAndPath, {});
            };
        /**
         * Gets a scripts url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @param {?} hostAndPath - Host and path name of the script to load.
         * @param {?} queryParams - Url query parameters.
         * @return {?} - The url with correct protocol, path, and query parameters.
         *
         */
        GoogleMapAPILoader.prototype.GetScriptSrc = /**
         * Gets a scripts url for injections into the header.
         *
         * \@memberof GoogleMapAPILoader
         * @param {?} hostAndPath - Host and path name of the script to load.
         * @param {?} queryParams - Url query parameters.
         * @return {?} - The url with correct protocol, path, and query parameters.
         *
         */
            function (hostAndPath, queryParams) {
                var /** @type {?} */ protocolType = (((this._config && this._config.protocol) || ScriptProtocol$1.HTTPS));
                var /** @type {?} */ protocol;
                switch (protocolType) {
                    case ScriptProtocol$1.AUTO:
                        protocol = '';
                        break;
                    case ScriptProtocol$1.HTTP:
                        protocol = 'http:';
                        break;
                    case ScriptProtocol$1.HTTPS:
                        protocol = 'https:';
                        break;
                }
                var /** @type {?} */ params = Object.keys(queryParams)
                    .filter(function (k) { return queryParams[k] != null; })
                    .filter(function (k) {
                    // remove empty arrays
                    return !Array.isArray(queryParams[k]) ||
                        (Array.isArray(queryParams[k]) && queryParams[k].length > 0);
                })
                    .map(function (k) {
                    // join arrays as comma seperated strings
                    var /** @type {?} */ i = queryParams[k];
                    if (Array.isArray(i)) {
                        return { key: k, value: i.join(',') };
                    }
                    return { key: k, value: queryParams[k] };
                })
                    .map(function (entry) { return entry.key + "=" + entry.value; })
                    .join('&');
                return protocol + "//" + hostAndPath + "?" + params;
            };
        GoogleMapAPILoader.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleMapAPILoader.ctorParameters = function () {
            return [
                { type: GoogleMapAPILoaderConfig, decorators: [{ type: core.Optional }] },
                { type: WindowRef },
                { type: DocumentRef }
            ];
        };
        return GoogleMapAPILoader;
    }(MapAPILoader));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the MarkerService abstract class for Google.
     *
     * @export
     */
    var GoogleMarkerService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleMarkerService.
         * @param _mapService - {@link MapService} instance.
         * The concrete {@link GoogleMapService} implementation is expected.
         * @param _layerService - {@link LayerService} instance.
         * The concrete {@link GoogleLayerService} implementation is expected.
         * @param _clusterService - {@link ClusterService} instance.
         * The concrete {@link GoogleClusterService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof GoogleMarkerService
         */
        function GoogleMarkerService(_mapService, _layerService, _clusterService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._clusterService = _clusterService;
            this._zone = _zone;
            this._markers = new Map();
        }
        /**
         * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} to be added.
         * @return {?}
         */
        GoogleMarkerService.prototype.AddMarker = /**
         * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} to be added.
         * @return {?}
         */
            function (marker) {
                var /** @type {?} */ o = {
                    anchor: marker.Anchor,
                    position: { latitude: marker.Latitude, longitude: marker.Longitude },
                    title: marker.Title,
                    label: marker.Label,
                    draggable: marker.Draggable,
                    icon: marker.IconUrl,
                    iconInfo: marker.IconInfo,
                    width: marker.Width,
                    height: marker.Height,
                    isFirst: marker.IsFirstInSet,
                    isLast: marker.IsLastInSet
                };
                // create marker via promise.
                var /** @type {?} */ markerPromise = null;
                if (marker.InClusterLayer) {
                    markerPromise = this._clusterService.CreateMarker(marker.LayerId, o);
                }
                else if (marker.InCustomLayer) {
                    markerPromise = this._layerService.CreateMarker(marker.LayerId, o);
                }
                else {
                    markerPromise = this._mapService.CreateMarker(o);
                }
                this._markers.set(marker, markerPromise);
                if (marker.IconInfo) {
                    markerPromise.then(function (m) {
                        // update iconInfo to provide hook to do post icon creation activities and
                        // also re-anchor the marker
                        marker.DynamicMarkerCreated.emit(o.iconInfo);
                        var /** @type {?} */ p = {
                            x: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.width * o.iconInfo.markerOffsetRatio.x) : 0,
                            y: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.height * o.iconInfo.markerOffsetRatio.y) : 0,
                        };
                        m.SetAnchor(p);
                    });
                }
            };
        /**
         * Registers an event delegate for a marker.
         *
         * \@memberof GoogleMarkerService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} marker - The {\@link MapMarkerDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         */
        GoogleMarkerService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a marker.
         *
         * \@memberof GoogleMarkerService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} marker - The {\@link MapMarkerDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         */
            function (eventName, marker) {
                var _this = this;
                return rxjs.Observable.create(function (observer) {
                    _this._markers.get(marker).then(function (m) {
                        m.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes a marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - {\@link MapMarkerDirective} to be deleted.
         * @return {?} - A promise fullfilled once the marker has been deleted.
         */
        GoogleMarkerService.prototype.DeleteMarker = /**
         * Deletes a marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - {\@link MapMarkerDirective} to be deleted.
         * @return {?} - A promise fullfilled once the marker has been deleted.
         */
            function (marker) {
                var _this = this;
                var /** @type {?} */ m = this._markers.get(marker);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (ma) {
                    if (marker.InClusterLayer) {
                        _this._clusterService.GetNativeLayer(marker.LayerId).then(function (l) { l.RemoveEntity(ma); });
                    }
                    if (marker.InCustomLayer) {
                        _this._layerService.GetNativeLayer(marker.LayerId).then(function (l) { l.RemoveEntity(ma); });
                    }
                    return _this._zone.run(function () {
                        ma.DeleteMarker();
                        _this._markers.delete(marker);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the marker on the click location
         *
         * \@memberof GoogleMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
        GoogleMarkerService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the marker on the click location
         *
         * \@memberof GoogleMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.latLng) {
                    return null;
                }
                if (!e.latLng.lat || !e.latLng.lng) {
                    return null;
                }
                return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };
            };
        /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} for which to obtain the marker model.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} implementation of the underlying platform.
         */
        GoogleMarkerService.prototype.GetNativeMarker = /**
         * Obtains the marker model for the marker allowing access to native implementation functionatiliy.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker - The {\@link MapMarkerDirective} for which to obtain the marker model.
         * @return {?} - A promise that when fullfilled contains the {\@link Marker} implementation of the underlying platform.
         */
            function (marker) {
                return this._markers.get(marker);
            };
        /**
         * Obtains the marker pixel location for the marker on the click location
         *
         * \@memberof GoogleMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the pixels of the marker on the map canvas.
         */
        GoogleMarkerService.prototype.GetPixelsFromClick = /**
         * Obtains the marker pixel location for the marker on the click location
         *
         * \@memberof GoogleMarkerService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the pixels of the marker on the map canvas.
         */
            function (e) {
                if (!e || !e.latLng || !e.latLng.lat || !e.latLng.lng) {
                    return null;
                }
                if (this._mapService.MapInstance == null) {
                    return null;
                }
                var /** @type {?} */ crossesDateLine = false;
                var /** @type {?} */ m = this._mapService.MapInstance;
                var /** @type {?} */ p = m.getProjection();
                var /** @type {?} */ s = Math.pow(2, m.getZoom());
                var /** @type {?} */ b = m.getBounds();
                if (b.getCenter().lng() < b.getSouthWest().lng() ||
                    b.getCenter().lng() > b.getNorthEast().lng()) {
                    crossesDateLine = true;
                }
                var /** @type {?} */ offsetY = p.fromLatLngToPoint(b.getNorthEast()).y;
                var /** @type {?} */ offsetX = p.fromLatLngToPoint(b.getSouthWest()).x;
                var /** @type {?} */ point = p.fromLatLngToPoint(e.latLng);
                return {
                    x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),
                    y: Math.floor((point.y - offsetY) * s)
                };
            };
        /**
         * Converts a geo location to a pixel location relative to the map canvas.
         *
         * \@memberof GoogleMarkerService
         * @param {?} target - Either a {\@link MapMarkerDirective}
         * or a {\@link ILatLong} for the basis of translation.
         * @return {?} - A promise that when fullfilled contains a {\@link IPoint}
         * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.
         */
        GoogleMarkerService.prototype.LocationToPoint = /**
         * Converts a geo location to a pixel location relative to the map canvas.
         *
         * \@memberof GoogleMarkerService
         * @param {?} target - Either a {\@link MapMarkerDirective}
         * or a {\@link ILatLong} for the basis of translation.
         * @return {?} - A promise that when fullfilled contains a {\@link IPoint}
         * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.
         */
            function (target) {
                var _this = this;
                if (target == null) {
                    return Promise.resolve(null);
                }
                if (target instanceof MapMarkerDirective) {
                    return this._markers.get(target).then(function (m) {
                        var /** @type {?} */ l = m.Location;
                        var /** @type {?} */ p = _this._mapService.LocationToPoint(l);
                        return p;
                    });
                }
                return this._mapService.LocationToPoint(target);
            };
        /**
         * Updates the anchor position for the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the anchor position has been updated.
         */
        GoogleMarkerService.prototype.UpdateAnchor = /**
         * Updates the anchor position for the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the anchor position has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    m.SetAnchor(marker.Anchor);
                });
            };
        /**
         * Updates whether the marker is draggable.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the marker has been updated.
         */
        GoogleMarkerService.prototype.UpdateDraggable = /**
         * Updates whether the marker is draggable.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the marker has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetDraggable(marker.Draggable); });
            };
        /**
         * Updates the Icon on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the icon information has been updated.
         */
        GoogleMarkerService.prototype.UpdateIcon = /**
         * Updates the Icon on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the icon information has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    if (marker.IconInfo) {
                        var /** @type {?} */ x = {
                            position: { latitude: marker.Latitude, longitude: marker.Longitude },
                            iconInfo: marker.IconInfo
                        };
                        var /** @type {?} */ o = GoogleConversions.TranslateMarkerOptions(x);
                        m.SetIcon(o.icon);
                        marker.DynamicMarkerCreated.emit(x.iconInfo);
                    }
                    else {
                        m.SetIcon(marker.IconUrl);
                    }
                });
            };
        /**
         * Updates the label on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the label has been updated.
         */
        GoogleMarkerService.prototype.UpdateLabel = /**
         * Updates the label on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the label has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { m.SetLabel(marker.Label); });
            };
        /**
         * Updates the geo coordinates for the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the position has been updated.
         */
        GoogleMarkerService.prototype.UpdateMarkerPosition = /**
         * Updates the geo coordinates for the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the position has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) {
                    return m.SetPosition({
                        latitude: marker.Latitude,
                        longitude: marker.Longitude
                    });
                });
            };
        /**
         * Updates the title on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         */
        GoogleMarkerService.prototype.UpdateTitle = /**
         * Updates the title on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetTitle(marker.Title); });
            };
        /**
         * Updates the visibility on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         */
        GoogleMarkerService.prototype.UpdateVisible = /**
         * Updates the visibility on the marker.
         *
         * \@memberof GoogleMarkerService
         * @param {?} marker
         * @return {?} - A promise that is fullfilled when the title has been updated.
         */
            function (marker) {
                return this._markers.get(marker).then(function (m) { return m.SetVisible(marker.Visible); });
            };
        GoogleMarkerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleMarkerService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: ClusterService },
                { type: core.NgZone }
            ];
        };
        return GoogleMarkerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of a clustering layer for the Google Map Provider.
     *
     * @export
     */
    var /**
     * Concrete implementation of a clustering layer for the Google Map Provider.
     *
     * @export
     */ GoogleMarkerClusterer = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates a new instance of the GoogleMarkerClusterer class.
         *
         * @param _layer GoogleMapTypes.MarkerClusterer. Native Google Maps Marker Clusterer supporting the cluster layer.
         * @param _maps MapService. MapService implementation to leverage for the layer.
         *
         * @memberof GoogleMarkerClusterer
         */
        function GoogleMarkerClusterer(_layer) {
            this._layer = _layer;
            this._isClustering = true;
            this._markerLookup = new Map();
            this._markers = new Array();
            this._pendingMarkers = new Array();
            this._mapclicks = 0;
            this._currentZoom = 0;
            this._visible = true;
        }
        Object.defineProperty(GoogleMarkerClusterer.prototype, "NativePrimitve", {
            get: /**
             * Get the native primitive underneath the abstraction layer.
             *
             * \@memberof GoogleMarkerClusterer
             * @return {?} GoogleMapTypes.MarkerClusterer.
             *
             */ function () {
                return this._layer;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an event listener for the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.AddListener = /**
         * Adds an event listener for the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native
         * layer supports.
         * @param {?} fn function. Handler to call when the event occurs.
         *
         * @return {?}
         */
            function (eventType, fn) {
                throw (new Error('Events are not supported on Google Cluster Layers. You can still add events to individual markers.'));
            };
        /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entity Marker. Entity to add to the layer.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.AddEntity = /**
         * Adds an entity to the layer. Use this method with caution as it will
         * trigger a recaluation of the clusters (and associated markers if approprite) for
         * each invocation. If you use this method to add many markers to the cluster, use
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entity Marker. Entity to add to the layer.
         *
         * @return {?}
         */
            function (entity) {
                var /** @type {?} */ isMarker = entity instanceof Marker;
                isMarker = entity instanceof GoogleMarker || isMarker;
                if (isMarker) {
                    entity.NativePrimitve.setMap(null);
                    // remove the marker from the map as the clusterer will control marker visibility.
                    if (entity.IsFirst) {
                        this.StopClustering();
                    }
                }
                if (entity.NativePrimitve && entity.Location) {
                    if (this._isClustering && this._visible) {
                        this._layer.addMarker(entity.NativePrimitve);
                        this._markers.push(entity);
                    }
                    else {
                        this._pendingMarkers.push(entity);
                    }
                    this._markerLookup.set(entity.NativePrimitve, entity);
                }
                if (isMarker) {
                    if (entity.IsLast) {
                        this.StartClustering();
                    }
                }
            };
        /**
         * Adds a number of markers to the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entities Array<Marker>. Entities to add to the layer.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.AddEntities = /**
         * Adds a number of markers to the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entities Array<Marker>. Entities to add to the layer.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                if (entities != null && Array.isArray(entities) && entities.length !== 0) {
                    var /** @type {?} */ e = entities.map(function (p) {
                        _this._markerLookup.set(p.NativePrimitve, p);
                        p.NativePrimitve.setMap(null);
                        // remove the marker from the map as the clusterer will control marker visibility.
                        return p.NativePrimitve;
                    });
                    if (this._isClustering && this._visible) {
                        this._layer.addMarkers(e);
                        (_a = this._markers).push.apply(_a, __spread(entities));
                    }
                    else {
                        // if layer is not visible, always add to pendingMarkers. Setting the layer to visible later
                        // will render the markers appropriately
                        // if layer is not visible, always add to pendingMarkers. Setting the layer to visible later
                        // will render the markers appropriately
                        (_b = this._pendingMarkers).push.apply(_b, __spread(entities));
                    }
                }
                var _a, _b;
            };
        /**
         * Deletes the clustering layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.Delete = /**
         * Deletes the clustering layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         */
            function () {
                this._layer.getMarkers().forEach(function (m) {
                    m.setMap(null);
                    // remove the marker from the map as the clusterer will control marker visibility.
                });
                this._layer.clearMarkers();
                this._markers.splice(0);
                this._pendingMarkers.splice(0);
            };
        /**
         * Returns the abstract marker used to wrap the Google Marker.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} pin
         * @return {?} Marker. The abstract marker object representing the pushpin.
         *
         */
        GoogleMarkerClusterer.prototype.GetMarkerFromGoogleMarker = /**
         * Returns the abstract marker used to wrap the Google Marker.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} pin
         * @return {?} Marker. The abstract marker object representing the pushpin.
         *
         */
            function (pin) {
                var /** @type {?} */ m = this._markerLookup.get(pin);
                return m;
            };
        /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?} IClusterOptions. The layer options.
         *
         */
        GoogleMarkerClusterer.prototype.GetOptions = /**
         * Returns the options governing the behavior of the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?} IClusterOptions. The layer options.
         *
         */
            function () {
                var /** @type {?} */ options = {
                    id: 0,
                    gridSize: this._layer.getGridSize(),
                    clusteringEnabled: this._layer.getGridSize() === 0,
                    maxZoom: this._layer.getMaxZoom(),
                    minimumClusterSize: this._layer.getMinClusterSize(),
                    placementMode: this._layer.isAverageCenter() ? ClusterPlacementMode.MeanValue : ClusterPlacementMode.FirstPin,
                    visible: this._visible,
                    zoomOnClick: this._layer.isZoomOnClick(),
                    styles: this._layer.getStyles()
                };
                return options;
            };
        /**
         * Returns the visibility state of the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
        GoogleMarkerClusterer.prototype.GetVisible = /**
         * Returns the visibility state of the layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?} Boolean. True is the layer is visible, false otherwise.
         *
         */
            function () {
                return this._visible;
            };
        /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entity Marker Entity to be removed from the layer.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.RemoveEntity = /**
         * Removes an entity from the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entity Marker Entity to be removed from the layer.
         *
         * @return {?}
         */
            function (entity) {
                if (entity.NativePrimitve && entity.Location) {
                    var /** @type {?} */ j = this._markers.indexOf(entity);
                    var /** @type {?} */ k = this._pendingMarkers.indexOf(entity);
                    if (j > -1) {
                        this._markers.splice(j, 1);
                    }
                    if (k > -1) {
                        this._pendingMarkers.splice(k, 1);
                    }
                    if (this._isClustering) {
                        this._layer.removeMarker(entity.NativePrimitve);
                    }
                    this._markerLookup.delete(entity.NativePrimitve);
                }
            };
        /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entities Array<Marker> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.SetEntities = /**
         * Sets the entities for the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} entities Array<Marker> containing
         * the entities to add to the cluster. This replaces any existing entities.
         *
         * @return {?}
         */
            function (entities) {
                var _this = this;
                this._layer.getMarkers().forEach(function (m) {
                    m.setMap(null);
                });
                this._layer.clearMarkers();
                this._markers.splice(0);
                this._pendingMarkers.splice(0);
                this._markerLookup.clear();
                var /** @type {?} */ p = new Array();
                entities.forEach(function (e) {
                    if (e.NativePrimitve && e.Location) {
                        e.NativePrimitve.setMap(null);
                        _this._markerLookup.set(e.NativePrimitve, e);
                        if (_this._visible) {
                            _this._markers.push(e);
                            p.push(e.NativePrimitve);
                        }
                        else {
                            _this._pendingMarkers.push(e);
                        }
                    }
                });
                this._layer.addMarkers(p);
            };
        /**
         * Sets the options for the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.SetOptions = /**
         * Sets the options for the cluster layer.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options
         * are merged with the default/existing options.
         *
         * @return {?}
         */
            function (options) {
                if (options.placementMode != null) {
                    throw (new Error('GoogleMarkerClusterer: PlacementMode option cannot be set after initial creation.'));
                }
                if (options.zoomOnClick != null) {
                    throw (new Error('GoogleMarkerClusterer: ZoomOnClick option cannot be set after initial creation.'));
                }
                if (options.callback != null) ;
                if (options.clusteringEnabled != null) {
                    this._layer.setMinClusterSize(options.clusteringEnabled ? 1 : 10000000);
                    this._layer.resetViewport();
                    this._layer.redraw();
                }
                if (options.gridSize != null && (options.clusteringEnabled == null || options.clusteringEnabled)) {
                    this._layer.setGridSize(options.gridSize);
                    this._layer.resetViewport();
                    this._layer.redraw();
                }
                if (options.maxZoom != null) {
                    this._layer.setMaxZoom(options.maxZoom);
                }
                if (options.minimumClusterSize != null) {
                    this._layer.setMinClusterSize(options.minimumClusterSize);
                }
                if (options.styles != null) {
                    this._layer.setStyles(options.styles);
                }
                if (options.visible != null) {
                    this.SetVisible(options.visible);
                }
            };
        /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.SetVisible = /**
         * Toggles the cluster layer visibility.
         *
         * \@memberof GoogleMarkerClusterer
         * @param {?} visible Boolean true to make the layer visible, false to hide the layer.
         *
         * @return {?}
         */
            function (visible) {
                var /** @type {?} */ map = visible ? this._layer.getMap() : null;
                if (!visible) {
                    this._layer.resetViewport(true);
                }
                else {
                    var /** @type {?} */ p_1 = new Array();
                    if (this._pendingMarkers.length > 0) {
                        this._pendingMarkers.forEach(function (e) {
                            if (e.NativePrimitve && e.Location) {
                                p_1.push(/** @type {?} */ (e.NativePrimitve));
                            }
                        });
                        this._layer.addMarkers(p_1);
                        this._markers = this._markers.concat(this._pendingMarkers.splice(0));
                    }
                    else {
                        this._layer.redraw();
                    }
                }
                this._visible = visible;
            };
        /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         */
        GoogleMarkerClusterer.prototype.StartClustering = /**
         * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities
         * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._isClustering) {
                    return;
                }
                if (this._visible) {
                    var /** @type {?} */ p_2 = new Array();
                    this._markers.forEach(function (e) {
                        if (e.NativePrimitve && e.Location) {
                            p_2.push(/** @type {?} */ (e.NativePrimitve));
                        }
                    });
                    this._pendingMarkers.forEach(function (e) {
                        if (e.NativePrimitve && e.Location) {
                            p_2.push(/** @type {?} */ (e.NativePrimitve));
                        }
                    });
                    this._layer.addMarkers(p_2);
                    this._markers = this._markers.concat(this._pendingMarkers.splice(0));
                }
                if (!this._visible) {
                    // only add the markers if the layer is visible. Otherwise, keep them pending. They would be added once the
                    // layer is set to visible.
                    rxjs.timer(0).subscribe(function () {
                        _this._layer.resetViewport(true);
                    });
                }
                this._isClustering = true;
            };
        /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         *
         */
        GoogleMarkerClusterer.prototype.StopClustering = /**
         * Stop to actually cluster the entities in a cluster layer.
         * This method is used for performance reasons as adding an entitiy will recalculate all clusters.
         * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is
         * complete to recalculate the clusters.
         *
         * \@memberof GoogleMarkerClusterer
         * @return {?}
         *
         */
            function () {
                if (!this._isClustering) {
                    return;
                }
                this._isClustering = false;
            };
        return GoogleMarkerClusterer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the MapService abstract implementing a Google Maps provider
     *
     * @export
     */
    var GoogleMapService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleMapService.
         * @param _loader MapAPILoader instance implemented for Google Maps. This instance will generally be injected.
         * @param _zone NgZone object to enable zone aware promises. This will generally be injected.
         *
         * @memberof GoogleMapService
         */
        function GoogleMapService(_loader, _zone) {
            var _this = this;
            this._loader = _loader;
            this._zone = _zone;
            this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
            this._config = ((this._loader)).Config;
        }
        Object.defineProperty(GoogleMapService.prototype, "MapInstance", {
            get: /**
             * Gets the Google Map control instance underlying the implementation
             *
             * \@readonly
             * \@memberof GoogleMapService
             * @return {?}
             */ function () { return this._mapInstance; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMapService.prototype, "MapPromise", {
            get: /**
             * Gets a Promise for a Google Map control instance underlying the implementation. Use this instead of {\@link MapInstance} if you
             * are not sure if and when the instance will be created.
             * \@readonly
             * \@memberof GoogleMapService
             * @return {?}
             */ function () { return this._map; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GoogleMapService.prototype, "MapSize", {
            get: /**
             * Gets the maps physical size.
             *
             * \@readonly
             * @abstract
             * \@memberof BingMapService
             * @return {?}
             */ function () {
                if (this.MapInstance) {
                    var /** @type {?} */ el = this.MapInstance.getDiv();
                    var /** @type {?} */ s = { width: el.offsetWidth, height: el.offsetHeight };
                    return s;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates a canvas overlay layer to perform custom drawing over the map with out
         * some of the overhead associated with going through the Map objects.
         * \@memberof GoogleMapService
         * @param {?} drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @return {?} - Promise of a {\@link CanvasOverlay} object.
         */
        GoogleMapService.prototype.CreateCanvasOverlay = /**
         * Creates a canvas overlay layer to perform custom drawing over the map with out
         * some of the overhead associated with going through the Map objects.
         * \@memberof GoogleMapService
         * @param {?} drawCallback A callback function that is triggered when the canvas is ready to be
         * rendered for the current map view.
         * @return {?} - Promise of a {\@link CanvasOverlay} object.
         */
            function (drawCallback) {
                return this._map.then(function (map) {
                    var /** @type {?} */ overlay = new GoogleCanvasOverlay(drawCallback);
                    overlay.SetMap(map);
                    return overlay;
                });
            };
        /**
         * @param {?} options
         * @return {?}
         */
        GoogleMapService.prototype.CreateClusterLayer = /**
         * @param {?} options
         * @return {?}
         */
            function (options) {
                return this._map.then(function (map) {
                    var /** @type {?} */ updateOptions = false;
                    var /** @type {?} */ markerClusterer = new MarkerClusterer(map, [], options);
                    var /** @type {?} */ clusterLayer = new GoogleMarkerClusterer(markerClusterer);
                    var /** @type {?} */ o = {
                        id: options.id
                    };
                    if (!options.visible) {
                        o.visible = false;
                        updateOptions = true;
                    }
                    if (!options.clusteringEnabled) {
                        o.clusteringEnabled = false;
                        updateOptions = true;
                    }
                    if (updateOptions) {
                        clusterLayer.SetOptions(o);
                    }
                    return clusterLayer;
                });
            };
        /**
         * Creates an information window for a map position
         *
         * \@memberof GoogleMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.
         *
         */
        GoogleMapService.prototype.CreateInfoWindow = /**
         * Creates an information window for a map position
         *
         * \@memberof GoogleMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    var /** @type {?} */ o = GoogleConversions.TranslateInfoWindowOptions(options);
                    var /** @type {?} */ infoWindow = new google.maps.InfoWindow(o);
                    return new GoogleInfoWindow(infoWindow, _this);
                });
            };
        /**
         * Creates a map layer within the map context
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options for the layer. See {\@link ILayerOptions}
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.Layer object.
         *
         */
        GoogleMapService.prototype.CreateLayer = /**
         * Creates a map layer within the map context
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options for the layer. See {\@link ILayerOptions}
         * @return {?} - Promise of a {\@link Layer} object, which models the underlying Microsoft.Maps.Layer object.
         *
         */
            function (options) {
                var _this = this;
                return this._map.then(function (map) {
                    return new GoogleLayer(map, _this, options.id);
                });
            };
        /**
         * Creates a map instance
         *
         * \@memberof GoogleMapService
         * @param {?} el - HTML element to host the map.
         * @param {?} mapOptions - Map options
         * @return {?} - Promise fullfilled once the map has been created.
         *
         */
        GoogleMapService.prototype.CreateMap = /**
         * Creates a map instance
         *
         * \@memberof GoogleMapService
         * @param {?} el - HTML element to host the map.
         * @param {?} mapOptions - Map options
         * @return {?} - Promise fullfilled once the map has been created.
         *
         */
            function (el, mapOptions) {
                var _this = this;
                return this._loader.Load().then(function () {
                    // apply mixins
                    MixinMapLabelWithOverlayView$1();
                    MixinCanvasOverlay$1();
                    // execute map startup
                    if (!mapOptions.mapTypeId == null) {
                        mapOptions.mapTypeId = MapTypeId.hybrid;
                    }
                    if (_this._mapInstance != null) {
                        _this.DisposeMap();
                    }
                    var /** @type {?} */ o = GoogleConversions.TranslateOptions(mapOptions);
                    var /** @type {?} */ map = new google.maps.Map(el, o);
                    if (mapOptions.bounds) {
                        map.fitBounds(GoogleConversions.TranslateBounds(mapOptions.bounds));
                    }
                    _this._mapInstance = map;
                    _this._mapResolver(map);
                    return;
                });
            };
        /**
         * Creates a Google map marker within the map context
         *
         * \@memberof GoogleMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.
         *
         */
        GoogleMapService.prototype.CreateMarker = /**
         * Creates a Google map marker within the map context
         *
         * \@memberof GoogleMapService
         * @param {?=} options
         * @return {?} - Promise of a {\@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.
         *
         */
            function (options) {
                if (options === void 0) {
                    options = /** @type {?} */ ({});
                }
                var /** @type {?} */ payload = function (x, map) {
                    var /** @type {?} */ marker = new google.maps.Marker(x);
                    var /** @type {?} */ m = new GoogleMarker(marker);
                    m.IsFirst = options.isFirst;
                    m.IsLast = options.isLast;
                    if (options.metadata) {
                        options.metadata.forEach(function (val, key) { return m.Metadata.set(key, val); });
                    }
                    marker.setMap(map);
                    return m;
                };
                return this._map.then(function (map) {
                    var /** @type {?} */ o = GoogleConversions.TranslateMarkerOptions(options);
                    if (options.iconInfo && options.iconInfo.markerType) {
                        var /** @type {?} */ s = Marker.CreateMarker(options.iconInfo);
                        if (typeof (s) === 'string') {
                            o.icon = s;
                            return payload(o, map);
                        }
                        else {
                            return s.then(function (x) {
                                o.icon = x.icon;
                                return payload(o, map);
                            });
                        }
                    }
                    else {
                        return payload(o, map);
                    }
                });
            };
        /**
         * Creates a polygon within the Google Map map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polygon. See {\@link IPolygonOptions}.
         * @return {?} - Promise of a {\@link Polygon} object, which models the underlying native polygon.
         *
         */
        GoogleMapService.prototype.CreatePolygon = /**
         * Creates a polygon within the Google Map map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polygon. See {\@link IPolygonOptions}.
         * @return {?} - Promise of a {\@link Polygon} object, which models the underlying native polygon.
         *
         */
            function (options) {
                return this._map.then(function (map) {
                    var /** @type {?} */ o = GoogleConversions.TranslatePolygonOptions(options);
                    var /** @type {?} */ polygon = new google.maps.Polygon(o);
                    polygon.setMap(map);
                    var /** @type {?} */ p = new GooglePolygon(polygon);
                    if (options.metadata) {
                        options.metadata.forEach(function (val, key) { return p.Metadata.set(key, val); });
                    }
                    if (options.title && options.title !== '') {
                        p.Title = options.title;
                    }
                    if (options.showLabel != null) {
                        p.ShowLabel = options.showLabel;
                    }
                    if (options.showTooltip != null) {
                        p.ShowTooltip = options.showTooltip;
                    }
                    if (options.labelMaxZoom != null) {
                        p.LabelMaxZoom = options.labelMaxZoom;
                    }
                    if (options.labelMinZoom != null) {
                        p.LabelMinZoom = options.labelMinZoom;
                    }
                    return p;
                });
            };
        /**
         * Creates a polyline within the Google Map map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polyline. See {\@link IPolylineOptions}.
         * @return {?} - Promise of a {\@link Polyline} object (or an array therefore for complex paths)
         * which models the underlying native polyline.
         *
         */
        GoogleMapService.prototype.CreatePolyline = /**
         * Creates a polyline within the Google Map map context
         *
         * @abstract
         * \@memberof MapService
         * @param {?} options - Options for the polyline. See {\@link IPolylineOptions}.
         * @return {?} - Promise of a {\@link Polyline} object (or an array therefore for complex paths)
         * which models the underlying native polyline.
         *
         */
            function (options) {
                var /** @type {?} */ polyline;
                return this._map.then(function (map) {
                    var /** @type {?} */ o = GoogleConversions.TranslatePolylineOptions(options);
                    if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {
                        o.path = GoogleConversions.TranslatePaths(options.path)[0];
                        polyline = new google.maps.Polyline(o);
                        polyline.setMap(map);
                        var /** @type {?} */ pl_1 = new GooglePolyline(polyline);
                        if (options.metadata) {
                            options.metadata.forEach(function (val, key) { return pl_1.Metadata.set(key, val); });
                        }
                        if (options.title && options.title !== '') {
                            pl_1.Title = options.title;
                        }
                        if (options.showTooltip != null) {
                            pl_1.ShowTooltip = options.showTooltip;
                        }
                        return pl_1;
                    }
                    else {
                        var /** @type {?} */ paths = GoogleConversions.TranslatePaths(options.path);
                        var /** @type {?} */ lines_1 = new Array();
                        paths.forEach(function (p) {
                            o.path = p;
                            polyline = new google.maps.Polyline(o);
                            polyline.setMap(map);
                            var /** @type {?} */ pl = new GooglePolyline(polyline);
                            if (options.metadata) {
                                options.metadata.forEach(function (val, key) { return pl.Metadata.set(key, val); });
                            }
                            if (options.title && options.title !== '') {
                                pl.Title = options.title;
                            }
                            if (options.showTooltip != null) {
                                pl.ShowTooltip = options.showTooltip;
                            }
                            lines_1.push(pl);
                        });
                        return lines_1;
                    }
                });
            };
        /**
         * Deletes a layer from the map.
         *
         * \@memberof GoogleMapService
         * @param {?} layer - Layer to delete. See {\@link Layer}. This method expects the Google specific Layer model implementation.
         * @return {?} - Promise fullfilled when the layer has been removed.
         *
         */
        GoogleMapService.prototype.DeleteLayer = /**
         * Deletes a layer from the map.
         *
         * \@memberof GoogleMapService
         * @param {?} layer - Layer to delete. See {\@link Layer}. This method expects the Google specific Layer model implementation.
         * @return {?} - Promise fullfilled when the layer has been removed.
         *
         */
            function (layer) {
                // return resolved promise as there is no conept of a custom layer in Google.
                return Promise.resolve();
            };
        /**
         * Dispaose the map and associated resoures.
         *
         * \@memberof GoogleMapService
         * @return {?}
         */
        GoogleMapService.prototype.DisposeMap = /**
         * Dispaose the map and associated resoures.
         *
         * \@memberof GoogleMapService
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._map == null && this._mapInstance == null) {
                    return;
                }
                if (this._mapInstance != null) {
                    this._mapInstance = null;
                    this._map = new Promise(function (resolve) { _this._mapResolver = resolve; });
                }
            };
        /**
         * Gets the geo coordinates of the map center
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the center. See {\@link ILatLong}.
         *
         */
        GoogleMapService.prototype.GetCenter = /**
         * Gets the geo coordinates of the map center
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the goe location of the center. See {\@link ILatLong}.
         *
         */
            function () {
                return this._map.then(function (map) {
                    var /** @type {?} */ center = map.getCenter();
                    return /** @type {?} */ ({
                        latitude: center.lat(),
                        longitude: center.lng()
                    });
                });
            };
        /**
         * Gets the geo coordinates of the map bounding box
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the geo location of the bounding box. See {\@link IBox}.
         *
         */
        GoogleMapService.prototype.GetBounds = /**
         * Gets the geo coordinates of the map bounding box
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the geo location of the bounding box. See {\@link IBox}.
         *
         */
            function () {
                return this._map.then(function (map) {
                    var /** @type {?} */ box = map.getBounds();
                    return /** @type {?} */ ({
                        maxLatitude: box.getNorthEast().lat(),
                        maxLongitude: Math.max(box.getNorthEast().lng(), box.getSouthWest().lng()),
                        minLatitude: box.getSouthWest().lat(),
                        minLongitude: Math.min(box.getNorthEast().lng(), box.getSouthWest().lng()),
                        center: { latitude: box.getCenter().lat(), longitude: box.getCenter().lng() },
                        padding: 0
                    });
                });
            };
        /**
         * Gets the current zoom level of the map.
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the zoom level.
         *
         */
        GoogleMapService.prototype.GetZoom = /**
         * Gets the current zoom level of the map.
         *
         * \@memberof GoogleMapService
         * @return {?} - A promise that when fullfilled contains the zoom level.
         *
         */
            function () {
                return this._map.then(function (map) { return map.getZoom(); });
            };
        /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof GoogleMapService
         * @param {?} loc - The geo coordinates to translate.
         * @return {?} - Promise of an {\@link IPoint} interface representing the pixels. This promise resolves to null
         * if the goe coordinates are not in the view port.
         *
         */
        GoogleMapService.prototype.LocationToPoint = /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof GoogleMapService
         * @param {?} loc - The geo coordinates to translate.
         * @return {?} - Promise of an {\@link IPoint} interface representing the pixels. This promise resolves to null
         * if the goe coordinates are not in the view port.
         *
         */
            function (loc) {
                return this._map.then(function (m) {
                    var /** @type {?} */ crossesDateLine = false;
                    var /** @type {?} */ l = GoogleConversions.TranslateLocationObject(loc);
                    var /** @type {?} */ p = m.getProjection();
                    var /** @type {?} */ s = Math.pow(2, m.getZoom());
                    var /** @type {?} */ b = m.getBounds();
                    if (b.getCenter().lng() < b.getSouthWest().lng() ||
                        b.getCenter().lng() > b.getNorthEast().lng()) {
                        crossesDateLine = true;
                    }
                    var /** @type {?} */ offsetY = p.fromLatLngToPoint(b.getNorthEast()).y;
                    var /** @type {?} */ offsetX = p.fromLatLngToPoint(b.getSouthWest()).x;
                    var /** @type {?} */ point = p.fromLatLngToPoint(l);
                    return {
                        x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),
                        y: Math.floor((point.y - offsetY) * s)
                    };
                });
            };
        /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} locs
         * @return {?} - Promise of an {\@link IPoint} interface array representing the pixels.
         *
         */
        GoogleMapService.prototype.LocationsToPoints = /**
         * Provides a conversion of geo coordinates to pixels on the map control.
         *
         * \@memberof BingMapService
         * @param {?} locs
         * @return {?} - Promise of an {\@link IPoint} interface array representing the pixels.
         *
         */
            function (locs) {
                return this._map.then(function (m) {
                    var /** @type {?} */ crossesDateLine = false;
                    var /** @type {?} */ p = m.getProjection();
                    var /** @type {?} */ s = Math.pow(2, m.getZoom());
                    var /** @type {?} */ b = m.getBounds();
                    if (b.getCenter().lng() < b.getSouthWest().lng() ||
                        b.getCenter().lng() > b.getNorthEast().lng()) {
                        crossesDateLine = true;
                    }
                    var /** @type {?} */ offsetX = p.fromLatLngToPoint(b.getSouthWest()).x;
                    var /** @type {?} */ offsetY = p.fromLatLngToPoint(b.getNorthEast()).y;
                    var /** @type {?} */ l = locs.map(function (ll) {
                        var /** @type {?} */ l1 = GoogleConversions.TranslateLocationObject(ll);
                        var /** @type {?} */ point = p.fromLatLngToPoint(l1);
                        return {
                            x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),
                            y: Math.floor((point.y - offsetY) * s)
                        };
                    });
                    return l;
                });
            };
        /**
         * Centers the map on a geo location.
         *
         * \@memberof GoogleMapService
         * @param {?} latLng - GeoCoordinates around which to center the map. See {\@link ILatLong}
         * @return {?} - Promise that is fullfilled when the center operations has been completed.
         *
         */
        GoogleMapService.prototype.SetCenter = /**
         * Centers the map on a geo location.
         *
         * \@memberof GoogleMapService
         * @param {?} latLng - GeoCoordinates around which to center the map. See {\@link ILatLong}
         * @return {?} - Promise that is fullfilled when the center operations has been completed.
         *
         */
            function (latLng) {
                return this._map.then(function (map) {
                    var /** @type {?} */ center = GoogleConversions.TranslateLocationObject(latLng);
                    map.setCenter(center);
                });
            };
        /**
         * Sets the generic map options.
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
        GoogleMapService.prototype.SetMapOptions = /**
         * Sets the generic map options.
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
            function (options) {
                this._map.then(function (m) {
                    var /** @type {?} */ o = GoogleConversions.TranslateOptions(options);
                    m.setOptions(o);
                });
            };
        /**
         * Sets the view options of the map.
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
        GoogleMapService.prototype.SetViewOptions = /**
         * Sets the view options of the map.
         *
         * \@memberof GoogleMapService
         * @param {?} options - Options to set.
         *
         * @return {?}
         */
            function (options) {
                this._map.then(function (m) {
                    if (options.bounds) {
                        m.fitBounds(GoogleConversions.TranslateBounds(options.bounds));
                    }
                    var /** @type {?} */ o = GoogleConversions.TranslateOptions(options);
                    m.setOptions(o);
                });
            };
        /**
         * Sets the zoom level of the map.
         *
         * \@memberof GoogleMapService
         * @param {?} zoom - Zoom level to set.
         * @return {?} - A Promise that is fullfilled once the zoom operation is complete.
         *
         */
        GoogleMapService.prototype.SetZoom = /**
         * Sets the zoom level of the map.
         *
         * \@memberof GoogleMapService
         * @param {?} zoom - Zoom level to set.
         * @return {?} - A Promise that is fullfilled once the zoom operation is complete.
         *
         */
            function (zoom) {
                return this._map.then(function (map) { return map.setZoom(zoom); });
            };
        /**
         * Creates an event subscription
         *
         * \@memberof GoogleMapService
         * @template E
         * @param {?} eventName - The name of the event (e.g. 'click')
         * @return {?} - An observable of type E that fires when the event occurs.
         *
         */
        GoogleMapService.prototype.SubscribeToMapEvent = /**
         * Creates an event subscription
         *
         * \@memberof GoogleMapService
         * @template E
         * @param {?} eventName - The name of the event (e.g. 'click')
         * @return {?} - An observable of type E that fires when the event occurs.
         *
         */
            function (eventName) {
                var _this = this;
                var /** @type {?} */ googleEventName = GoogleMapEventsLookup[eventName];
                return rxjs.Observable.create(function (observer) {
                    _this._map.then(function (m) {
                        m.addListener(googleEventName, function (e) {
                            _this._zone.run(function () { return observer.next(e); });
                        });
                    });
                });
            };
        /**
         * Triggers the given event name on the map instance.
         *
         * \@memberof GoogleMapService
         * @param {?} eventName - Event to trigger.
         * @return {?} - A promise that is fullfilled once the event is triggered.
         *
         */
        GoogleMapService.prototype.TriggerMapEvent = /**
         * Triggers the given event name on the map instance.
         *
         * \@memberof GoogleMapService
         * @param {?} eventName - Event to trigger.
         * @return {?} - A promise that is fullfilled once the event is triggered.
         *
         */
            function (eventName) {
                return this._map.then(function (m) { return google.maps.event.trigger(m, eventName, null); });
            };
        GoogleMapService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleMapService.ctorParameters = function () {
            return [
                { type: MapAPILoader },
                { type: core.NgZone }
            ];
        };
        return GoogleMapService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the Polygon Service abstract class for Google Maps.
     *
     * @export
     */
    var GooglePolygonService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GooglePolygonService.
         * @param _mapService - {@link MapService} instance. The concrete {@link GoogleMapService} implementation is expected.
         * @param _layerService - {@link GoogleLayerService} instance.
         * The concrete {@link GoogleLayerService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof GooglePolygonService
         */
        function GooglePolygonService(_mapService, _layerService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._zone = _zone;
            this._polygons = new Map();
        }
        /**
         * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} to be added.
         *
         * @return {?}
         */
        GooglePolygonService.prototype.AddPolygon = /**
         * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} to be added.
         *
         * @return {?}
         */
            function (polygon) {
                var /** @type {?} */ o = {
                    id: polygon.Id,
                    clickable: polygon.Clickable,
                    draggable: polygon.Draggable,
                    editable: polygon.Editable,
                    fillColor: polygon.FillColor,
                    fillOpacity: polygon.FillOpacity,
                    geodesic: polygon.Geodesic,
                    labelMaxZoom: polygon.LabelMaxZoom,
                    labelMinZoom: polygon.LabelMinZoom,
                    paths: polygon.Paths,
                    showLabel: polygon.ShowLabel,
                    showTooltip: polygon.ShowTooltip,
                    strokeColor: polygon.StrokeColor,
                    strokeOpacity: polygon.StrokeOpacity,
                    strokeWeight: polygon.StrokeWeight,
                    title: polygon.Title,
                    visible: polygon.Visible,
                    zIndex: polygon.zIndex,
                };
                var /** @type {?} */ polygonPromise = this._mapService.CreatePolygon(o);
                this._polygons.set(polygon, polygonPromise);
            };
        /**
         * Registers an event delegate for a polygon.
         *
         * \@memberof GooglePolygonService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        GooglePolygonService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a polygon.
         *
         * \@memberof GooglePolygonService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, polygon) {
                var _this = this;
                return rxjs.Observable.create(function (observer) {
                    _this._polygons.get(polygon).then(function (p) {
                        p.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });
                    });
                });
            };
        /**
         * Deletes a polygon.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polygon has been deleted.
         *
         */
        GooglePolygonService.prototype.DeletePolygon = /**
         * Deletes a polygon.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polygon has been deleted.
         *
         */
            function (polygon) {
                var _this = this;
                var /** @type {?} */ m = this._polygons.get(polygon);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        l.Delete();
                        _this._polygons.delete(polygon);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the polygon on the click location
         *
         * @abstract
         * \@memberof GooglePolygonService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
        GooglePolygonService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the polygon on the click location
         *
         * @abstract
         * \@memberof GooglePolygonService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked marker.
         *
         */
            function (e) {
                return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };
            };
        /**
         * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to obtain the polygon model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polygon} implementation of the underlying platform.
         *
         */
        GooglePolygonService.prototype.GetNativePolygon = /**
         * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - The {\@link MapPolygonDirective} for which to obtain the polygon model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polygon} implementation of the underlying platform.
         *
         */
            function (polygon) {
                return this._polygons.get(polygon);
            };
        /**
         * Set the polygon options.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @param {?} options - {\@link IPolygonOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polygon options have been set.
         *
         */
        GooglePolygonService.prototype.SetOptions = /**
         * Set the polygon options.
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @param {?} options - {\@link IPolygonOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polygon options have been set.
         *
         */
            function (polygon, options) {
                return this._polygons.get(polygon).then(function (l) { l.SetOptions(options); });
            };
        /**
         * Updates the Polygon path
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @return {?} - A promise fullfilled once the polygon has been updated.
         *
         */
        GooglePolygonService.prototype.UpdatePolygon = /**
         * Updates the Polygon path
         *
         * \@memberof GooglePolygonService
         * @param {?} polygon - {\@link MapPolygonDirective} to be updated.
         * @return {?} - A promise fullfilled once the polygon has been updated.
         *
         */
            function (polygon) {
                var /** @type {?} */ m = this._polygons.get(polygon);
                if (m == null || polygon.Paths == null || !Array.isArray(polygon.Paths) || polygon.Paths.length === 0) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    if (Array.isArray(polygon.Paths[0])) {
                        l.SetPaths(polygon.Paths);
                    }
                    else {
                        l.SetPath(/** @type {?} */ (polygon.Paths));
                    }
                });
            };
        GooglePolygonService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GooglePolygonService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: core.NgZone }
            ];
        };
        return GooglePolygonService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete implementation of the Polyline Service abstract class for Google Maps.
     *
     * @export
     */
    var GooglePolylineService = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GooglePolylineService.
         * @param _mapService - {@link MapService} instance. The concrete {@link GoogleMapService} implementation is expected.
         * @param _layerService - {@link LayerService} instance.
         * The concrete {@link GoogleLayerService} implementation is expected.
         * @param _zone - NgZone instance to support zone aware promises.
         *
         * @memberof GooglePolylineService
         */
        function GooglePolylineService(_mapService, _layerService, _zone) {
            this._mapService = _mapService;
            this._layerService = _layerService;
            this._zone = _zone;
            this._polylines = new Map();
        }
        /**
         * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} to be added.
         *
         * @return {?}
         */
        GooglePolylineService.prototype.AddPolyline = /**
         * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a
         * correcsponding layer.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} to be added.
         *
         * @return {?}
         */
            function (polyline) {
                var /** @type {?} */ o = {
                    id: polyline.Id,
                    clickable: polyline.Clickable,
                    draggable: polyline.Draggable,
                    editable: polyline.Editable,
                    geodesic: polyline.Geodesic,
                    path: polyline.Path,
                    showTooltip: polyline.ShowTooltip,
                    strokeColor: polyline.StrokeColor,
                    strokeOpacity: polyline.StrokeOpacity,
                    strokeWeight: polyline.StrokeWeight,
                    title: polyline.Title,
                    visible: polyline.Visible,
                    zIndex: polyline.zIndex,
                };
                var /** @type {?} */ polylinePromise = this._mapService.CreatePolyline(o);
                this._polylines.set(polyline, polylinePromise);
            };
        /**
         * Registers an event delegate for a line.
         *
         * \@memberof GooglePolylineService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
        GooglePolylineService.prototype.CreateEventObservable = /**
         * Registers an event delegate for a line.
         *
         * \@memberof GooglePolylineService
         * @template T
         * @param {?} eventName - The name of the event to register (e.g. 'click')
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to register the event.
         * @return {?} - Observable emiting an instance of T each time the event occurs.
         *
         */
            function (eventName, polyline) {
                var _this = this;
                return rxjs.Observable.create(function (observer) {
                    _this._polylines.get(polyline).then(function (p) {
                        var /** @type {?} */ x = Array.isArray(p) ? p : [p];
                        x.forEach(function (line) { return line.AddListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); }); });
                    });
                });
            };
        /**
         * Deletes a polyline.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polyline has been deleted.
         *
         */
        GooglePolylineService.prototype.DeletePolyline = /**
         * Deletes a polyline.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be deleted.
         * @return {?} - A promise fullfilled once the polyline has been deleted.
         *
         */
            function (polyline) {
                var _this = this;
                var /** @type {?} */ m = this._polylines.get(polyline);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        var /** @type {?} */ x = Array.isArray(l) ? l : [l];
                        x.forEach(function (line) { return line.Delete(); });
                        _this._polylines.delete(polyline);
                    });
                });
            };
        /**
         * Obtains geo coordinates for the line on the click location
         *
         * @abstract
         * \@memberof GooglePolylineService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked line.
         *
         */
        GooglePolylineService.prototype.GetCoordinatesFromClick = /**
         * Obtains geo coordinates for the line on the click location
         *
         * @abstract
         * \@memberof GooglePolylineService
         * @param {?} e - The mouse event.
         * @return {?} - {\@link ILatLong} containing the geo coordinates of the clicked line.
         *
         */
            function (e) {
                if (!e) {
                    return null;
                }
                if (!e.latLng) {
                    return null;
                }
                if (!e.latLng.lat || !e.latLng.lng) {
                    return null;
                }
                return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };
            };
        /**
         * Obtains the polyline model for the line allowing access to native implementation functionatiliy.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to obtain the polyline model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polyline}
         * implementation of the underlying platform. For complex paths, returns an array of polylines.
         *
         */
        GooglePolylineService.prototype.GetNativePolyline = /**
         * Obtains the polyline model for the line allowing access to native implementation functionatiliy.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - The {\@link MapPolylineDirective} for which to obtain the polyline model.
         * @return {?} - A promise that when fullfilled contains the {\@link Polyline}
         * implementation of the underlying platform. For complex paths, returns an array of polylines.
         *
         */
            function (polyline) {
                return this._polylines.get(polyline);
            };
        /**
         * Set the polyline options.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @param {?} options - {\@link IPolylineOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polyline options have been set.
         *
         */
        GooglePolylineService.prototype.SetOptions = /**
         * Set the polyline options.
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @param {?} options - {\@link IPolylineOptions} object containing the options. Options will be merged with the
         * options already on the underlying object.
         * @return {?} - A promise fullfilled once the polyline options have been set.
         *
         */
            function (polyline, options) {
                return this._polylines.get(polyline).then(function (l) {
                    var /** @type {?} */ x = Array.isArray(l) ? l : [l];
                    x.forEach(function (line) { return line.SetOptions(options); });
                });
            };
        /**
         * Updates the Polyline path
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @return {?} - A promise fullfilled once the polyline has been updated.
         *
         */
        GooglePolylineService.prototype.UpdatePolyline = /**
         * Updates the Polyline path
         *
         * \@memberof GooglePolylineService
         * @param {?} polyline - {\@link MapPolylineDirective} to be updated.
         * @return {?} - A promise fullfilled once the polyline has been updated.
         *
         */
            function (polyline) {
                var _this = this;
                var /** @type {?} */ m = this._polylines.get(polyline);
                if (m == null) {
                    return Promise.resolve();
                }
                return m.then(function (l) {
                    return _this._zone.run(function () {
                        var /** @type {?} */ x = Array.isArray(l) ? l : [l];
                        var /** @type {?} */ p = polyline.Path.length > 0 && Array.isArray(polyline.Path[0]) ? /** @type {?} */ (polyline.Path) : /** @type {?} */ ([polyline.Path]);
                        x.forEach(function (line, index) {
                            if (p.length > index) {
                                line.SetPath(p[index]);
                            }
                        });
                        if (Array.isArray(l) && l.length > p.length) {
                            l.splice(p.length - 1).forEach(function (line) { return line.Delete(); });
                        }
                    });
                });
            };
        GooglePolylineService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GooglePolylineService.ctorParameters = function () {
            return [
                { type: MapService },
                { type: LayerService },
                { type: core.NgZone }
            ];
        };
        return GooglePolylineService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Implements a factory to create three necessary Google Maps specific service instances.
     *
     * @export
     */
    var GoogleMapServiceFactory = (function () {
        ///
        /// Constructor
        ///
        /**
         * Creates an instance of GoogleMapServiceFactory.
         * @param _loader - {@link MapAPILoader} implementation for the Google Map provider.
         * @param _zone - NgZone object to implement zone aware promises.
         *
         * @memberof GoogleMapServiceFactory
         */
        function GoogleMapServiceFactory(_loader, _zone) {
            var _this = this;
            this._loader = _loader;
            this._zone = _zone;
            this._map =
                new Promise(function (resolve) { _this._mapResolver = resolve; });
        }
        /**
         * Creates the map service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @return {?} - {\@link MapService}. A concreted instance of the {\@link GoogleMapService}.
         *
         */
        GoogleMapServiceFactory.prototype.Create = /**
         * Creates the map service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @return {?} - {\@link MapService}. A concreted instance of the {\@link GoogleMapService}.
         *
         */
            function () {
                return new GoogleMapService(this._loader, this._zone);
            };
        /**
         * Creates the cluster service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link ClusterService}. A concreted instance of the {\@link GoogleClusterService}.
         *
         */
        GoogleMapServiceFactory.prototype.CreateClusterService = /**
         * Creates the cluster service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link ClusterService}. A concreted instance of the {\@link GoogleClusterService}.
         *
         */
            function (_mapService) {
                return new GoogleClusterService(_mapService, this._zone);
            };
        /**
         * Creates thh info box service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @param {?} _markerService
         * @return {?} - {\@link InfoBoxService}. A concreted instance of the {\@link GoogleInfoBoxService}.
         *
         */
        GoogleMapServiceFactory.prototype.CreateInfoBoxService = /**
         * Creates thh info box service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @param {?} _markerService
         * @return {?} - {\@link InfoBoxService}. A concreted instance of the {\@link GoogleInfoBoxService}.
         *
         */
            function (_mapService, _markerService) {
                return new GoogleInfoBoxService(_mapService, _markerService, this._zone);
            };
        /**
         * Creates the layer service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link LayerService}. A concreted instance of the {\@link GoogleLayerService}.
         *
         */
        GoogleMapServiceFactory.prototype.CreateLayerService = /**
         * Creates the layer service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @return {?} - {\@link LayerService}. A concreted instance of the {\@link GoogleLayerService}.
         *
         */
            function (_mapService) {
                return new GoogleLayerService(_mapService, this._zone);
            };
        /**
         * Creates the marker service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @param {?} _layerService
         * @param {?} _clusterService
         * @return {?} - {\@link MarkerService}. A concreted instance of the {\@link GoogleMarkerService}.
         *
         */
        GoogleMapServiceFactory.prototype.CreateMarkerService = /**
         * Creates the marker service for the Google Maps implementation.
         *
         * \@memberof GoogleMapServiceFactory
         * @param {?} _mapService
         * @param {?} _layerService
         * @param {?} _clusterService
         * @return {?} - {\@link MarkerService}. A concreted instance of the {\@link GoogleMarkerService}.
         *
         */
            function (_mapService, _layerService, _clusterService) {
                return new GoogleMarkerService(_mapService, _layerService, _clusterService, this._zone);
            };
        /**
         * Creates the polygon service for the Google Maps implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolygonService} implementation for the underlying map architecture.
         *
         */
        GoogleMapServiceFactory.prototype.CreatePolygonService = /**
         * Creates the polygon service for the Google Maps implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolygonService} implementation for the underlying map architecture.
         *
         */
            function (map, layers) {
                return new GooglePolygonService(map, layers, this._zone);
            };
        /**
         * Creates the polyline service for the Google Maps implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolylineService} implementation for the underlying map architecture.
         *
         */
        GoogleMapServiceFactory.prototype.CreatePolylineService = /**
         * Creates the polyline service for the Google Maps implementation.
         *
         * \@memberof MapServiceFactory
         * @param {?} map - {\@link MapService} implementation for thh underlying map archticture.
         * @param {?} layers - {\@link LayerService} implementation for the underlying map architecture.
         * @return {?} - {\@link PolylineService} implementation for the underlying map architecture.
         *
         */
            function (map, layers) {
                return new GooglePolylineService(map, layers, this._zone);
            };
        GoogleMapServiceFactory.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        GoogleMapServiceFactory.ctorParameters = function () {
            return [
                { type: MapAPILoader },
                { type: core.NgZone }
            ];
        };
        return GoogleMapServiceFactory;
    }());
    /**
     *  Creates a new instance of a plaform specific MapServiceFactory.
     *
     * @param {?} apiLoader - An {\@link MapAPILoader} instance. This is expected to the a {\@link GoogleMapAPILoader}.
     * @param {?} zone - An NgZone instance to provide zone aware promises.
     *
     * @return {?} - A {\@link MapServiceFactory} instance.
     */
    function GoogleMapServiceFactoryFactory(apiLoader, zone) {
        return new GoogleMapServiceFactory(apiLoader, zone);
    }
    /**
     * Creates a new instance of a plaform specific MapLoaderFactory.
     *
     * @export
     * @return {?} - A {\@link MapAPILoader} instance.
     */
    function GoogleMapLoaderFactory() {
        return new GoogleMapAPILoader(new GoogleMapAPILoaderConfig(), new WindowRef(), new DocumentRef());
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MapModule = (function () {
        function MapModule() {
        }
        /**
         * @param {?=} mapServiceFactory
         * @param {?=} loader
         * @return {?}
         */
        MapModule.forRoot = /**
         * @param {?=} mapServiceFactory
         * @param {?=} loader
         * @return {?}
         */
            function (mapServiceFactory, loader) {
                return {
                    ngModule: MapModule,
                    providers: [
                        mapServiceFactory ? { provide: MapServiceFactory, useValue: mapServiceFactory } :
                            { provide: MapServiceFactory, deps: [MapAPILoader, core.NgZone], useFactory: BingMapServiceFactoryFactory },
                        loader ? { provide: MapAPILoader, useValue: loader } : { provide: MapAPILoader, useFactory: BingMapLoaderFactory },
                        DocumentRef,
                        WindowRef
                    ]
                };
            };
        /**
         * @return {?}
         */
        MapModule.forRootBing = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: MapModule,
                    providers: [
                        { provide: MapServiceFactory, deps: [MapAPILoader, core.NgZone], useFactory: BingMapServiceFactoryFactory },
                        { provide: MapAPILoader, useFactory: BingMapLoaderFactory },
                        DocumentRef,
                        WindowRef
                    ]
                };
            };
        /**
         * @return {?}
         */
        MapModule.forRootGoogle = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: MapModule,
                    providers: [
                        { provide: MapServiceFactory, deps: [MapAPILoader, core.NgZone], useFactory: GoogleMapServiceFactoryFactory },
                        { provide: MapAPILoader, useFactory: GoogleMapLoaderFactory },
                        DocumentRef,
                        WindowRef
                    ]
                };
            };
        MapModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            MapLayerDirective,
                            MapComponent,
                            MapMarkerDirective,
                            InfoBoxComponent,
                            InfoBoxActionDirective,
                            MapPolygonDirective,
                            MapPolylineDirective,
                            ClusterLayerDirective,
                            MapMarkerLayerDirective,
                            MapPolygonLayerDirective,
                            MapPolylineLayerDirective
                        ],
                        imports: [common.CommonModule],
                        exports: [
                            common.CommonModule,
                            MapComponent,
                            MapMarkerDirective,
                            MapPolygonDirective,
                            MapPolylineDirective,
                            InfoBoxComponent,
                            InfoBoxActionDirective,
                            MapLayerDirective,
                            ClusterLayerDirective,
                            MapMarkerLayerDirective,
                            MapPolygonLayerDirective,
                            MapPolylineLayerDirective
                        ]
                    },] },
        ];
        return MapModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.MapComponent = MapComponent;
    exports.InfoBoxComponent = InfoBoxComponent;
    exports.MapMarkerDirective = MapMarkerDirective;
    exports.MapPolygonDirective = MapPolygonDirective;
    exports.MapPolylineDirective = MapPolylineDirective;
    exports.InfoBoxActionDirective = InfoBoxActionDirective;
    exports.MapMarkerLayerDirective = MapMarkerLayerDirective;
    exports.MapPolygonLayerDirective = MapPolygonLayerDirective;
    exports.MapLayerDirective = MapLayerDirective;
    exports.ClusterLayerDirective = ClusterLayerDirective;
    exports.MapPolylineLayerDirective = MapPolylineLayerDirective;
    exports.MapTypeId = MapTypeId;
    exports.Marker = Marker;
    exports.MarkerTypeId = MarkerTypeId;
    exports.InfoWindow = InfoWindow;
    exports.Layer = Layer;
    exports.ClusterPlacementMode = ClusterPlacementMode;
    exports.ClusterClickAction = ClusterClickAction;
    exports.SpiderClusterMarker = SpiderClusterMarker;
    exports.Polygon = Polygon;
    exports.Polyline = Polyline;
    exports.CanvasOverlay = CanvasOverlay;
    exports.MapService = MapService;
    exports.MapServiceFactory = MapServiceFactory;
    exports.MarkerService = MarkerService;
    exports.InfoBoxService = InfoBoxService;
    exports.MapAPILoader = MapAPILoader;
    exports.WindowRef = WindowRef;
    exports.DocumentRef = DocumentRef;
    exports.LayerService = LayerService;
    exports.PolygonService = PolygonService;
    exports.PolylineService = PolylineService;
    exports.ClusterService = ClusterService;
    exports.BingMapServiceFactory = BingMapServiceFactory;
    exports.BingMapAPILoaderConfig = BingMapAPILoaderConfig;
    exports.BingMapService = BingMapService;
    exports.BingInfoBoxService = BingInfoBoxService;
    exports.BingMarkerService = BingMarkerService;
    exports.BingPolygonService = BingPolygonService;
    exports.BingPolylineService = BingPolylineService;
    exports.BingMapAPILoader = BingMapAPILoader;
    exports.BingLayerService = BingLayerService;
    exports.BingClusterService = BingClusterService;
    exports.BingLayer = BingLayer;
    exports.BingMarker = BingMarker;
    exports.BingPolyline = BingPolyline;
    exports.BingMapEventsLookup = BingMapEventsLookup;
    exports.BingPolygon = BingPolygon;
    exports.BingInfoWindow = BingInfoWindow;
    exports.BingClusterLayer = BingClusterLayer;
    exports.BingSpiderClusterMarker = BingSpiderClusterMarker;
    exports.BingCanvasOverlay = BingCanvasOverlay;
    exports.GoogleClusterService = GoogleClusterService;
    exports.GoogleInfoBoxService = GoogleInfoBoxService;
    exports.GoogleLayerService = GoogleLayerService;
    exports.GoogleMapAPILoader = GoogleMapAPILoader;
    exports.GoogleMapAPILoaderConfig = GoogleMapAPILoaderConfig;
    exports.GoogleMapServiceFactory = GoogleMapServiceFactory;
    exports.GoogleMapService = GoogleMapService;
    exports.GoogleMarkerService = GoogleMarkerService;
    exports.GooglePolygonService = GooglePolygonService;
    exports.GooglePolylineService = GooglePolylineService;
    exports.GoogleMarker = GoogleMarker;
    exports.GoogleInfoWindow = GoogleInfoWindow;
    exports.GooglePolygon = GooglePolygon;
    exports.GooglePolyline = GooglePolyline;
    exports.GoogleMapEventsLookup = GoogleMapEventsLookup;
    exports.GoogleCanvasOverlay = GoogleCanvasOverlay;
    exports.MapModule = MapModule;
    exports.a = ClusterServiceFactory;
    exports.b = InfoBoxServiceFactory;
    exports.c = LayerServiceFactory;
    exports.d = MapServiceCreator;
    exports.e = MarkerServiceFactory;
    exports.f = PolygonServiceFactory;
    exports.g = PolylineServiceFactory;
    exports.l = BingLayerBase;
    exports.i = BingMapLoaderFactory;
    exports.h = BingMapServiceFactoryFactory;
    exports.m = GoogleLayerBase;
    exports.k = GoogleMapLoaderFactory;
    exports.j = GoogleMapServiceFactoryFactory;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1tYXBzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvaW5mby13aW5kb3cudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL21hcmtlci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvbGF5ZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL3BvbHlnb24udHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL3BvbHlsaW5lLnRzIixudWxsLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL3NwaWRlci1jbHVzdGVyLW1hcmtlci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvY2FudmFzLW92ZXJsYXkudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1sYXllci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctY29udmVyc2lvbnMudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1tYXJrZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1zcGlkZXItY2x1c3Rlci1tYXJrZXIudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2JpbmcvYmluZy1jbHVzdGVyLWxheWVyLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9iaW5nL2JpbmctaW5mby13aW5kb3cudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL21hcC1sYWJlbC50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvYmluZy9iaW5nLWxhYmVsLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9iaW5nL2JpbmctcG9seWdvbi50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvYmluZy9iaW5nLXBvbHlsaW5lLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9iaW5nL2JpbmctZXZlbnRzLWxvb2t1cC50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvYmluZy9iaW5nLWNhbnZhcy1vdmVybGF5LnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLXR5cGVzLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtY29udmVyc2lvbnMudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtaW5mby13aW5kb3cudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtbWFya2VyLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLWxhYmVsLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLXBvbHlnb24udHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtcG9seWxpbmUudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtZXZlbnRzLWxvb2t1cC50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1jYW52YXMtb3ZlcmxheS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9tYXBzZXJ2aWNlZmFjdG9yeS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9tYXAuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9tYXJrZXIuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9pbmZvYm94LnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvbGF5ZXIuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9wb2x5Z29uLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvcG9seWxpbmUuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9jbHVzdGVyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvY29tcG9uZW50cy9pbmZvYm94LWFjdGlvbi50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL2luZm9ib3gudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvY29tcG9uZW50cy9tYXAtbWFya2VyLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL2NvbXBvbmVudHMvbWFwLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL2NvbXBvbmVudHMvbWFwLWxheWVyLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL2NvbXBvbmVudHMvY2x1c3Rlci1sYXllci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL21hcC1wb2x5Z29uLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL2NvbXBvbmVudHMvbWFwLXBvbHlsaW5lLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL2NvbXBvbmVudHMvbWFwLW1hcmtlci1sYXllci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9jb21wb25lbnRzL21hcC1wb2x5Z29uLWxheWVyLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL2NvbXBvbmVudHMvbWFwLXBvbHlsaW5lLWxheWVyLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL21hcGFwaWxvYWRlci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctbWFwLmFwaS1sb2FkZXIuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctaW5mb2JveC5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1tYXJrZXIuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctbWFwLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvYmluZy9iaW5nLWxheWVyLWJhc2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvYmluZy9iaW5nLWxheWVyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvYmluZy9iaW5nLWNsdXN0ZXIuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctcG9seWdvbi5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1wb2x5bGluZS5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1tYXAuc2VydmljZS5mYWN0b3J5LnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbGF5ZXItYmFzZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWNsdXN0ZXIuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWluZm9ib3guc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1sYXllci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWxheWVyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtYXBpLWxvYWRlci5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFya2VyLnNlcnZpY2UudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtbWFya2VyLWNsdXN0ZXJlci50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcC5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtcG9seWdvbi5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLW1hcHMvc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtcG9seWxpbmUuc2VydmljZS50cyIsIm5nOi8vYW5ndWxhci1tYXBzL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcC5zZXJ2aWNlLmZhY3RvcnkudHMiLCJuZzovL2FuZ3VsYXItbWFwcy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbmZvV2luZG93IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgaW5mbyBib3ggaXMgY3VycmVudGx5IG9wZW4uXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvV2luZG93XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgSXNPcGVuKCk6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHVuZGVybHlpbmcgbmF0aXZlIHByaW1pdGl2ZSBvZiB0aGUgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvV2luZG93XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgTmF0aXZlUHJpbWl0dmUoKTogYW55O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGV2ZW50IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgbGlzdGVuZXIgKGUuZy4gXCJjbGlja1wiKVxyXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgaW52b2tlZCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9XaW5kb3dcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoZSBpbmZvIHdpbmRvdy5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb1dpbmRvd1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQ2xvc2UoKTogdm9pZCA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcmV0dXJucyAtIFJldHVybnMgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9XaW5kb3dcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldFBvc2l0aW9uKCk6IElMYXRMb25nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgdGhlIGluZm8gd2luZG93LlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvV2luZG93XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBPcGVuKCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBpbmZvIHdpbmRvdyBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBJbmZvIHdpbmRvdyBvcHRpb25zIHRvIHNldC4gVGhlIG9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgd2l0aCBhbnkgZXhpc3Rpbmcgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb1dpbmRvd1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0T3B0aW9ucyhvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaW5mbyB3aW5kb3cgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gLSBHZW8gY29vcmRpbmF0ZXMgdG8gbW92ZSB0aGUgYW5jaG9yIG9mIHRoZSBpbmZvIHdpbmRvdyB0by5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb1dpbmRvd1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0UG9zaXRpb24ocG9zaXRpb246IElMYXRMb25nKTogdm9pZDtcclxufVxyXG4iLCJpbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSU1hcmtlckljb25JbmZvIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbWFya2VyLWljb24taW5mbyc7XHJcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvaW50JztcclxuaW1wb3J0IHsgSVNpemUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lzaXplJztcclxuaW1wb3J0IHsgTWFya2VyVHlwZUlkIH0gZnJvbSAnLi4vbW9kZWxzL21hcmtlci10eXBlLWlkJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGludGVyZmFjZSBkZWZpbmVzIHRoZSBjb250cmFjdCBmb3IgYW4gaWNvbiBjYWNoZSBlbnRyeS5cclxuICovXHJcbmludGVyZmFjZSBJTWFya2VySWNvbkNhY2hlRW50cnkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaWNvbiBzdHJpbmcgb2YgdGhlIGNhY2hlIGVudHJ5LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJTWFya2VySWNvbkNhY2hlRW50cnlcclxuICAgICAqL1xyXG4gICAgbWFya2VySWNvblN0cmluZzogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIFNpemUgb2YgdGhlIGljb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIElNYXJrZXJJY29uQ2FjaGVFbnRyeVxyXG4gICAgKiAqL1xyXG4gICAgbWFya2VyU2l6ZTogSVNpemU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGRlZmluZXMgdGhlIGNvbnRyYWN0IGZvciBhIG1hcmtlci5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNYXJrZXIge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlZmluaXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhY2hlcyBjb25jcmV0ZSBpbWcgZWxlbWVudHMgZm9yIG1hcmtlciBpY29ucyB0byBhY2NlbGVyYXRlIHBhdGluaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgSW1hZ2VFbGVtZW50Q2FjaGU6IE1hcDxzdHJpbmcsIEhUTUxJbWFnZUVsZW1lbnQ+ID0gbmV3IE1hcDxzdHJpbmcsIEhUTUxJbWFnZUVsZW1lbnQ+KCk7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBjYWNoZSBnZW5lcmF0ZWQgbWFya2VycyBmb3IgcGVyZm9ybWFuY2UgYW5kIHJldXNhYmlsaXR5LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgTWFya2VyQ2FjaGU6IE1hcDxzdHJpbmcsIElNYXJrZXJJY29uQ2FjaGVFbnRyeT4gPSBuZXcgTWFwPHN0cmluZywgSU1hcmtlckljb25DYWNoZUVudHJ5PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG1hcmtlciBiYXNlZCBvbiB0aGUgbWFya2VyIGluZm8uIEluIHR1cm4gY2FsbHMgYSBudW1iZXIgb2YgaW50ZXJuYWwgbWVtYmVycyB0b1xyXG4gICAgICogY3JlYXRlIHRoZSBhY3R1YWwgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpY29uSW5mbyAtIGljb24gaW5mb3JtYXRpb24uIERlcGVuZGluZyBvbiB0aGUgbWFya2VyIHR5cGUsIHZhcmlvdXMgcHJvcGVydGllc1xyXG4gICAgICogbmVlZCB0byBiZSBwcmVzZW50LiBGb3IgcGVyZm9ybWFuY2UsIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBhbiBpZCBmb3IgbWFya2VycyB0aGF0IGFyZSBjb21tb24gdG8gZmFjaWxpdGF0ZVxyXG4gICAgICogcmV1c2UuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBhIGNhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCBvbiBtYXJrZXJzIHRoYXQgcmVxdWlyZSBhc3luY3Jvbm91c1xyXG4gICAgICogcHJvY2Vzc2luZyBkdXJpbmcgY3JlYXRpb24uIEZvciBtYXJrZXJzIHRoYXQgZG8gbm90IHJlcXVpcmUgYXN5bmMgcHJvY2Vzc2luZywgdGhpcyBwYXJhbWV0ZXIgaXMgaWdub3JlZC5cclxuICAgICAqIEByZXR1cm5zIC0gYSBzdHJpbmcgb3IgYSBwcm9taXNlIGZvciBhIHN0cmluZyBjb250YWluaW5nXHJcbiAgICAgKiBhIGRhdGEgdXJsIHdpdGggdGhlIG1hcmtlciBpbWFnZS5cclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBDcmVhdGVNYXJrZXIoaWNvbkluZm86IElNYXJrZXJJY29uSW5mbyk6IHN0cmluZ3xQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PiB7XHJcbiAgICAgICAgc3dpdGNoIChpY29uSW5mby5tYXJrZXJUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgTWFya2VyVHlwZUlkLkNhbnZhc01hcmtlcjogcmV0dXJuIE1hcmtlci5DcmVhdGVDYW52YXNNYXJrZXIoaWNvbkluZm8pO1xyXG4gICAgICAgICAgICBjYXNlIE1hcmtlclR5cGVJZC5EeW5tYWljQ2lyY2xlTWFya2VyOiByZXR1cm4gTWFya2VyLkNyZWF0ZUR5bm1haWNDaXJjbGVNYXJrZXIoaWNvbkluZm8pO1xyXG4gICAgICAgICAgICBjYXNlIE1hcmtlclR5cGVJZC5Gb250TWFya2VyOiByZXR1cm4gTWFya2VyLkNyZWF0ZUZvbnRCYXNlZE1hcmtlcihpY29uSW5mbyk7XHJcbiAgICAgICAgICAgIGNhc2UgTWFya2VyVHlwZUlkLlJvdGF0ZWRJbWFnZU1hcmtlcjogcmV0dXJuIE1hcmtlci5DcmVhdGVSb3RhdGVkSW1hZ2VNYXJrZXIoaWNvbkluZm8pO1xyXG4gICAgICAgICAgICBjYXNlIE1hcmtlclR5cGVJZC5Sb3VuZGVkSW1hZ2VNYXJrZXI6IHJldHVybiBNYXJrZXIuQ3JlYXRlUm91bmRlZEltYWdlTWFya2VyKGljb25JbmZvKTtcclxuICAgICAgICAgICAgY2FzZSBNYXJrZXJUeXBlSWQuU2NhbGVkSW1hZ2VNYXJrZXI6IHJldHVybiBNYXJrZXIuQ3JlYXRlU2NhbGVkSW1hZ2VNYXJrZXIoaWNvbkluZm8pO1xyXG4gICAgICAgICAgICBjYXNlIE1hcmtlclR5cGVJZC5DdXN0b206IHRocm93IEVycm9yKCdDdXN0b20gTWFya2VyIENyZWF0b3JzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIG1hcmtlciB0eXBlOiAnICsgaWNvbkluZm8ubWFya2VyVHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGEgc2hhcmVkIGltZyBlbGVtZW50IGZvciBhIG1hcmtlciBpY29uIHRvIHByZXZlbnQgdW5lY2Vzc2FyeSBjcmVhdGlvbiBvZlxyXG4gICAgICogRE9NIGl0ZW1zLiBUaGlzIGhhcyBzcGVkIHVwIGxhcmdlIHNjYWxlIG1ha2VycyBvbiBCaW5nIE1hcHMgYnkgYWJvdXQgNzAlXHJcbiAgICAgKiBAcGFyYW0gaWNvbiAtIFRoZSBpY29uIHN0cmluZyAodXJsLCBkYXRhIHVybCwgc3ZnKSBmb3Igd2hpY2ggdG8gb2J0YWluIHRoZSBpbWFnZS5cclxuICAgICAqIEByZXR1cm5zIC0gVGhlIG9idGFpbmVkIGltYWdlIGVsZW1lbnQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgR2V0SW1hZ2VGb3JNYXJrZXIoaWNvbjogc3RyaW5nKTogSFRNTEltYWdlRWxlbWVudCB7XHJcbiAgICAgICAgaWYgKGljb24gPT0gbnVsbCB8fCBpY29uID09PSAnJyApIHsgcmV0dXJuICBudWxsOyB9XHJcblxyXG4gICAgICAgIGxldCBpbWc6IEhUTUxJbWFnZUVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIGltZyA9IE1hcmtlci5JbWFnZUVsZW1lbnRDYWNoZS5nZXQoaWNvbik7XHJcbiAgICAgICAgaWYgKGltZyAhPSBudWxsKSB7IHJldHVybiBpbWc7IH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZihkb2N1bWVudCkgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcbiAgICAgICAgICAgIGltZy5zcmMgPSBpY29uO1xyXG4gICAgICAgICAgICBNYXJrZXIuSW1hZ2VFbGVtZW50Q2FjaGUuc2V0KGljb24sIGltZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbWc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY2FudmFzZWQgYmFzZWQgbWFya2VyIHVzaW5nIHRoZSBwb2ludCBjb2xsZWN0aW9uIGNvbnRhaW5lZCBpbiB0aGUgaWNvbkluZm8gcGFyYW1ldGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSBpY29uSW5mbyAtIHtAbGluayBJTWFya2VySWNvbkluZm99IGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBjcmVhdGUgdGhlIGljb24uXHJcbiAgICAgKiBAcmV0dXJucyAtIFN0cmluZyB3aXRoIHRoZSBkYXRhIHVybCBmb3IgdGhlIG1hcmtlciBpbWFnZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgQ3JlYXRlQ2FudmFzTWFya2VyKGljb25JbmZvOiBJTWFya2VySWNvbkluZm8pOiBzdHJpbmcge1xyXG4gICAgICAgIGlmIChkb2N1bWVudCA9PSBudWxsKSB7IHRocm93IEVycm9yKCdEb2N1bWVudCBjb250ZXh0ICh3aW5kb3cuZG9jdW1lbnQpIGlzIHJlcXVpcmVkIGZvciBjYW52YXMgbWFya2Vycy4nKTsgfVxyXG4gICAgICAgIGlmIChpY29uSW5mbyA9PSBudWxsIHx8IGljb25JbmZvLnNpemUgPT0gbnVsbCB8fCBpY29uSW5mby5wb2ludHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSU1hcmtlckljb25JbmZvLnNpemUsIGFuZCBJTWFya2VySUNvbkluZm8ucG9pbnRzIGFyZSByZXF1aXJlZCBmb3IgY2FudmFzIG1hcmtlcnMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsICYmIE1hcmtlci5NYXJrZXJDYWNoZS5oYXMoaWNvbkluZm8uaWQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pOiBJTWFya2VySWNvbkNhY2hlRW50cnkgPSBNYXJrZXIuTWFya2VyQ2FjaGUuZ2V0KGljb25JbmZvLmlkKTtcclxuICAgICAgICAgICAgaWNvbkluZm8uc2l6ZSA9IG1pLm1hcmtlclNpemU7XHJcbiAgICAgICAgICAgIHJldHVybiBtaS5tYXJrZXJJY29uU3RyaW5nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYzogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBjb25zdCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBjLndpZHRoID0gaWNvbkluZm8uc2l6ZS53aWR0aDtcclxuICAgICAgICBjLmhlaWdodCA9IGljb25JbmZvLnNpemUuaGVpZ2h0O1xyXG4gICAgICAgIGlmIChpY29uSW5mby5yb3RhdGlvbikge1xyXG4gICAgICAgICAgICAvLyBPZmZzZXQgdGhlIGNhbnZhcyBzdWNoIHRoYXQgd2Ugd2lsbCByb3RhdGUgYXJvdW5kIHRoZSBjZW50ZXIgb2Ygb3VyIGFycm93XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoYy53aWR0aCAqIDAuNSwgYy5oZWlnaHQgKiAwLjUpO1xyXG4gICAgICAgICAgICAvLyBSb3RhdGUgdGhlIGNhbnZhcyBieSB0aGUgZGVzaXJlZCBoZWFkaW5nXHJcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoaWNvbkluZm8ucm90YXRpb24gKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjYW52YXMgb2Zmc2V0IGJhY2sgdG8gaXQncyBvcmlnaW5hbCBwb3NpdGlvblxyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jLndpZHRoICogMC41LCAtYy5oZWlnaHQgKiAwLjUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGljb25JbmZvLmNvbG9yIHx8ICdyZWQnO1xyXG5cclxuICAgICAgICAvLyBEcmF3IGEgcGF0aCBpbiB0aGUgc2hhcGUgb2YgYW4gYXJyb3cuXHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGlmIChpY29uSW5mby5kcmF3aW5nT2Zmc2V0KSB7IGN0eC5tb3ZlVG8oaWNvbkluZm8uZHJhd2luZ09mZnNldC54LCBpY29uSW5mby5kcmF3aW5nT2Zmc2V0LnkpOyB9XHJcbiAgICAgICAgaWNvbkluZm8ucG9pbnRzLmZvckVhY2goKHA6IElQb2ludCkgPT4geyBjdHgubGluZVRvKHAueCwgcC55KTsgfSk7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG5cclxuICAgICAgICBjb25zdCBzOiBzdHJpbmcgPSBjLnRvRGF0YVVSTCgpO1xyXG4gICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsKSB7IE1hcmtlci5NYXJrZXJDYWNoZS5zZXQoaWNvbkluZm8uaWQsIHsgbWFya2VySWNvblN0cmluZzogcywgbWFya2VyU2l6ZTogaWNvbkluZm8uc2l6ZSB9KTsgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNpcmNsZSBtYXJrZXIgaW1hZ2UgdXNpbmcgaW5mb3JtYXRpb24gY29udGFpbmVkIGluIHRoZSBpY29uSW5mbyBwYXJhbWV0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIGljb25JbmZvIC0ge0BsaW5rIElNYXJrZXJJY29uSW5mb30gY29udGFpbmluZyB0aGUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIGNyZWF0ZSB0aGUgaWNvbi5cclxuICAgICAqIEByZXR1cm5zIC0gU3RyaW5nIHdpdGggdGhlIGRhdGEgdXJsIGZvciB0aGUgbWFya2VyIGltYWdlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBDcmVhdGVEeW5tYWljQ2lyY2xlTWFya2VyKGljb25JbmZvOiBJTWFya2VySWNvbkluZm8pOiBzdHJpbmcge1xyXG4gICAgICAgIGlmIChkb2N1bWVudCA9PSBudWxsKSB7IHRocm93IEVycm9yKCdEb2N1bWVudCBjb250ZXh0ICh3aW5kb3cuZG9jdW1lbnQpIGlzIHJlcXVpcmVkIGZvciBkeW5hbWljIGNpcmNsZSBtYXJrZXJzLicpOyB9XHJcbiAgICAgICAgaWYgKGljb25JbmZvID09IG51bGwgfHwgaWNvbkluZm8uc2l6ZSA9PSBudWxsKSB7IHRocm93IEVycm9yKCdJTWFya2VySWNvbkluZm8uc2l6ZSBpcyByZXF1aXJlZCBmb3IgZHluYW1pYyBjaXJjbGUgbWFya2Vycy4nKTsgfVxyXG4gICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsICYmIE1hcmtlci5NYXJrZXJDYWNoZS5oYXMoaWNvbkluZm8uaWQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pOiBJTWFya2VySWNvbkNhY2hlRW50cnkgPSBNYXJrZXIuTWFya2VyQ2FjaGUuZ2V0KGljb25JbmZvLmlkKTtcclxuICAgICAgICAgICAgaWNvbkluZm8uc2l6ZSA9IG1pLm1hcmtlclNpemU7XHJcbiAgICAgICAgICAgIHJldHVybiBtaS5tYXJrZXJJY29uU3RyaW5nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGg6IG51bWJlciA9IGljb25JbmZvLnN0cm9rZVdpZHRoIHx8IDA7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuIFNWRyBzdHJpbmcgb2YgYSBjaXJjbGUgd2l0aCB0aGUgc3BlY2lmaWVkIHJhZGl1cyBhbmQgY29sb3IuXHJcbiAgICAgICAgY29uc3Qgc3ZnOiBBcnJheTxzdHJpbmc+ID0gW1xyXG4gICAgICAgICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCInLFxyXG4gICAgICAgICAgICBpY29uSW5mby5zaXplLndpZHRoLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICdcIiBoZWlnaHQ9XCInLFxyXG4gICAgICAgICAgICBpY29uSW5mby5zaXplLndpZHRoLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICdcIj48Y2lyY2xlIGN4PVwiJyxcclxuICAgICAgICAgICAgKGljb25JbmZvLnNpemUud2lkdGggLyAyKS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAnXCIgY3k9XCInLFxyXG4gICAgICAgICAgICAoaWNvbkluZm8uc2l6ZS53aWR0aCAvIDIpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICdcIiByPVwiJyxcclxuICAgICAgICAgICAgKChpY29uSW5mby5zaXplLndpZHRoIC8gMikgLSBzdHJva2VXaWR0aCkudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgJ1wiIHN0cm9rZT1cIicsXHJcbiAgICAgICAgICAgIGljb25JbmZvLmNvbG9yIHx8ICdyZWQnLFxyXG4gICAgICAgICAgICAnXCIgc3Ryb2tlLXdpZHRoPVwiJyxcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGgudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgJ1wiIGZpbGw9XCInLFxyXG4gICAgICAgICAgICBpY29uSW5mby5jb2xvciB8fCAncmVkJyxcclxuICAgICAgICAgICAgJ1wiLz48L3N2Zz4nXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgY29uc3Qgczogc3RyaW5nID0gc3ZnLmpvaW4oJycpO1xyXG4gICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsKSB7IE1hcmtlci5NYXJrZXJDYWNoZS5zZXQoaWNvbkluZm8uaWQsIHsgbWFya2VySWNvblN0cmluZzogcywgbWFya2VyU2l6ZTogaWNvbkluZm8uc2l6ZSB9KTsgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZvbnQgYmFzZWQgbWFya2VyIGltYWdlIChzdWNoIGFzIEZvbnQtQXdlc29tZSksIGJ5IHVzaW5nIGluZm9ybWF0aW9uIHN1cHBsaWVkIGluIHRoZSBwYXJhbWV0ZXJzIChzdWNoIGFzIEZvbnQtQXdlc29tZSkuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIGljb25JbmZvIC0ge0BsaW5rIElNYXJrZXJJY29uSW5mb30gY29udGFpbmluZyB0aGUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIGNyZWF0ZSB0aGUgaWNvbi5cclxuICAgICAqIEByZXR1cm5zIC0gU3RyaW5nIHdpdGggdGhlIGRhdGEgdXJsIGZvciB0aGUgbWFya2VyIGltYWdlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBDcmVhdGVGb250QmFzZWRNYXJrZXIoaWNvbkluZm86IElNYXJrZXJJY29uSW5mbyk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50ID09IG51bGwpIHsgdGhyb3cgRXJyb3IoJ0RvY3VtZW50IGNvbnRleHQgKHdpbmRvdy5kb2N1bWVudCkgaXMgcmVxdWlyZWQgZm9yIGZvbnQgYmFzZWQgbWFya2VycycpOyB9XHJcbiAgICAgICAgaWYgKGljb25JbmZvID09IG51bGwgfHwgaWNvbkluZm8uZm9udE5hbWUgPT0gbnVsbCB8fCBpY29uSW5mby5mb250U2l6ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJTWFya2VySWNvbkluZm8uZm9udE5hbWUsIElNYXJrZXJJY29uSW5mby5mb250U2l6ZSBhbmQgSU1hcmtlcklDb25JbmZvLnRleHQgYXJlIHJlcXVpcmVkIGZvciBmb250IGJhc2VkIG1hcmtlcnMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsICYmIE1hcmtlci5NYXJrZXJDYWNoZS5oYXMoaWNvbkluZm8uaWQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pOiBJTWFya2VySWNvbkNhY2hlRW50cnkgPSBNYXJrZXIuTWFya2VyQ2FjaGUuZ2V0KGljb25JbmZvLmlkKTtcclxuICAgICAgICAgICAgaWNvbkluZm8uc2l6ZSA9IG1pLm1hcmtlclNpemU7XHJcbiAgICAgICAgICAgIHJldHVybiBtaS5tYXJrZXJJY29uU3RyaW5nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYzogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBjb25zdCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBjb25zdCBmb250OiBzdHJpbmcgPSBpY29uSW5mby5mb250U2l6ZSArICdweCAnICsgaWNvbkluZm8uZm9udE5hbWU7XHJcbiAgICAgICAgY3R4LmZvbnQgPSBmb250O1xyXG5cclxuICAgICAgICAvLyBSZXNpemUgY2FudmFzIGJhc2VkIG9uIHNpZSBvZiB0ZXh0LlxyXG4gICAgICAgIGNvbnN0IHNpemU6IFRleHRNZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGljb25JbmZvLnRleHQpO1xyXG4gICAgICAgIGMud2lkdGggPSBzaXplLndpZHRoO1xyXG4gICAgICAgIGMuaGVpZ2h0ID0gaWNvbkluZm8uZm9udFNpemU7XHJcblxyXG4gICAgICAgIGlmIChpY29uSW5mby5yb3RhdGlvbikge1xyXG4gICAgICAgICAgICAvLyBPZmZzZXQgdGhlIGNhbnZhcyBzdWNoIHRoYXQgd2Ugd2lsbCByb3RhdGUgYXJvdW5kIHRoZSBjZW50ZXIgb2Ygb3VyIGFycm93XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoYy53aWR0aCAqIDAuNSwgYy5oZWlnaHQgKiAwLjUpO1xyXG4gICAgICAgICAgICAvLyBSb3RhdGUgdGhlIGNhbnZhcyBieSB0aGUgZGVzaXJlZCBoZWFkaW5nXHJcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoaWNvbkluZm8ucm90YXRpb24gKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjYW52YXMgb2Zmc2V0IGJhY2sgdG8gaXQncyBvcmlnaW5hbCBwb3NpdGlvblxyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jLndpZHRoICogMC41LCAtYy5oZWlnaHQgKiAwLjUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzZXQgZm9udCBhcyBpdCB3aWxsIGJlIGNsZWFyZWQgYnkgdGhlIHJlc2l6ZS5cclxuICAgICAgICBjdHguZm9udCA9IGZvbnQ7XHJcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBpY29uSW5mby5jb2xvciB8fCAncmVkJztcclxuXHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KGljb25JbmZvLnRleHQsIDAsIDApO1xyXG4gICAgICAgIGljb25JbmZvLnNpemUgPSB7IHdpZHRoOiBjLndpZHRoLCBoZWlnaHQ6IGMuaGVpZ2h0IH07XHJcbiAgICAgICAgY29uc3Qgczogc3RyaW5nID0gYy50b0RhdGFVUkwoKTtcclxuICAgICAgICBpZiAoaWNvbkluZm8uaWQgIT0gbnVsbCkgeyBNYXJrZXIuTWFya2VyQ2FjaGUuc2V0KGljb25JbmZvLmlkLCB7IG1hcmtlckljb25TdHJpbmc6IHMsIG1hcmtlclNpemU6IGljb25JbmZvLnNpemUgfSk7IH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW1hZ2UgbWFya2VyIGJ5IGFwcGx5aW5nIGEgcm9hdGlvbiB0byBhIHN1cHBsaWVkIGltYWdlLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSBpY29uSW5mbyAtIHtAbGluayBJTWFya2VySWNvbkluZm99IGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBjcmVhdGUgdGhlIGljb24uXHJcbiAgICAgKiBAcmV0dXJucyAtIGEgc3RyaW5nIG9yIGEgcHJvbWlzZSBmb3IgYSBzdHJpbmcgY29udGFpbmluZ1xyXG4gICAgICogYSBkYXRhIHVybCB3aXRoIHRoZSBtYXJrZXIgaW1hZ2UuIEluIGNhc2Ugb2YgYSBjYWNoZWQgaW1hZ2UsIHRoZSBpbWFnZSB3aWxsIGJlIHJldHVybmVkLCBvdGhlcndpc2UgdGhlIHByb21pc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIENyZWF0ZVJvdGF0ZWRJbWFnZU1hcmtlcihpY29uSW5mbzogSU1hcmtlckljb25JbmZvKTogc3RyaW5nfFByb21pc2U8e2ljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mb30+IHtcclxuICAgICAgICBpZiAoZG9jdW1lbnQgPT0gbnVsbCkgeyB0aHJvdyBFcnJvcignRG9jdW1lbnQgY29udGV4dCAod2luZG93LmRvY3VtZW50KSBpcyByZXF1aXJlZCBmb3Igcm90YXRlZCBpbWFnZSBtYXJrZXJzJyk7IH1cclxuICAgICAgICBpZiAoaWNvbkluZm8gPT0gbnVsbCB8fCBpY29uSW5mby5yb3RhdGlvbiA9PSBudWxsIHx8IGljb25JbmZvLnVybCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJTWFya2VySWNvbkluZm8ucm90YXRpb24sIElNYXJrZXJJY29uSW5mby51cmwgYXJlIHJlcXVpcmVkIGZvciByb3RhdGVkIGltYWdlIG1hcmtlcnMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsICYmIE1hcmtlci5NYXJrZXJDYWNoZS5oYXMoaWNvbkluZm8uaWQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pOiBJTWFya2VySWNvbkNhY2hlRW50cnkgPSBNYXJrZXIuTWFya2VyQ2FjaGUuZ2V0KGljb25JbmZvLmlkKTtcclxuICAgICAgICAgICAgaWNvbkluZm8uc2l6ZSA9IG1pLm1hcmtlclNpemU7XHJcbiAgICAgICAgICAgIHJldHVybiBtaS5tYXJrZXJJY29uU3RyaW5nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICBjb25zdCBwcm9taXNlOiBQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PiA9XHJcbiAgICAgICAgICAgIG5ldyBQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEFsbG93IGNyb3NzIGRvbWFpbiBpbWFnZSBlZGl0dGluZy5cclxuICAgICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gaWNvbkluZm8udXJsO1xyXG4gICAgICAgICAgICBpZiAoaWNvbkluZm8uc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2Uud2lkdGggPSBpY29uSW5mby5zaXplLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgaW1hZ2UuaGVpZ2h0ID0gaWNvbkluZm8uc2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYzogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gYy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmFkczogbnVtYmVyID0gaWNvbkluZm8ucm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSByb3RhdGVkIGltYWdlIHNpemUuXHJcbiAgICAgICAgICAgICAgICBjLndpZHRoID0gTWF0aC5jZWlsKE1hdGguYWJzKGltYWdlLndpZHRoICogTWF0aC5jb3MocmFkcykpICsgTWF0aC5hYnMoaW1hZ2UuaGVpZ2h0ICogTWF0aC5zaW4ocmFkcykpKTtcclxuICAgICAgICAgICAgICAgIGMuaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGguYWJzKGltYWdlLndpZHRoICogTWF0aC5zaW4ocmFkcykpICsgTWF0aC5hYnMoaW1hZ2UuaGVpZ2h0ICogTWF0aC5jb3MocmFkcykpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGNhbnZhcy5cclxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoYy53aWR0aCAvIDIsIGMuaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgICAgICAvLyBSb3RhdGUgdGhlIGNhbnZhcyB0byB0aGUgc3BlY2lmaWVkIGFuZ2xlIGluIGRlZ3JlZXMuXHJcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKHJhZHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gRHJhdyB0aGUgaW1hZ2UsIHNpbmNlIHRoZSBjb250ZXh0IGlzIHJvdGF0ZWQsIHRoZSBpbWFnZSB3aWxsIGJlIHJvdGF0ZWQgYWxzby5cclxuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIC1pbWFnZS53aWR0aCAvIDIsIC1pbWFnZS5oZWlnaHQgLyAyLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGljb25JbmZvLnNpemUgPSB7IHdpZHRoOiBjLndpZHRoLCBoZWlnaHQ6IGMuaGVpZ2h0IH07XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgczogc3RyaW5nID0gYy50b0RhdGFVUkwoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsKSB7IE1hcmtlci5NYXJrZXJDYWNoZS5zZXQoaWNvbkluZm8uaWQsIHsgbWFya2VySWNvblN0cmluZzogcywgbWFya2VyU2l6ZTogaWNvbkluZm8uc2l6ZSB9KTsgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7aWNvbjogcywgaWNvbkluZm86IGljb25JbmZvfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcm91bmRlZCBpbWFnZSBtYXJrZXIgYnkgYXBwbHlpbmcgYSBjaXJjbGUgbWFzayB0byBhIHN1cHBsaWVkIGltYWdlLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSBpY29uSW5mbyAtIHtAbGluayBJTWFya2VySWNvbkluZm99IGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBjcmVhdGUgdGhlIGljb24uXHJcbiAgICAgKiBAcGFyYW0gaWNvbkluZm8gLSBDYWxsYmFjayBpbnZva2VkIG9uY2UgbWFya2VyIGdlbmVyYXRpb24gaXMgY29tcGxldGUuIFRoZSBjYWxsYmFja1xyXG4gICAgICogcGFyYW1ldGVycyBhcmUgdGhlIGRhdGEgdXJpIGFuZCB0aGUgSU1hcmtlckljb25JbmZvLlxyXG4gICAgICogQHJldHVybnMgLSBhIHN0cmluZyBvciBhIHByb21pc2UgZm9yIGEgc3RyaW5nIGNvbnRhaW5pbmdcclxuICAgICAqIGEgZGF0YSB1cmwgd2l0aCB0aGUgbWFya2VyIGltYWdlLiBJbiBjYXNlIG9mIGEgY2FjaGVkIGltYWdlLCB0aGUgaW1hZ2Ugd2lsbCBiZSByZXR1cm5lZCwgb3RoZXJ3aXNlIHRoZSBwcm9taXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBDcmVhdGVSb3VuZGVkSW1hZ2VNYXJrZXIoaWNvbkluZm86IElNYXJrZXJJY29uSW5mbyk6IHN0cmluZ3xQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PiB7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50ID09IG51bGwpIHsgdGhyb3cgRXJyb3IoJ0RvY3VtZW50IGNvbnRleHQgKHdpbmRvdy5kb2N1bWVudCkgaXMgcmVxdWlyZWQgZm9yIHJvdW5kZWQgaW1hZ2UgbWFya2VycycpOyB9XHJcbiAgICAgICAgaWYgKGljb25JbmZvID09IG51bGwgfHwgaWNvbkluZm8uc2l6ZSA9PSBudWxsIHx8IGljb25JbmZvLnVybCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJTWFya2VySWNvbkluZm8uc2l6ZSwgSU1hcmtlckljb25JbmZvLnVybCBhcmUgcmVxdWlyZWQgZm9yIHJvdW5kZWQgaW1hZ2UgbWFya2Vycy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGljb25JbmZvLmlkICE9IG51bGwgJiYgTWFya2VyLk1hcmtlckNhY2hlLmhhcyhpY29uSW5mby5pZCkpIHtcclxuICAgICAgICAgICAgY29uc3QgbWk6IElNYXJrZXJJY29uQ2FjaGVFbnRyeSA9IE1hcmtlci5NYXJrZXJDYWNoZS5nZXQoaWNvbkluZm8uaWQpO1xyXG4gICAgICAgICAgICBpY29uSW5mby5zaXplID0gbWkubWFya2VyU2l6ZTtcclxuICAgICAgICAgICAgcmV0dXJuIG1pLm1hcmtlckljb25TdHJpbmc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwcm9taXNlOiBQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PiA9XHJcbiAgICAgICAgICAgIG5ldyBQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1czogbnVtYmVyID0gaWNvbkluZm8uc2l6ZS53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldDogSVBvaW50ID0gaWNvbkluZm8uZHJhd2luZ09mZnNldCB8fCB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFsbG93IGNyb3NzIGRvbWFpbiBpbWFnZSBlZGl0dGluZy5cclxuICAgICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gaWNvbkluZm8udXJsO1xyXG4gICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjOiBIVE1MQ2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgICAgICBjLndpZHRoID0gaWNvbkluZm8uc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIGMuaGVpZ2h0ID0gaWNvbkluZm8uc2l6ZS53aWR0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEcmF3IGEgY2lyY2xlIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGNsaXAgdGhlIGltYWdlLCB0aGVuIGRyYXcgdGhlIGltYWdlLlxyXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmFyYyhyYWRpdXMsIHJhZGl1cywgcmFkaXVzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5jbGlwKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBvZmZzZXQueCwgb2Zmc2V0LnksIGljb25JbmZvLnNpemUud2lkdGgsIGljb25JbmZvLnNpemUud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgaWNvbkluZm8uc2l6ZSA9IHsgd2lkdGg6IGMud2lkdGgsIGhlaWdodDogYy5oZWlnaHQgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzOiBzdHJpbmcgPSBjLnRvRGF0YVVSTCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGljb25JbmZvLmlkICE9IG51bGwpIHsgTWFya2VyLk1hcmtlckNhY2hlLnNldChpY29uSW5mby5pZCwgeyBtYXJrZXJJY29uU3RyaW5nOiBzLCBtYXJrZXJTaXplOiBpY29uSW5mby5zaXplIH0pOyB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtpY29uOiBzLCBpY29uSW5mbzogaWNvbkluZm99KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzY2FsZWQgaW1hZ2UgbWFya2VyIGJ5IHNjYWxpbmcgYSBzdXBwbGllZCBpbWFnZSBieSBhIGZhY3RvciB1c2luZyBhIGNhbnZhcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0gaWNvbkluZm8gLSB7QGxpbmsgSU1hcmtlckljb25JbmZvfSBjb250YWluaW5nIHRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gY3JlYXRlIHRoZSBpY29uLlxyXG4gICAgICogQHBhcmFtIGljb25JbmZvIC0gQ2FsbGJhY2sgaW52b2tlZCBvbmNlIG1hcmtlciBnZW5lcmF0aW9uIGlzIGNvbXBsZXRlLiBUaGUgY2FsbGJhY2tcclxuICAgICAqIHBhcmFtZXRlcnMgYXJlIHRoZSBkYXRhIHVyaSBhbmQgdGhlIElNYXJrZXJJY29uSW5mby5cclxuICAgICAqIEByZXR1cm5zIC0gYSBzdHJpbmcgb3IgYSBwcm9taXNlIGZvciBhIHN0cmluZyBjb250YWluaW5nXHJcbiAgICAgKiBhIGRhdGEgdXJsIHdpdGggdGhlIG1hcmtlciBpbWFnZS4gSW4gY2FzZSBvZiBhIGNhY2hlZCBpbWFnZSwgdGhlIGltYWdlIHdpbGwgYmUgcmV0dXJuZWQsIG90aGVyd2lzZSB0aGUgcHJvbWlzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgQ3JlYXRlU2NhbGVkSW1hZ2VNYXJrZXIoaWNvbkluZm86IElNYXJrZXJJY29uSW5mbyk6IHN0cmluZ3xQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PiB7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50ID09IG51bGwpIHsgdGhyb3cgRXJyb3IoJ0RvY3VtZW50IGNvbnRleHQgKHdpbmRvdy5kb2N1bWVudCkgaXMgcmVxdWlyZWQgZm9yIHNjYWxlZCBpbWFnZSBtYXJrZXJzJyk7IH1cclxuICAgICAgICBpZiAoaWNvbkluZm8gPT0gbnVsbCB8fCBpY29uSW5mby5zY2FsZSA9PSBudWxsIHx8IGljb25JbmZvLnVybCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJTWFya2VySWNvbkluZm8uc2NhbGUsIElNYXJrZXJJY29uSW5mby51cmwgYXJlIHJlcXVpcmVkIGZvciBzY2FsZWQgaW1hZ2UgbWFya2Vycy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGljb25JbmZvLmlkICE9IG51bGwgJiYgTWFya2VyLk1hcmtlckNhY2hlLmhhcyhpY29uSW5mby5pZCkpIHtcclxuICAgICAgICAgICAgY29uc3QgbWk6IElNYXJrZXJJY29uQ2FjaGVFbnRyeSA9IE1hcmtlci5NYXJrZXJDYWNoZS5nZXQoaWNvbkluZm8uaWQpO1xyXG4gICAgICAgICAgICBpY29uSW5mby5zaXplID0gbWkubWFya2VyU2l6ZTtcclxuICAgICAgICAgICAgcmV0dXJuIG1pLm1hcmtlckljb25TdHJpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByb21pc2U6IFByb21pc2U8e2ljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mb30+ID1cclxuICAgICAgICAgICAgbmV3IFByb21pc2U8e2ljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mb30+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFsbG93IGNyb3NzIGRvbWFpbiBpbWFnZSBlZGl0dGluZy5cclxuICAgICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuICAgICAgICAgICAgaW1hZ2Uuc3JjID0gaWNvbkluZm8udXJsO1xyXG4gICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjOiBIVE1MQ2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgICAgICBjLndpZHRoID0gaW1hZ2Uud2lkdGggKiBpY29uSW5mby5zY2FsZTtcclxuICAgICAgICAgICAgICAgIGMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0ICogaWNvbkluZm8uc2NhbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBhIGNpcmNsZSB3aGljaCBjYW4gYmUgdXNlZCB0byBjbGlwIHRoZSBpbWFnZSwgdGhlbiBkcmF3IHRoZSBpbWFnZS5cclxuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIGMud2lkdGgsIGMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGljb25JbmZvLnNpemUgPSB7IHdpZHRoOiBjLndpZHRoLCBoZWlnaHQ6IGMuaGVpZ2h0IH07XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgczogc3RyaW5nID0gYy50b0RhdGFVUkwoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpY29uSW5mby5pZCAhPSBudWxsKSB7IE1hcmtlci5NYXJrZXJDYWNoZS5zZXQoaWNvbkluZm8uaWQsIHsgbWFya2VySWNvblN0cmluZzogcywgbWFya2VyU2l6ZTogaWNvbkluZm8uc2l6ZSB9KTsgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7aWNvbjogcywgaWNvbkluZm86IGljb25JbmZvfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgZGVmaW5pdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIG1hcmtlciBpcyB0aGUgZmlyc3QgbWFya2VyIGluIGEgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IElzRmlyc3QoKTogYm9vbGVhbjtcclxuICAgIHB1YmxpYyBhYnN0cmFjdCBzZXQgSXNGaXJzdCh2YWw6IGJvb2xlYW4pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIG1hcmtlciBpcyB0aGUgbGFzdCBtYXJrZXIgaW4gdGhlIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBJc0xhc3QoKTogYm9vbGVhbjtcclxuICAgIHB1YmxpYyBhYnN0cmFjdCBzZXQgSXNMYXN0KHZhbDogYm9vbGVhbik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBMb2NhdGlvbiBvZiB0aGUgbWFya2VyXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBMb2NhdGlvbigpOiBJTGF0TG9uZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG1hcmtlciBtZXRhZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IE1ldGFkYXRhKCk6IE1hcDxzdHJpbmcsIGFueT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgcHJpbWl0dmUgaW1wbGVtZW50aW5nIHRoZSBtYXJrZXIgKGUuZy4gTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbilcclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IGFueTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGV2ZW50IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgbGlzdGVuZXIgKGUuZy4gXCJjbGlja1wiKVxyXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgaW52b2tlZCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQWRkTGlzdGVuZXIoZXZlbnRUeXBlOiBzdHJpbmcsIGZuOiBGdW5jdGlvbik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgRGVsZXRlTWFya2VyKCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXJrZXIgbGFiZWxcclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRMYWJlbCgpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXJrZXIgdmlzaWJpbGl0eVxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldFZpc2libGUoKTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGFuY2hvciBmb3IgdGhlIG1hcmtlci4gVXNlIHRoaXMgdG8gYWRqdXN0IHRoZSByb290IGxvY2F0aW9uIGZvciB0aGUgbWFya2VyIHRvIGFjY29tb2RhdGUgdmFyaW91cyBtYXJrZXIgaW1hZ2Ugc2l6ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gYW5jaG9yIC0gUG9pbnQgY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXJrZXIgYW5jaG9yLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldEFuY2hvcihhbmNob3I6IElQb2ludCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBkcmFnZ2FiaWxpdHkgb2YgYSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZHJhZ2dhYmxlIC0gVHJ1ZSB0byBtYXJrIHRoZSBtYXJrZXIgYXMgZHJhZ2dhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0RHJhZ2dhYmxlKGRyYWdnYWJsZTogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBpY29uIGZvciB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGljb24gLSBTdHJpbmcgY29udGFpbmluZyB0aGUgaWNvbiBpbiB2YXJpb3VzIGZvcm1zICh1cmwsIGRhdGEgdXJsLCBldGMuKVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldEljb24oaWNvbjogc3RyaW5nKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1hcmtlciBsYWJlbC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYWJlbCAtIFN0cmluZyBjb250YWluaW5nIHRoZSBsYWJlbCB0byBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0TGFiZWwobGFiZWw6IHN0cmluZyk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXJrZXIgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF0TG5nIC0gR2VvIGNvb3JkaW5hdGVzIHRvIHNldCB0aGUgbWFya2VyIHBvc2l0aW9uIHRvLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldFBvc2l0aW9uKGxhdExuZzogSUxhdExvbmcpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWFya2VyIHRpdGxlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHRpdGxlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIHRpdGxlIHRvIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRUaXRsZSh0aXRsZTogc3RyaW5nKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1hcmtlciBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSU1hcmtlck9wdGlvbnN9IG9iamVjdCBjb250YWluaW5nIHRoZSBtYXJrZXIgb3B0aW9ucyB0byBzZXQuIFRoZSBzdXBwbGllZCBvcHRpb25zIGFyZVxyXG4gICAgICogbWVyZ2VkIHdpdGggdGhlIHVuZGVybHlpbmcgbWFya2VyIG9wdGlvbnMuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRPcHRpb25zKG9wdGlvbnM6IElNYXJrZXJPcHRpb25zKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZpc2libGlsdHkgb2YgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSB2aXNpYmxlIC0gQm9vbGVhbiB3aGljaCBkZXRlcm1pbmVzIGlmIHRoZSBtYXJrZXIgaXMgdmlzaWJsZSBvciBub3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZDtcclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuL21hcmtlcic7XHJcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuL3BvbHlnb24nO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4vcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi9pbmZvLXdpbmRvdyc7XHJcblxyXG4vKipcclxuICogRGVmaW5lcyB0aGUgY29udHJhY3QgZm9yIGEgbWFwIGxheWVyIGltcGxlbWVudGF0aW9uLiBEZXJpdmluZyBwcm92aWRlcnMgc2hvdWxkIGltcGxlbWVudHMgdGhpcyBhYnN0cmFjdFxyXG4gKiB0byBwcm92aWRlIGNvbmNyZXRlIGxheWVyIGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSBtYXAuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTGF5ZXIge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlZmluaXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbmF0aXZlIHByaW1pdGl2ZSB1bmRlcm5lYXRoIHRoZSBhYnN0cmFjdGlvbiBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgbGF5ZXIgaW4gdGhlIHVuZGVybHlpbmcgcHJvdmlkZXIgKHN1Y2ggYXNcclxuICAgICAqIE1pY3Jvc29mdC5NYXBzLkxheWVyKS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IGFueTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kcywgTGF5ZXIgaW50ZXJmYWNlIGltcGxlbWVudGF0aW9uXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIHN0cmluZy4gVHlwZSBvZiBldmVudCB0byBhZGQgKGNsaWNrLCBtb3VzZW92ZXIsIGV0YykuIFlvdSBjYW4gdXNlIGFueSBldmVudCB0aGF0IHRoZSB1bmRlcmx5aW5nIG5hdGl2ZVxyXG4gICAgICogbGF5ZXIgc3VwcG9ydHMuXHJcbiAgICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24uIEhhbmRsZXIgdG8gY2FsbCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBlbnRpdHkgdG8gdGhlIGxheWVyLiBFbnRpdGllcyBpbiB0aGlzIGNvbnRleHQgc2hvdWxkIGJlIG1vZGVsIGFic3RyYWN0aW9ucyBvZiBjb25jZXJlZCBtYXAgZnVuY3Rpb25hbGl0eSAoc3VjaFxyXG4gICAgICogYXMgbWFya2VyLCBpbmZvd2luZG93LCBwb2x5bGluZSwgcG9seWdvbiwgZXRjLi4pIEltcGxlbWVudGF0aW9ucyBvZiB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGV4cGVjdCBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2ZcclxuICAgICAqIHRoZXNlIGNvbmNlcHRzLCBpbnN0ZWFkLCB0aGUgYXBwcm9wcmlhdGUgYWJzdHJhY3QgbW9kZWwgY2xhc3NlcyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgZm9yIGVhY2ggcHJvdmlkZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5IE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmUuIEVudGl0eSB0byBhZGQgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBMYXllclxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBBZGRFbnRpdHkoZW50aXR5OiBNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBudW1iZXIgb2YgZW50aXRpZXMgdG8gdGhlIGxheWVyLiBFbnRpdGllcyBpbiB0aGlzIGNvbnRleHQgc2hvdWxkIGJlIG1vZGVsIGFic3RyYWN0aW9ucyBvZiBjb25jZXJlZCBtYXAgZnVuY3Rpb25hbGl0eSAoc3VjaFxyXG4gICAgICogYXMgbWFya2VyLCBpbmZvd2luZG93LCBwb2x5bGluZSwgcG9seWdvbiwgZXRjLi4pIEltcGxlbWVudGF0aW9ucyBvZiB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGV4cGVjdCBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2ZcclxuICAgICAqIHRoaXNlIGNvbmNlcHRzLCBpbnN0ZWFkLCB0aGUgYXBwcm9wcmlhdGUgYWJzdHJhY3QgbW9kZWwgY2xhc3NlcyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgZm9yIGVhY2ggcHJvdmlkZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZT4uIEVudGl0aWVzIHRvIGFkZCB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEFkZEVudGl0aWVzKGVudGl0eTogQXJyYXk8TWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZT4pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IERlbGV0ZSgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgb3B0aW9ucyBnb3Zlcm5pbmcgdGhlIGJlaGF2aW9yIG9mIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBsYXllciBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBMYXllclxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRPcHRpb25zKCk6IElMYXllck9wdGlvbnM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2aXNpYmlsaXR5IHN0YXRlIG9mIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaXMgdGhlIGxheWVyIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0VmlzaWJsZSgpOiBib29sZWFuO1xyXG5cclxuICAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gZW50aXR5IGZyb20gdGhlIGNsdXN0ZXIgbGF5ZXIuIEVudGl0aWVzIGluIHRoaXMgY29udGV4dCBzaG91bGQgYmUgbW9kZWwgYWJzdHJhY3Rpb25zIG9mIGNvbmNlcmVkIG1hcCBmdW5jdGlvbmFsaXR5IChzdWNoXHJcbiAgICAgKiBhcyBtYXJrZXIsIGluZm93aW5kb3csIHBvbHlsaW5lLCBwb2x5Z29uLCBldGMuLikgSW1wbGVtZW50YXRpb25zIG9mIHRoaXMgbWV0aG9kIHNob3VsZCBub3QgZXhwZWN0IG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZlxyXG4gICAgICogdGhpc2UgY29uY2VwdHMsIGluc3RlYWQsIHRoZSBhcHByb3ByaWF0ZSBhYnN0cmFjdCBtb2RlbCBjbGFzc2VzIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBmb3IgZWFjaCBwcm92aWRlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZSBFbnRpdHkgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgUmVtb3ZlRW50aXR5KGVudGl0eTogTWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZSk6IHZvaWQ7XHJcblxyXG4gICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZW50aXRpZXMgZm9yIHRoZSBjbHVzdGVyIGxheWVyLiBFbnRpdGllcyBpbiB0aGlzIGNvbnRleHQgc2hvdWxkIGJlIG1vZGVsIGFic3RyYWN0aW9ucyBvZiBjb25jZXJlZCBtYXAgZnVuY3Rpb25hbGl0eSAoc3VjaFxyXG4gICAgICogYXMgbWFya2VyLCBpbmZvd2luZG93LCBwb2x5bGluZSwgcG9seWdvbiwgZXRjLi4pIEltcGxlbWVudGF0aW9ucyBvZiB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGV4cGVjdCBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2ZcclxuICAgICAqIHRoaXNlIGNvbmNlcHRzLCBpbnN0ZWFkLCB0aGUgYXBwcm9wcmlhdGUgYWJzdHJhY3QgbW9kZWwgY2xhc3NlcyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgZm9yIGVhY2ggcHJvdmlkZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyPnxBcnJheTxJbmZvV2luZG93PnxBcnJheTxQb2x5Z29uPnxBcnJheTxQb2x5bGluZT4gY29udGFpbmluZyB0aGUgZW50aXRpZXMgdG8gYWRkIHRvIHRoZSBjbHVzdGVyLlxyXG4gICAgICogVGhpcyByZXBsYWNlcyBhbnkgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldEVudGl0aWVzKGVudGl0aWVzOiBBcnJheTxNYXJrZXI+fEFycmF5PEluZm9XaW5kb3c+fEFycmF5PFBvbHlnb24+fEFycmF5PFBvbHlsaW5lPik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBvcHRpb25zIGZvciB0aGUgY2x1c3RlciBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJQ2x1c3Rlck9wdGlvbnMgY29udGFpbmluZyB0aGUgb3B0aW9ucyBlbnVtZXJhdGlvbiBjb250cm9sbGluZyB0aGUgbGF5ZXIgYmVoYXZpb3IuIFRoZSBzdXBwbGllZCBvcHRpb25zXHJcbiAgICAgKiBhcmUgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQvZXhpc3Rpbmcgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0T3B0aW9ucyhvcHRpb25zOiBJTGF5ZXJPcHRpb25zKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRvZ2dsZXMgdGhlIGNsdXN0ZXIgbGF5ZXIgdmlzaWJpbGl0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSBCb29sZWFuIHRydWUgdG8gbWFrZSB0aGUgbGF5ZXIgdmlzaWJsZSwgZmFsc2UgdG8gaGlkZSB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZDtcclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBjbGFzcyBkZWZpbmluZyB0aGUgY29udHJhY3QgZm9yIGEgcG9seWdvbiBpbiB0aGUgYXJjaGl0ZWN0dXJlIHNwZWNpZmljIGltcGxlbWVudGF0aW9uLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBvbHlnb24ge1xyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByb3RlY3RlZCBfY2VudHJvaWQ6IElMYXRMb25nO1xyXG4gICAgcHJvdGVjdGVkIF9jZW50ZXI6IElMYXRMb25nO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlZmluaXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlnb24ncyBjZW50ZXIuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgQ2VudGVyKCk6IElMYXRMb25nIHtcclxuICAgICAgICBpZiAodGhpcy5fY2VudGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2VudGVyID0gdGhpcy5HZXRCb3VuZGluZ0NlbnRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY2VudGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9seWdvbidzIGNlbnRyb2lkLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IENlbnRyb2lkKCk6IElMYXRMb25nIHtcclxuICAgICAgICBpZiAodGhpcy5fY2VudHJvaWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jZW50cm9pZCA9IHRoaXMuR2V0UG9seWdvbkNlbnRyb2lkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jZW50cm9pZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4aW11bSB6b29tIGF0IHdoaWNoIHRoZSBsYWJlbCBpcyBkaXNwbGF5ZWQuIElnbm9yZWQgb3IgU2hvd0xhYmVsIGlzIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IExhYmVsTWF4Wm9vbSgpOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgYWJzdHJhY3Qgc2V0IExhYmVsTWF4Wm9vbSh2YWw6IG51bWJlcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gem9vbSBhdCB3aGljaCB0aGUgbGFiZWwgaXMgZGlzcGxheWVkLiBJZ25vcmVkIG9yIFNob3dMYWJlbCBpcyBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBMYWJlbE1pblpvb20oKTogbnVtYmVyO1xyXG4gICAgcHVibGljIGFic3RyYWN0IHNldCBMYWJlbE1pblpvb20odmFsOiBudW1iZXIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9seWdvbiBtZXRhZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBNZXRhZGF0YSgpOiBNYXA8c3RyaW5nLCBhbnk+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIHByaW1pdHZlIGltcGxlbWVudGluZyB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgTmF0aXZlUHJpbWl0dmUoKTogYW55O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gc2hvdyB0aGUgbGFiZWxcclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBTaG93TGFiZWwoKTogYm9vbGVhbjtcclxuICAgIHB1YmxpYyBhYnN0cmFjdCBzZXQgU2hvd0xhYmVsKHZhbDogYm9vbGVhbik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0byBzaG93IHRoZSB0b29sdGlwXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgU2hvd1Rvb2x0aXAoKTogYm9vbGVhbjtcclxuICAgIHB1YmxpYyBhYnN0cmFjdCBzZXQgU2hvd1Rvb2x0aXAodmFsOiBib29sZWFuKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgdGl0bGUgb2ZmIHRoZSBwb2x5Z29uXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgVGl0bGUoKTogc3RyaW5nO1xyXG4gICAgcHVibGljIGFic3RyYWN0IHNldCBUaXRsZSh2YWw6IHN0cmluZyk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGRlbGVnYXRlIGZvciBhbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgZXZlbnQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBmbiAtIERlbGVnYXRlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlZCB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgRGVsZXRlKCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgZHJhZ2dhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5Z29uIGlzIGRyYWdhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldERyYWdnYWJsZSgpOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIHBhdGggY2FuIGJlIGVkaXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcGF0aCBjYW4gYmUgZWRpdGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldEVkaXRhYmxlKCk6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb2x5Z29uIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcmV0dXJucyAtIEFycmF5IG9mIElMYXRMb25nIG9iamVjdHMgZGVzY3JpYmluZyB0aGUgcG9seWdvbiBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRQYXRoKCk6IEFycmF5PElMYXRMb25nPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlnb24gcGF0aHMuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcmV0dXJucyAtIEFycmF5IG9mIEFycmF5IG9mIElMYXRMb25nIG9iamVjdHMgZGVzY3JpYmluZyBtdWx0aXBsZSBwb2x5Z29uIHBhdGhzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRQYXRocygpOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBvbHlnb24gaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRWaXNpYmxlKCk6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgZHJhZ2FibGUuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZHJhZ2dhYmxlIC0gVHJ1ZSB0byBtYWtlIHRoZSBwb2x5Z29uIGRyYWdhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3ZXRoZXIgdGhlIHBvbHlnb24gcGF0aCBpcyBlZGl0YWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBlZGl0YWJsZSAtIFRydWUgdG8gbWFrZSBwb2x5Z29uIHBhdGggZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0RWRpdGFibGUoZWRpdGFibGU6IGJvb2xlYW4pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9seWdvbiBvcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIFRoZSBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBodGUgb25lc1xyXG4gICAgICogYWxyZWFkeSBvbiB0aGUgdW5kZXJseWluZyBtb2RlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0T3B0aW9ucyhvcHRpb25zOiBJUG9seWdvbk9wdGlvbnMpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9seWdvbiBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHBhdGggLSBBbiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IChvciBhcnJheSBvZiBhcnJheXMpIGRlc2NyaWJpbmcgdGhlIHBvbHlnb25zIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldFBhdGgocGF0aDogQXJyYXk8SUxhdExvbmc+IHwgQXJyYXk8SUxhdExvbmc+KTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcG9seWdvbiBwYXRoIG9yIHBhdGhzLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHBhdGhzIEFuIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ31cclxuICAgICAqIChvciBhcnJheSBvZiBhcnJheXMpIGRlc2NyaWJpbmcgdGhlIHBvbHlnb25zIHBhdGgocykuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldFBhdGhzKHBhdGhzOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+IHwgQXJyYXk8SUxhdExvbmc+KTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciB0aGUgcG9seWdvbiBpcyB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHZpc2libGUgLSBUcnVlIHRvIHNldCB0aGUgcG9seWdvbiB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvdGVjdGVkIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY2VudGVyIG9mIHRoZSBwb2x5Z29ucycgYm91bmRpbmcgYm94LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gSUxhdExvbmcgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgYm94LlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIEdldEJvdW5kaW5nQ2VudGVyKCk6IElMYXRMb25nIHtcclxuICAgICAgICBsZXQgYzogSUxhdExvbmcgPSB7bGF0aXR1ZGU6IDAsIGxvbmdpdHVkZTogMH07XHJcbiAgICAgICAgbGV0IHgxOiBudW1iZXIgPSA5MCwgeDI6IG51bWJlciA9IC05MCwgeTE6IG51bWJlciA9IDE4MCwgeTI6IG51bWJlciA9IC0xODA7XHJcbiAgICAgICAgY29uc3QgcGF0aDogQXJyYXk8QXJyYXk8SUxhdExvbmc+PiA9IHRoaXMuR2V0UGF0aHMoKTtcclxuICAgICAgICBpZiAocGF0aCkge1xyXG4gICAgICAgICAgICBwYXRoLmZvckVhY2goaW5uZXIgPT4gaW5uZXIuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChwLmxhdGl0dWRlIDwgeDEpIHsgeDEgPSBwLmxhdGl0dWRlOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAocC5sYXRpdHVkZSA+IHgyKSB7IHgyID0gcC5sYXRpdHVkZTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHAubG9uZ2l0dWRlIDwgeTEpIHsgeTEgPSBwLmxvbmdpdHVkZTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHAubG9uZ2l0dWRlID4geTIpIHsgeTIgPSBwLmxvbmdpdHVkZTsgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIGMubGF0aXR1ZGUgPSB4MSArICh4MiAtIHgxKSAvIDI7XHJcbiAgICAgICAgICAgIGMubG9uZ2l0dWRlID0geTEgKyAoeTIgLSB5MSkgLyAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjZW50cm9pZCBvZiB0aGUgcG9seWdvbiBiYXNlZCBvbiB0aGUgcG9seWdvbiBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVGhlIGNlbnRyb2lkIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2x5Z29uLlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIEdldFBvbHlnb25DZW50cm9pZCgpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgbGV0IGM6IElMYXRMb25nID0ge2xhdGl0dWRlOiAwLCBsb25naXR1ZGU6IDB9O1xyXG4gICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PEFycmF5PElMYXRMb25nPj4gPSB0aGlzLkdldFBhdGhzKCk7XHJcbiAgICAgICAgY29uc3Qgb2ZmID0gcGF0aFswXVswXTtcclxuICAgICAgICBpZiAob2ZmICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IHR3aWNlYXJlYTogbnVtYmVyID0gMDtcclxuICAgICAgICAgICAgbGV0IHg6IG51bWJlciA9IDA7XHJcbiAgICAgICAgICAgIGxldCB5OiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICBsZXQgcDE6IElMYXRMb25nLCBwMjogSUxhdExvbmc7XHJcbiAgICAgICAgICAgIGxldCBmOiBudW1iZXI7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcGF0aC5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBwYXRoW2tdLmxlbmd0aCAtIDE7IGkgPCBwYXRoW2tdLmxlbmd0aDsgaiA9IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHAxID0gcGF0aFtrXVtpXTtcclxuICAgICAgICAgICAgICAgICAgICBwMiA9IHBhdGhba11bal07XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IChwMS5sYXRpdHVkZSAtIG9mZi5sYXRpdHVkZSkgKiAocDIubG9uZ2l0dWRlIC0gb2ZmLmxvbmdpdHVkZSkgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocDIubGF0aXR1ZGUgLSBvZmYubGF0aXR1ZGUpICogKHAxLmxvbmdpdHVkZSAtIG9mZi5sb25naXR1ZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHR3aWNlYXJlYSArPSBmO1xyXG4gICAgICAgICAgICAgICAgICAgIHggKz0gKHAxLmxhdGl0dWRlICsgcDIubGF0aXR1ZGUgLSAyICogb2ZmLmxhdGl0dWRlKSAqIGY7XHJcbiAgICAgICAgICAgICAgICAgICAgeSArPSAocDEubG9uZ2l0dWRlICsgcDIubG9uZ2l0dWRlIC0gMiAqIG9mZi5sb25naXR1ZGUpICogZjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHdpY2VhcmVhICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmID0gdHdpY2VhcmVhICogMztcclxuICAgICAgICAgICAgICAgIGMubGF0aXR1ZGUgPSB4IC8gZiArIG9mZi5sYXRpdHVkZTtcclxuICAgICAgICAgICAgICAgIGMubG9uZ2l0dWRlID0geSAvIGYgKyBvZmYubG9uZ2l0dWRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYy5sYXRpdHVkZSA9IG9mZi5sYXRpdHVkZTtcclxuICAgICAgICAgICAgICAgIGMubG9uZ2l0dWRlID0gb2ZmLmxvbmdpdHVkZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBjbGFzcyBkZWZpbmluZyB0aGUgY29udHJhY3QgZm9yIGEgcG9seWxpbmUgaW4gdGhlIGFyY2hpdGVjdHVyZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbi5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQb2x5bGluZSB7XHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJvdGVjdGVkIF9jZW50cm9pZDogSUxhdExvbmc7XHJcbiAgICBwcm90ZWN0ZWQgX2NlbnRlcjogSUxhdExvbmc7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgZGVmaW5pdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9seWxpbmUncyBjZW50ZXIuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IENlbnRlcigpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NlbnRlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NlbnRlciA9IHRoaXMuR2V0Qm91bmRpbmdDZW50ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlsaW5lJ3MgY2VudHJvaWQuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IENlbnRyb2lkKCk6IElMYXRMb25nIHtcclxuICAgICAgICBpZiAodGhpcy5fY2VudHJvaWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jZW50cm9pZCA9IHRoaXMuR2V0UG9seWxpbmVDZW50cm9pZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fY2VudHJvaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgcHJpbWl0dmUgaW1wbGVtZW50aW5nIHRoZSBwb2x5bGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IGFueTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlsaW5lIG1ldGFkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IE1ldGFkYXRhKCk6IE1hcDxzdHJpbmcsIGFueT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0byBzaG93IHRoZSB0b29sdGlwXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZ2V0IFNob3dUb29sdGlwKCk6IGJvb2xlYW47XHJcbiAgICBwdWJsaWMgYWJzdHJhY3Qgc2V0IFNob3dUb29sdGlwKHZhbDogYm9vbGVhbik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHRpdGxlIG9mZiB0aGUgcG9seWxpbmVcclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgVGl0bGUoKTogc3RyaW5nO1xyXG4gICAgcHVibGljIGFic3RyYWN0IHNldCBUaXRsZSh2YWw6IHN0cmluZyk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjZW50cm9pZCBvZiB0aGUgcG9seWxpbmUgYmFzZWQgb24gdGhlIGEgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHRoZSBwYXRoIGZvciB3aGljaCB0byBnZW5lcmF0ZSB0aGUgY2VudHJvaWRcclxuICAgICAqIEByZXR1cm5zIC0gVGhlIGNlbnRyb2lkIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2x5bGluZS5cclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEdldFBvbHlsaW5lQ2VudHJvaWQocGF0aDogQXJyYXk8SUxhdExvbmc+KTogSUxhdExvbmcge1xyXG4gICAgICAgIGxldCBjOiBJTGF0TG9uZyA9IHtsYXRpdHVkZTogMCwgbG9uZ2l0dWRlOiAwfTtcclxuICAgICAgICBjb25zdCBvZmYgPSBwYXRoWzBdO1xyXG4gICAgICAgIGlmIChvZmYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsZXQgdHdpY2VhcmVhOiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICBsZXQgeDogbnVtYmVyID0gMDtcclxuICAgICAgICAgICAgbGV0IHk6IG51bWJlciA9IDA7XHJcbiAgICAgICAgICAgIGxldCBwMTogSUxhdExvbmcsIHAyOiBJTGF0TG9uZztcclxuICAgICAgICAgICAgbGV0IGY6IG51bWJlcjtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gcGF0aC5sZW5ndGggLSAxOyBpIDwgcGF0aC5sZW5ndGg7IGogPSBpKyspIHtcclxuICAgICAgICAgICAgICAgIHAxID0gcGF0aFtpXTtcclxuICAgICAgICAgICAgICAgIHAyID0gcGF0aFtqXTtcclxuICAgICAgICAgICAgICAgIGYgPSAocDEubGF0aXR1ZGUgLSBvZmYubGF0aXR1ZGUpICogKHAyLmxvbmdpdHVkZSAtIG9mZi5sb25naXR1ZGUpIC1cclxuICAgICAgICAgICAgICAgICAgICAocDIubGF0aXR1ZGUgLSBvZmYubGF0aXR1ZGUpICogKHAxLmxvbmdpdHVkZSAtIG9mZi5sb25naXR1ZGUpO1xyXG4gICAgICAgICAgICAgICAgdHdpY2VhcmVhICs9IGY7XHJcbiAgICAgICAgICAgICAgICB4ICs9IChwMS5sYXRpdHVkZSArIHAyLmxhdGl0dWRlIC0gMiAqIG9mZi5sYXRpdHVkZSkgKiBmO1xyXG4gICAgICAgICAgICAgICAgeSArPSAocDEubG9uZ2l0dWRlICsgcDIubG9uZ2l0dWRlIC0gMiAqIG9mZi5sb25naXR1ZGUpICogZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHdpY2VhcmVhICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmID0gdHdpY2VhcmVhICogMztcclxuICAgICAgICAgICAgICAgIGMubGF0aXR1ZGUgPSB4IC8gZiArIG9mZi5sYXRpdHVkZTtcclxuICAgICAgICAgICAgICAgIGMubG9uZ2l0dWRlID0geSAvIGYgKyBvZmYubG9uZ2l0dWRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYy5sYXRpdHVkZSA9IG9mZi5sYXRpdHVkZTtcclxuICAgICAgICAgICAgICAgIGMubG9uZ2l0dWRlID0gb2ZmLmxvbmdpdHVkZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGRlbGVnYXRlIGZvciBhbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgZXZlbnQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBmbiAtIERlbGVnYXRlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQWRkTGlzdGVuZXIoZXZlbnRUeXBlOiBzdHJpbmcsIGZuOiBGdW5jdGlvbik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVkIHRoZSBwb2x5bGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IERlbGV0ZSgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyBkcmFnZ2FibGUuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBvbHlsaW5lIGlzIGRyYWdhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXREcmFnZ2FibGUoKTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWxpbmUgcGF0aCBjYW4gYmUgZWRpdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwYXRoIGNhbiBiZSBlZGl0ZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldEVkaXRhYmxlKCk6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb2x5bGluZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiBJTGF0TG9uZyBvYmplY3RzIGRlc2NyaWJpbmcgdGhlIHBvbHlsaW5lIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRQYXRoKCk6IEFycmF5PElMYXRMb25nPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWxpbmUgaXMgdmlzaWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcG9seWxpbmUgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0VmlzaWJsZSgpOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyBkcmFnYWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBkcmFnZ2FibGUgLSBUcnVlIHRvIG1ha2UgdGhlIHBvbHlsaW5lIGRyYWdhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXREcmFnZ2FibGUoZHJhZ2dhYmxlOiBib29sZWFuKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2V0aGVyIHRoZSBwb2x5bGluZSBwYXRoIGlzIGVkaXRhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGVkaXRhYmxlIC0gVHJ1ZSB0byBtYWtlIHBvbHlsaW5lIHBhdGggZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldEVkaXRhYmxlKGVkaXRhYmxlOiBib29sZWFuKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvbHlsaW5lIG9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElMYXRMb25nfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucy4gVGhlIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGh0ZSBvbmVzXHJcbiAgICAgKiBhbHJlYWR5IG9uIHRoZSB1bmRlcmx5aW5nIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0T3B0aW9ucyhvcHRpb25zOiBJUG9seWxpbmVPcHRpb25zKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvbHlsaW5lIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIEFuIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ30gKG9yIGFycmF5IG9mIGFycmF5cykgZGVzY3JpYmluZyB0aGUgcG9seWxpbmVzIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRQYXRoKHBhdGg6IEFycmF5PElMYXRMb25nPiB8IEFycmF5PElMYXRMb25nPik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIGlzIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSAtIFRydWUgdG8gc2V0IHRoZSBwb2x5bGluZSB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3RlY3RlZCBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGNlbnRlciBvZiB0aGUgcG9seWxpbmUnIGJvdW5kaW5nIGJveC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgYm94LlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBHZXRCb3VuZGluZ0NlbnRlcigpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgbGV0IGM6IElMYXRMb25nID0ge2xhdGl0dWRlOiAwLCBsb25naXR1ZGU6IDB9O1xyXG4gICAgICAgIGxldCB4MTogbnVtYmVyID0gOTAsIHgyOiBudW1iZXIgPSAtOTAsIHkxOiBudW1iZXIgPSAxODAsIHkyOiBudW1iZXIgPSAtMTgwO1xyXG4gICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PElMYXRMb25nPiA9IHRoaXMuR2V0UGF0aCgpO1xyXG4gICAgICAgIGlmIChwYXRoKSB7XHJcbiAgICAgICAgICAgIHBhdGguZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChwLmxhdGl0dWRlIDwgeDEpIHsgeDEgPSBwLmxhdGl0dWRlOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAocC5sYXRpdHVkZSA+IHgyKSB7IHgyID0gcC5sYXRpdHVkZTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHAubG9uZ2l0dWRlIDwgeTEpIHsgeTEgPSBwLmxvbmdpdHVkZTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHAubG9uZ2l0dWRlID4geTIpIHsgeTIgPSBwLmxvbmdpdHVkZTsgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYy5sYXRpdHVkZSA9IHgxICsgKHgyIC0geDEpIC8gMjtcclxuICAgICAgICAgICAgYy5sb25naXR1ZGUgPSB5MSArICh5MiAtIHkxKSAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNlbnRyb2lkIG9mIHRoZSBwb2x5bGluZSBiYXNlZCBvbiB0aGUgcG9seWxpbmUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBjZW50cm9pZCBjb29yZGluYXRlcyBvZiB0aGUgcG9seWxpbmUuXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIEdldFBvbHlsaW5lQ2VudHJvaWQoKTogSUxhdExvbmcge1xyXG4gICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PElMYXRMb25nPiA9IHRoaXMuR2V0UGF0aCgpO1xyXG4gICAgICAgIGNvbnN0IGM6IElMYXRMb25nICA9IFBvbHlsaW5lLkdldFBvbHlsaW5lQ2VudHJvaWQocGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuL21hcmtlcic7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3BpZGVyQ2x1c3Rlck1hcmtlciBleHRlbmRzIE1hcmtlciB7XHJcblxyXG4gICAgLyoqIFRoZSBwYXJlbnQgcHVzaHBpbiBpbiB3aGljaCB0aGUgc3BpZGVyIHB1c2hwaW4gaXMgZGVyaXZlZCBmcm9tLiAqL1xyXG4gICAgcHVibGljIFBhcmVudE1hcmtlcjogTWFya2VyO1xyXG5cclxuICAgIC8qKiBUaGUgc3RpY2sgdGhhdCBjb25uZWN0cyB0aGUgc3BpZGVyIHB1c2hwaW4gdG8gdGhlIGNsdXN0ZXIuICovXHJcbiAgICBwdWJsaWMgU3RpY2s6IGFueTtcclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgTWFwTGFiZWwgfSBmcm9tICcuL21hcC1sYWJlbCc7XHJcblxyXG5sZXQgaWQ6IG51bWJlciA9IDA7XHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgYmFzZSBpbXBsZW1lbnRpbmcgYSBjYW52YXMgb3ZlcmxheSB0byBiZSBwbGFjZWQgb24gdGhlIG1hcC5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDYW52YXNPdmVybGF5IHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBmaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJvdGVjdGVkIF9yZWFkeVJlc29sdmVyOiAodmFsOiBib29sZWFuKSA9PiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIF9jYW52YXM6IEhUTUxDYW52YXNFbGVtZW50O1xyXG4gICAgcHJvdGVjdGVkIF96b29tU3RhcnQ6IG51bWJlcjtcclxuICAgIHByb3RlY3RlZCBfY2VudGVyU3RhcnQ6IElMYXRMb25nO1xyXG4gICAgcHVibGljIF9jYW52YXNSZWFkeTogUHJvbWlzZTxib29sZWFuPiA9IG5ldyBQcm9taXNlPGJvb2xlYW4+KChyZXNvbHZlLCByZWplY3QpID0+IHsgdGhpcy5fcmVhZHlSZXNvbHZlciA9IHJlc29sdmU7IH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBnZXRzIHJlc29sdmVkIHdoZW4gdGhlIGNhbnZhcyBvdmVybGF5IGlzIHJlYWR5IGZvciBpbnRlcmFjdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBDYW52YXNSZWFkeSgpOiBQcm9taXNlPGJvb2xlYW4+IHsgcmV0dXJuIHRoaXMuX2NhbnZhc1JlYWR5OyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY2FudmFzIGlzIHJlYWR5IHRvIGJlIHJlbmRlcmVkIGZvciB0aGUgY3VycmVudCBtYXAgdmlldy5cclxuICAgICovXHJcbiAgICBwcml2YXRlIF9kcmF3Q2FsbGJhY2s6IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB2b2lkO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIENhbnZhc092ZXJsYXkgY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGRyYXdDYWxsYmFjazogKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpID0+IHZvaWQpIHtcclxuICAgICAgICB0aGlzLl9kcmF3Q2FsbGJhY2sgPSBkcmF3Q2FsbGJhY2s7XHJcbiAgICAgICAgaWQrKztcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSBjYW52YXMgb3ZlcmxheS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLlNldE1hcChudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgZ2VvIGNvb3JkaW5hdGVzIGZvciB0aGUgY2xpY2sgbG9jYXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IGFueSk6IElMYXRMb25nO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG1hcCBhc3NvY2l0ZWQgd2l0aCB0aGUgbGFiZWwuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRNYXAoKTogYW55O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIE1hcExhYmVsIGluc3RhbmNlIGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgdG9vbHRpcC5cclxuICAgICAqIFRoaXMgbWV0aG9kIG9ubHkgZ2VuZXJhdGVzIHRoZSBtYXAgbGFiZWwuIENvbnRlbnQgYW5kIHBsYWNlbWVudCBpcyB0aGUgcmVzcG9uc2liaWxpdHlcclxuICAgICAqIG9mIHRoZSBjYWxsZXIuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRUb29sVGlwT3ZlcmxheSgpOiBNYXBMYWJlbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbnZhc092ZXJsYXkgYWRkZWQgdG8gbWFwLCBsb2FkIGNhbnZhcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIE9uQWRkKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmxlZnQgPSAnMHB4JztcclxuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUudG9wID0gJzBweCc7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLmlkID0gYHhNYXBPdmVybGF5JHtpZH1gO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIGNhbnZhcyB0byB0aGUgb3ZlcmxheS5cclxuICAgICAgICB0aGlzLlNldENhbnZhc0VsZW1lbnQodGhpcy5fY2FudmFzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbnZhc092ZXJsYXkgbG9hZGVkLCBhdHRhY2ggbWFwIGV2ZW50cyBmb3IgdXBkYXRpbmcgY2FudmFzLlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgT25Mb2FkKCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIHRoZSBDYW52YXNMYXllciBpcyByZW1vdmVkIGZyb20gdGhlIG1hcCwgcmVsZWFzZSByZXNvdXJjZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgT25SZW1vdmUoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5TZXRDYW52YXNFbGVtZW50KG51bGwpO1xyXG4gICAgICAgIHRoaXMuUmVtb3ZlRXZlbnRIYW5kbGVycygpO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXdzIHRoZSBjYW52YXMgZm9yIHRoZSBjdXJyZW50IG1hcCB2aWV3LlxyXG4gICAgICogQHBhcmFtIGNsZWFyIC0gVHJ1ZSB0byBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIFJlZHJhdyhjbGVhcjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYW52YXMgPT0gbnVsbCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgY2FudmFzIGJ5IHVwZGF0aW5nIGRpbWVuc2lvbnMuIFRoaXMgYWxzbyBlbnN1cmVzIGNhbnZhcyBzdGF5cyB0aGUgc2FtZSBzaXplIGFzIHRoZSBtYXAuXHJcbiAgICAgICAgaWYgKGNsZWFyKSB7IHRoaXMuUmVzaXplKCk7IH1cclxuXHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgZHJhd2luZyBjYWxsYmFjayBmdW5jdGlvbiBpZiBzcGVjaWZpZWQuXHJcbiAgICAgICAgaWYgKHRoaXMuX2RyYXdDYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLl9kcmF3Q2FsbGJhY2sodGhpcy5fY2FudmFzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXAgZm9yIHRoZSBsYWJlbC4gU2V0dGluZ3MgdGhpcyB0byBudWxsIHJlbW92ZSB0aGUgbGFiZWwgZnJvbSBodGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSBBIG5hdGl2ZSBtYXAgb2JqZWN0IGZvciB0aGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbi4gSW1wbGVtZW50aW5nIGRlcml2YXRpdmVzIHNob3VsZCByZXR1cm4gdGhlXHJcbiAgICAgKiBhY3R1YWwgbmF0aXZlIG9iamVjdC5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTZXRNYXAobWFwOiBhbnkpOiB2b2lkO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3RlY3RlZCBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIHRoZSBjYW52YXMgdG8gdGhlIG1hcC5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBTZXRDYW52YXNFbGVtZW50KGVsOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgdGhlIG1hcCBldmVudCBoYW5kbGVycy5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IFJlbW92ZUV2ZW50SGFuZGxlcnMoKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIENhbnZhcyBzaXplIGJhc2VkIG9uIHRoZSBtYXAgc2l6ZS5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IFJlc2l6ZSgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgQ2FudmFzLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IFVwZGF0ZUNhbnZhcygpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2ltcGxlIGZ1bmN0aW9uIGZvciB1cGRhdGluZyB0aGUgQ1NTIHBvc2l0aW9uIGFuZCBkaW1lbnNpb25zIG9mIHRoZSBjYW52YXMuXHJcbiAgICAgKiBAcGFyYW0geCBUaGUgaG9yaXpvbnRhbCBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIGNhbnZhcy5cclxuICAgICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIGNhbnZhcy5cclxuICAgICAqIEBwYXJhbSB3IFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzLlxyXG4gICAgICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIFVwZGF0ZVBvc2l0aW9uKHg6IG51bWJlciwgeTogbnVtYmVyLCB3OiBudW1iZXIsIGg6IG51bWJlcikge1xyXG4gICAgICAgIC8vIFVwZGF0ZSBDU1MgcG9zaXRpb24uXHJcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcclxuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUudG9wID0geSArICdweCc7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBDU1MgZGltZW5zaW9ucy5cclxuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcclxuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IGVhY2hTZXJpZXMsIG5leHRUaWNrIH0gZnJvbSAnYXN5bmMnO1xyXG5pbXBvcnQgeyBJTGF5ZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF5ZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vbGF5ZXInO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi9tYXJrZXInO1xyXG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vcG9seWdvbic7XHJcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi4vcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vaW5mby13aW5kb3cnO1xyXG5pbXBvcnQgeyBCaW5nTWFwU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2V9IGZyb20gJy4uLy4uL3NlcnZpY2VzL21hcC5zZXJ2aWNlJztcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIG1hcCBsYXllciBmb3IgdGhlIEJpbmcgTWFwIFByb3ZpZGVyLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmluZ0xheWVyIGltcGxlbWVudHMgTGF5ZXIge1xyXG5cclxuICAgIHByaXZhdGUgX3BlbmRpbmdFbnRpdGllczogQXJyYXk8TWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZT4gPSBuZXcgQXJyYXk8TWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZT4oKTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWZpbml0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG5hdGl2ZSBwcmltaXRpdmUgdW5kZXJuZWF0aCB0aGUgYWJzdHJhY3Rpb24gbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgTWljcm9zb2Z0Lk1hcHMuTGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IGFueSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEJpbmdDbHVzdGVyTGF5ZXIgY2xhc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIF9sYXllciBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyTGF5ZXIuIE5hdGl2ZSBCaW5nIENsdXN0ZXIgTGF5ZXIgc3VwcG9ydGluZyB0aGUgY2x1c3RlciBsYXllci5cclxuICAgICAqIEBwYXJhbSBfbWFwcyBNYXBTZXJ2aWNlLiBNYXBTZXJ2aWNlIGltcGxlbWVudGF0aW9uIHRvIGxldmVyYWdlIGZvciB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sYXllcjogTWljcm9zb2Z0Lk1hcHMuTGF5ZXIsIHByaXZhdGUgX21hcHM6IE1hcFNlcnZpY2UpIHsgfVxyXG5cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kcywgTGF5ZXIgaW50ZXJmYWNlIGltcGxlbWVudGF0aW9uXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIHN0cmluZy4gVHlwZSBvZiBldmVudCB0byBhZGQgKGNsaWNrLCBtb3VzZW92ZXIsIGV0YykuIFlvdSBjYW4gdXNlIGFueSBldmVudCB0aGF0IHRoZSB1bmRlcmx5aW5nIG5hdGl2ZVxyXG4gICAgICogbGF5ZXIgc3VwcG9ydHMuXHJcbiAgICAgKiBAcGFyYW0gZm4gZnVuY3Rpb24uIEhhbmRsZXIgdG8gY2FsbCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkTGlzdGVuZXIoZXZlbnRUeXBlOiBzdHJpbmcsIGZuOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX2xheWVyLCBldmVudFR5cGUsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGZuKGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBlbnRpdHkgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZS4gRW50aXR5IHRvIGFkZCB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkRW50aXR5KGVudGl0eTogTWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChlbnRpdHkgJiYgZW50aXR5Lk5hdGl2ZVByaW1pdHZlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLkdldFZpc2libGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIuYWRkKGVudGl0eS5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nRW50aXRpZXMucHVzaChlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG51bWJlciBvZiBlbnRpdGllcyB0byB0aGUgbGF5ZXIuIEVudGl0aWVzIGluIHRoaXMgY29udGV4dCBzaG91bGQgYmUgbW9kZWwgYWJzdHJhY3Rpb25zIG9mIGNvbmNlcmVkIG1hcCBmdW5jdGlvbmFsaXR5IChzdWNoXHJcbiAgICAgKiBhcyBtYXJrZXIsIGluZm93aW5kb3csIHBvbHlsaW5lLCBwb2x5Z29uLCBldGMuLilcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZT4uIEVudGl0aWVzIHRvIGFkZCB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkRW50aXRpZXMoZW50aXRpZXM6IEFycmF5PE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmU+KTogdm9pZCB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyB1c2UgZWFjaFNlcmllcyBhcyBvcHBvc2VkIHRvIF9sYXllci5hZGQoW10pIHRvIHByb3ZpZGUgYSBub24tYmxvY2tpbmcgZXhwZXJpZW5jZSBmb3IgbGFyZ2VyIGRhdGEgc2V0cy5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGlmIChlbnRpdGllcyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkoZW50aXRpZXMpICYmIGVudGl0aWVzLmxlbmd0aCAhPT0gMCApIHtcclxuICAgICAgICAgICAgZWFjaFNlcmllcyhbLi4uZW50aXRpZXNdLCAoZSwgbmV4dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuR2V0VmlzaWJsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIuYWRkKGUuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0VudGl0aWVzLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXh0VGljaygoKSA9PiBuZXh0KCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGUoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbWFwcy5EZWxldGVMYXllcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG9wdGlvbnMgZ292ZXJuaW5nIHRoZSBiZWhhdmlvciBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgSUNsdXN0ZXJPcHRpb25zLiBUaGUgbGF5ZXIgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRPcHRpb25zKCk6IElMYXllck9wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG86IElMYXllck9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGlkOiBOdW1iZXIodGhpcy5fbGF5ZXIuZ2V0SWQoKSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQm9vbGVhbi4gVHJ1ZSBpcyB0aGUgbGF5ZXIgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllci5nZXRWaXNpYmxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIGVudGl0eSBmcm9tIHRoZSBjbHVzdGVyIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZSB0byBiZSByZW1vdmVkIGZyb20gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFJlbW92ZUVudGl0eShlbnRpdHk6IE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmUpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZW50aXR5Lk5hdGl2ZVByaW1pdHZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLnJlbW92ZShlbnRpdHkuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGVudGl0aWVzIGZvciB0aGUgY2x1c3RlciBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyPnxBcnJheTxJbmZvV2luZG93PnxBcnJheTxQb2x5Z29uPnxBcnJheTxQb2x5bGluZT4gY29udGFpbmluZyB0aGUgZW50aXRpZXMgdG8gYWRkIHRvIHRoZSBjbHVzdGVyLlxyXG4gICAgICogVGhpcyByZXBsYWNlcyBhbnkgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0RW50aXRpZXMoZW50aXRpZXM6IEFycmF5PE1hcmtlcj58QXJyYXk8SW5mb1dpbmRvdz58QXJyYXk8UG9seWdvbj58QXJyYXk8UG9seWxpbmU+KTogdm9pZCB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyB3ZSBhcmUgdXNpbmcgcmVtb3ZhbCBhbmQgYWRkIGFzIG9wcG9zZWQgdG8gc2V0IGFzIGZvciBsYXJnZSBudW1iZXIgb2Ygb2JqZWN0cyBpdCB5aWVsZHMgYSBub24tYmxvY2tpbmcsIHNtb290aGVyIHBlcmZvcm1hbmNlLi4uXHJcbiAgICAgICAgLy9cclxuICAgICAgICB0aGlzLl9sYXllci5zZXRQcmltaXRpdmVzKFtdKTtcclxuICAgICAgICB0aGlzLkFkZEVudGl0aWVzKGVudGl0aWVzKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBvcHRpb25zIGZvciB0aGUgY2x1c3RlciBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJQ2x1c3Rlck9wdGlvbnMgY29udGFpbmluZyB0aGUgb3B0aW9ucyBlbnVtZXJhdGlvbiBjb250cm9sbGluZyB0aGUgbGF5ZXIgYmVoYXZpb3IuIFRoZSBzdXBwbGllZCBvcHRpb25zXHJcbiAgICAgKiBhcmUgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQvZXhpc3Rpbmcgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRPcHRpb25zKG9wdGlvbnM6IElMYXllck9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9sYXllci5tZXRhZGF0YS5pZCA9IG9wdGlvbnMuaWQudG9TdHJpbmcoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRvZ2dsZXMgdGhlIGNsdXN0ZXIgbGF5ZXIgdmlzaWJpbGl0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSBCb29sZWFuIHRydWUgdG8gbWFrZSB0aGUgbGF5ZXIgdmlzaWJsZSwgZmFsc2UgdG8gaGlkZSB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXIuc2V0VmlzaWJsZSh2aXNpYmxlKTtcclxuICAgICAgICBpZiAodmlzaWJsZSAmJiB0aGlzLl9wZW5kaW5nRW50aXRpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLkFkZEVudGl0aWVzKHRoaXMuX3BlbmRpbmdFbnRpdGllcy5zcGxpY2UoMCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSU1hcE9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXAtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElCb3ggfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lib3gnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSU1hcmtlckljb25JbmZvIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLWljb24taW5mbyc7XHJcbmltcG9ydCB7IElDbHVzdGVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWNsdXN0ZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElJbmZvV2luZG93T3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJSW5mb1dpbmRvd0FjdGlvbiB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LWFjdGlvbic7XHJcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9pbnQnO1xyXG5pbXBvcnQgeyBNYXBUeXBlSWQgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFwLXR5cGUtaWQnO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcclxuaW1wb3J0IHsgQ2x1c3RlclBsYWNlbWVudE1vZGUgfSBmcm9tICcuLi8uLi9tb2RlbHMvY2x1c3Rlci1wbGFjZW1lbnQtbW9kZSc7XHJcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLW1hcC5zZXJ2aWNlJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGNvbnRhaW5zIGhlbHBlcmZ1bmN0aW9ucyB0byBtYXAgdmFyaW91cyBpbnRlcmZhY2VzIHVzZWQgdG8gcmVwcmVzZW50IG9wdGlvbnMgYW5kIHN0cnVjdHVyZXMgaW50byB0aGVcclxuICogY29ycmVzcG9uZGluZyBCaW5nIE1hcHMgVjggc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmluZ0NvbnZlcnNpb25zIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBCaW5nIE1hcCBwcm9wZXJ0aWVzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfbWFwT3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xyXG4gICAgICAgICdiYWNrZ3JvdW5kQ29sb3InLFxyXG4gICAgICAgICdjcmVkZW50aWFscycsXHJcbiAgICAgICAgJ2N1c3RvbWl6ZU92ZXJsYXlzJyxcclxuICAgICAgICAnZGlzYWJsZUJpcmRzZXllJyxcclxuICAgICAgICAnZGlzYWJsZUtleWJvYXJkSW5wdXQnLFxyXG4gICAgICAgICdkaXNhYmxlTW91c2VJbnB1dCcsXHJcbiAgICAgICAgJ2Rpc2FibGVQYW5uaW5nJyxcclxuICAgICAgICAnZGlzYWJsZVRvdWNoSW5wdXQnLFxyXG4gICAgICAgICdkaXNhYmxlVXNlcklucHV0JyxcclxuICAgICAgICAnZGlzYWJsZVpvb21pbmcnLFxyXG4gICAgICAgICdkaXNhYmxlU3RyZWV0c2lkZScsXHJcbiAgICAgICAgJ2VuYWJsZUNsaWNrYWJsZUxvZ28nLFxyXG4gICAgICAgICdlbmFibGVTZWFyY2hMb2dvJyxcclxuICAgICAgICAnZml4ZWRNYXBQb3NpdGlvbicsXHJcbiAgICAgICAgJ2hlaWdodCcsXHJcbiAgICAgICAgJ2luZXJ0aWFJbnRlbnNpdHknLFxyXG4gICAgICAgICduYXZpZ2F0aW9uQmFyTW9kZScsXHJcbiAgICAgICAgJ3Nob3dCcmVhZGNydW1iJyxcclxuICAgICAgICAnc2hvd0NvcHlyaWdodCcsXHJcbiAgICAgICAgJ3Nob3dEYXNoYm9hcmQnLFxyXG4gICAgICAgICdzaG93TWFwVHlwZVNlbGVjdG9yJyxcclxuICAgICAgICAnc2hvd1NjYWxlYmFyJyxcclxuICAgICAgICAndGhlbWUnLFxyXG4gICAgICAgICd0aWxlQnVmZmVyJyxcclxuICAgICAgICAndXNlSW5lcnRpYScsXHJcbiAgICAgICAgJ3dpZHRoJyxcclxuICAgICAgICAnY2VudGVyJyxcclxuICAgICAgICAnem9vbScsXHJcbiAgICAgICAgJ21hcFR5cGVJZCdcclxuICAgIF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWaWV3IG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBCaW5nIE1hcCBwcm9wZXJ0aWVzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfdmlld09wdGlvbnNBdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtcclxuICAgICAgICAnYW5pbWF0ZScsXHJcbiAgICAgICAgJ2JvdW5kcycsXHJcbiAgICAgICAgJ2NlbnRlcicsXHJcbiAgICAgICAgJ2NlbnRlck9mZnNldCcsXHJcbiAgICAgICAgJ2hlYWRpbmcnLFxyXG4gICAgICAgICdsYWJlbE92ZXJsYXknLFxyXG4gICAgICAgICdtYXBUeXBlSWQnLFxyXG4gICAgICAgICdwYWRkaW5nJyxcclxuICAgICAgICAnem9vbSdcclxuICAgIF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmZvV2luZG93IG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBCaW5nIE1hcCBwcm9wZXJ0aWVzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfaW5mb1dpbmRvd09wdGlvbnNBdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtcclxuICAgICAgICAnYWN0aW9ucycsXHJcbiAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcclxuICAgICAgICAnaHRtbENvbnRlbnQnLFxyXG4gICAgICAgICdpZCcsXHJcbiAgICAgICAgJ3Bvc2l0aW9uJyxcclxuICAgICAgICAncGl4ZWxPZmZzZXQnLFxyXG4gICAgICAgICdzaG93Q2xvc2VCdXR0b24nLFxyXG4gICAgICAgICdzaG93UG9pbnRlcicsXHJcbiAgICAgICAgJ3B1c2hwaW4nLFxyXG4gICAgICAgICd0aXRsZScsXHJcbiAgICAgICAgJ3RpdGxlQ2xpY2tIYW5kbGVyJyxcclxuICAgICAgICAndHlwZU5hbWUnLFxyXG4gICAgICAgICd2aXNpYmxlJyxcclxuICAgICAgICAnd2lkdGgnLFxyXG4gICAgICAgICdoZWlnaHQnXHJcbiAgICBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFya2VyIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBCaW5nIE1hcCBwcm9wZXJ0aWVzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfbWFya2VyT3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xyXG4gICAgICAgICdhbmNob3InLFxyXG4gICAgICAgICdkcmFnZ2FibGUnLFxyXG4gICAgICAgICdoZWlnaHQnLFxyXG4gICAgICAgICdodG1sQ29udGVudCcsXHJcbiAgICAgICAgJ2ljb24nLFxyXG4gICAgICAgICdpbmZvYm94JyxcclxuICAgICAgICAnc3RhdGUnLFxyXG4gICAgICAgICd0aXRsZScsXHJcbiAgICAgICAgJ3RleHRPZmZzZXQnLFxyXG4gICAgICAgICd0eXBlTmFtZScsXHJcbiAgICAgICAgJ3Zpc2libGUnLFxyXG4gICAgICAgICd3aWR0aCcsXHJcbiAgICAgICAgJ3pJbmRleCdcclxuICAgIF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb2x5Z29uIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBCaW5nIE1hcCBQb2x5Z29uIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9wb2x5Z29uT3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xyXG4gICAgICAgICdjdXJzb3InLFxyXG4gICAgICAgICdmaWxsQ29sb3InLFxyXG4gICAgICAgICdmaWxsT3BhY2l0eScsXHJcbiAgICAgICAgJ3N0cm9rZUNvbG9yJyxcclxuICAgICAgICAnc3Ryb2tlT3BhY2l0eScsXHJcbiAgICAgICAgJ3N0cm9rZVdlaWdodCcsXHJcbiAgICAgICAgJ3Zpc2libGUnXHJcbiAgICBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9seWxpbmUgb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEJpbmcgTWFwIFBvbHlsaW5lIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9wb2x5bGluZU9wdGlvbnNBdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtcclxuICAgICAgICAnY3Vyc29yJyxcclxuICAgICAgICAnc3Ryb2tlQ29sb3InLFxyXG4gICAgICAgICdzdHJva2VPcGFjaXR5JyxcclxuICAgICAgICAnc3Ryb2tlV2VpZ2h0JyxcclxuICAgICAgICAndmlzaWJsZSdcclxuICAgIF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbHVzdGVyIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBCaW5nIE1hcCBwcm9wZXJ0aWVzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfY2x1c3Rlck9wdGlvbnNBdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtcclxuICAgICAgICAnY2FsbGJhY2snLFxyXG4gICAgICAgICdjbHVzdGVyZWRQaW5DYWxsYmFjaycsXHJcbiAgICAgICAgJ2NsdXN0ZXJpbmdFbmFibGVkJyxcclxuICAgICAgICAnZ3JpZFNpemUnLFxyXG4gICAgICAgICdsYXllck9mZnNldCcsXHJcbiAgICAgICAgJ3BsYWNlbWVudE1vZGUnLFxyXG4gICAgICAgICd2aXNpYmxlJyxcclxuICAgICAgICAnekluZGV4J1xyXG4gICAgXTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGFuIElJbmZvV2luZG93QWN0aW9uIHRvIGEgTWljcm9zb2Z0Lk1hcHMuSUluZm9ib3hBY3Rpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE5hdnRpdmUgbWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlQWN0aW9uKGFjdGlvbjogSUluZm9XaW5kb3dBY3Rpb24pOiBNaWNyb3NvZnQuTWFwcy5JSW5mb2JveEFjdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IGE6IE1pY3Jvc29mdC5NYXBzLklJbmZvYm94QWN0aW9ucyA9IHtcclxuICAgICAgICAgICAgZXZlbnRIYW5kbGVyOiBhY3Rpb24uZXZlbnRIYW5kbGVyLFxyXG4gICAgICAgICAgICBsYWJlbDogYWN0aW9uLmxhYmVsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gQXJyYXkgb2YgSUluZm9XaW5kb3dBY3Rpb24gdG8gYW4gQXJyYXkgb2YgTWljcm9zb2Z0Lk1hcHMuSUluZm9ib3hBY3Rpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdGlvbnMgLSBBcnJheSBvZiBvYmplY3RzIHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gQXJyYXkgb2YgbWFwcGVkIG9iamVjdHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZUFjdGlvbnMoYWN0aW9uczogQXJyYXk8SUluZm9XaW5kb3dBY3Rpb24+KTogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuSUluZm9ib3hBY3Rpb25zPiB7XHJcbiAgICAgICAgY29uc3QgYTogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuSUluZm9ib3hBY3Rpb25zPiA9IG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5JSW5mb2JveEFjdGlvbnM+KCk7XHJcbiAgICAgICAgYWN0aW9ucy5mb3JFYWNoKHggPT4gYS5wdXNoKEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVBY3Rpb24oeCkpKTtcclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gSUJveCBvYmplY3QgdG8gYSBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvblJlY3Qgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBib3ggLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVCb3VuZHMoYm94OiBJQm94KTogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb25SZWN0IHtcclxuICAgICAgICBjb25zdCByOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvblJlY3QgPVxyXG4gICAgICAgICAgICBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvblJlY3QuZnJvbUVkZ2VzKGJveC5tYXhMYXRpdHVkZSwgYm94Lm1pbkxvbmdpdHVkZSwgYm94Lm1pbkxhdGl0dWRlLCBib3gubWF4TG9uZ2l0dWRlKTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gSUNsdXN0ZXJPcHRpb25zIG9iamVjdCB0byBhIE1pY3Jvc29mdC5NYXBzLklDbHVzdGVyTGF5ZXJPcHRpb25zIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZUNsdXN0ZXJPcHRpb25zKG9wdGlvbnM6IElDbHVzdGVyT3B0aW9ucyk6IE1pY3Jvc29mdC5NYXBzLklDbHVzdGVyTGF5ZXJPcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JQ2x1c3RlckxheWVyT3B0aW9ucyB8IGFueSA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoayA9PiBCaW5nQ29udmVyc2lvbnMuX2NsdXN0ZXJPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMSlcclxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChrID09PSAnbGF5ZXJPZmZzZXQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5sYXllck9mZnNldCA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2ludChvcHRpb25zLmxheWVyT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChrID09PSAncGxhY2VtZW50TW9kZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wbGFjZW1lbnRNb2RlID09PSBDbHVzdGVyUGxhY2VtZW50TW9kZS5GaXJzdFBpbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvLnBsYWNlbWVudE1vZGUgPSBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUGxhY2VtZW50VHlwZS5GaXJzdExvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5wbGFjZW1lbnRNb2RlID0gTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclBsYWNlbWVudFR5cGUuTWVhbkF2ZXJhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb1trXSA9ICg8YW55Pm9wdGlvbnMpW2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gSUluZm9XaW5kb3dPcHRpb25zIG9iamVjdCB0byBhIE1pY3Jvc29mdC5NYXBzLklJbmZvYm94T3B0aW9ucyBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVJbmZvQm94T3B0aW9ucyhvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMpOiBNaWNyb3NvZnQuTWFwcy5JSW5mb2JveE9wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklJbmZvYm94T3B0aW9ucyB8IGFueSA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoayA9PiBCaW5nQ29udmVyc2lvbnMuX2luZm9XaW5kb3dPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMSlcclxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChrID09PSAncGl4ZWxPZmZzZXQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5vZmZzZXQgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9pbnQob3B0aW9ucy5waXhlbE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrID09PSAncG9zaXRpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5sb2NhdGlvbiA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihvcHRpb25zLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdhY3Rpb25zJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uYWN0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVBY3Rpb25zKG9wdGlvbnMuYWN0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhbiBJTWFwT3B0aW9ucyBvYmplY3QgdG8gYSBNaWNyb3NvZnQuTWFwcy5JTWFwTG9hZE9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlTG9hZE9wdGlvbnMob3B0aW9uczogSU1hcE9wdGlvbnMpOiBNaWNyb3NvZnQuTWFwcy5JTWFwTG9hZE9wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklNYXBMb2FkT3B0aW9ucyB8IGFueSA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoayA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQmluZ0NvbnZlcnNpb25zLl9tYXBPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMSB8fCBCaW5nQ29udmVyc2lvbnMuX3ZpZXdPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChrID09PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uY2VudGVyID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKG9wdGlvbnMuY2VudGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdtYXBUeXBlSWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFwVHlwZUlkID09PSBNYXBUeXBlSWQuaHlicmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ubWFwVHlwZUlkID0gTWljcm9zb2Z0Lk1hcHMuTWFwVHlwZUlkLmFlcmlhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5sYWJlbE92ZXJsYXkgPSBNaWNyb3NvZnQuTWFwcy5MYWJlbE92ZXJsYXkudmlzaWJsZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5tYXBUeXBlSWQgPT09IE1hcFR5cGVJZC5hZXJpYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5tYXBUeXBlSWQgPSBNaWNyb3NvZnQuTWFwcy5NYXBUeXBlSWQuYWVyaWFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvLmxhYmVsT3ZlcmxheSA9IE1pY3Jvc29mdC5NYXBzLkxhYmVsT3ZlcmxheS5oaWRkZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvLm1hcFR5cGVJZCA9IE1pY3Jvc29mdC5NYXBzLk1hcFR5cGVJZFsoPGFueT5NYXBUeXBlSWQpW29wdGlvbnMubWFwVHlwZUlkXV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ2JvdW5kcycpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLmJvdW5kcyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVCb3VuZHMob3B0aW9ucy5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb1trXSA9ICg8YW55Pm9wdGlvbnMpW2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gSUxhdExvbmcgb2JqZWN0IHRvIGEgTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXRsb25nIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlTG9jYXRpb24obGF0bG9uZzogSUxhdExvbmcpOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiB7XHJcbiAgICAgICAgY29uc3QgbDogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPSBuZXcgTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24obGF0bG9uZy5sYXRpdHVkZSwgbGF0bG9uZy5sb25naXR1ZGUpO1xyXG4gICAgICAgIHJldHVybiBsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhbiBJTWFya2VyT3B0aW9ucyBvYmplY3QgdG8gYSBNaWNyb3NvZnQuTWFwcy5JUHVzaHBpbk9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gVGhlIG1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZU1hcmtlck9wdGlvbnMob3B0aW9uczogSU1hcmtlck9wdGlvbnMpOiBNaWNyb3NvZnQuTWFwcy5JUHVzaHBpbk9wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoayA9PiBCaW5nQ29udmVyc2lvbnMuX21hcmtlck9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKVxyXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdhbmNob3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5hbmNob3IgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9pbnQob3B0aW9ucy5hbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKDxhbnk+bylba10gPSAoPGFueT5vcHRpb25zKVtrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG87XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGFuIElNYXBPcHRpb25zIG9iamVjdCB0byBhIE1pY3Jvc29mdC5NYXBzLklNYXBPcHRpb25zIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZU9wdGlvbnMob3B0aW9uczogSU1hcE9wdGlvbnMpOiBNaWNyb3NvZnQuTWFwcy5JTWFwT3B0aW9ucyB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSU1hcE9wdGlvbnMgfCBhbnkgPSB7fTtcclxuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGsgPT4gQmluZ0NvbnZlcnNpb25zLl9tYXBPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMSlcclxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChrID09PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uY2VudGVyID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKG9wdGlvbnMuY2VudGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdtYXBUeXBlSWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5tYXBUeXBlSWQgPSBNaWNyb3NvZnQuTWFwcy5NYXBUeXBlSWRbKDxhbnk+TWFwVHlwZUlkKVtvcHRpb25zLm1hcFR5cGVJZF1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb1trXSA9ICg8YW55Pm9wdGlvbnMpW2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zbGF0ZXMgYW4gYXJyYXkgb2YgbG9jYXRpb25zIG9yIGFuIGFycmF5IG9yIGFycmF5cyBvZiBsb2NhdGlvbiB0byBhbmQgYXJyYXkgb2YgYXJyYXlzIG9mIEJpbmcgTWFwIExvY2F0aW9uc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRocyAtIElMYXRMb25nIGJhc2VkIGxvY2F0aW9ucyB0byBjb252ZXJ0LlxyXG4gICAgICogQHJldHVybnMgLSBjb252ZXJ0ZWQgbG9jYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVQYXRocyhwYXRoczogQXJyYXk8SUxhdExvbmc+IHwgQXJyYXk8QXJyYXk8SUxhdExvbmc+Pik6IEFycmF5PEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPj4ge1xyXG4gICAgICAgIGNvbnN0IHA6IEFycmF5PEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPj4gPSBuZXcgQXJyYXk8QXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+PigpO1xyXG4gICAgICAgIGlmIChwYXRocyA9PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHBhdGhzKSB8fCBwYXRocy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcC5wdXNoKG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGF0aHNbMF0pKSB7XHJcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvciBhcnJheXNcclxuICAgICAgICAgICAgLy8gdXMgZm9yIGxvb3AgZm9yIHBlcmZvcm1hbmNlXHJcbiAgICAgICAgICAgIGNvbnN0IHAxID0gPEFycmF5PEFycmF5PElMYXRMb25nPj4+cGF0aHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcDEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IF9wOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4gPSBuZXcgQXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHAxW2ldLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3AucHVzaChuZXcgTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24ocDFbaV1bal0ubGF0aXR1ZGUsIHAxW2ldW2pdLmxvbmdpdHVkZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcC5wdXNoKF9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIGlzIGEgc2ltcGxlIGFycmF5Li4uLlxyXG4gICAgICAgICAgICBjb25zdCB5OiBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4gPSBuZXcgQXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHAxID0gPEFycmF5PElMYXRMb25nPj5wYXRocztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgeS5wdXNoKG5ldyBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbihwMVtpXS5sYXRpdHVkZSwgcDFbaV0ubG9uZ2l0dWRlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcC5wdXNoKHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqICBNYXBzIGFuIElQb2ludCBvYmplY3QgdG8gYSBNaWNyb3NvZnQuTWFwcy5Qb2ludCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvaW50IC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlUG9pbnQocG9pbnQ6IElQb2ludCk6IE1pY3Jvc29mdC5NYXBzLlBvaW50IHtcclxuICAgICAgICBjb25zdCBwOiBNaWNyb3NvZnQuTWFwcy5Qb2ludCA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2ludChwb2ludC54LCBwb2ludC55KTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqICBNYXBzIGFuIElQb2x5Z29uT3B0aW9ucyBvYmplY3QgdG8gYSBNaWNyb3NvZnQuTWFwcy5JUG9seWdvbk9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVQb2x5Z29uT3B0aW9ucyhvcHRpb25zOiBJUG9seWdvbk9wdGlvbnMpOiBNaWNyb3NvZnQuTWFwcy5JUG9seWdvbk9wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQb2x5Z29uT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGY6IChzOiBzdHJpbmcsIGE6IG51bWJlcikgPT4gc3RyaW5nID0gKHMsIGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbSA9IC9yZ2JhP1xcKChcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyooLFxccypcXGQrW1xcLlxcZCtdKikqXFwpL2cuZXhlYyhzKTtcclxuICAgICAgICAgICAgaWYgKG0gJiYgbS5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gYSA+IDEgPyAoYSAvIDEwMCkgOiBhO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyBbbVsxXSwgbVsyXSwgbVszXSwgYV0uam9pbignLCcpICsgJyknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNbMF0gPT09ICcjJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeDogbnVtYmVyID0gYSA+IDEgPyBhIDogTWF0aC5mbG9vcihhICogMjU1KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHo6IHN0cmluZyA9IHMuc3Vic3RyKDEpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcjogbnVtYmVyID0gcGFyc2VJbnQoei5zdWJzdHIoMCwgMiksIDE2KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGc6IG51bWJlciA9IHBhcnNlSW50KHouc3Vic3RyKDIsIDIpLCAxNik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiOiBudW1iZXIgPSBwYXJzZUludCh6LnN1YnN0cig0LCAyKSwgMTYpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyBbciAsIGcsIGIsIGFdLmpvaW4oJywnKSArICcpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucylcclxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEJpbmdDb252ZXJzaW9ucy5fcG9seWdvbk9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKVxyXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdzdHJva2VXZWlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5zdHJva2VUaGlja25lc3MgPSBvcHRpb25zLnN0cm9rZVdlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdzdHJva2VDb2xvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdHJva2VPcGFjaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uc3Ryb2tlQ29sb3IgPSBmKG9wdGlvbnMuc3Ryb2tlQ29sb3IsIG9wdGlvbnMuc3Ryb2tlT3BhY2l0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvLnN0cm9rZUNvbG9yID0gb3B0aW9ucy5zdHJva2VDb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrID09PSAnc3Ryb2tlT3BhY2l0eScpIHt9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrID09PSAnZmlsbENvbG9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbGxPcGFjaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uZmlsbENvbG9yID0gZihvcHRpb25zLmZpbGxDb2xvciwgb3B0aW9ucy5maWxsT3BhY2l0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvLmZpbGxDb2xvciA9IG9wdGlvbnMuZmlsbENvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdmaWxsT3BhY2l0eScpIHt9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAoPGFueT5vKVtrXSA9ICg8YW55Pm9wdGlvbnMpW2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqICBNYXBzIGFuIElQb2x5bGluZU9wdGlvbnMgb2JqZWN0IHRvIGEgTWljcm9zb2Z0Lk1hcHMuSVBvbHlsaW5lT3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZVBvbHlsaW5lT3B0aW9ucyhvcHRpb25zOiBJUG9seWxpbmVPcHRpb25zKTogTWljcm9zb2Z0Lk1hcHMuSVBvbHlsaW5lT3B0aW9ucyB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVBvbHlsaW5lT3B0aW9ucyB8IGFueSA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGY6IChzOiBzdHJpbmcsIGE6IG51bWJlcikgPT4gc3RyaW5nID0gKHMsIGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbSA9IC9yZ2JhP1xcKChcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyooLFxccypcXGQrW1xcLlxcZCtdKikqXFwpL2cuZXhlYyhzKTtcclxuICAgICAgICAgICAgaWYgKG0gJiYgbS5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gYSA+IDEgPyAoYSAvIDEwMCkgOiBhO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyBbbVsxXSwgbVsyXSwgbVszXSwgYV0uam9pbignLCcpICsgJyknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNbMF0gPT09ICcjJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeDogbnVtYmVyID0gYSA+IDEgPyBhIDogTWF0aC5mbG9vcihhICogMjU1KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHo6IHN0cmluZyA9IHMuc3Vic3RyKDEpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcjogbnVtYmVyID0gcGFyc2VJbnQoei5zdWJzdHIoMCwgMiksIDE2KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGc6IG51bWJlciA9IHBhcnNlSW50KHouc3Vic3RyKDIsIDIpLCAxNik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiOiBudW1iZXIgPSBwYXJzZUludCh6LnN1YnN0cig0LCAyKSwgMTYpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyBbciAsIGcsIGIsIGFdLmpvaW4oJywnKSArICcpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGsgPT4gQmluZ0NvbnZlcnNpb25zLl9wb2x5bGluZU9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKVxyXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdzdHJva2VXZWlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5zdHJva2VUaGlja25lc3MgPSBvcHRpb25zLnN0cm9rZVdlaWdodDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ3N0cm9rZUNvbG9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0cm9rZU9wYWNpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5zdHJva2VDb2xvciA9IGYob3B0aW9ucy5zdHJva2VDb2xvciwgb3B0aW9ucy5zdHJva2VPcGFjaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uc3Ryb2tlQ29sb3IgPSBvcHRpb25zLnN0cm9rZUNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdzdHJva2VPcGFjaXR5Jykge1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb1trXSA9ICg8YW55Pm9wdGlvbnMpW2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gSU1hcE9wdGlvbnMgb2JqZWN0IHRvIGEgTWljcm9zb2Z0Lk1hcHMuSVZpZXdPcHRpb25zIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZVZpZXdPcHRpb25zKG9wdGlvbnM6IElNYXBPcHRpb25zKTogTWljcm9zb2Z0Lk1hcHMuSVZpZXdPcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JVmlld09wdGlvbnMgfCBhbnkgPSB7fTtcclxuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGsgPT4gQmluZ0NvbnZlcnNpb25zLl92aWV3T3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTEpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKChrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLmNlbnRlciA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihvcHRpb25zLmNlbnRlcik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGsgPT09ICdib3VuZHMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5ib3VuZHMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlQm91bmRzKG9wdGlvbnMuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ2NlbnRlck9mZnNldCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLmNlbnRlck9mZnNldCA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2ludChvcHRpb25zLmNlbnRlck9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGsgPT09ICdtYXBUeXBlSWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5tYXBUeXBlSWQgPSBNaWNyb3NvZnQuTWFwcy5NYXBUeXBlSWRbKDxhbnk+TWFwVHlwZUlkKVtvcHRpb25zLm1hcFR5cGVJZF1dO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi9tYXJrZXInO1xyXG5pbXBvcnQgeyBCaW5nTWFwU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1jb252ZXJzaW9ucyc7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHtAbGluayBNYXJrZXJ9IGNvbnRyYWN0IGZvciB0aGUgQmluZyBNYXBzIFY4IG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCaW5nTWFya2VyIGltcGxlbWVudHMgTWFya2VyIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWZpbml0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF9tZXRhZGF0YTogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XHJcbiAgICBwcml2YXRlIF9pc0ZpcnN0ID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9pc0xhc3QgPSB0cnVlO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlZmluaXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBtYXJrZXIgaXMgdGhlIGZpcnN0IG1hcmtlciBpbiBhIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgSXNGaXJzdCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2lzRmlyc3Q7IH1cclxuICAgIHB1YmxpYyBzZXQgSXNGaXJzdCh2YWw6IGJvb2xlYW4pIHsgdGhpcy5faXNGaXJzdCA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIG1hcmtlciBpcyB0aGUgbGFzdCBtYXJrZXIgaW4gdGhlIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgSXNMYXN0KCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faXNMYXN0OyB9XHJcbiAgICBwdWJsaWMgc2V0IElzTGFzdCh2YWw6IGJvb2xlYW4pIHsgdGhpcy5faXNMYXN0ID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBMb2NhdGlvbiBvZiB0aGUgbWFya2VyXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IExvY2F0aW9uKCk6IElMYXRMb25nIHtcclxuICAgICAgICBjb25zdCBsOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IHRoaXMuX3B1c2hwaW4uZ2V0TG9jYXRpb24oKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsYXRpdHVkZTogbC5sYXRpdHVkZSxcclxuICAgICAgICAgICAgbG9uZ2l0dWRlOiBsLmxvbmdpdHVkZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXJrZXIgbWV0YWRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE1ldGFkYXRhKCk6IE1hcDxzdHJpbmcsIGFueT4geyByZXR1cm4gdGhpcy5fbWV0YWRhdGE7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBwcmltaXR2ZSBpbXBsZW1lbnRpbmcgdGhlIG1hcmtlciwgaW4gdGhpcyBjYXNlIHtAbGluayBNaWNyb3NvZnQuTWFwcy5QdXNocGlufVxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBOYXRpdmVQcmltaXR2ZSgpOiBhbnkgeyByZXR1cm4gdGhpcy5fcHVzaHBpbjsgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmluZ01hcmtlci5cclxuICAgICAqIEBwYXJhbSBfcHVzaHBpbiAtIFRoZSB7QGxpbmsgTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbn0gdW5kZXJseWluZyB0aGUgbW9kZWwuXHJcbiAgICAgKiBAcGFyYW0gX21hcCAtIFRoZSBjb250ZXh0IG1hcC5cclxuICAgICAqIEBwYXJhbSBfbGF5ZXIgLSBUaGUgY29udGV4dCBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wdXNocGluOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluLCBwcm90ZWN0ZWQgX21hcDogTWljcm9zb2Z0Lk1hcHMuTWFwLCBwcm90ZWN0ZWQgX2xheWVyOiBNaWNyb3NvZnQuTWFwcy5MYXllcikgeyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSBldmVudCBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGxpc3RlbmVyIChlLmcuIFwiY2xpY2tcIilcclxuICAgICAqIEBwYXJhbSBmbiAtIERlbGVnYXRlIGludm9rZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fcHVzaHBpbiwgZXZlbnRUeXBlLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBmbihlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlTWFya2VyKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICghdGhpcy5fbWFwICYmICF0aGlzLl9sYXllcikgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAodGhpcy5fbGF5ZXIpIHsgdGhpcy5fbGF5ZXIucmVtb3ZlKHRoaXMuTmF0aXZlUHJpbWl0dmUpOyB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcC5lbnRpdGllcy5yZW1vdmUodGhpcy5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbWFya2VyIGxhYmVsXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldExhYmVsKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hwaW4uZ2V0VGV4dCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBtYXJrZXIgaXMgdmlzaWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIG1hcmtlciBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hwaW4uZ2V0VmlzaWJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYW5jaG9yIGZvciB0aGUgbWFya2VyLiBVc2UgdGhpcyB0byBhZGp1c3QgdGhlIHJvb3QgbG9jYXRpb24gZm9yIHRoZSBtYXJrZXIgdG8gYWNjb21vZGF0ZSB2YXJpb3VzIG1hcmtlciBpbWFnZSBzaXplcy5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBhbmNob3IgLSBQb2ludCBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlciBhbmNob3IuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldEFuY2hvcihhbmNob3I6IElQb2ludCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIG8uYW5jaG9yID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvaW50KGFuY2hvci54LCBhbmNob3IueSk7XHJcbiAgICAgICAgdGhpcy5fcHVzaHBpbi5zZXRPcHRpb25zKG8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZHJhZ2dhYmlsaXR5IG9mIGEgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGRyYWdnYWJsZSAtIFRydWUgdG8gbWFyayB0aGUgbWFya2VyIGFzIGRyYWdnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXREcmFnZ2FibGUoZHJhZ2dhYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zID0ge307XHJcbiAgICAgICAgby5kcmFnZ2FibGUgPSBkcmFnZ2FibGU7XHJcbiAgICAgICAgdGhpcy5fcHVzaHBpbi5zZXRPcHRpb25zKG8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaWNvbiBmb3IgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBpY29uIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGljb24gaW4gdmFyaW91cyBmb3JtcyAodXJsLCBkYXRhIHVybCwgZXRjLilcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0SWNvbihpY29uOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUHVzaHBpbk9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvLmljb24gPSBpY29uO1xyXG4gICAgICAgIHRoaXMuX3B1c2hwaW4uc2V0T3B0aW9ucyhvKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1hcmtlciBsYWJlbC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYWJlbCAtIFN0cmluZyBjb250YWluaW5nIHRoZSBsYWJlbCB0byBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldExhYmVsKGxhYmVsOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUHVzaHBpbk9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvLnRleHQgPSBsYWJlbDtcclxuICAgICAgICB0aGlzLl9wdXNocGluLnNldE9wdGlvbnMobyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXJrZXIgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF0TG5nIC0gR2VvIGNvb3JkaW5hdGVzIHRvIHNldCB0aGUgbWFya2VyIHBvc2l0aW9uIHRvLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRQb3NpdGlvbihsYXRMbmc6IElMYXRMb25nKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcDogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24obGF0TG5nKTtcclxuICAgICAgICB0aGlzLl9wdXNocGluLnNldExvY2F0aW9uKHApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWFya2VyIHRpdGxlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHRpdGxlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIHRpdGxlIHRvIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0VGl0bGUodGl0bGU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyB8IGFueSA9IHt9O1xyXG4gICAgICAgIG8udGl0bGUgPSB0aXRsZTtcclxuICAgICAgICB0aGlzLl9wdXNocGluLnNldE9wdGlvbnMobyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXJrZXIgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElNYXJrZXJPcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgbWFya2VyIG9wdGlvbnMgdG8gc2V0LiBUaGUgc3VwcGxpZWQgb3B0aW9ucyBhcmVcclxuICAgICAqIG1lcmdlZCB3aXRoIHRoZSB1bmRlcmx5aW5nIG1hcmtlciBvcHRpb25zLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9ICBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTWFya2VyT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9wdXNocGluLnNldE9wdGlvbnMobyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIG1hcmtlciBpcyB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2aXNpYmxlIC0gVHJ1ZSB0byBzZXQgdGhlIG1hcmtlciB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zIHwgYW55ID0ge307XHJcbiAgICAgICAgby52aXNpYmxlID0gdmlzaWJsZTtcclxuICAgICAgICB0aGlzLl9wdXNocGluLnNldE9wdGlvbnMobyk7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEJpbmdNYXJrZXIgfSBmcm9tICcuL2JpbmctbWFya2VyJztcclxuaW1wb3J0IHsgU3BpZGVyQ2x1c3Rlck1hcmtlciB9IGZyb20gJy4uL3NwaWRlci1jbHVzdGVyLW1hcmtlcic7XHJcblxyXG5leHBvcnQgY2xhc3MgQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXIgZXh0ZW5kcyBCaW5nTWFya2VyIGltcGxlbWVudHMgU3BpZGVyQ2x1c3Rlck1hcmtlciB7XHJcblxyXG4gICAgLyoqIFRoZSBwYXJlbnQgcHVzaHBpbiBpbiB3aGljaCB0aGUgc3BpZGVyIHB1c2hwaW4gaXMgZGVyaXZlZCBmcm9tLiAqL1xyXG4gICAgcHVibGljIFBhcmVudE1hcmtlcjogQmluZ01hcmtlcjtcclxuXHJcbiAgICAvKiogVGhlIHN0aWNrIHRoYXQgY29ubmVjdHMgdGhlIHNwaWRlciBwdXNocGluIHRvIHRoZSBjbHVzdGVyLiAqL1xyXG4gICAgcHVibGljIFN0aWNrOiBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZTtcclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSUNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pY2x1c3Rlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSVNwaWRlckNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pc3BpZGVyLWNsdXN0ZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1jb252ZXJzaW9ucyc7XHJcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmluZy9iaW5nLW1hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9sYXllcic7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uL21hcmtlcic7XHJcbmltcG9ydCB7IEluZm9XaW5kb3cgfSBmcm9tICcuLi9pbmZvLXdpbmRvdyc7XHJcbmltcG9ydCB7IEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyIH0gZnJvbSAnLi9iaW5nLXNwaWRlci1jbHVzdGVyLW1hcmtlcic7XHJcbmltcG9ydCB7IEJpbmdNYXJrZXIgfSBmcm9tICcuL2JpbmctbWFya2VyJztcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGNsdXN0ZXJpbmcgbGF5ZXIgZm9yIHRoZSBCaW5nIE1hcCBQcm92aWRlci5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJpbmdDbHVzdGVyTGF5ZXIgaW1wbGVtZW50cyBMYXllciB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2lzQ2x1c3RlcmluZyA9IHRydWU7XHJcbiAgICBwcml2YXRlIF9tYXJrZXJzOiBBcnJheTxNYXJrZXI+ID0gbmV3IEFycmF5PE1hcmtlcj4oKTtcclxuICAgIHByaXZhdGUgX21hcmtlckxvb2t1cDogTWFwPE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4sIE1hcmtlcj4gPSBuZXcgTWFwPE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4sIE1hcmtlcj4oKTtcclxuICAgIHByaXZhdGUgX3BlbmRpbmdNYXJrZXJzOiBBcnJheTxNYXJrZXI+ID0gbmV3IEFycmF5PE1hcmtlcj4oKTtcclxuICAgIHByaXZhdGUgX3NwaWRlck1hcmtlcnM6IEFycmF5PEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyPiA9IG5ldyBBcnJheTxCaW5nU3BpZGVyQ2x1c3Rlck1hcmtlcj4oKTtcclxuICAgIHByaXZhdGUgX3NwaWRlck1hcmtlckxvb2t1cDogTWFwPE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4sIEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyPiA9XHJcbiAgICAgICAgICAgICAgICAgICAgIG5ldyBNYXA8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiwgQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXI+KCk7XHJcbiAgICBwcml2YXRlIF91c2VTcGlkZXJDbHVzdGVyID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9tYXBjbGlja3MgPSAwO1xyXG4gICAgcHJpdmF0ZSBfc3BpZGVyTGF5ZXI6IE1pY3Jvc29mdC5NYXBzLkxheWVyO1xyXG4gICAgcHJpdmF0ZSBfZXZlbnRzOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkPiA9IG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkPigpO1xyXG4gICAgcHJpdmF0ZSBfY3VycmVudFpvb20gPSAwO1xyXG4gICAgcHJpdmF0ZSBfc3BpZGVyT3B0aW9uczogSVNwaWRlckNsdXN0ZXJPcHRpb25zID0ge1xyXG4gICAgICAgIGNpcmNsZVNwaXJhbFN3aXRjaG92ZXI6IDksXHJcbiAgICAgICAgY29sbGFwc2VDbHVzdGVyT25NYXBDaGFuZ2U6IGZhbHNlLFxyXG4gICAgICAgIGNvbGxhcHNlQ2x1c3Rlck9uTnRoQ2xpY2s6IDEsXHJcbiAgICAgICAgaW52b2tlQ2xpY2tPbkhvdmVyOiB0cnVlLFxyXG4gICAgICAgIG1pbkNpcmNsZUxlbmd0aDogNjAsXHJcbiAgICAgICAgbWluU3BpcmFsQW5nbGVTZXBlcmF0aW9uOiAyNSxcclxuICAgICAgICBzcGlyYWxEaXN0YW5jZUZhY3RvcjogNSxcclxuICAgICAgICBzdGlja1N0eWxlOiB7XHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiAnYmxhY2snLFxyXG4gICAgICAgICAgICBzdHJva2VUaGlja25lc3M6IDJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0aWNrSG92ZXJTdHlsZTogeyBzdHJva2VDb2xvcjogJ3JlZCcgfSxcclxuICAgICAgICBtYXJrZXJTZWxlY3RlZDogbnVsbCxcclxuICAgICAgICBtYXJrZXJVblNlbGVjdGVkOiBudWxsXHJcbiAgICB9O1xyXG4gICAgcHJpdmF0ZSBfY3VycmVudENsdXN0ZXI6IE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJQdXNocGluID0gbnVsbDtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWZpbml0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG5hdGl2ZSBwcmltaXRpdmUgdW5kZXJuZWF0aCB0aGUgYWJzdHJhY3Rpb24gbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlckxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTmF0aXZlUHJpbWl0dmUoKTogYW55IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgQmluZ0NsdXN0ZXJMYXllciBjbGFzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyIE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJMYXllci4gTmF0aXZlIEJpbmcgQ2x1c3RlciBMYXllciBzdXBwb3J0aW5nIHRoZSBjbHVzdGVyIGxheWVyLlxyXG4gICAgICogQHBhcmFtIF9tYXBzIE1hcFNlcnZpY2UuIE1hcFNlcnZpY2UgaW1wbGVtZW50YXRpb24gdG8gbGV2ZXJhZ2UgZm9yIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sYXllcjogTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlckxheWVyLCBwcml2YXRlIF9tYXBzOiBNYXBTZXJ2aWNlKSB7IH1cclxuXHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHMsIExheWVyIGludGVyZmFjZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSBzdHJpbmcuIFR5cGUgb2YgZXZlbnQgdG8gYWRkIChjbGljaywgbW91c2VvdmVyLCBldGMpLiBZb3UgY2FuIHVzZSBhbnkgZXZlbnQgdGhhdCB0aGUgdW5kZXJseWluZyBuYXRpdmVcclxuICAgICAqIGxheWVyIHN1cHBvcnRzLlxyXG4gICAgICogQHBhcmFtIGZuIGZ1bmN0aW9uLiBIYW5kbGVyIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fbGF5ZXIsIGV2ZW50VHlwZSwgKGUpID0+IHtcclxuICAgICAgICAgICAgZm4oZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGVudGl0eSB0byB0aGUgbGF5ZXIuIFVzZSB0aGlzIG1ldGhvZCB3aXRoIGNhdXRpb24gYXMgaXQgd2lsbFxyXG4gICAgICogdHJpZ2dlciBhIHJlY2FsdWF0aW9uIG9mIHRoZSBjbHVzdGVycyAoYW5kIGFzc29jaWF0ZWQgbWFya2VycyBpZiBhcHByb3ByaXRlKSBmb3JcclxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gSWYgeW91IHVzZSB0aGlzIG1ldGhvZCB0byBhZGQgbWFueSBtYXJrZXJzIHRvIHRoZSBjbHVzdGVyLCB1c2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5IE1hcmtlci4gRW50aXR5IHRvIGFkZCB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZEVudGl0eShlbnRpdHk6IE1hcmtlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCBpc01hcmtlcjogYm9vbGVhbiA9IGVudGl0eSBpbnN0YW5jZW9mIE1hcmtlcjtcclxuICAgICAgICBpc01hcmtlciA9IGVudGl0eSBpbnN0YW5jZW9mIEJpbmdNYXJrZXIgfHwgaXNNYXJrZXI7XHJcbiAgICAgICAgaWYgKGlzTWFya2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkuSXNGaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5TdG9wQ2x1c3RlcmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbnRpdHkuTmF0aXZlUHJpbWl0dmUgJiYgZW50aXR5LkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NsdXN0ZXJpbmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHA6IEFycmF5PE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+ID0gdGhpcy5fbGF5ZXIuZ2V0UHVzaHBpbnMoKTtcclxuICAgICAgICAgICAgICAgIHAucHVzaChlbnRpdHkuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIuc2V0UHVzaHBpbnMocCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXJzLnB1c2goZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdNYXJrZXJzLnB1c2goZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJMb29rdXAuc2V0KGVudGl0eS5OYXRpdmVQcmltaXR2ZSwgZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTWFya2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkuSXNMYXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXJ0Q2x1c3RlcmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG51bWJlciBvZiBtYXJrZXJzIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyPi4gRW50aXRpZXMgdG8gYWRkIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkRW50aXRpZXMoZW50aXRpZXM6IEFycmF5PE1hcmtlcj4pOiB2b2lkIHtcclxuICAgICAgICBpZiAoZW50aXRpZXMgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KGVudGl0aWVzKSAmJiBlbnRpdGllcy5sZW5ndGggIT09IDAgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGU6IEFycmF5PE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+ID0gZW50aXRpZXMubWFwKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya2VyTG9va3VwLnNldChwLk5hdGl2ZVByaW1pdHZlLCBwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwLk5hdGl2ZVByaW1pdHZlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ2x1c3RlcmluZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj4gPSB0aGlzLl9sYXllci5nZXRQdXNocGlucygpO1xyXG4gICAgICAgICAgICAgICAgcC5wdXNoKC4uLmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIuc2V0UHVzaHBpbnMocCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXJzLnB1c2goLi4uZW50aXRpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMucHVzaCguLi5lbnRpdGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBzcGlkZXIgYmVoYXZpb3IgZm9yIHRoZSBjbHVzZXJpbmcgbGF5ZXIgKHdoZW4gYSBjbHVzdGVyIG1ha2VyIGlzIGNsaWNrZWQsIGl0IGV4cGxvZGVzIGludG8gYSBzcGlkZXIgb2YgdGhlXHJcbiAgICAgKiBpbmRpdmlkdWFsIHVuZGVybHlpbmcgcGlucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJU3BpZGVyQ2x1c3Rlck9wdGlvbnMuIE9wdGlvbmFsLiBPcHRpb25zIGdvdmVybmluZyB0aGUgYmVoYXZpb3Igb2YgdGhlIHNwaWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgSW5pdGlhbGl6ZVNwaWRlckNsdXN0ZXJTdXBwb3J0KG9wdGlvbnM/OiBJU3BpZGVyQ2x1c3Rlck9wdGlvbnMpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fdXNlU3BpZGVyQ2x1c3RlcikgeyByZXR1cm47IH1cclxuICAgICAgICBjb25zdCBtOiBNaWNyb3NvZnQuTWFwcy5NYXAgPSAoPEJpbmdNYXBTZXJ2aWNlPnRoaXMuX21hcHMpLk1hcEluc3RhbmNlO1xyXG4gICAgICAgIHRoaXMuX3VzZVNwaWRlckNsdXN0ZXIgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3NwaWRlckxheWVyID0gbmV3IE1pY3Jvc29mdC5NYXBzLkxheWVyKCk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFpvb20gPSBtLmdldFpvb20oKTtcclxuICAgICAgICB0aGlzLlNldFNwaWRlck9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgbS5sYXllcnMuaW5zZXJ0KHRoaXMuX3NwaWRlckxheWVyKTtcclxuXHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgLy8vIEFkZCBzcGlkZXIgcmVsYXRlZCBldmVudHMuLi4uXHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIobSwgJ2NsaWNrJywgZSA9PiB0aGlzLk9uTWFwQ2xpY2soZSkpKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcihtLCAndmlld2NoYW5nZXN0YXJ0JywgZSA9PiB0aGlzLk9uTWFwVmlld0NoYW5nZVN0YXJ0KGUpKSk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIobSwgJ3ZpZXdjaGFuZ2VlbmQnLCBlID0+IHRoaXMuT25NYXBWaWV3Q2hhbmdlRW5kKGUpKSk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fbGF5ZXIsICdjbGljaycsIGUgPT4gdGhpcy5PbkxheWVyQ2xpY2soZSkpKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9zcGlkZXJMYXllciwgJ2NsaWNrJywgZSA9PiB0aGlzLk9uTGF5ZXJDbGljayhlKSkpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX3NwaWRlckxheWVyLCAnbW91c2VvdmVyJywgZSA9PiB0aGlzLk9uU3BpZGVyTW91c2VPdmVyKGUpKSk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fc3BpZGVyTGF5ZXIsICdtb3VzZW91dCcsIGUgPT4gdGhpcy5PblNwaWRlck1vdXNlT3V0KGUpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSBjbHVzdGVyaW5nIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGUoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3VzZVNwaWRlckNsdXN0ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3BpZGVyTGF5ZXIuY2xlYXIoKTtcclxuICAgICAgICAgICAgKDxCaW5nTWFwU2VydmljZT50aGlzLl9tYXBzKS5NYXBQcm9taXNlLnRoZW4obSA9PiB7XHJcbiAgICAgICAgICAgICAgICBtLmxheWVycy5yZW1vdmUodGhpcy5fc3BpZGVyTGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyTGF5ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmZvckVhY2goZSA9PiBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcihlKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5zcGxpY2UoMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VzZVNwaWRlckNsdXN0ZXIgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbWFya2Vycy5zcGxpY2UoMCk7XHJcbiAgICAgICAgdGhpcy5fc3BpZGVyTWFya2Vycy5zcGxpY2UoMCk7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMuc3BsaWNlKDApO1xyXG4gICAgICAgIHRoaXMuX21hcmtlckxvb2t1cC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX21hcHMuRGVsZXRlTGF5ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhYnN0cmFjdCBtYXJrZXIgdXNlZCB0byB3cmFwIHRoZSBCaW5nIFB1c2hwaW4uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgTWFya2VyLiBUaGUgYWJzdHJhY3QgbWFya2VyIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHB1c2hwaW4uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldE1hcmtlckZyb21CaW5nTWFya2VyKHBpbjogTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbik6IE1hcmtlciB7XHJcbiAgICAgICAgY29uc3QgbTogTWFya2VyID0gdGhpcy5fbWFya2VyTG9va3VwLmdldChwaW4pO1xyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgb3B0aW9ucyBnb3Zlcm5pbmcgdGhlIGJlaGF2aW9yIG9mIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBJQ2x1c3Rlck9wdGlvbnMuIFRoZSBsYXllciBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRPcHRpb25zKCk6IElDbHVzdGVyT3B0aW9ucyB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSUNsdXN0ZXJMYXllck9wdGlvbnMgPSB0aGlzLl9sYXllci5nZXRPcHRpb25zKCk7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uczogSUNsdXN0ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogMCxcclxuICAgICAgICAgICAgZ3JpZFNpemU6IG8uZ3JpZFNpemUsXHJcbiAgICAgICAgICAgIGxheWVyT2Zmc2V0OiBvLmxheWVyT2Zmc2V0LFxyXG4gICAgICAgICAgICBjbHVzdGVyaW5nRW5hYmxlZDogby5jbHVzdGVyaW5nRW5hYmxlZCxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IG8uY2FsbGJhY2ssXHJcbiAgICAgICAgICAgIGNsdXN0ZXJlZFBpbkNhbGxiYWNrOiBvLmNsdXN0ZXJlZFBpbkNhbGxiYWNrLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiBvLnZpc2libGUsXHJcbiAgICAgICAgICAgIHpJbmRleDogby56SW5kZXhcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQm9vbGVhbi4gVHJ1ZSBpcyB0aGUgbGF5ZXIgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRWaXNpYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllci5nZXRPcHRpb25zKCkudmlzaWJsZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGFic3RyYWN0IG1hcmtlciB1c2VkIHRvIHdyYXAgdGhlIEJpbmcgUHVzaHBpbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBhYnN0cmFjdCBtYXJrZXIgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcHVzaHBpbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0U3BpZGVyTWFya2VyRnJvbUJpbmdNYXJrZXIocGluOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluKTogQmluZ1NwaWRlckNsdXN0ZXJNYXJrZXIge1xyXG4gICAgICAgIGNvbnN0IG06IEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyID0gdGhpcy5fc3BpZGVyTWFya2VyTG9va3VwLmdldChwaW4pO1xyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbiBlbnRpdHkgZnJvbSB0aGUgY2x1c3RlciBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5IE1hcmtlciAtIEVudGl0eSB0byBiZSByZW1vdmVkIGZyb20gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBSZW1vdmVFbnRpdHkoZW50aXR5OiBNYXJrZXIpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZW50aXR5Lk5hdGl2ZVByaW1pdHZlICYmIGVudGl0eS5Mb2NhdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBqOiBudW1iZXIgPSB0aGlzLl9tYXJrZXJzLmluZGV4T2YoZW50aXR5KTtcclxuICAgICAgICAgICAgY29uc3QgazogbnVtYmVyID0gdGhpcy5fcGVuZGluZ01hcmtlcnMuaW5kZXhPZihlbnRpdHkpO1xyXG4gICAgICAgICAgICBpZiAoaiA+IC0xKSB7IHRoaXMuX21hcmtlcnMuc3BsaWNlKGosIDEpOyB9XHJcbiAgICAgICAgICAgIGlmIChrID4gLTEpIHsgdGhpcy5fcGVuZGluZ01hcmtlcnMuc3BsaWNlKGssIDEpOyB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NsdXN0ZXJpbmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHA6IEFycmF5PE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+ID0gdGhpcy5fbGF5ZXIuZ2V0UHVzaHBpbnMoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGk6IG51bWJlciA9IHAuaW5kZXhPZihlbnRpdHkuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHAuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyLnNldFB1c2hwaW5zKHApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtlckxvb2t1cC5kZWxldGUoZW50aXR5Lk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBlbnRpdGllcyBmb3IgdGhlIGNsdXN0ZXIgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVudGl0aWVzIEFycmF5PE1hcmtlcj4gY29udGFpbmluZ1xyXG4gICAgICogdGhlIGVudGl0aWVzIHRvIGFkZCB0byB0aGUgY2x1c3Rlci4gVGhpcyByZXBsYWNlcyBhbnkgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldEVudGl0aWVzKGVudGl0aWVzOiBBcnJheTxNYXJrZXI+KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcDogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj4gPSBuZXcgQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj4oKTtcclxuICAgICAgICB0aGlzLl9tYXJrZXJzLnNwbGljZSgwKTtcclxuICAgICAgICB0aGlzLl9tYXJrZXJMb29rdXAuY2xlYXIoKTtcclxuICAgICAgICBlbnRpdGllcy5mb3JFYWNoKChlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGUuTmF0aXZlUHJpbWl0dmUgJiYgZS5Mb2NhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya2Vycy5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya2VyTG9va3VwLnNldChlLk5hdGl2ZVByaW1pdHZlLCBlKTtcclxuICAgICAgICAgICAgICAgIHAucHVzaCg8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj5lLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2xheWVyLnNldFB1c2hwaW5zKHApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgb3B0aW9ucyBmb3IgdGhlIGNsdXN0ZXIgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgSUNsdXN0ZXJPcHRpb25zIGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMgZW51bWVyYXRpb24gY29udHJvbGxpbmcgdGhlIGxheWVyIGJlaGF2aW9yLiBUaGUgc3VwcGxpZWQgb3B0aW9uc1xyXG4gICAgICogYXJlIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0L2V4aXN0aW5nIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMob3B0aW9uczogSUNsdXN0ZXJPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSUNsdXN0ZXJMYXllck9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlQ2x1c3Rlck9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXIuc2V0T3B0aW9ucyhvKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5zcGlkZXJDbHVzdGVyT3B0aW9ucykgeyB0aGlzLlNldFNwaWRlck9wdGlvbnMob3B0aW9ucy5zcGlkZXJDbHVzdGVyT3B0aW9ucyk7IH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRvZ2dsZXMgdGhlIGNsdXN0ZXIgbGF5ZXIgdmlzaWJpbGl0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSBCb29sZWFuIHRydWUgdG8gbWFrZSB0aGUgbGF5ZXIgdmlzaWJsZSwgZmFsc2UgdG8gaGlkZSB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklDbHVzdGVyTGF5ZXJPcHRpb25zID0gdGhpcy5fbGF5ZXIuZ2V0T3B0aW9ucygpO1xyXG4gICAgICAgIG8udmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXIuc2V0T3B0aW9ucyhvKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGUgaW5pdGlhbCBzZXQgb2YgZW50aXRpZXNcclxuICAgICAqIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgY2x1c3Rlci4gVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBhcyBhZGRpbmcgYW4gZW50aXRpeSB3aWxsIHJlY2FsY3VsYXRlIGFsbCBjbHVzdGVycy5cclxuICAgICAqIEFzIHN1Y2gsIFN0b3BDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGFkZGluZyBtYW55IGVudGl0aWVzIGFuZCBTdGFydENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBvbmNlIGFkZGluZyBpc1xyXG4gICAgICogY29tcGxldGUgdG8gcmVjYWxjdWxhdGUgdGhlIGNsdXN0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTdGFydENsdXN0ZXJpbmcoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2x1c3RlcmluZykgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgY29uc3QgcDogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj4gPSBuZXcgQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj4oKTtcclxuICAgICAgICB0aGlzLl9tYXJrZXJzLmZvckVhY2goZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLk5hdGl2ZVByaW1pdHZlICYmIGUuTG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHAucHVzaCg8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj5lLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdNYXJrZXJzLmZvckVhY2goZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLk5hdGl2ZVByaW1pdHZlICYmIGUuTG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHAucHVzaCg8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj5lLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2xheWVyLnNldFB1c2hwaW5zKHApO1xyXG4gICAgICAgIHRoaXMuX21hcmtlcnMgPSB0aGlzLl9tYXJrZXJzLmNvbmNhdCh0aGlzLl9wZW5kaW5nTWFya2Vycy5zcGxpY2UoMCkpO1xyXG4gICAgICAgIHRoaXMuX2lzQ2x1c3RlcmluZyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgYXMgYWRkaW5nIGFuIGVudGl0aXkgd2lsbCByZWNhbGN1bGF0ZSBhbGwgY2x1c3RlcnMuXHJcbiAgICAgKiBBcyBzdWNoLCBTdG9wQ2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhZGRpbmcgbWFueSBlbnRpdGllcyBhbmQgU3RhcnRDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgb25jZSBhZGRpbmcgaXNcclxuICAgICAqIGNvbXBsZXRlIHRvIHJlY2FsY3VsYXRlIHRoZSBjbHVzdGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU3RvcENsdXN0ZXJpbmcoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NsdXN0ZXJpbmcpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgdGhpcy5faXNDbHVzdGVyaW5nID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiBhIHB1c2hwaW5zIGJhc2ljIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBpbiBQdXNocGluIHRvIGNvcHkgb3B0aW9ucyBmcm9tLlxyXG4gICAgICogQHJldHVybnMgLSBBIGNvcHkgb2YgYSBwdXNocGlucyBiYXNpYyBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgR2V0QmFzaWNQdXNocGluT3B0aW9ucyhwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4pOiBNaWNyb3NvZnQuTWFwcy5JUHVzaHBpbk9wdGlvbnMge1xyXG4gICAgICAgIHJldHVybiA8TWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zPntcclxuICAgICAgICAgICAgYW5jaG9yOiBwaW4uZ2V0QW5jaG9yKCksXHJcbiAgICAgICAgICAgIGNvbG9yOiBwaW4uZ2V0Q29sb3IoKSxcclxuICAgICAgICAgICAgY3Vyc29yOiBwaW4uZ2V0Q3Vyc29yKCksXHJcbiAgICAgICAgICAgIGljb246IHBpbi5nZXRJY29uKCksXHJcbiAgICAgICAgICAgIHJvdW5kQ2xpY2thYmxlQXJlYTogcGluLmdldFJvdW5kQ2xpY2thYmxlQXJlYSgpLFxyXG4gICAgICAgICAgICBzdWJUaXRsZTogcGluLmdldFN1YlRpdGxlKCksXHJcbiAgICAgICAgICAgIHRleHQ6IHBpbi5nZXRUZXh0KCksXHJcbiAgICAgICAgICAgIHRleHRPZmZzZXQ6IHBpbi5nZXRUZXh0T2Zmc2V0KCksXHJcbiAgICAgICAgICAgIHRpdGxlOiBwaW4uZ2V0VGl0bGUoKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWRlcyB0aGUgc3BpZGVyIGNsdXN0ZXIgYW5kIHJlc290cmVzIHRoZSBvcmlnaW5hbCBwaW4uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBIaWRlU3BpZGVyQ2x1c3RlcigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9tYXBjbGlja3MgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50Q2x1c3Rlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9zcGlkZXJMYXllci5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9zcGlkZXJNYXJrZXJzLnNwbGljZSgwKTtcclxuICAgICAgICAgICAgdGhpcy5fc3BpZGVyTWFya2VyTG9va3VwLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRDbHVzdGVyID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fbWFwY2xpY2tzID0gLTE7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zcGlkZXJPcHRpb25zLm1hcmtlclVuU2VsZWN0ZWQpIHsgdGhpcy5fc3BpZGVyT3B0aW9ucy5tYXJrZXJVblNlbGVjdGVkKCk7IH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGljayBldmVudCBoYW5kbGVyIGZvciB3aGVuIGEgc2hhcGUgaW4gdGhlIGNsdXN0ZXIgbGF5ZXIgaXMgY2xpY2tlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZSBUaGUgbW91c2UgZXZlbnQgYXJndXJtZW50IGZyb20gdGhlIGNsaWNrIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgT25MYXllckNsaWNrKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyk6IHZvaWQge1xyXG4gICAgICAgIGlmIChlLnByaW1pdGl2ZSBpbnN0YW5jZW9mIE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJQdXNocGluKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNwOiBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbiA9IDxNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbj5lLnByaW1pdGl2ZTtcclxuICAgICAgICAgICAgY29uc3Qgc2hvd05ld0NsdXN0ZXI6IGJvb2xlYW4gPSBjcCAhPT0gdGhpcy5fY3VycmVudENsdXN0ZXI7XHJcbiAgICAgICAgICAgIHRoaXMuSGlkZVNwaWRlckNsdXN0ZXIoKTtcclxuICAgICAgICAgICAgaWYgKHNob3dOZXdDbHVzdGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlNob3dTcGlkZXJDbHVzdGVyKDxNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbj5lLnByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gPSA8TWljcm9zb2Z0Lk1hcHMuUHVzaHBpbj5lLnByaW1pdGl2ZTtcclxuICAgICAgICAgICAgaWYgKHBpbi5tZXRhZGF0YSAmJiBwaW4ubWV0YWRhdGEuaXNDbHVzdGVyTWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtOiBCaW5nU3BpZGVyQ2x1c3Rlck1hcmtlciA9IHRoaXMuR2V0U3BpZGVyTWFya2VyRnJvbUJpbmdNYXJrZXIocGluKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHA6IEJpbmdNYXJrZXIgPSBtLlBhcmVudE1hcmtlcjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gPSBwLk5hdGl2ZVByaW1pdHZlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NwaWRlck9wdGlvbnMubWFya2VyU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLm1hcmtlclNlbGVjdGVkKHAsIG5ldyBCaW5nTWFya2VyKHRoaXMuX2N1cnJlbnRDbHVzdGVyLCBudWxsLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmhhc0hhbmRsZXIocHBpbiwgJ2NsaWNrJykpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmludm9rZShwcGluLCAnY2xpY2snLCBlKTsgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwY2xpY2tzID0gMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zcGlkZXJPcHRpb25zLm1hcmtlclNlbGVjdGVkKSB7IHRoaXMuX3NwaWRlck9wdGlvbnMubWFya2VyU2VsZWN0ZWQodGhpcy5HZXRNYXJrZXJGcm9tQmluZ01hcmtlcihwaW4pLCBudWxsKTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5oYXNIYW5kbGVyKHBpbiwgJ2NsaWNrJykpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmludm9rZShwaW4sICdjbGljaycsIGUpOyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyB0aGUgY2xpY2sgZXZlbnQgb24gdGhlIG1hcCAob3V0c2lkZSBhIHNwaWRlciBjbHVzdGVyKS4gRGVwZW5kaW5nIG9uIHRoZVxyXG4gICAgICogc3BpZGVyIG9wdGlvbnMsIGNsb3NlcyB0aGUgY2x1c3RlciBvciBpbmNyZW1lbnRzIHRoZSBjbGljayBjb3VudGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlIC0gTW91c2UgZXZlbnRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIE9uTWFwQ2xpY2soZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzIHwgTWljcm9zb2Z0Lk1hcHMuSU1hcFR5cGVDaGFuZ2VFdmVudEFyZ3MpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fbWFwY2xpY2tzID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBlbHNlIGlmICgrK3RoaXMuX21hcGNsaWNrcyA+PSB0aGlzLl9zcGlkZXJPcHRpb25zLmNvbGxhcHNlQ2x1c3Rlck9uTnRoQ2xpY2spIHtcclxuICAgICAgICAgICAgdGhpcy5IaWRlU3BpZGVyQ2x1c3RlcigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcgYXMgdGhpcy5fbWFwY2xpY2tzIGhhcyBhbHJlYWR5IGJlZW4gaW5jcmVtZW50ZWQgYWJvdmVcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyB0aGUgbWFwIHZpZXcgY2hhbmdlZCBlbmQgZXZlbnQuIEhpZGVzIHRoZSBzcGlkZXIgY2x1c3RlciBpZiB0aGUgem9vbSBsZXZlbCBoYXMgY2hhbmdlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZSAtIE1vdXNlIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgT25NYXBWaWV3Q2hhbmdlRW5kKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyB8IE1pY3Jvc29mdC5NYXBzLklNYXBUeXBlQ2hhbmdlRXZlbnRBcmdzKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgejogbnVtYmVyID0gKDxNaWNyb3NvZnQuTWFwcy5NYXA+ZS50YXJnZXQpLmdldFpvb20oKTtcclxuICAgICAgICBjb25zdCBoYXNab29tQ2hhbmdlZDogYm9vbGVhbiA9ICh6ICE9PSB0aGlzLl9jdXJyZW50Wm9vbSk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFpvb20gPSB6O1xyXG4gICAgICAgIGlmIChoYXNab29tQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICB0aGlzLkhpZGVTcGlkZXJDbHVzdGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZWdhdGUgaGFuZGxpbmcgdGhlIG1hcCB2aWV3IGNoYW5nZSBzdGFydCBldmVudC4gRGVwZW5kaW5nIG9uIHRoZSBzcGlkZXIgb3B0aW9ucywgaGlkZXMgdGhlXHJcbiAgICAgKiB0aGUgZXhwbG9kZWQgc3BpZGVyIG9yIGRvZXMgbm90aGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZSAtIE1vdXNlIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlckxheWVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgT25NYXBWaWV3Q2hhbmdlU3RhcnQoZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzIHwgTWljcm9zb2Z0Lk1hcHMuSU1hcFR5cGVDaGFuZ2VFdmVudEFyZ3MpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fc3BpZGVyT3B0aW9ucy5jb2xsYXBzZUNsdXN0ZXJPbk1hcENoYW5nZSkge1xyXG4gICAgICAgICAgICB0aGlzLkhpZGVTcGlkZXJDbHVzdGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZWdhdGUgaW52b2tlZCBvbiBtb3VzZSBvdXQgb24gYW4gZXhwbG9kZWQgc3BpZGVyIG1hcmtlci4gUmVzZXRzIHRoZSBob3ZlciBzdHlsZSBvbiB0aGUgc3RpY2suXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGUgLSBNb3VzZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBPblNwaWRlck1vdXNlT3V0KGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHBpbjogTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiA9IDxNaWNyb3NvZnQuTWFwcy5QdXNocGluPmUucHJpbWl0aXZlO1xyXG4gICAgICAgIGlmIChwaW4gaW5zdGFuY2VvZiBNaWNyb3NvZnQuTWFwcy5QdXNocGluICYmIHBpbi5tZXRhZGF0YSAmJiBwaW4ubWV0YWRhdGEuaXNDbHVzdGVyTWFya2VyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG06IEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyID0gdGhpcy5HZXRTcGlkZXJNYXJrZXJGcm9tQmluZ01hcmtlcihwaW4pO1xyXG4gICAgICAgICAgICBtLlN0aWNrLnNldE9wdGlvbnModGhpcy5fc3BpZGVyT3B0aW9ucy5zdGlja1N0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VkIG9uIG1vdXNlIG92ZXIgb24gYW4gZXhwbG9kZWQgc3BpZGVyIG1hcmtlci4gU2V0cyB0aGUgaG92ZXIgc3R5bGUgb24gdGhlIHN0aWNrLiBBbHNvIGludm9rZXMgdGhlIGNsaWNrIGV2ZW50XHJcbiAgICAgKiBvbiB0aGUgdW5kZXJseWluZyBvcmlnaW5hbCBtYXJrZXIgZGVwZW5kZW50IG9uIHRoZSBzcGlkZXIgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZSAtIE1vdXNlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIE9uU3BpZGVyTW91c2VPdmVyKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHBpbjogTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbiA9IDxNaWNyb3NvZnQuTWFwcy5QdXNocGluPmUucHJpbWl0aXZlO1xyXG4gICAgICAgIGlmIChwaW4gaW5zdGFuY2VvZiBNaWNyb3NvZnQuTWFwcy5QdXNocGluICYmIHBpbi5tZXRhZGF0YSAmJiBwaW4ubWV0YWRhdGEuaXNDbHVzdGVyTWFya2VyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG06IEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyID0gdGhpcy5HZXRTcGlkZXJNYXJrZXJGcm9tQmluZ01hcmtlcihwaW4pO1xyXG4gICAgICAgICAgICBtLlN0aWNrLnNldE9wdGlvbnModGhpcy5fc3BpZGVyT3B0aW9ucy5zdGlja0hvdmVyU3R5bGUpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3BpZGVyT3B0aW9ucy5pbnZva2VDbGlja09uSG92ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHA6IEJpbmdNYXJrZXIgPSBtLlBhcmVudE1hcmtlcjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gPSBwLk5hdGl2ZVByaW1pdHZlO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5oYXNIYW5kbGVyKHBwaW4sICdjbGljaycpKSB7IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5pbnZva2UocHBpbiwgJ2NsaWNrJywgZSk7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG9wdGlvbnMgZm9yIHNwaWRlciBiZWhhdmlvci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJU3BpZGVyQ2x1c3Rlck9wdGlvbnMgY29udGFpbmluZyB0aGUgb3B0aW9ucyBlbnVtZXJhdGlvbiBjb250cm9sbGluZyB0aGUgc3BpZGVyIGNsdXN0ZXIgYmVoYXZpb3IuIFRoZSBzdXBwbGllZCBvcHRpb25zXHJcbiAgICAgKiBhcmUgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQvZXhpc3Rpbmcgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJMYXllclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIFNldFNwaWRlck9wdGlvbnMob3B0aW9uczogSVNwaWRlckNsdXN0ZXJPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNpcmNsZVNwaXJhbFN3aXRjaG92ZXIgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLmNpcmNsZVNwaXJhbFN3aXRjaG92ZXIgPSBvcHRpb25zLmNpcmNsZVNwaXJhbFN3aXRjaG92ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbGxhcHNlQ2x1c3Rlck9uTWFwQ2hhbmdlID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwaWRlck9wdGlvbnMuY29sbGFwc2VDbHVzdGVyT25NYXBDaGFuZ2UgPSBvcHRpb25zLmNvbGxhcHNlQ2x1c3Rlck9uTWFwQ2hhbmdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb2xsYXBzZUNsdXN0ZXJPbk50aENsaWNrID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy5jb2xsYXBzZUNsdXN0ZXJPbk50aENsaWNrID0gb3B0aW9ucy5jb2xsYXBzZUNsdXN0ZXJPbk50aENsaWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnZva2VDbGlja09uSG92ZXIgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy5pbnZva2VDbGlja09uSG92ZXIgPSBvcHRpb25zLmludm9rZUNsaWNrT25Ib3ZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWluU3BpcmFsQW5nbGVTZXBlcmF0aW9uID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy5taW5TcGlyYWxBbmdsZVNlcGVyYXRpb24gPSBvcHRpb25zLm1pblNwaXJhbEFuZ2xlU2VwZXJhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3BpcmFsRGlzdGFuY2VGYWN0b3IgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLnNwaXJhbERpc3RhbmNlRmFjdG9yID0gb3B0aW9ucy5zcGlyYWxEaXN0YW5jZUZhY3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWluQ2lyY2xlTGVuZ3RoID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy5taW5DaXJjbGVMZW5ndGggPSBvcHRpb25zLm1pbkNpcmNsZUxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGlja0hvdmVyU3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwaWRlck9wdGlvbnMuc3RpY2tIb3ZlclN0eWxlID0gb3B0aW9ucy5zdGlja0hvdmVyU3R5bGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RpY2tTdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy5zdGlja1N0eWxlID0gb3B0aW9ucy5zdGlja1N0eWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1hcmtlclNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLm1hcmtlclNlbGVjdGVkID0gb3B0aW9ucy5tYXJrZXJTZWxlY3RlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tYXJrZXJVblNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJPcHRpb25zLm1hcmtlclVuU2VsZWN0ZWQgPSBvcHRpb25zLm1hcmtlclVuU2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnZpc2libGUgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyT3B0aW9ucy52aXNpYmxlID0gb3B0aW9ucy52aXNpYmxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuU2V0T3B0aW9ucyg8SUNsdXN0ZXJPcHRpb25zPm9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4cGFuZHMgYSBjbHVzdGVyIGludG8gaXQncyBvcGVuIHNwaWRlciBsYXlvdXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNsdXN0ZXIgVGhlIGNsdXN0ZXIgdG8gc2hvdyBpbiBpdCdzIG9wZW4gc3BpZGVyIGxheW91dC4uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBTaG93U3BpZGVyQ2x1c3RlcihjbHVzdGVyOiBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuSGlkZVNwaWRlckNsdXN0ZXIoKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Q2x1c3RlciA9IGNsdXN0ZXI7XHJcblxyXG4gICAgICAgIGlmIChjbHVzdGVyICYmIGNsdXN0ZXIuY29udGFpbmVkUHVzaHBpbnMpIHtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIHNwaWRlciBkYXRhLlxyXG4gICAgICAgICAgICBjb25zdCBtOiBNaWNyb3NvZnQuTWFwcy5NYXAgPSAoPEJpbmdNYXBTZXJ2aWNlPnRoaXMuX21hcHMpLk1hcEluc3RhbmNlO1xyXG4gICAgICAgICAgICBjb25zdCBwaW5zOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5QdXNocGluPiA9IGNsdXN0ZXIuY29udGFpbmVkUHVzaHBpbnM7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlcjogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPSBjbHVzdGVyLmdldExvY2F0aW9uKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlclBvaW50OiBNaWNyb3NvZnQuTWFwcy5Qb2ludCA9XHJcbiAgICAgICAgICAgICAgICA8TWljcm9zb2Z0Lk1hcHMuUG9pbnQ+bS50cnlMb2NhdGlvblRvUGl4ZWwoY2VudGVyLCBNaWNyb3NvZnQuTWFwcy5QaXhlbFJlZmVyZW5jZS5jb250cm9sKTtcclxuICAgICAgICAgICAgbGV0IHN0aWNrOiBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZTtcclxuICAgICAgICAgICAgbGV0IGFuZ2xlID0gMDtcclxuICAgICAgICAgICAgY29uc3QgbWFrZVNwaXJhbDogYm9vbGVhbiA9IHBpbnMubGVuZ3RoID4gdGhpcy5fc3BpZGVyT3B0aW9ucy5jaXJjbGVTcGlyYWxTd2l0Y2hvdmVyO1xyXG4gICAgICAgICAgICBsZXQgbGVnUGl4ZWxMZW5ndGg6IG51bWJlcjtcclxuICAgICAgICAgICAgbGV0IHN0ZXBBbmdsZTogbnVtYmVyO1xyXG4gICAgICAgICAgICBsZXQgc3RlcExlbmd0aDogbnVtYmVyO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1ha2VTcGlyYWwpIHtcclxuICAgICAgICAgICAgICAgIGxlZ1BpeGVsTGVuZ3RoID0gdGhpcy5fc3BpZGVyT3B0aW9ucy5taW5DaXJjbGVMZW5ndGggLyBNYXRoLlBJO1xyXG4gICAgICAgICAgICAgICAgc3RlcExlbmd0aCA9IDIgKiBNYXRoLlBJICogdGhpcy5fc3BpZGVyT3B0aW9ucy5zcGlyYWxEaXN0YW5jZUZhY3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0ZXBBbmdsZSA9IDIgKiBNYXRoLlBJIC8gcGlucy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBsZWdQaXhlbExlbmd0aCA9ICh0aGlzLl9zcGlkZXJPcHRpb25zLnNwaXJhbERpc3RhbmNlRmFjdG9yIC8gc3RlcEFuZ2xlIC8gTWF0aC5QSSAvIDIpICogcGlucy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVnUGl4ZWxMZW5ndGggPCB0aGlzLl9zcGlkZXJPcHRpb25zLm1pbkNpcmNsZUxlbmd0aCkgeyBsZWdQaXhlbExlbmd0aCA9IHRoaXMuX3NwaWRlck9wdGlvbnMubWluQ2lyY2xlTGVuZ3RoOyB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwaW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgc3BpZGVyIHBpbiBsb2NhdGlvbi5cclxuICAgICAgICAgICAgICAgIGlmICghbWFrZVNwaXJhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gc3RlcEFuZ2xlICogaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlICs9IHRoaXMuX3NwaWRlck9wdGlvbnMubWluU3BpcmFsQW5nbGVTZXBlcmF0aW9uIC8gbGVnUGl4ZWxMZW5ndGggKyBpICogMC4wMDA1O1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ1BpeGVsTGVuZ3RoICs9IHN0ZXBMZW5ndGggLyBhbmdsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50OiBNaWNyb3NvZnQuTWFwcy5Qb2ludCA9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IE1pY3Jvc29mdC5NYXBzLlBvaW50KGNlbnRlclBvaW50LnggKyBsZWdQaXhlbExlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyUG9pbnQueSArIGxlZ1BpeGVsTGVuZ3RoICogTWF0aC5zaW4oYW5nbGUpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvYzogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPVxyXG4gICAgICAgICAgICAgICAgICAgIDxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj5tLnRyeVBpeGVsVG9Mb2NhdGlvbihwb2ludCwgTWljcm9zb2Z0Lk1hcHMuUGl4ZWxSZWZlcmVuY2UuY29udHJvbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHN0aWNrIHRvIHBpbi5cclxuICAgICAgICAgICAgICAgIHN0aWNrID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lKFtjZW50ZXIsIGxvY10sIHRoaXMuX3NwaWRlck9wdGlvbnMuc3RpY2tTdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJMYXllci5hZGQoc3RpY2spO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBwaW4gaW4gc3BpcmFsIHRoYXQgY29udGFpbnMgc2FtZSBtZXRhZGF0YSBhcyBwYXJlbnQgcGluLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGluOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluID0gbmV3IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4obG9jKTtcclxuICAgICAgICAgICAgICAgIHBpbi5tZXRhZGF0YSA9IHBpbnNbaV0ubWV0YWRhdGEgfHwge307XHJcbiAgICAgICAgICAgICAgICBwaW4ubWV0YWRhdGEuaXNDbHVzdGVyTWFya2VyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHBpbi5zZXRPcHRpb25zKHRoaXMuR2V0QmFzaWNQdXNocGluT3B0aW9ucyhwaW5zW2ldKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGlkZXJMYXllci5hZGQocGluKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcGlkZXJNYXJrZXI6IEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyID0gbmV3IEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyKHBpbiwgbnVsbCwgdGhpcy5fc3BpZGVyTGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgc3BpZGVyTWFya2VyLlN0aWNrID0gc3RpY2s7XHJcbiAgICAgICAgICAgICAgICBzcGlkZXJNYXJrZXIuUGFyZW50TWFya2VyID0gPEJpbmdNYXJrZXI+dGhpcy5HZXRNYXJrZXJGcm9tQmluZ01hcmtlcihwaW5zW2ldKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwaWRlck1hcmtlcnMucHVzaChzcGlkZXJNYXJrZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BpZGVyTWFya2VyTG9va3VwLnNldChwaW4sIHNwaWRlck1hcmtlcik7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX21hcGNsaWNrcyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcclxuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9iaW5nL2JpbmctbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCaW5nQ29udmVyc2lvbnMgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9iaW5nL2JpbmctY29udmVyc2lvbnMnO1xyXG5cclxuLyoqXHJcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHRoZSB7QGxpbmsgSW5mb1dpbmRvd30gY29udHJhY3QgZm9yIHRoZSBCaW5nIE1hcHMgVjggbWFwIGFyY2hpdGVjdHVyZS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJpbmdJbmZvV2luZG93IGltcGxlbWVudHMgSW5mb1dpbmRvdyB7XHJcblxyXG4gICAgcHJpdmF0ZSBfaXNPcGVuOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBpbmZvIGJveCBpcyBjdXJyZW50bHkgb3Blbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nSW5mb1dpbmRvd1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IElzT3BlbigpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAodGhpcy5faW5mb0JveCAmJiB0aGlzLl9pbmZvQm94LmdldE9wdGlvbnMoKS52aXNpYmxlID09PSB0cnVlKSB7IHJldHVybiB0cnVlOyB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBuYXRpdmUgcHJpbWl0dmUgdW5kZXJseWluZyB0aGUgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdJbmZvV2luZG93XHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IE1pY3Jvc29mdC5NYXBzLkluZm9ib3gge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbmZvQm94O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nSW5mb1dpbmRvdy5cclxuICAgICAqIEBwYXJhbSBfaW5mb0JveCAtIEEge0BsaW5rIE1pY3Jvc29mdC5NYXBzLkluZm9ib3h9IGluc3RhbmNlIHVuZGVybHlpbmcgdGhlIG1vZGVsXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0luZm9XaW5kb3dcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfaW5mb0JveDogTWljcm9zb2Z0Lk1hcHMuSW5mb2JveCkge1xyXG4gICAgICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgSW5mb1dpbmRvdy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGV2ZW50IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgbGlzdGVuZXIgKGUuZy4gXCJjbGlja1wiKVxyXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgaW52b2tlZCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdJbmZvV2luZG93XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5faW5mb0JveCwgZXZlbnRUeXBlLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5ldmVudE5hbWUgPT09ICdpbmZvYm94Q2hhbmdlZCcpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmZvQm94LmdldE9wdGlvbnMoKS52aXNpYmxlID09PSB0cnVlKSB7IHRoaXMuX2lzT3BlbiA9IHRydWU7IH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmZvQm94LmdldE9wdGlvbnMoKS52aXNpYmxlID09PSBmYWxzZSAmJiB0aGlzLl9pc09wZW4gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNPcGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZuKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhlIGluZm8gd2luZG93LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nSW5mb1dpbmRvd1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ2xvc2UoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSUluZm9ib3hPcHRpb25zID0ge307XHJcbiAgICAgICAgby52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faW5mb0JveC5zZXRPcHRpb25zKG8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGluZm8gd2luZG93LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gUmV0dXJucyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBpbmZvIHdpbmRvdy5cclxuICAgICAqIEBtZW1iZXJvZiBCaW5nSW5mb1dpbmRvd1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0UG9zaXRpb24oKTogSUxhdExvbmcge1xyXG4gICAgICAgIGNvbnN0IHA6IElMYXRMb25nID0ge1xyXG4gICAgICAgICAgICBsYXRpdHVkZTogdGhpcy5faW5mb0JveC5nZXRMb2NhdGlvbigpLmxhdGl0dWRlLFxyXG4gICAgICAgICAgICBsb25naXR1ZGU6IHRoaXMuX2luZm9Cb3guZ2V0TG9jYXRpb24oKS5sb25naXR1ZGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgdGhlIGluZm8gd2luZG93LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nSW5mb1dpbmRvd1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgT3BlbigpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JSW5mb2JveE9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2luZm9Cb3guc2V0T3B0aW9ucyhvKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBJbmZvIHdpbmRvdyBvcHRpb25zIHRvIHNldC4gVGhlIG9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgd2l0aCBhbnkgZXhpc3Rpbmcgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0luZm9XaW5kb3dcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMob3B0aW9uczogSUluZm9XaW5kb3dPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSUluZm9ib3hPcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUluZm9Cb3hPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2luZm9Cb3guc2V0T3B0aW9ucyhvKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IHBvc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAtIEdlbyBjb29yZGluYXRlcyB0byBtb3ZlIHRoZSBhbmNob3Igb2YgdGhlIGluZm8gd2luZG93IHRvLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nSW5mb1dpbmRvd1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0UG9zaXRpb24ocG9zaXRpb246IElMYXRMb25nKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbDogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24ocG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuX2luZm9Cb3guc2V0TG9jYXRpb24obCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSUxhYmVsT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhYmVsLW9wdGlvbnMnO1xyXG5cclxuLyoqXHJcbiAqIEFic3RyYWN0IGJhc2UgaW1wbGVtZW50aW5nIGEgbGFiZWwgdG8gYmUgcGxhY2VkIG9uIHRoZSBtYXAuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTWFwTGFiZWwge1xyXG4vLyBleHBvcnQgY2xhc3MgTWFwTGFiZWwgZXh0ZW5kcyBNaWNyb3NvZnQuTWFwcy5DdXN0b21PdmVybGF5IHtcclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcm90ZWN0ZWQgX2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGxhYmVsIHN0eWxlIGZvciB0aGUgcGxhdGZvcm1cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXQgRGVmYXVsdExhYmVsU3R5bGUoKTogSUxhYmVsT3B0aW9ucztcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1hcExhYmVsXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBwcm9wZXJ0aWVzIHRvIHNldC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSkge1xyXG4gICAgICAgIHRoaXMuU2V0KCdmb250RmFtaWx5JywgJ3NhbnMtc2VyaWYnKTtcclxuICAgICAgICB0aGlzLlNldCgnZm9udFNpemUnLCAxMik7XHJcbiAgICAgICAgdGhpcy5TZXQoJ2ZvbnRDb2xvcicsICcjZmZmZmZmJyk7XHJcbiAgICAgICAgdGhpcy5TZXQoJ3N0cm9rZVdlaWdodCcsIDQpO1xyXG4gICAgICAgIHRoaXMuU2V0KCdzdHJva2VDb2xvcicsICcjMDAwMDAwJyk7XHJcbiAgICAgICAgdGhpcy5TZXQoJ2FsaWduJywgJ2NlbnRlcicpO1xyXG4gICAgICAgIHRoaXMuU2V0VmFsdWVzKG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIGxhYmVsIGZyb20gdGhlIG1hcC4gVGhpcyBtZXRob2QgZG9lcyBub3QgYXR1YWxseSBkZWxldGUgdGhlIGxhYmVsIGl0c2VsZiwgc29cclxuICAgICAqIGl0IGNhbiBiZSByZWFkZGVkIHRvIG1hcCBsYXRlci5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuU2V0TWFwKG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZWdhdGUgY2FsbGVkIHdoZW4gdW5kZXJseWluZyBwcm9wZXJ0aWVzIGNoYW5nZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHJvcCAtIFRoZSBwcm9wZXJ0eSBvciBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBjaGFuZ2VkLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDaGFuZ2VkKHByb3A6IHN0cmluZyB8IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcclxuICAgICAgICBsZXQgc2hvdWxkUnVuRHJhd0NhbnZhcyA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBzaG91bGRSdW5EcmF3ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3ApKSB7IHByb3AgPSBbcHJvcF07IH1cclxuICAgICAgICBwcm9wLmZvckVhY2gocCA9PiB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAocCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZm9udEZhbWlseSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdmb250U2l6ZSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdmb250Q29sb3InOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3Ryb2tlV2VpZ2h0JzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cm9rZUNvbG9yJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2FsaWduJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJ1bkRyYXdDYW52YXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbWF4Wm9vbSc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtaW5ab29tJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ29mZnNldCc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdoaWRkZW4nOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAncG9zaXRpb24nOlxyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJ1bkRyYXcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHNob3VsZFJ1bkRyYXdDYW52YXMpIHsgdGhpcy5EcmF3Q2FudmFzKCk7IH1cclxuICAgICAgICBpZiAoc2hvdWxkUnVuRHJhdykgeyB0aGlzLkRyYXcoKTsgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdmFsdWUgb2YgYSBzZXR0aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgc3BlY2lmeWluZyB0aGUgc2V0dGluZy5cclxuICAgICAqIEByZXR1cm5zIC0gVGhlIHZhbHVlIG9mIHRoZSBzZXR0aW5nLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldChrZXk6IHN0cmluZyk6IGFueTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG1hcCBhc3NvY2l0ZWQgd2l0aCB0aGUgbGFiZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBBIG5hdGl2ZSBtYXAgb2JqZWN0IGZvciB0aGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbi4gSW1wbGVtZW50aW5nIGRlcml2YXRpdmVzIHNob3VsZCByZXR1cm4gdGhlXHJcbiAgICAgKiBhY3R1YWwgbmF0aXZlIG9iamVjdC5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXRNYXAoKTogYW55O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgYSBzZXR0aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgc3BlY2lmeWluZyB0aGUgc2V0dGluZy5cclxuICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsdWUgdG8gc2V0LlxyXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldChrZXk6IHN0cmluZywgdmFsOiBhbnkpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWFwIGZvciB0aGUgbGFiZWwuIFNldHRpbmdzIHRoaXMgdG8gbnVsbCByZW1vdmUgdGhlIGxhYmVsIGZyb20gaHRlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFwIC0gQSBuYXRpdmUgbWFwIG9iamVjdCBmb3IgdGhlIHVuZGVybHlpbmcgaW1wbGVtZW50YXRpb24uIEltcGxlbWVudGluZyBkZXJpdmF0aXZlcyBzaG91bGQgcmV0dXJuIHRoZVxyXG4gICAgICogYWN0dWFsIG5hdGl2ZSBvYmplY3QuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFNldE1hcChtYXA6IGFueSk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHNldHRpbmdzIHRvIHRoZSBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXR0aW5ncyBrZXkgdmFsdWUgcGFpcnMuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU2V0VmFsdWVzKG9wdGlvbnM6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiB2b2lkO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3RlY3RlZCBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbGFiZWwuIFZpc2liaWxpdHkgZGVwZW5kcyBvbiBab29tIHNldHRpbmdzLlxyXG4gICAgICogQHJldHVybnMgLSBibGFuayBzdHJpbmcgaWYgdmlzaWJsZSwgJ2hpZGRlbicgaWYgaW52aXNpYmxlLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgR2V0VmlzaWJsZSgpIHtcclxuICAgICAgICBjb25zdCBtaW5ab29tOiBudW1iZXIgPSB0aGlzLkdldCgnbWluWm9vbScpO1xyXG4gICAgICAgIGNvbnN0IG1heFpvb206IG51bWJlciA9IHRoaXMuR2V0KCdtYXhab29tJyk7XHJcbiAgICAgICAgY29uc3QgaGlkZGVuOiBib29sZWFuID0gdGhpcy5HZXQoJ2hpZGRlbicpO1xyXG5cclxuICAgICAgICBpZiAoaGlkZGVuKSB7cmV0dXJuICdoaWRkZW4nOyB9XHJcbiAgICAgICAgaWYgKG1pblpvb20gPT09IHVuZGVmaW5lZCAmJiBtYXhab29tID09PSB1bmRlZmluZWQpIHsgcmV0dXJuICcnOyB9XHJcbiAgICAgICAgaWYgKCF0aGlzLkdldE1hcCgpKSB7IHJldHVybiAnJzsgfVxyXG5cclxuICAgICAgICBjb25zdCBtYXBab29tOiBudW1iZXIgPSB0aGlzLkdldE1hcCgpLmdldFpvb20oKTtcclxuICAgICAgICBpZiAobWFwWm9vbSA8IG1pblpvb20gfHwgbWFwWm9vbSA+IG1heFpvb20pIHsgcmV0dXJuICdoaWRkZW4nOyB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIGxhYmVsIG9uIHRoZSBtYXAuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IERyYXcoKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBsYWJlbCB0byB0aGUgY2FudmFzIDJkIGNvbnRleHQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIERyYXdDYW52YXMgKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fY2FudmFzKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICBjb25zdCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9IHRoaXMuX2NhbnZhcy5zdHlsZTtcclxuICAgICAgICBzdHlsZS56SW5kZXggPSB0aGlzLkdldCgnekluZGV4Jyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuR2V0KCdzdHJva2VDb2xvcicpO1xyXG4gICAgICAgIGN0eC5mb250ID0gdGhpcy5HZXQoJ2ZvbnRTaXplJykgKyAncHggJyArIHRoaXMuR2V0KCdmb250RmFtaWx5Jyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRDb2xvcjogc3RyaW5nID0gdGhpcy5HZXQoJ2JhY2tncm91bmRDb2xvcicpO1xyXG4gICAgICAgIGNvbnN0IHN0cm9rZVdlaWdodDogbnVtYmVyID0gTnVtYmVyKHRoaXMuR2V0KCdzdHJva2VXZWlnaHQnKSk7XHJcbiAgICAgICAgY29uc3QgdGV4dDogc3RyaW5nID0gdGhpcy5HZXQoJ3RleHQnKTtcclxuICAgICAgICBjb25zdCB0ZXh0TWVhc3VyZTogVGV4dE1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQodGV4dCk7XHJcbiAgICAgICAgY29uc3QgdGV4dFdpZHRoOiBudW1iZXIgPSB0ZXh0TWVhc3VyZS53aWR0aDtcclxuICAgICAgICBpZiAodGV4dCAmJiBzdHJva2VXZWlnaHQgJiYgc3Ryb2tlV2VpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdlaWdodDtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHRleHQsIDQsIDQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmFja2dyb3VuZENvbG9yICYmIGJhY2tncm91bmRDb2xvciAhPT0gJycpIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRleHRXaWR0aCArIDgsIChwYXJzZUludChjdHguZm9udCwgMTApICogMikgLSAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuR2V0KCdmb250Q29sb3InKTtcclxuICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgNCwgNCk7XHJcblxyXG4gICAgICAgIHN0eWxlLm1hcmdpbkxlZnQgPSB0aGlzLkdldE1hcmdpbkxlZnQodGV4dFdpZHRoKSArICdweCc7XHJcbiAgICAgICAgc3R5bGUubWFyZ2luVG9wID0gJy0wLjRlbSc7XHJcbiAgICAgICAgc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuICAgICAgICAgICAgLy8gQnJpbmcgYWN0dWFsIHRleHQgdG9wIGluIGxpbmUgd2l0aCBkZXNpcmVkIGxhdGl0dWRlLlxyXG4gICAgICAgICAgICAvLyBDaGVhcGVyIHRoYW4gY2FsY3VsYXRpbmcgaGVpZ2h0IG9mIHRleHQuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBtYXJnaW4tbGVmdCBmb3IgdGhlIGNhbnZhcy5cclxuICAgICAqIEBwYXJhbSB0ZXh0V2lkdGggIC0gVGhlIHdpZHRoIG9mIHRoZSB0ZXh0LCBpbiBwaXhlbHMuXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBtYXJnaW4tbGVmdCwgaW4gcGl4ZWxzLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBHZXRNYXJnaW5MZWZ0KHRleHRXaWR0aDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuR2V0KCdhbGlnbicpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOiAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOiAgIHJldHVybiAtdGV4dFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGV4dFdpZHRoIC8gLTI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBjYWxsZWQgd2hlbiB0aGUgbGFiZWwgaXMgYWRkZWQgdG8gdGhlIG1hcC4gR2VuZXJhdGVzIGFuZCBjb25maWd1cmVzXHJcbiAgICAgKiB0aGUgY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBPbkFkZCgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGxhYmVsIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBPblJlbW92ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fY2FudmFzICYmIHRoaXMuX2NhbnZhcy5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NhbnZhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBCaW5nTWFwU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1jb252ZXJzaW9ucyc7XHJcbmltcG9ydCB7IElMYWJlbE9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYWJlbC1vcHRpb25zJztcclxuaW1wb3J0IHsgTWFwTGFiZWwgfSBmcm9tICcuLi9tYXAtbGFiZWwnO1xyXG5cclxubGV0IGlkOiBudW1iZXIgPSAwO1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgbWFwIGEgbGFibGVkIHRvIGJlIHBsYWNlZCBvbiB0aGUgbWFwLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmluZ01hcExhYmVsIGV4dGVuZHMgTWFwTGFiZWwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBsYWJlbCBzdHlsZSBmb3IgdGhlIHBsYXRmb3JtXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwTGFiZWxcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBEZWZhdWx0TGFiZWxTdHlsZSgpOiBJTGFiZWxPcHRpb25zIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcclxuICAgICAgICAgICAgZm9udENvbG9yOiAnI2ZmZmZmZicsXHJcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogMixcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6ICcjMDAwMDAwJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNYXBMYWJlbFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgcHJvcGVydGllcyB0byBzZXQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IHsgW2tleTogc3RyaW5nXTogYW55IH0pIHtcclxuICAgICAgICBvcHRpb25zLmZvbnRTaXplID0gb3B0aW9ucy5mb250U2l6ZSB8fCAxMjtcclxuICAgICAgICBvcHRpb25zLmZvbnRDb2xvciA9IG9wdGlvbnMuZm9udENvbG9yIHx8ICcjZmZmZmZmJztcclxuICAgICAgICBvcHRpb25zLnN0cm9rZVdlaWdodCA9IG9wdGlvbnMuc3Ryb2tlV2VpZ2h0IHx8IDI7XHJcbiAgICAgICAgb3B0aW9ucy5zdHJva2VDb2xvciA9IG9wdGlvbnMuc3Ryb2tlQ29sb3IgfHwgJyMwMDAwMDAnO1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgICg8YW55PnRoaXMpLl9vcHRpb25zLmJlbmVhdGhMYWJlbHMgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHNldHRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSBzcGVjaWZ5aW5nIHRoZSBzZXR0aW5nLlxyXG4gICAgICogQHJldHVybnMgLSBUaGUgdmFsdWUgb2YgdGhlIHNldHRpbmcuXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXQoa2V5OiBzdHJpbmcpOiBhbnkge1xyXG4gICAgICAgIHJldHVybiAoPGFueT50aGlzKVtrZXldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbWFwIGFzc29jaXRlZCB3aXRoIHRoZSBsYWJlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRNYXAoKTogTWljcm9zb2Z0Lk1hcHMuTWFwIHtcclxuICAgICAgICByZXR1cm4gKDxhbnk+dGhpcykuZ2V0TWFwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHZhbHVlIGZvciBhIHNldHRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSBzcGVjaWZ5aW5nIHRoZSBzZXR0aW5nLlxyXG4gICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWx1ZSB0byBzZXQuXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXQoa2V5OiBzdHJpbmcsIHZhbDogYW55KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ3Bvc2l0aW9uJyAmJiAhdmFsLmhhc093blByb3BlcnR5KCdhbHRpdHVkZScpICYmIHZhbC5oYXNPd25Qcm9wZXJ0eSgnbGF0aXR1ZGUnKSAmJiB2YWwuaGFzT3duUHJvcGVydHkoJ2xvbmdpdHVkZScpKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbih2YWwubGF0aXR1ZGUsIHZhbC5sb25naXR1ZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5HZXQoa2V5KSAhPT0gdmFsKSB7XHJcbiAgICAgICAgICAgICg8YW55PnRoaXMpW2tleV0gPSB2YWw7XHJcbiAgICAgICAgICAgIHRoaXMuQ2hhbmdlZChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1hcCBmb3IgdGhlIGxhYmVsLiBTZXR0aW5ncyB0aGlzIHRvIG51bGwgcmVtb3ZlIHRoZSBsYWJlbCBmcm9tIGh0ZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAtIE1hcCB0byBhc3NvY2lhdGVkIHdpdGggdGhlIGxhYmVsLlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0TWFwKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbTogTWljcm9zb2Z0Lk1hcHMuTWFwID0gdGhpcy5HZXRNYXAoKTtcclxuICAgICAgICBpZiAobWFwID09PSBtKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgIG0ubGF5ZXJzLnJlbW92ZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hcCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1hcC5sYXllcnMuaW5zZXJ0KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgc2V0dGluZ3MgdG8gdGhlIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNldHRpbmdzIGtleSB2YWx1ZSBwYWlycy5cclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwTGFiZWxcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFZhbHVlcyhvcHRpb25zOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcDogQXJyYXk8c3RyaW5nPiA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3Bvc2l0aW9uJyAmJiAhb3B0aW9uc1trZXldLmhhc093blByb3BlcnR5KCdhbHRpdHVkZScpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldLmhhc093blByb3BlcnR5KCdsYXRpdHVkZScpICYmIG9wdGlvbnNba2V5XS5oYXNPd25Qcm9wZXJ0eSgnbG9uZ2l0dWRlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSBuZXcgTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24ob3B0aW9uc1trZXldLmxhdGl0dWRlLCBvcHRpb25zW2tleV0ubG9uZ2l0dWRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLkdldChrZXkpICE9PSBvcHRpb25zW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAoPGFueT50aGlzKVtrZXldID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIHAucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLmxlbmd0aCA+IDApIHsgdGhpcy5DaGFuZ2VkKHApOyB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvdGVjdGVkIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIGxhYmVsIG9uIHRoZSBtYXAuXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBEcmF3KCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHZpc2liaWxpdHk6IHN0cmluZyA9IHRoaXMuR2V0VmlzaWJsZSgpO1xyXG4gICAgICAgIGNvbnN0IG06IE1pY3Jvc29mdC5NYXBzLk1hcCA9IHRoaXMuR2V0TWFwKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jYW52YXMpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgaWYgKCFtKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGNvbnN0IHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uID0gdGhpcy5fY2FudmFzLnN0eWxlO1xyXG4gICAgICAgIGlmICh2aXNpYmlsaXR5ICE9PSAnJykge1xyXG4gICAgICAgICAgICAvLyBsYWJlbCBpcyBub3QgdmlzaWJsZSwgZG9uJ3QgY2FsY3VsYXRlIHBvc2l0aW9ucyBldGMuXHJcbiAgICAgICAgICAgIHN0eWxlWyd2aXNpYmlsaXR5J10gPSB2aXNpYmlsaXR5O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgb2Zmc2V0OiBNaWNyb3NvZnQuTWFwcy5Qb2ludCA9IHRoaXMuR2V0KCdvZmZzZXQnKTtcclxuICAgICAgICBjb25zdCBsYXRMbmc6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uID0gdGhpcy5HZXQoJ3Bvc2l0aW9uJyk7XHJcbiAgICAgICAgaWYgKCFsYXRMbmcpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgaWYgKCFvZmZzZXQpIHsgb2Zmc2V0ID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvaW50KDAsIDApOyB9XHJcblxyXG4gICAgICAgIGNvbnN0IHBvczogTWljcm9zb2Z0Lk1hcHMuUG9pbnQgPSA8TWljcm9zb2Z0Lk1hcHMuUG9pbnQ+bS50cnlMb2NhdGlvblRvUGl4ZWwoXHJcbiAgICAgICAgICAgIGxhdExuZyxcclxuICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuUGl4ZWxSZWZlcmVuY2UuY29udHJvbCk7XHJcbiAgICAgICAgc3R5bGVbJ3RvcCddID0gKHBvcy55ICsgb2Zmc2V0LnkpICsgJ3B4JztcclxuICAgICAgICBzdHlsZVsnbGVmdCddID0gKHBvcy54ICsgb2Zmc2V0LngpICsgJ3B4JztcclxuICAgICAgICBzdHlsZVsndmlzaWJpbGl0eSddID0gdmlzaWJpbGl0eTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGVnYXRlIGNhbGxlZCB3aGVuIHRoZSBsYWJlbCBpcyBhZGRlZCB0byB0aGUgbWFwLiBHZW5lcmF0ZXMgYW5kIGNvbmZpZ3VyZXNcclxuICAgICAqIHRoZSBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgT25BZGQoKSB7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLmlkID0gYHhNYXBMYWJlbCR7aWQrK31gO1xyXG4gICAgICAgIGNvbnN0IHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uID0gdGhpcy5fY2FudmFzLnN0eWxlO1xyXG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHJcbiAgICAgICAgY29uc3QgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xyXG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcclxuXHJcbiAgICAgICAgKDxhbnk+dGhpcykuc2V0SHRtbEVsZW1lbnQodGhpcy5fY2FudmFzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcml2YXRlIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZWdhdGUgY2FsbGxlZCB3aGVuIHRoZSBsYWJlbCBpcyBsb2FkZWRcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwTGFiZWxcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBPbkxvYWQoKSB7XHJcbiAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5HZXRNYXAoKSwgJ3ZpZXdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuQ2hhbmdlZCgncG9zaXRpb24nKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLkRyYXdDYW52YXMoKTtcclxuICAgICAgICB0aGlzLkRyYXcoKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBleHRlbmQgdGhlIEN1c3RvbU92ZXJsYXkgaW50byB0aGUgTWFwTGFiZWxcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAbWV0aG9kXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTWl4aW5NYXBMYWJlbFdpdGhPdmVybGF5VmlldygpIHtcclxuICAgIGNvbnN0IHggPSBCaW5nTWFwTGFiZWwucHJvdG90eXBlO1xyXG4gICAgQmluZ01hcExhYmVsLnByb3RvdHlwZSA9IDxhbnk+IG5ldyBNaWNyb3NvZnQuTWFwcy5DdXN0b21PdmVybGF5KCk7XHJcbiAgICBmb3IgKGNvbnN0IHkgaW4geCkgeyBpZiAoKDxhbnk+eClbeV0gIT0gbnVsbCkgeyAoPGFueT5CaW5nTWFwTGFiZWwucHJvdG90eXBlKVt5XSA9ICg8YW55PngpW3ldOyB9fVxyXG4gICAgKDxhbnk+QmluZ01hcExhYmVsLnByb3RvdHlwZSlbJ29uQWRkJ10gPSB4WydPbkFkZCddO1xyXG4gICAgKDxhbnk+QmluZ01hcExhYmVsLnByb3RvdHlwZSlbJ29uTG9hZCddID0geFsnT25Mb2FkJ107XHJcbiAgICAoPGFueT5CaW5nTWFwTGFiZWwucHJvdG90eXBlKVsnb25SZW1vdmUnXSA9IHhbJ09uUmVtb3ZlJ107XHJcbn1cclxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlnb25FdmVudCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlnb24tZXZlbnQnO1xyXG5pbXBvcnQgeyBCaW5nQ29udmVyc2lvbnMgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9iaW5nL2JpbmctY29udmVyc2lvbnMnO1xyXG5pbXBvcnQgeyBCaW5nTWFwU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2JpbmcvYmluZy1tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuLi9wb2x5Z29uJztcclxuaW1wb3J0IHsgQmluZ01hcExhYmVsIH0gZnJvbSAnLi9iaW5nLWxhYmVsJztcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBmb3IgYSBwb2x5Z29uIG1vZGVsIGZvciBCaW5nIE1hcHMgVjguXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCaW5nUG9seWdvbiBleHRlbmRzIFBvbHlnb24gaW1wbGVtZW50cyBQb2x5Z29uIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfbWFwOiBNaWNyb3NvZnQuTWFwcy5NYXAgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfaXNFZGl0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfdGl0bGU6IHN0cmluZyA9ICcnO1xyXG4gICAgcHJpdmF0ZSBfbWF4Wm9vbTogbnVtYmVyID0gLTE7XHJcbiAgICBwcml2YXRlIF9taW5ab29tOiBudW1iZXIgPSAtMTtcclxuICAgIHByaXZhdGUgX3Nob3dMYWJlbDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfc2hvd1Rvb2x0aXA6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2xhYmVsOiBCaW5nTWFwTGFiZWwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcDogQmluZ01hcExhYmVsID0gbnVsbDtcclxuICAgIHByaXZhdGUgX2hhc1Rvb2xUaXBSZWNlaXZlcjogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcFZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX21vdXNlT3Zlckxpc3RlbmVyOiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xyXG4gICAgcHJpdmF0ZSBfbW91c2VNb3ZlTGlzdGVuZXI6IE1pY3Jvc29mdC5NYXBzLklIYW5kbGVySWQ7XHJcbiAgICBwcml2YXRlIF9tb3VzZU91dExpc3RlbmVyOiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xyXG4gICAgcHJpdmF0ZSBfbWV0YWRhdGE6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xyXG4gICAgcHJpdmF0ZSBfb3JpZ2luYWxQYXRoOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+O1xyXG4gICAgcHJpdmF0ZSBfZWRpdGluZ0NvbXBsZXRlRW1pdHRlcjogKGV2ZW50OiBJUG9seWdvbkV2ZW50KSA9PiB2b2lkO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gem9vbSBhdCB3aGljaCB0aGUgbGFiZWwgaXMgZGlzcGxheWVkLiBJZ25vcmVkIG9yIFNob3dMYWJlbCBpcyBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTGFiZWxNYXhab29tKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9tYXhab29tOyB9XHJcbiAgICBwdWJsaWMgc2V0IExhYmVsTWF4Wm9vbSh2YWw6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX21heFpvb20gPSB2YWw7XHJcbiAgICAgICAgdGhpcy5NYW5hZ2VMYWJlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHpvb20gYXQgd2hpY2ggdGhlIGxhYmVsIGlzIGRpc3BsYXllZC4gSWdub3JlZCBvciBTaG93TGFiZWwgaXMgZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IExhYmVsTWluWm9vbSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fbWluWm9vbTsgfVxyXG4gICAgcHVibGljIHNldCBMYWJlbE1pblpvb20odmFsOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9taW5ab29tID0gdmFsO1xyXG4gICAgICAgIHRoaXMuTWFuYWdlTGFiZWwoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlnb24gbWV0YWRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBNZXRhZGF0YSgpOiBNYXA8c3RyaW5nLCBhbnk+IHsgcmV0dXJuIHRoaXMuX21ldGFkYXRhOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgcHJpbWl0dmUgaW1wbGVtZW50aW5nIHRoZSBwb2x5Z29uLCBpbiB0aGlzIGNhc2Uge0BsaW5rIE1pY3Jvc29mdC5NYXBzLlBvbHlnb259XHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBOYXRpdmVQcmltaXR2ZSgpOiBNaWNyb3NvZnQuTWFwcy5Qb2x5Z29uIHsgcmV0dXJuIHRoaXMuX3BvbHlnb247IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRvIHNob3cgdGhlIGxhYmVsXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IFNob3dMYWJlbCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3Nob3dMYWJlbDsgfVxyXG4gICAgcHVibGljIHNldCBTaG93TGFiZWwodmFsOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5fc2hvd0xhYmVsID0gdmFsO1xyXG4gICAgICAgIHRoaXMuTWFuYWdlTGFiZWwoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRvIHNob3cgdGhlIHRvb2x0aXBcclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgU2hvd1Rvb2x0aXAoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9zaG93VG9vbHRpcDsgfVxyXG4gICAgcHVibGljIHNldCBTaG93VG9vbHRpcCh2YWw6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLl9zaG93VG9vbHRpcCA9IHZhbDtcclxuICAgICAgICB0aGlzLk1hbmFnZVRvb2x0aXAoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgdGl0bGUgb2ZmIHRoZSBwb2x5Z29uXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IFRpdGxlKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl90aXRsZTsgfVxyXG4gICAgcHVibGljIHNldCBUaXRsZSh2YWw6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX3RpdGxlID0gdmFsO1xyXG4gICAgICAgIHRoaXMuTWFuYWdlTGFiZWwoKTtcclxuICAgICAgICB0aGlzLk1hbmFnZVRvb2x0aXAoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBjb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmdQb2x5Z29uLlxyXG4gICAgICogQHBhcmFtIF9wb2x5Z29uIC0gVGhlIHtAbGluayBNaWNyb3NvZnQuTWFwcy5Qb2x5Z29ufSB1bmRlcmx5aW5nIHRoZSBtb2RlbC5cclxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSBJbnN0YW5jZSBvZiB0aGUgTWFwIFNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyIC0gVGhlIGNvbnRleHQgbGF5ZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBfcG9seWdvbjogTWljcm9zb2Z0Lk1hcHMuUG9seWdvbixcclxuICAgICAgICBwcm90ZWN0ZWQgX21hcFNlcnZpY2U6IEJpbmdNYXBTZXJ2aWNlLFxyXG4gICAgICAgIHByb3RlY3RlZCBfbGF5ZXI6IE1pY3Jvc29mdC5NYXBzLkxheWVyLFxyXG4gICAgKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9tYXAgPSB0aGlzLl9tYXBTZXJ2aWNlLk1hcEluc3RhbmNlO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsUGF0aCA9IHRoaXMuR2V0UGF0aHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBkZWxlZ2F0ZSBmb3IgYW4gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSBldmVudCBuYW1lLlxyXG4gICAgICogQHBhcmFtIGZuIC0gRGVsZWdhdGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcblxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgc3VwcG9ydGVkRXZlbnRzID0gWydjbGljaycsICdkYmxjbGljaycsICdkcmFnJywgJ2RyYWdlbmQnLCAnZHJhZ3N0YXJ0JywgJ21vdXNlZG93bicsICdtb3VzZW91dCcsICdtb3VzZW92ZXInLCAnbW91c2V1cCddO1xyXG4gICAgICAgIGlmIChzdXBwb3J0ZWRFdmVudHMuaW5kZXhPZihldmVudFR5cGUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9wb2x5Z29uLCBldmVudFR5cGUsIChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBmbihlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudFR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XHJcbiAgICAgICAgICAgIGxldCBoYW5kbGVySWQ6IE1pY3Jvc29mdC5NYXBzLklIYW5kbGVySWQ7XHJcbiAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX3BvbHlnb24sICdtb3VzZW92ZXInLCBlID0+IHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJJZCA9IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKHRoaXMuX21hcCwgJ21vdXNlbW92ZScsIG0gPT4gZm4obSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fcG9seWdvbiwgJ21vdXNlb3V0JywgZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcklkKSB7IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5yZW1vdmVIYW5kbGVyKGhhbmRsZXJJZCk7IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBpZiAoZXZlbnRUeXBlID09PSAncGF0aGNoYW5nZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VkaXRpbmdDb21wbGV0ZUVtaXR0ZXIgPSA8KGV2ZW50OiBJUG9seWdvbkV2ZW50KSA9PiB2b2lkPmZuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZWQgdGhlIHBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGUoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xheWVyKSB7IHRoaXMuX2xheWVyLnJlbW92ZSh0aGlzLk5hdGl2ZVByaW1pdHZlKTsgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXAuZW50aXRpZXMucmVtb3ZlKHRoaXMuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHsgdGhpcy5fbGFiZWwuRGVsZXRlKCk7IH1cclxuICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCkgeyB0aGlzLl90b29sdGlwLkRlbGV0ZSgpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgZHJhZ2dhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcG9seWdvbiBpcyBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0RHJhZ2dhYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIC8vLyBCaW5nIHBvbHlnb25zIGFyZSBub3QgZHJhZ2dhYmxlIGJ5IGRlZmF1bHQuXHJcbiAgICAgICAgLy8vIFNlZSBodHRwczovL3NvY2lhbC5tc2RuLm1pY3Jvc29mdC5jb20vRm9ydW1zL2VuLVVTL1xyXG4gICAgICAgIC8vLyAgICAgN2FhYWU3NDgtNGQ1Zi00YmU1LWE3YmItOTA0OThlMDhiNDFjL2hvdy1jYW4taS1tYWtlLXBvbHlnb25wb2x5bGluZS1kcmFnZ2FibGUtaW4tYmluZy1tYXBzLTg/XHJcbiAgICAgICAgLy8vICAgICBmb3J1bT1iaW5nbWFwc1xyXG4gICAgICAgIC8vLyBmb3IgYSBwb3NzaWJsZSBhcHByb2FjaCB0byBiZSBpbXBsZW1lbnRlZCBpbiB0aGUgbW9kZWwuXHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIHBhdGggY2FuIGJlIGVkaXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBhdGggY2FuIGJlIGVkaXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0RWRpdGFibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRWRpdGFibGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb2x5Z29uIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IG9iamVjdHMgZGVzY3JpYmluZyB0aGUgcG9seWdvbiBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0UGF0aCgpOiBBcnJheTxJTGF0TG9uZz4ge1xyXG4gICAgICAgIGNvbnN0IHA6IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPiA9IHRoaXMuX3BvbHlnb24uZ2V0TG9jYXRpb25zKCk7XHJcbiAgICAgICAgY29uc3QgcGF0aDogQXJyYXk8SUxhdExvbmc+ID0gbmV3IEFycmF5PElMYXRMb25nPigpO1xyXG4gICAgICAgIHAuZm9yRWFjaChsID0+IHBhdGgucHVzaCh7IGxhdGl0dWRlOiBsLmxhdGl0dWRlLCBsb25naXR1ZGU6IGwubG9uZ2l0dWRlIH0pKTtcclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlnb24gcGF0aHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IG9iamVjdHMgZGVzY3JpYmluZyBtdWx0aXBsZSBwb2x5Z29uIHBhdGhzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0UGF0aHMoKTogQXJyYXk8QXJyYXk8SUxhdExvbmc+PiB7XHJcbiAgICAgICAgY29uc3QgcDogQXJyYXk8QXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+PiA9IHRoaXMuX3BvbHlnb24uZ2V0UmluZ3MoKTtcclxuICAgICAgICBjb25zdCBwYXRoczogQXJyYXk8QXJyYXk8SUxhdExvbmc+PiA9IG5ldyBBcnJheTxBcnJheTxJTGF0TG9uZz4+KCk7XHJcbiAgICAgICAgcC5mb3JFYWNoKHggPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoOiBBcnJheTxJTGF0TG9uZz4gPSBuZXcgQXJyYXk8SUxhdExvbmc+KCk7XHJcbiAgICAgICAgICAgIHguZm9yRWFjaCh5ID0+IHBhdGgucHVzaCh7IGxhdGl0dWRlOiB5LmxhdGl0dWRlLCBsb25naXR1ZGU6IHkubG9uZ2l0dWRlIH0pKTtcclxuICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGF0aHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgdmlzaWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBvbHlnb24gaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0VmlzaWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbi5nZXRWaXNpYmxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgZHJhZ2FibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRyYWdnYWJsZSAtIFRydWUgdG8gbWFrZSB0aGUgcG9seWdvbiBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0RHJhZ2dhYmxlKGRyYWdnYWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIC8vLyBCaW5nIHBvbHlnb25zIGFyZSBub3QgZHJhZ2dhYmxlIGJ5IGRlZmF1bHQuXHJcbiAgICAgICAgLy8vIFNlZSBodHRwczovL3NvY2lhbC5tc2RuLm1pY3Jvc29mdC5jb20vRm9ydW1zL2VuLVVTL1xyXG4gICAgICAgIC8vLyAgICAgN2FhYWU3NDgtNGQ1Zi00YmU1LWE3YmItOTA0OThlMDhiNDFjL2hvdy1jYW4taS1tYWtlLXBvbHlnb25wb2x5bGluZS1kcmFnZ2FibGUtaW4tYmluZy1tYXBzLThcclxuICAgICAgICAvLyAgICAgID9mb3J1bT1iaW5nbWFwc1xyXG4gICAgICAgIC8vLyBmb3IgYSBwb3NzaWJsZSBhcHByb2FjaCB0byBiZSBpbXBsZW1lbnRlZCBpbiB0aGUgbW9kZWwuXHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignVGhlIGJpbmcgbWFwcyBpbXBsZW1lbnRhdGlvbiBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBkcmFnZ2FibGUgcG9seWdvbnMuJykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3ZXRoZXIgdGhlIHBvbHlnb24gcGF0aCBpcyBlZGl0YWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZWRpdGFibGUgLSBUcnVlIHRvIG1ha2UgcG9seWdvbiBwYXRoIGVkaXRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGlzQ2hhbmdlZCA9IHRoaXMuX2lzRWRpdGFibGUgIT09IGVkaXRhYmxlO1xyXG4gICAgICAgIHRoaXMuX2lzRWRpdGFibGUgPSBlZGl0YWJsZTtcclxuICAgICAgICBpZiAoIWlzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5faXNFZGl0YWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFBhdGggPSB0aGlzLkdldFBhdGhzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuR2V0RHJhd2luZ1Rvb2xzKCkudGhlbih0ID0+IHtcclxuICAgICAgICAgICAgICAgIHQuZWRpdCh0aGlzLl9wb2x5Z29uKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkdldERyYXdpbmdUb29scygpLnRoZW4odCA9PiB7XHJcbiAgICAgICAgICAgICAgICB0LmZpbmlzaCgoZWRpdGVkUG9seWdvbjogTWljcm9zb2Z0Lk1hcHMuUG9seWdvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGl0ZWRQb2x5Z29uICE9PSB0aGlzLl9wb2x5Z29uIHx8ICF0aGlzLl9lZGl0aW5nQ29tcGxldGVFbWl0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UGF0aDogQXJyYXk8QXJyYXk8SUxhdExvbmc+PiA9IHRoaXMuR2V0UGF0aHMoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFBhdGg6IEFycmF5PEFycmF5PElMYXRMb25nPj4gPSB0aGlzLl9vcmlnaW5hbFBhdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5TZXRQYXRocyhuZXdQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIHRoZSBuZXcgcGF0aCB0byBwZXJzaXN0IGl0IGFwcGVhcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWRpdGluZ0NvbXBsZXRlRW1pdHRlcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENsaWNrOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBQb2x5Z29uOiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBPcmlnaW5hbFBhdGg6IG9yaWdpbmFsUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgTmV3UGF0aDogbmV3UGF0aFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvbHlnb24gb3B0aW9uc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElMYXRMb25nfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucy4gVGhlIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGh0ZSBvbmVzXHJcbiAgICAgKiBhbHJlYWR5IG9uIHRoZSB1bmRlcmx5aW5nIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRPcHRpb25zKG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQb2x5Z29uT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5Z29uT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9wb2x5Z29uLnNldE9wdGlvbnMobyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudmlzaWJsZSAhPSBudWxsICYmIHRoaXMuX3Nob3dMYWJlbCAmJiB0aGlzLl9sYWJlbCkgeyB0aGlzLl9sYWJlbC5TZXQoJ2hpZGRlbicsICFvcHRpb25zLnZpc2libGUpOyB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGl0YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5TZXRFZGl0YWJsZShvcHRpb25zLmVkaXRhYmxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb2x5Z29uIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBBbiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IChvciBhcnJheSBvZiBhcnJheXMpIGRlc2NyaWJpbmcgdGhlIHBvbHlnb25zIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRQYXRoKHBhdGg6IEFycmF5PElMYXRMb25nPik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHA6IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPiA9IG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4oKTtcclxuICAgICAgICBwYXRoLmZvckVhY2goeCA9PiBwLnB1c2gobmV3IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uKHgubGF0aXR1ZGUsIHgubG9uZ2l0dWRlKSkpO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsUGF0aCA9IFtwYXRoXTtcclxuICAgICAgICB0aGlzLl9wb2x5Z29uLnNldExvY2F0aW9ucyhwKTtcclxuICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2VudHJvaWQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLk1hbmFnZUxhYmVsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBwb2x5Z29uIHBhdGggb3IgcGF0aHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGhzXHJcbiAgICAgKiBBbiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IChvciBhcnJheSBvZiBhcnJheXMpIGRlc2NyaWJpbmcgdGhlIHBvbHlnb25zIHBhdGgocykuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRQYXRocyhwYXRoczogQXJyYXk8QXJyYXk8SUxhdExvbmc+PiB8IEFycmF5PElMYXRMb25nPik6IHZvaWQge1xyXG4gICAgICAgIGlmIChwYXRocyA9PSBudWxsKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29uLnNldFJpbmdzKG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4oKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwuRGVsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoc1swXSkpIHtcclxuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9yIGFycmF5c1xyXG4gICAgICAgICAgICBjb25zdCBwOiBBcnJheTxBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4+ID0gbmV3IEFycmF5PEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPj4oKTtcclxuICAgICAgICAgICAgKDxBcnJheTxBcnJheTxJTGF0TG9uZz4+PnBhdGhzKS5mb3JFYWNoKHBhdGggPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgX3A6IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPiA9IG5ldyBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4oKTtcclxuICAgICAgICAgICAgICAgIHBhdGguZm9yRWFjaCh4ID0+IF9wLnB1c2gobmV3IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uKHgubGF0aXR1ZGUsIHgubG9uZ2l0dWRlKSkpO1xyXG4gICAgICAgICAgICAgICAgcC5wdXNoKF9wKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsUGF0aCA9IDxBcnJheTxBcnJheTxJTGF0TG9uZz4+PnBhdGhzO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29uLnNldFJpbmdzKHApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NlbnRyb2lkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuTWFuYWdlTGFiZWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIGlzIGEgc2ltcGxlIGFycmF5Li4uLlxyXG4gICAgICAgICAgICB0aGlzLlNldFBhdGgoPEFycmF5PElMYXRMb25nPj5wYXRocyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZpc2libGUgLSBUcnVlIHRvIHNldCB0aGUgcG9seWdvbiB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9wb2x5Z29uLnNldE9wdGlvbnMoPE1pY3Jvc29mdC5NYXBzLklQb2x5Z29uT3B0aW9ucz57IHZpc2libGU6IHZpc2libGUgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dMYWJlbCAmJiB0aGlzLl9sYWJlbCkgeyB0aGlzLl9sYWJlbC5TZXQoJ2hpZGRlbicsICF2aXNpYmxlKTsgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25maWd1cmVzIHRoZSBsYWJlbCBmb3IgdGhlIHBvbHlnb25cclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgTWFuYWdlTGFiZWwoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuR2V0UGF0aCA9PSBudWxsIHx8IHRoaXMuR2V0UGF0aCgpLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAodGhpcy5fc2hvd0xhYmVsICYmIHRoaXMuX3RpdGxlICE9IG51bGwgJiYgdGhpcy5fdGl0bGUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG86IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLl90aXRsZSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24odGhpcy5DZW50cm9pZClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKG8ucG9zaXRpb24gPT0gbnVsbCkgeyByZXR1cm47IH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX21pblpvb20gIT09IC0xKSB7IG8ubWluWm9vbSA9IHRoaXMuX21pblpvb207IH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX21heFpvb20gIT09IC0xKSB7IG8ubWF4Wm9vbSA9IHRoaXMuX21heFpvb207IH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gbmV3IEJpbmdNYXBMYWJlbChvKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLlNldE1hcCh0aGlzLl9tYXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwuU2V0VmFsdWVzKG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsLlNldCgnaGlkZGVuJywgIXRoaXMuR2V0VmlzaWJsZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwuU2V0TWFwKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFiZWwgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uZmlndXJlcyB0aGUgdG9vbHRpcCBmb3IgdGhlIHBvbHlnb25cclxuICAgICAqIEBtZW1iZXJvZiBQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgTWFuYWdlVG9vbHRpcCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fc2hvd1Rvb2x0aXAgJiYgdGhpcy5fdGl0bGUgIT0gbnVsbCAmJiB0aGlzLl90aXRsZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgY29uc3QgbzogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX3RpdGxlLFxyXG4gICAgICAgICAgICAgICAgYWxpZ246ICdsZWZ0JyxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogbmV3IE1pY3Jvc29mdC5NYXBzLlBvaW50KDAsIDI1KSxcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2Jpc3F1ZScsXHJcbiAgICAgICAgICAgICAgICBoaWRkZW46IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgICAgICAgICBmb250Q29sb3I6ICcjMDAwMDAwJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdlaWdodDogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwID0gbmV3IEJpbmdNYXBMYWJlbChvKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0TWFwKHRoaXMuX21hcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldFZhbHVlcyhvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VPdmVyTGlzdGVuZXIgPSBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcihcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2x5Z29uLCAnbW91c2VvdmVyJywgKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBlLmxvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90b29sdGlwVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lciA9IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLCAnbW91c2Vtb3ZlJywgKG06IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwVmlzaWJsZSAmJiBtLmxvY2F0aW9uICYmIG0ucHJpbWl0aXZlID09PSB0aGlzLl9wb2x5Z29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdwb3NpdGlvbicsIG0ubG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VPdXRMaXN0ZW5lciA9IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlnb24sICdtb3VzZW91dCcsIChlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lcikgeyBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcih0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lcik7IH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCghdGhpcy5fc2hvd1Rvb2x0aXAgfHwgdGhpcy5fdGl0bGUgPT09ICcnIHx8IHRoaXMuX3RpdGxlID09IG51bGwpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU91dExpc3RlbmVyKSB7IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5yZW1vdmVIYW5kbGVyKHRoaXMuX21vdXNlT3V0TGlzdGVuZXIpOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW91c2VPdmVyTGlzdGVuZXIpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLnJlbW92ZUhhbmRsZXIodGhpcy5fbW91c2VPdmVyTGlzdGVuZXIpOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLnJlbW92ZUhhbmRsZXIodGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIpOyB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXRNYXAobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBCaW5nQ29udmVyc2lvbnMgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9iaW5nL2JpbmctY29udmVyc2lvbnMnO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uL3BvbHlsaW5lJztcclxuaW1wb3J0IHsgQmluZ01hcExhYmVsIH0gZnJvbSAnLi9iaW5nLWxhYmVsJztcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBmb3IgYSBwb2x5bGluZSBtb2RlbCBmb3IgQmluZyBNYXBzIFY4LlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmluZ1BvbHlsaW5lIGV4dGVuZHMgUG9seWxpbmUgaW1wbGVtZW50cyBQb2x5bGluZSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2lzRWRpdGFibGU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF90aXRsZTogc3RyaW5nID0gJyc7XHJcbiAgICBwcml2YXRlIF9zaG93VG9vbHRpcDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcDogQmluZ01hcExhYmVsID0gbnVsbDtcclxuICAgIHByaXZhdGUgX2hhc1Rvb2xUaXBSZWNlaXZlcjogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcFZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX21vdXNlT3Zlckxpc3RlbmVyOiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xyXG4gICAgcHJpdmF0ZSBfbW91c2VNb3ZlTGlzdGVuZXI6IE1pY3Jvc29mdC5NYXBzLklIYW5kbGVySWQ7XHJcbiAgICBwcml2YXRlIF9tb3VzZU91dExpc3RlbmVyOiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xyXG4gICAgcHJpdmF0ZSBfbWV0YWRhdGE6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9seWxpbmUgbWV0YWRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTWV0YWRhdGEoKTogTWFwPHN0cmluZywgYW55PiB7IHJldHVybiB0aGlzLl9tZXRhZGF0YTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgTmF2aXR2ZSBQb2x5bGluZSB1bmRlcmx5aW5nIHRoZSBtb2RlbFxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lIHsgcmV0dXJuIHRoaXMuX3BvbHlsaW5lOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0byBzaG93IHRoZSB0b29sdGlwXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBTaG93VG9vbHRpcCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3Nob3dUb29sdGlwOyB9XHJcbiAgICBwdWJsaWMgc2V0IFNob3dUb29sdGlwKHZhbDogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuX3Nob3dUb29sdGlwID0gdmFsO1xyXG4gICAgICAgIHRoaXMuTWFuYWdlVG9vbHRpcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB0aXRsZSBvZmYgdGhlIHBvbHlsaW5lXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBUaXRsZSgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fdGl0bGU7IH1cclxuICAgIHB1YmxpYyBzZXQgVGl0bGUodmFsOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl90aXRsZSA9IHZhbDtcclxuICAgICAgICB0aGlzLk1hbmFnZVRvb2x0aXAoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBjb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmdQb2x5Z29uLlxyXG4gICAgICogQHBhcmFtIF9wb2x5bGluZSAtIFRoZSB7QGxpbmsgTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmV9IHVuZGVybHlpbmcgdGhlIG1vZGVsLlxyXG4gICAgICogQHBhcmFtIF9tYXAgLSBUaGUgY29udGV4dCBtYXAuXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyIC0gVGhlIGNvbnRleHQgbGF5ZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BvbHlsaW5lOiBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZSwgcHJvdGVjdGVkIF9tYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCwgcHJvdGVjdGVkIF9sYXllcjogTWljcm9zb2Z0Lk1hcHMuTGF5ZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGRlbGVnYXRlIGZvciBhbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gZm4gLSBEZWxlZ2F0ZSBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBzdXBwb3J0ZWRFdmVudHMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ2RyYWcnLCAnZHJhZ2VuZCcsICdkcmFnc3RhcnQnLCAnbW91c2Vkb3duJywgJ21vdXNlb3V0JywgJ21vdXNlb3ZlcicsICdtb3VzZXVwJyBdO1xyXG4gICAgICAgIGlmIChzdXBwb3J0ZWRFdmVudHMuaW5kZXhPZihldmVudFR5cGUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9wb2x5bGluZSwgZXZlbnRUeXBlLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm4oZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnRUeXBlID09PSAnbW91c2Vtb3ZlJykge1xyXG4gICAgICAgICAgICBsZXQgaGFuZGxlcklkOiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xyXG4gICAgICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9wb2x5bGluZSwgJ21vdXNlb3ZlcicsIGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcklkID0gTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIodGhpcy5fbWFwLCAnbW91c2Vtb3ZlJywgbSA9PiBmbihtKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcih0aGlzLl9wb2x5bGluZSwgJ21vdXNlb3V0JywgZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcklkKSB7IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5yZW1vdmVIYW5kbGVyKGhhbmRsZXJJZCk7IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlZCB0aGUgcG9seWxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXllcikgeyB0aGlzLl9sYXllci5yZW1vdmUodGhpcy5OYXRpdmVQcmltaXR2ZSk7IH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwLmVudGl0aWVzLnJlbW92ZSh0aGlzLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXApIHsgdGhpcy5fdG9vbHRpcC5EZWxldGUoKTsgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyBkcmFnZ2FibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5bGluZSBpcyBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldERyYWdnYWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gQmluZyBwb2x5Z29ucyBhcmUgbm90IGRyYWdnYWJsZSBieSBkZWZhdWx0LlxyXG4gICAgICAgIC8vLyBTZWUgaHR0cHM6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9lbi1VUy9cclxuICAgICAgICAvLy8gICAgIDdhYWFlNzQ4LTRkNWYtNGJlNS1hN2JiLTkwNDk4ZTA4YjQxYy9ob3ctY2FuLWktbWFrZS1wb2x5Z29ucG9seWxpbmUtZHJhZ2dhYmxlLWluLWJpbmctbWFwcy04XHJcbiAgICAgICAgLy8vICAgICA/Zm9ydW09YmluZ21hcHNcclxuICAgICAgICAvLy8gZm9yIGEgcG9zc2libGUgYXBwcm9hY2ggdG8gYmUgaW1wbGVtZW50ZWQgaW4gdGhlIG1vZGVsLlxyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWxpbmUgcGF0aCBjYW4gYmUgZWRpdGVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcGF0aCBjYW4gYmUgZWRpdGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0RWRpdGFibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRWRpdGFibGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb2x5bGluZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gQXJyYXkgb2Yge0BsaW5rIElMYXRMb25nfSBvYmplY3RzIGRlc2NyaWJpbmcgdGhlIHBvbHlsaW5lIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0UGF0aCgpOiBBcnJheTxJTGF0TG9uZz4ge1xyXG4gICAgICAgIGNvbnN0IHA6IEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPiA9IHRoaXMuX3BvbHlsaW5lLmdldExvY2F0aW9ucygpO1xyXG4gICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PElMYXRMb25nPiA9IG5ldyBBcnJheTxJTGF0TG9uZz4oKTtcclxuICAgICAgICBwLmZvckVhY2gobCA9PiBwYXRoLnB1c2goeyBsYXRpdHVkZTogbC5sYXRpdHVkZSwgbG9uZ2l0dWRlOiBsLmxvbmdpdHVkZSB9KSk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIGlzIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5bGluZSBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0VmlzaWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWxpbmUuZ2V0VmlzaWJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyBkcmFnYWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZHJhZ2dhYmxlIC0gVHJ1ZSB0byBtYWtlIHRoZSBwb2x5bGluZSBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gQmluZyBwb2x5Z29ucyBhcmUgbm90IGRyYWdnYWJsZSBieSBkZWZhdWx0LlxyXG4gICAgICAgIC8vLyBTZWUgaHR0cHM6Ly9zb2NpYWwubXNkbi5taWNyb3NvZnQuY29tL0ZvcnVtcy9lbi1VUy9cclxuICAgICAgICAvLy8gICAgIDdhYWFlNzQ4LTRkNWYtNGJlNS1hN2JiLTkwNDk4ZTA4YjQxYy9ob3ctY2FuLWktbWFrZS1wb2x5Z29ucG9seWxpbmUtZHJhZ2dhYmxlLWluLWJpbmctbWFwcy04XHJcbiAgICAgICAgLy8vICAgICA/Zm9ydW09YmluZ21hcHNcclxuICAgICAgICAvLy8gZm9yIGEgcG9zc2libGUgYXBwcm9hY2ggdG8gYmUgaW1wbGVtZW50ZWQgaW4gdGhlIG1vZGVsLlxyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIHRocm93KG5ldyBFcnJvcignVGhlIGJpbmcgbWFwcyBpbXBsZW1lbnRhdGlvbiBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBkcmFnZ2FibGUgcG9seWxpbmVzLicpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2V0aGVyIHRoZSBwb2x5bGluZSBwYXRoIGlzIGVkaXRhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlZGl0YWJsZSAtIFRydWUgdG8gbWFrZSBwb2x5bGluZSBwYXRoIGVkaXRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0RWRpdGFibGUoZWRpdGFibGU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9pc0VkaXRhYmxlID0gZWRpdGFibGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb2x5bGluZSBvcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSUxhdExvbmd9IG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zLiBUaGUgb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggaHRlIG9uZXNcclxuICAgICAqIGFscmVhZHkgb24gdGhlIHVuZGVybHlpbmcgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhvcHRpb25zOiBJUG9seWxpbmVPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVBvbHlsaW5lT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5bGluZU9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fcG9seWxpbmUuc2V0T3B0aW9ucyhvKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5wYXRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuU2V0UGF0aCg8QXJyYXk8SUxhdExvbmc+Pm9wdGlvbnMucGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9seWxpbmUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIEFuIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ30gKG9yIGFycmF5IG9mIGFycmF5cykgZGVzY3JpYmluZyB0aGUgcG9seWxpbmVzIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0UGF0aChwYXRoOiBBcnJheTxJTGF0TG9uZz4pOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBwOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4gPSBuZXcgQXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+KCk7XHJcbiAgICAgICAgcGF0aC5mb3JFYWNoKHggPT4gcC5wdXNoKG5ldyBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbih4LmxhdGl0dWRlLCB4LmxvbmdpdHVkZSkpKTtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZS5zZXRMb2NhdGlvbnMocCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIGlzIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZpc2libGUgLSBUcnVlIHRvIHNldCB0aGUgcG9seWxpbmUgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lLnNldE9wdGlvbnMoPE1pY3Jvc29mdC5NYXBzLklQb2x5bGluZU9wdGlvbnM+eyB2aXNpYmxlOiB2aXNpYmxlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25maWd1cmVzIHRoZSB0b29sdGlwIGZvciB0aGUgcG9seWdvblxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBNYW5hZ2VUb29sdGlwKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9zaG93VG9vbHRpcCAmJiB0aGlzLl90aXRsZSAhPSBudWxsICYmIHRoaXMuX3RpdGxlICE9PSAnJykge1xyXG4gICAgICAgICAgICBjb25zdCBvOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fdGl0bGUsXHJcbiAgICAgICAgICAgICAgICBhbGlnbjogJ2xlZnQnLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9pbnQoMCwgMjUpLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnYmlzcXVlJyxcclxuICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMixcclxuICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogJyMwMDAwMDAnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAgPSBuZXcgQmluZ01hcExhYmVsKG8pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXRNYXAodGhpcy5fbWFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0VmFsdWVzKG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZU92ZXJMaXN0ZW5lciA9IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2x5bGluZSwgJ21vdXNlb3ZlcicsIChlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBlLmxvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdoaWRkZW4nLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyID0gTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAsICdtb3VzZW1vdmUnLCAoZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBWaXNpYmxlICYmIGUubG9jYXRpb24gJiYgZS5wcmltaXRpdmUgPT09IHRoaXMuX3BvbHlsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdwb3NpdGlvbicsIGUubG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VPdXRMaXN0ZW5lciA9IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9seWxpbmUsICdtb3VzZW91dCcsIChlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKCF0aGlzLl9zaG93VG9vbHRpcCB8fCB0aGlzLl90aXRsZSA9PT0gJycgfHwgdGhpcy5fdGl0bGUgPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlT3V0TGlzdGVuZXIpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLnJlbW92ZUhhbmRsZXIodGhpcy5fbW91c2VPdXRMaXN0ZW5lcikgOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW91c2VPdmVyTGlzdGVuZXIpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLnJlbW92ZUhhbmRsZXIodGhpcy5fbW91c2VPdmVyTGlzdGVuZXIpOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIpIHsgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLnJlbW92ZUhhbmRsZXIodGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIpOyB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXRNYXAobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJTWFwRXZlbnRMb29rdXAgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXAtZXZlbnQtbG9va3VwJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNvbnRzdGFudCB0cmFuc2xhdGVzIHRoZSBhYnN0cmFjdCBtYXAgZXZlbnRzIGludG8gdGhlaXIgY29ycmVzcG9uZGluZyBiaW5nIG1hcFxyXG4gKiBlcXVpdmFsZW50cy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBCaW5nTWFwRXZlbnRzTG9va3VwOiBJTWFwRXZlbnRMb29rdXAgPSB7XHJcbiAgICBjbGljayA6ICAgICAgICAgICAgICdjbGljaycsXHJcbiAgICBkYmxjbGljayA6ICAgICAgICAgICdkYmxjbGljaycsXHJcbiAgICByaWdodGNsaWNrIDogICAgICAgICdyaWdodGNsaWNrJyxcclxuICAgIHJlc2l6ZSA6ICAgICAgICAgICAgJ3Jlc2l6ZScsXHJcbiAgICBib3VuZHNjaGFuZ2VkIDogICAgICd2aWV3Y2hhbmdlZW5kJyxcclxuICAgIGNlbnRlcmNoYW5nZWQgOiAgICAgJ3ZpZXdjaGFuZ2VlbmQnLFxyXG4gICAgem9vbWNoYW5nZWQgOiAgICAgICAndmlld2NoYW5nZWVuZCcsXHJcbiAgICBtb3VzZW92ZXI6ICAgICAgICAgICdtb3VzZW92ZXInLFxyXG4gICAgbW91c2VvdXQgOiAgICAgICAgICAnbW91c2VvdXQnLFxyXG4gICAgbW91c2Vtb3ZlIDogICAgICAgICAnbW91c2Vtb3ZlJyxcclxuICAgIGluZm93aW5kb3djbG9zZTogICAgJ2luZm9ib3hDaGFuZ2VkJ1xyXG59O1xyXG4iLCJpbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBCaW5nQ29udmVyc2lvbnMgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9iaW5nL2JpbmctY29udmVyc2lvbnMnO1xyXG5pbXBvcnQgeyBDYW52YXNPdmVybGF5IH0gZnJvbSAnLi4vY2FudmFzLW92ZXJsYXknO1xyXG5pbXBvcnQgeyBNYXBMYWJlbCB9IGZyb20gJy4uL21hcC1sYWJlbCc7XHJcbmltcG9ydCB7IEJpbmdNYXBMYWJlbCB9IGZyb20gJy4vYmluZy1sYWJlbCc7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50aW5nIGEgY2FudmFzIG92ZXJsYXkgdG8gYmUgcGxhY2VkIG9uIHRoZSBtYXAgZm9yIEJpbmcgTWFwcy5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJpbmdDYW52YXNPdmVybGF5IGV4dGVuZHMgQ2FudmFzT3ZlcmxheSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gZmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX3ZpZXdDaGFuZ2VFdmVudDogTWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZDtcclxuICAgIHByaXZhdGUgX3ZpZXdDaGFuZ2VFbmRFdmVudDogTWljcm9zb2Z0Lk1hcHMuSUhhbmRsZXJJZDtcclxuICAgIHByaXZhdGUgX21hcFJlc2l6ZUV2ZW50OiBNaWNyb3NvZnQuTWFwcy5JSGFuZGxlcklkO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEJpbmdDYW52YXNPdmVybGF5IGNsYXNzLlxyXG4gICAgICogQHBhcmFtIGRyYXdDYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNhbnZhcyBpcyByZWFkeSB0byBiZVxyXG4gICAgICogcmVuZGVyZWQgZm9yIHRoZSBjdXJyZW50IG1hcCB2aWV3LlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDYW52YXNPdmVybGF5XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGRyYXdDYWxsYmFjazogKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpID0+IHZvaWQpIHtcclxuICAgICAgICBzdXBlcihkcmF3Q2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgZ2VvIGNvb3JkaW5hdGVzIGZvciB0aGUgY2xpY2sgbG9jYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBlIC0gVGhlIG1vdXNlIGV2ZW50LiBFeHBlY3RlZCB0byBpbXBsZW1lbnQge0BsaW5rIE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJnc30uXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIG1hcmtlci5cclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2FudmFzT3ZlcmxheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZTogTWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzKTogSUxhdExvbmcge1xyXG4gICAgICAgIHJldHVybiB7IGxhdGl0dWRlOiBlLmxvY2F0aW9uLmxhdGl0dWRlLCBsb25naXR1ZGU6IGUubG9jYXRpb24ubG9uZ2l0dWRlIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXAgYXNzb2NpdGVkIHdpdGggdGhlIGxhYmVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TWFwKCk6IE1pY3Jvc29mdC5NYXBzLk1hcCB7XHJcbiAgICAgICAgcmV0dXJuICg8YW55PnRoaXMpLmdldE1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIE1hcExhYmVsIGluc3RhbmNlIGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgdG9vbHRpcC5cclxuICAgICAqIFRoaXMgbWV0aG9kIG9ubHkgZ2VuZXJhdGVzIHRoZSBtYXAgbGFiZWwuIENvbnRlbnQgYW5kIHBsYWNlbWVudCBpcyB0aGUgcmVzcG9uc2liaWxpdHlcclxuICAgICAqIG9mIHRoZSBjYWxsZXIuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCByZXR1cm5zIG51bGwgdW50aWwgT25Mb2FkIGhhcyBiZWVuIGNhbGxlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBsYWJlbCB0byBiZSB1c2VkIGZvciB0aGUgdG9vbHRpcC5cclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0VG9vbFRpcE92ZXJsYXkoKTogTWFwTGFiZWwge1xyXG4gICAgICAgIGNvbnN0IG86IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7XHJcbiAgICAgICAgICAgIGFsaWduOiAnbGVmdCcsXHJcbiAgICAgICAgICAgIG9mZnNldDogbmV3IE1pY3Jvc29mdC5NYXBzLlBvaW50KDAsIDI1KSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnYmlzcXVlJyxcclxuICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgICAgIGZvbnRDb2xvcjogJyMwMDAwMDAnLFxyXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDBcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGxhYmVsOiBNYXBMYWJlbCA9IG5ldyBCaW5nTWFwTGFiZWwobyk7XHJcbiAgICAgICAgbGFiZWwuU2V0TWFwKHRoaXMuR2V0TWFwKCkpO1xyXG4gICAgICAgIHJldHVybiBsYWJlbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbnZhc092ZXJsYXkgbG9hZGVkLCBhdHRhY2ggbWFwIGV2ZW50cyBmb3IgdXBkYXRpbmcgY2FudmFzLlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NhbnZhc092ZXJsYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIE9uTG9hZCgpIHtcclxuICAgICAgICBjb25zdCBtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCA9ICg8YW55PnRoaXMpLmdldE1hcCgpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgdGhpcy5fem9vbVN0YXJ0ID0gbWFwLmdldFpvb20oKTtcclxuICAgICAgICB0aGlzLl9jZW50ZXJTdGFydCA9IDxJTGF0TG9uZz5tYXAuZ2V0Q2VudGVyKCk7XHJcblxyXG4gICAgICAgIC8vIFJlZHJhdyB0aGUgY2FudmFzLlxyXG4gICAgICAgIHRoaXMuUmVkcmF3KHRydWUpO1xyXG5cclxuICAgICAgICAvLyBXaGVuIHRoZSBtYXAgbW92ZXMsIG1vdmUgdGhlIGNhbnZhcyBhY2NvcmRpbmdseS5cclxuICAgICAgICB0aGlzLl92aWV3Q2hhbmdlRXZlbnQgPSBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcihtYXAsICd2aWV3Y2hhbmdlJywgKGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKG1hcC5nZXRNYXBUeXBlSWQoKSA9PT0gTWljcm9zb2Z0Lk1hcHMuTWFwVHlwZUlkLnN0cmVldHNpZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIERvbid0IHNob3cgdGhlIGNhbnZhcyBpZiB0aGUgbWFwIGlzIGluIFN0cmVldHNpZGUgbW9kZS5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUmUtZHJhd2luZyB0aGUgY2FudmFzIGFzIGl0IG1vdmVzIHdvdWxkIGJlIHRvbyBzbG93LiBJbnN0ZWFkLCBzY2FsZSBhbmQgdHJhbnNsYXRlIGNhbnZhcyBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgY29uc3Qgem9vbUN1cnJlbnQ6IG51bWJlciA9IG1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJDdXJyZW50OiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IG1hcC5nZXRDZW50ZXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgbWFwIHNjYWxlIGJhc2VkIG9uIHpvb20gbGV2ZWwgZGlmZmVyZW5jZS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlOiBudW1iZXIgPSBNYXRoLnBvdygyLCB6b29tQ3VycmVudCAtIHRoaXMuX3pvb21TdGFydCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzY2FsZWQgZGltZW5zaW9ucyBvZiB0aGUgY2FudmFzLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3V2lkdGg6IG51bWJlciA9IG1hcC5nZXRXaWR0aCgpICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdIZWlnaHQ6IG51bWJlciA9IG1hcC5nZXRIZWlnaHQoKSAqIHNjYWxlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBvZmZzZXQgb2YgY2FudmFzIGJhc2VkIG9uIHpvb20gYW5kIGNlbnRlciBvZmZzZXRzLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxQb2ludHM6IEFycmF5PE1pY3Jvc29mdC5NYXBzLlBvaW50PiA9IDxBcnJheTxNaWNyb3NvZnQuTWFwcy5Qb2ludD4+bWFwLnRyeUxvY2F0aW9uVG9QaXhlbChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbih0aGlzLl9jZW50ZXJTdGFydCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlckN1cnJlbnRcclxuICAgICAgICAgICAgICAgICAgICBdLCBNaWNyb3NvZnQuTWFwcy5QaXhlbFJlZmVyZW5jZS5jb250cm9sKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlck9mZnNldFg6IG51bWJlciA9IHBpeGVsUG9pbnRzWzFdLnggLSBwaXhlbFBvaW50c1swXS54O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VudGVyT2Zmc2V0WTogbnVtYmVyID0gcGl4ZWxQb2ludHNbMV0ueSAtIHBpeGVsUG9pbnRzWzBdLnk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4OiBudW1iZXIgPSAoLShuZXdXaWR0aCAtIG1hcC5nZXRXaWR0aCgpKSAvIDIpIC0gY2VudGVyT2Zmc2V0WDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHk6IG51bWJlciA9ICgtKG5ld0hlaWdodCAtIG1hcC5nZXRIZWlnaHQoKSkgLyAyKSAtIGNlbnRlck9mZnNldFk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjYW52YXMgQ1NTIHBvc2l0aW9uIGFuZCBkaW1lbnNpb25zLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5VcGRhdGVQb3NpdGlvbih4LCB5LCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBXaGVuIHRoZSBtYXAgc3RvcHMgbW92aW5nLCByZW5kZXIgbmV3IGRhdGEgb24gdGhlIGNhbnZhcy5cclxuICAgICAgICB0aGlzLl92aWV3Q2hhbmdlRW5kRXZlbnQgPSBNaWNyb3NvZnQuTWFwcy5FdmVudHMuYWRkSGFuZGxlcihtYXAsICd2aWV3Y2hhbmdlZW5kJywgKGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5VcGRhdGVDYW52YXMoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheSB3aGVuIHRoZSBtYXAgaXMgcmVzaXplZC5cclxuICAgICAgICB0aGlzLl9tYXBSZXNpemVFdmVudCA9IE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKG1hcCwgJ21hcHJlc2l6ZScsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuVXBkYXRlQ2FudmFzKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIHNldCB0aGUgb3ZlcmxheSB0byByZWFkeSBzdGF0ZVxyXG4gICAgICAgIHRoaXMuX3JlYWR5UmVzb2x2ZXIodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXAgZm9yIHRoZSBsYWJlbC4gU2V0dGluZ3MgdGhpcyB0byBudWxsIHJlbW92ZSB0aGUgbGFiZWwgZnJvbSBodGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSBNYXAgdG8gYXNzb2NpYXRlZCB3aXRoIHRoZSBsYWJlbC5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRNYXAobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBtOiBNaWNyb3NvZnQuTWFwcy5NYXAgPSB0aGlzLkdldE1hcCgpO1xyXG4gICAgICAgIGlmIChtYXAgPT09IG0pIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgaWYgKG0pIHtcclxuICAgICAgICAgICAgbS5sYXllcnMucmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWFwICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbWFwLmxheWVycy5pbnNlcnQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3RlY3RlZCBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIHRoZSBjYW52YXMgdG8gdGhlIG1hcC5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBTZXRDYW52YXNFbGVtZW50KGVsOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgICg8YW55PnRoaXMpLnNldEh0bWxFbGVtZW50KGVsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSB0aGUgbWFwIGV2ZW50IGhhbmRsZXJzLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIFJlbW92ZUV2ZW50SGFuZGxlcnMoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBldmVudCBoYW5kbGVycyBmcm9tIHRoZSBtYXAuXHJcbiAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLnJlbW92ZUhhbmRsZXIodGhpcy5fdmlld0NoYW5nZUV2ZW50KTtcclxuICAgICAgICBNaWNyb3NvZnQuTWFwcy5FdmVudHMucmVtb3ZlSGFuZGxlcih0aGlzLl92aWV3Q2hhbmdlRW5kRXZlbnQpO1xyXG4gICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5yZW1vdmVIYW5kbGVyKHRoaXMuX21hcFJlc2l6ZUV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIENhbnZhcyBzaXplIGJhc2VkIG9uIHRoZSBtYXAgc2l6ZS5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBSZXNpemUoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbWFwOiBNaWNyb3NvZnQuTWFwcy5NYXAgPSAoPGFueT50aGlzKS5nZXRNYXAoKTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgY2FudmFzIGJ5IHVwZGF0aW5nIGRpbWVuc2lvbnMuIFRoaXMgYWxzbyBlbnN1cmVzIGNhbnZhcyBzdGF5cyB0aGUgc2FtZSBzaXplIGFzIHRoZSBtYXAuXHJcbiAgICAgICAgdGhpcy5fY2FudmFzLndpZHRoID0gbWFwLmdldFdpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IG1hcC5nZXRIZWlnaHQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIENhbnZhcy5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNPdmVybGF5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBVcGRhdGVDYW52YXMoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbWFwOiBNaWNyb3NvZnQuTWFwcy5NYXAgPSAoPGFueT50aGlzKS5nZXRNYXAoKTtcclxuXHJcbiAgICAgICAgLy8gT25seSByZW5kZXIgdGhlIGNhbnZhcyBpZiBpdCBpc24ndCBpbiBzdHJlZXRzaWRlIG1vZGUuXHJcbiAgICAgICAgaWYgKG1hcC5nZXRNYXBUeXBlSWQoKSAhPT0gTWljcm9zb2Z0Lk1hcHMuTWFwVHlwZUlkLnN0cmVldHNpZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuXHJcbiAgICAgICAgICAgIC8vIFJlc2V0IENTUyBwb3NpdGlvbiBhbmQgZGltZW5zaW9ucyBvZiBjYW52YXMuXHJcbiAgICAgICAgICAgIHRoaXMuVXBkYXRlUG9zaXRpb24oMCwgMCwgbWFwLmdldFdpZHRoKCksIG1hcC5nZXRIZWlnaHQoKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWRyYXcgdGhlIGNhbnZhcy5cclxuICAgICAgICAgICAgdGhpcy5SZWRyYXcodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgIHRoaXMuX3pvb21TdGFydCA9IG1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NlbnRlclN0YXJ0ID0gPElMYXRMb25nPm1hcC5nZXRDZW50ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZXh0ZW5kIHRoZSBPdmVybGF5VmlldyBpbnRvIHRoZSBDYW52YXNPdmVybGF5XHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQG1ldGhvZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE1peGluQ2FudmFzT3ZlcmxheSgpIHtcclxuICAgIGNvbnN0IHggPSBCaW5nQ2FudmFzT3ZlcmxheS5wcm90b3R5cGU7XHJcbiAgICBCaW5nQ2FudmFzT3ZlcmxheS5wcm90b3R5cGUgPSA8YW55PiBuZXcgTWljcm9zb2Z0Lk1hcHMuQ3VzdG9tT3ZlcmxheSgpO1xyXG4gICAgZm9yIChjb25zdCB5IGluIHgpIHsgaWYgKCg8YW55PngpW3ldICE9IG51bGwpIHsgKDxhbnk+QmluZ0NhbnZhc092ZXJsYXkucHJvdG90eXBlKVt5XSA9ICg8YW55PngpW3ldOyB9fVxyXG4gICAgKDxhbnk+QmluZ0NhbnZhc092ZXJsYXkucHJvdG90eXBlKVsnb25BZGQnXSA9IHhbJ09uQWRkJ107XHJcbiAgICAoPGFueT5CaW5nQ2FudmFzT3ZlcmxheS5wcm90b3R5cGUpWydvbkxvYWQnXSA9IHhbJ09uTG9hZCddO1xyXG4gICAgKDxhbnk+QmluZ0NhbnZhc092ZXJsYXkucHJvdG90eXBlKVsnb25SZW1vdmUnXSA9IHhbJ09uUmVtb3ZlJ107XHJcbn1cclxuIiwiZXhwb3J0IGxldCBnb29nbGU6IGFueTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR29vZ2xlTWFwIGV4dGVuZHMgTVZDT2JqZWN0IHtcclxuICBkYXRhPzogRGF0YTtcclxuICBjb25zdHJ1Y3RvcihlbDogSFRNTEVsZW1lbnQsIG9wdHM/OiBNYXBPcHRpb25zKTogdm9pZDtcclxuICBwYW5UbyhsYXRMbmc6IExhdExuZ3xMYXRMbmdMaXRlcmFsKTogdm9pZDtcclxuICBzZXRab29tKHpvb206IG51bWJlcik6IHZvaWQ7XHJcbiAgZ2V0Q2VudGVyKCk6IExhdExuZztcclxuICBzZXRDZW50ZXIobGF0TG5nOiBMYXRMbmd8TGF0TG5nTGl0ZXJhbCk6IHZvaWQ7XHJcbiAgZ2V0Qm91bmRzKCk6IExhdExuZ0JvdW5kcztcclxuICBnZXRab29tKCk6IG51bWJlcjtcclxuICBnZXREaXYoKTogSFRNTERpdkVsZW1lbnQ7XHJcbiAgZ2V0UHJvamVjdGlvbigpOiBhbnk7XHJcbiAgc2V0T3B0aW9ucyhvcHRpb25zOiBNYXBPcHRpb25zKTogdm9pZDtcclxuICBwYW5Ub0JvdW5kcyhsYXRMbmdCb3VuZHM6IExhdExuZ0JvdW5kc3xMYXRMbmdCb3VuZHNMaXRlcmFsKTogdm9pZDtcclxuICBmaXRCb3VuZHMoYm91bmRzOiBMYXRMbmdCb3VuZHN8TGF0TG5nQm91bmRzTGl0ZXJhbCk6IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTGF0TG5nIHtcclxuICBjb25zdHJ1Y3RvcihsYXQ6IG51bWJlciwgbG5nOiBudW1iZXIpOiB2b2lkO1xyXG4gIGxhdCgpOiBudW1iZXI7XHJcbiAgbG5nKCk6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNYXJrZXIgZXh0ZW5kcyBNVkNPYmplY3Qge1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBNYXJrZXJPcHRpb25zKTogdm9pZDtcclxuICBzZXRNYXAobWFwOiBHb29nbGVNYXApOiB2b2lkO1xyXG4gIHNldFBvc2l0aW9uKGxhdExuZzogTGF0TG5nfExhdExuZ0xpdGVyYWwpOiB2b2lkO1xyXG4gIHNldFRpdGxlKHRpdGxlOiBzdHJpbmcpOiB2b2lkO1xyXG4gIHNldExhYmVsKGxhYmVsOiBzdHJpbmd8TWFya2VyTGFiZWwpOiB2b2lkO1xyXG4gIHNldFBvc2l0aW9uKGxhdGxuZzogTGF0TG5nfExhdExuZ0xpdGVyYWwpOiB2b2lkO1xyXG4gIHNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkO1xyXG4gIHNldEljb24oaWNvbjogc3RyaW5nKTogdm9pZDtcclxuICBzZXRPcGFjaXR5KG9wYWNpdHk6IG51bWJlcik6IHZvaWQ7XHJcbiAgc2V0T3B0aW9ucyhvcHRpb25zOiBNYXJrZXJPcHRpb25zKTogdm9pZDtcclxuICBzZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkO1xyXG4gIHNldFpJbmRleCh6SW5kZXg6IG51bWJlcik6IHZvaWQ7XHJcbiAgZ2V0TGFiZWwoKTogTWFya2VyTGFiZWw7XHJcbiAgZ2V0UG9zaXRpb24oKTogTGF0TG5nO1xyXG4gIGdldFZpc2libGUoKTogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNYXJrZXJPcHRpb25zIHtcclxuICBwb3NpdGlvbjogTGF0TG5nfExhdExuZ0xpdGVyYWw7XHJcbiAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgbWFwPzogR29vZ2xlTWFwO1xyXG4gIGxhYmVsPzogc3RyaW5nfE1hcmtlckxhYmVsO1xyXG4gIGRyYWdnYWJsZT86IGJvb2xlYW47XHJcbiAgY2xpY2thYmxlPzogYm9vbGVhbjtcclxuICBpY29uPzogc3RyaW5nO1xyXG4gIG9wYWNpdHk/OiBudW1iZXI7XHJcbiAgdmlzaWJsZT86IGJvb2xlYW47XHJcbiAgekluZGV4PzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1hcmtlckxhYmVsIHtcclxuICBjb2xvcjogc3RyaW5nO1xyXG4gIGZvbnRGYW1pbHk6IHN0cmluZztcclxuICBmb250U2l6ZTogc3RyaW5nO1xyXG4gIGZvbnRXZWlnaHQ6IHN0cmluZztcclxuICB0ZXh0OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2x1c3RlclN0eWxlIHtcclxuICB1cmw/OiBzdHJpbmc7XHJcbiAgaGVpZ2h0PzogbnVtYmVyO1xyXG4gIHdpZHRoPzogbnVtYmVyO1xyXG4gIGFuY2hvcj86IEFycmF5PG51bWJlcj47XHJcbiAgdGV4dENvbG9yPzogc3RyaW5nO1xyXG4gIHRleHRTaXplPzogbnVtYmVyO1xyXG4gIGJhY2tncm91bmRQb3NpdGlvbj86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNYXJrZXJDbHVzdGVyZXIge1xyXG4gIGlzWm9vbU9uQ2xpY2soKTogYm9vbGVhbjtcclxuICBpc0F2ZXJhZ2VDZW50ZXIoKTogYm9vbGVhbjtcclxuICBnZXRNYXJrZXJzKCk6IEFycmF5PE1hcmtlcj47XHJcbiAgZ2V0VG90YWxNYXJrZXJzKCk6IG51bWJlcjtcclxuICBzZXRNYXhab29tKG1heFpvb206IG51bWJlcik6IHZvaWQ7XHJcbiAgZ2V0TWF4Wm9vbSgpOiBudW1iZXI7XHJcbiAgYWRkTWFya2VycyhtYXJrZXJzOiBBcnJheTxNYXJrZXI+LCBvcHRfbm9kcmF3PzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgYWRkTWFya2VyKG1hcmtlcjogTWFya2VyLCBvcHRfbm9kcmF3PzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgcmVtb3ZlTWFya2VycyhtYXJrZXJzOiBBcnJheTxNYXJrZXI+LCBvcHRfbm9kcmF3PzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgcmVtb3ZlTWFya2VyKG1hcmtlcjogTWFya2VyLCBvcHRfbm9kcmF3PzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgZ2V0VG90YWxDbHVzdGVycygpOiBudW1iZXI7XHJcbiAgZ2V0TWFwKCk6IEdvb2dsZU1hcDtcclxuICBzZXRNYXAobWFwOiBHb29nbGVNYXApOiB2b2lkO1xyXG4gIGdldEdyaWRTaXplKCk6IG51bWJlcjtcclxuICBzZXRHcmlkU2l6ZShncmlkU2l6ZTogbnVtYmVyKTogdm9pZDtcclxuICBnZXRNaW5DbHVzdGVyU2l6ZSgpOiBudW1iZXI7XHJcbiAgc2V0TWluQ2x1c3RlclNpemUobWluQ2x1c3RlclNpemU6IG51bWJlcik6IHZvaWQ7XHJcbiAgY2xlYXJNYXJrZXJzKCk6IHZvaWQ7XHJcbiAgc2V0U3R5bGVzKHN0eWxlczogQXJyYXk8Q2x1c3RlclN0eWxlPik6IHZvaWQ7XHJcbiAgZ2V0U3R5bGVzKCk6IEFycmF5PENsdXN0ZXJTdHlsZT47XHJcbiAgc2V0Q2FsY3VsYXRvcihjYWxsYmFjazogKG1hcmtlcnM6IEFycmF5PE1hcmtlcj4sIG51bVN0eWxlczogbnVtYmVyKSA9PiB7IHRleHQ6IHN0cmluZywgaW5kZXg6IG51bWJlcn0pOiB2b2lkO1xyXG4gIGdldENhbGN1bGF0b3IoKTogKG1hcmtlcnM6IEFycmF5PE1hcmtlcj4sIG51bVN0eWxlczogbnVtYmVyKSA9PiB7IHRleHQ6IHN0cmluZywgaW5kZXg6IG51bWJlcn07XHJcbiAgcmVzZXRWaWV3cG9ydChoaWRlPzogYm9vbGVhbik6IHZvaWQ7XHJcbiAgcmVkcmF3KCk6IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2lyY2xlIGV4dGVuZHMgTVZDT2JqZWN0IHtcclxuICBnZXRCb3VuZHMoKTogTGF0TG5nQm91bmRzO1xyXG4gIGdldENlbnRlcigpOiBMYXRMbmc7XHJcbiAgZ2V0RHJhZ2dhYmxlKCk6IGJvb2xlYW47XHJcbiAgZ2V0RWRpdGFibGUoKTogYm9vbGVhbjtcclxuICBnZXRNYXAoKTogR29vZ2xlTWFwO1xyXG4gIGdldFJhZGl1cygpOiBudW1iZXI7XHJcbiAgZ2V0VmlzaWJsZSgpOiBib29sZWFuO1xyXG4gIHNldENlbnRlcihjZW50ZXI6IExhdExuZ3xMYXRMbmdMaXRlcmFsKTogdm9pZDtcclxuICBzZXREcmFnZ2FibGUoZHJhZ2dhYmxlOiBib29sZWFuKTogdm9pZDtcclxuICBzZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbik6IHZvaWQ7XHJcbiAgc2V0TWFwKG1hcDogR29vZ2xlTWFwKTogdm9pZDtcclxuICBzZXRPcHRpb25zKG9wdGlvbnM6IENpcmNsZU9wdGlvbnMpOiB2b2lkO1xyXG4gIHNldFJhZGl1cyhyYWRpdXM6IG51bWJlcik6IHZvaWQ7XHJcbiAgc2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDaXJjbGVPcHRpb25zIHtcclxuICBjZW50ZXI/OiBMYXRMbmd8TGF0TG5nTGl0ZXJhbDtcclxuICBjbGlja2FibGU/OiBib29sZWFuO1xyXG4gIGRyYWdnYWJsZT86IGJvb2xlYW47XHJcbiAgZWRpdGFibGU/OiBib29sZWFuO1xyXG4gIGZpbGxDb2xvcj86IHN0cmluZztcclxuICBmaWxsT3BhY2l0eT86IG51bWJlcjtcclxuICBtYXA/OiBHb29nbGVNYXA7XHJcbiAgcmFkaXVzPzogbnVtYmVyO1xyXG4gIHN0cm9rZUNvbG9yPzogc3RyaW5nO1xyXG4gIHN0cm9rZU9wYWNpdHk/OiBudW1iZXI7XHJcbiAgc3Ryb2tlUG9zaXRpb24/OiAnQ0VOVEVSJ3wnSU5TSURFJ3wnT1VUU0lERSc7XHJcbiAgc3Ryb2tlV2VpZ2h0PzogbnVtYmVyO1xyXG4gIHZpc2libGU/OiBib29sZWFuO1xyXG4gIHpJbmRleD86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMYXRMbmdCb3VuZHMge1xyXG4gIGNvbnRhaW5zKGxhdExuZzogTGF0TG5nKTogYm9vbGVhbjtcclxuICBlcXVhbHMob3RoZXI6IExhdExuZ0JvdW5kc3xMYXRMbmdCb3VuZHNMaXRlcmFsKTogYm9vbGVhbjtcclxuICBleHRlbmQocG9pbnQ6IExhdExuZyk6IHZvaWQ7XHJcbiAgZ2V0Q2VudGVyKCk6IExhdExuZztcclxuICBnZXROb3J0aEVhc3QoKTogTGF0TG5nO1xyXG4gIGdldFNvdXRoV2VzdCgpOiBMYXRMbmc7XHJcbiAgaW50ZXJzZWN0cyhvdGhlcjogTGF0TG5nQm91bmRzfExhdExuZ0JvdW5kc0xpdGVyYWwpOiBib29sZWFuO1xyXG4gIGlzRW1wdHkoKTogYm9vbGVhbjtcclxuICB0b0pTT04oKTogTGF0TG5nQm91bmRzTGl0ZXJhbDtcclxuICB0b1NwYW4oKTogTGF0TG5nO1xyXG4gIHRvU3RyaW5nKCk6IHN0cmluZztcclxuICB0b1VybFZhbHVlKHByZWNpc2lvbj86IG51bWJlcik6IHN0cmluZztcclxuICB1bmlvbihvdGhlcjogTGF0TG5nQm91bmRzfExhdExuZ0JvdW5kc0xpdGVyYWwpOiBMYXRMbmdCb3VuZHM7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTGF0TG5nQm91bmRzTGl0ZXJhbCB7XHJcbiAgZWFzdDogbnVtYmVyO1xyXG4gIG5vcnRoOiBudW1iZXI7XHJcbiAgc291dGg6IG51bWJlcjtcclxuICB3ZXN0OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTGF0TG5nTGl0ZXJhbCB7XHJcbiAgbGF0OiBudW1iZXI7XHJcbiAgbG5nOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTW91c2VFdmVudCB7IGxhdExuZzogTGF0TG5nOyB9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1hcE9wdGlvbnMge1xyXG4gIGNlbnRlcj86IExhdExuZ3xMYXRMbmdMaXRlcmFsO1xyXG4gIHpvb20/OiBudW1iZXI7XHJcbiAgbWluWm9vbT86IG51bWJlcjtcclxuICBtYXhab29tPzogbnVtYmVyO1xyXG4gIGRpc2FibGVEb3VibGVDbGlja1pvb20/OiBib29sZWFuO1xyXG4gIGRpc2FibGVEZWZhdWx0VUk/OiBib29sZWFuO1xyXG4gIHNjcm9sbHdoZWVsPzogYm9vbGVhbjtcclxuICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmc7XHJcbiAgZHJhZ2dhYmxlPzogYm9vbGVhbjtcclxuICBkcmFnZ2FibGVDdXJzb3I/OiBzdHJpbmc7XHJcbiAgZHJhZ2dpbmdDdXJzb3I/OiBzdHJpbmc7XHJcbiAga2V5Ym9hcmRTaG9ydGN1dHM/OiBib29sZWFuO1xyXG4gIHN0eWxlcz86IE1hcFR5cGVTdHlsZVtdO1xyXG4gIHpvb21Db250cm9sPzogYm9vbGVhbjtcclxuICB6b29tQ29udHJvbE9wdGlvbnM/OiBab29tQ29udHJvbE9wdGlvbnM7XHJcbiAgc3RyZWV0Vmlld0NvbnRyb2w/OiBib29sZWFuO1xyXG4gIHN0cmVldFZpZXdDb250cm9sT3B0aW9ucz86IFN0cmVldFZpZXdDb250cm9sT3B0aW9ucztcclxuICBzY2FsZUNvbnRyb2w/OiBib29sZWFuO1xyXG4gIHNjYWxlQ29udHJvbE9wdGlvbnM/OiBTY2FsZUNvbnRyb2xPcHRpb25zO1xyXG4gIG1hcFR5cGVDb250cm9sPzogYm9vbGVhbjtcclxuICBtYXBUeXBlQ29udHJvbE9wdGlvbnM/OiBNYXBUeXBlQ29udHJvbE9wdGlvbnM7XHJcbiAgcGFuQ29udHJvbD86IGJvb2xlYW47XHJcbiAgcGFuQ29udHJvbE9wdGlvbnM/OiBQYW5Db250cm9sT3B0aW9ucztcclxuICByb3RhdGVDb250cm9sPzogYm9vbGVhbjtcclxuICByb3RhdGVDb250cm9sT3B0aW9ucz86IFJvdGF0ZUNvbnRyb2xPcHRpb25zO1xyXG4gIGZ1bGxzY3JlZW5Db250cm9sPzogYm9vbGVhbjtcclxuICBmdWxsc2NyZWVuQ29udHJvbE9wdGlvbnM/OiBGdWxsc2NyZWVuQ29udHJvbE9wdGlvbnM7XHJcbiAgbWFwVHlwZUlkPzogc3RyaW5nfE1hcFR5cGVJZDtcclxuICBjbGlja2FibGVJY29ucz86IGJvb2xlYW47XHJcbiAgZ2VzdHVyZUhhbmRsaW5nPzogJ2Nvb3BlcmF0aXZlJ3wnZ3JlZWR5J3wnbm9uZSd8J2F1dG8nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1hcFR5cGVTdHlsZSB7XHJcbiAgZWxlbWVudFR5cGU/OiAnYWxsJ3wnZ2VvbWV0cnknfCdnZW9tZXRyeS5maWxsJ3wnZ2VvbWV0cnkuc3Ryb2tlJ3wnbGFiZWxzJ3wnbGFiZWxzLmljb24nfFxyXG4gICAgICAnbGFiZWxzLnRleHQnfCdsYWJlbHMudGV4dC5maWxsJ3wnbGFiZWxzLnRleHQuc3Ryb2tlJztcclxuICBmZWF0dXJlVHlwZT86ICdhZG1pbmlzdHJhdGl2ZSd8J2FkbWluaXN0cmF0aXZlLmNvdW50cnknfCdhZG1pbmlzdHJhdGl2ZS5sYW5kX3BhcmNlbCd8XHJcbiAgICAgICdhZG1pbmlzdHJhdGl2ZS5sb2NhbGl0eSd8J2FkbWluaXN0cmF0aXZlLm5laWdoYm9yaG9vZCd8J2FkbWluaXN0cmF0aXZlLnByb3ZpbmNlJ3wnYWxsJ3xcclxuICAgICAgJ2xhbmRzY2FwZSd8J2xhbmRzY2FwZS5tYW5fbWFkZSd8J2xhbmRzY2FwZS5uYXR1cmFsJ3wnbGFuZHNjYXBlLm5hdHVyYWwubGFuZGNvdmVyJ3xcclxuICAgICAgJ2xhbmRzY2FwZS5uYXR1cmFsLnRlcnJhaW4nfCdwb2knfCdwb2kuYXR0cmFjdGlvbid8J3BvaS5idXNpbmVzcyd8J3BvaS5nb3Zlcm5tZW50J3xcclxuICAgICAgJ3BvaS5tZWRpY2FsJ3wncG9pLnBhcmsnfCdwb2kucGxhY2Vfb2Zfd29yc2hpcCd8J3BvaS5zY2hvb2wnfCdwb2kuc3BvcnRzX2NvbXBsZXgnfCdyb2FkJ3xcclxuICAgICAgJ3JvYWQuYXJ0ZXJpYWwnfCdyb2FkLmhpZ2h3YXknfCdyb2FkLmhpZ2h3YXkuY29udHJvbGxlZF9hY2Nlc3MnfCdyb2FkLmxvY2FsJ3wndHJhbnNpdCd8XHJcbiAgICAgICd0cmFuc2l0LmxpbmUnfCd0cmFuc2l0LnN0YXRpb24nfCd0cmFuc2l0LnN0YXRpb24uYWlycG9ydCd8J3RyYW5zaXQuc3RhdGlvbi5idXMnfFxyXG4gICAgICAndHJhbnNpdC5zdGF0aW9uLnJhaWwnfCd3YXRlcic7XHJcbiAgc3R5bGVyczogTWFwVHlwZVN0eWxlcltdO1xyXG59XHJcblxyXG4vKipcclxuICogIElmIG1vcmUgdGhhbiBvbmUga2V5IGlzIHNwZWNpZmllZCBpbiBhIHNpbmdsZSBNYXBUeXBlU3R5bGVyLCBhbGwgYnV0IG9uZSB3aWxsIGJlIGlnbm9yZWQuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE1hcFR5cGVTdHlsZXIge1xyXG4gIGNvbG9yPzogc3RyaW5nO1xyXG4gIGdhbW1hPzogbnVtYmVyO1xyXG4gIGh1ZT86IHN0cmluZztcclxuICBpbnZlcnRfbGlnaHRuZXNzPzogYm9vbGVhbjtcclxuICBsaWdodG5lc3M/OiBudW1iZXI7XHJcbiAgc2F0dXJhdGlvbj86IG51bWJlcjtcclxuICB2aXNpYmlsaXR5Pzogc3RyaW5nO1xyXG4gIHdlaWdodD86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJbmZvV2luZG93IGV4dGVuZHMgTVZDT2JqZWN0IHtcclxuICBjb25zdHJ1Y3RvcihvcHRzPzogSW5mb1dpbmRvd09wdGlvbnMpOiB2b2lkO1xyXG4gIGNsb3NlKCk6IHZvaWQ7XHJcbiAgZ2V0Q29udGVudCgpOiBzdHJpbmd8Tm9kZTtcclxuICBnZXRQb3NpdGlvbigpOiBMYXRMbmc7XHJcbiAgZ2V0WkluZGV4KCk6IG51bWJlcjtcclxuICBvcGVuKG1hcD86IEdvb2dsZU1hcCwgYW5jaG9yPzogTVZDT2JqZWN0KTogdm9pZDtcclxuICBzZXRDb250ZW50KGNvbnRlbnQ6IHN0cmluZ3xOb2RlKTogdm9pZDtcclxuICBzZXRPcHRpb25zKG9wdGlvbnM6IEluZm9XaW5kb3dPcHRpb25zKTogdm9pZDtcclxuICBzZXRQb3NpdGlvbihwb3NpdGlvbjogTGF0TG5nfExhdExuZ0xpdGVyYWwpOiB2b2lkO1xyXG4gIHNldFpJbmRleCh6SW5kZXg6IG51bWJlcik6IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTVZDT2JqZWN0IHsgYWRkTGlzdGVuZXIoZXZlbnROYW1lOiBzdHJpbmcsIGhhbmRsZXI6IEZ1bmN0aW9uKTogTWFwc0V2ZW50TGlzdGVuZXI7IH1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFwc0V2ZW50TGlzdGVuZXIgeyByZW1vdmUoKTogdm9pZDsgfVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTaXplIHtcclxuICBoZWlnaHQ6IG51bWJlcjtcclxuICB3aWR0aDogbnVtYmVyO1xyXG4gIGNvbnN0cnVjdG9yKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB3aWR0aFVuaXQ/OiBzdHJpbmcsIGhlaWdodFVuaXQ/OiBzdHJpbmcpOiB2b2lkO1xyXG4gIGVxdWFscyhvdGhlcjogU2l6ZSk6IGJvb2xlYW47XHJcbiAgdG9TdHJpbmcoKTogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEluZm9XaW5kb3dPcHRpb25zIHtcclxuICBjb250ZW50Pzogc3RyaW5nfE5vZGU7XHJcbiAgZGlzYWJsZUF1dG9QYW4/OiBib29sZWFuO1xyXG4gIG1heFdpZHRoPzogbnVtYmVyO1xyXG4gIHBpeGVsT2Zmc2V0PzogU2l6ZTtcclxuICBwb3NpdGlvbj86IExhdExuZ3xMYXRMbmdMaXRlcmFsO1xyXG4gIHpJbmRleD86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQb2ludCB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHk6IG51bWJlcjtcclxuICBlcXVhbHMob3RoZXI6IFBvaW50KTogYm9vbGVhbjtcclxuICB0b1N0cmluZygpOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR29vZ2xlU3ltYm9sIHtcclxuICBhbmNob3I/OiBQb2ludDtcclxuICBmaWxsQ29sb3I/OiBzdHJpbmc7XHJcbiAgZmlsbE9wYWNpdHk/OiBzdHJpbmc7XHJcbiAgbGFiZWxPcmlnaW4/OiBQb2ludDtcclxuICBwYXRoPzogc3RyaW5nO1xyXG4gIHJvdGF0aW9uPzogbnVtYmVyO1xyXG4gIHNjYWxlPzogbnVtYmVyO1xyXG4gIHN0cm9rZUNvbG9yPzogc3RyaW5nO1xyXG4gIHN0cm9rZU9wYWNpdHk/OiBudW1iZXI7XHJcbiAgc3Ryb2tlV2VpZ2h0PzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEljb25TZXF1ZW5jZSB7XHJcbiAgZml4ZWRSb3RhdGlvbj86IGJvb2xlYW47XHJcbiAgaWNvbj86IEdvb2dsZVN5bWJvbDtcclxuICBvZmZzZXQ/OiBzdHJpbmc7XHJcbiAgcmVwZWF0Pzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBvbHlsaW5lT3B0aW9ucyB7XHJcbiAgY2xpY2thYmxlPzogYm9vbGVhbjtcclxuICBkcmFnZ2FibGU/OiBib29sZWFuO1xyXG4gIGVkaXRhYmxlPzogYm9vbGVhbjtcclxuICBnZW9kZXNpYz86IGJvb2xlYW47XHJcbiAgaWNvbj86IEFycmF5PEljb25TZXF1ZW5jZT47XHJcbiAgbWFwPzogR29vZ2xlTWFwO1xyXG4gIHBhdGg/OiBBcnJheTxMYXRMbmc+fEFycmF5PExhdExuZ3xMYXRMbmdMaXRlcmFsPjtcclxuICBzdHJva2VDb2xvcj86IHN0cmluZztcclxuICBzdHJva2VPcGFjaXR5PzogbnVtYmVyO1xyXG4gIHN0cm9rZVdlaWdodD86IG51bWJlcjtcclxuICB2aXNpYmxlPzogYm9vbGVhbjtcclxuICB6SW5kZXg/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUG9seWxpbmUgZXh0ZW5kcyBNVkNPYmplY3Qge1xyXG4gIGdldERyYWdnYWJsZSgpOiBib29sZWFuO1xyXG4gIGdldEVkaXRhYmxlKCk6IGJvb2xlYW47XHJcbiAgZ2V0TWFwKCk6IEdvb2dsZU1hcDtcclxuICBnZXRQYXRoKCk6IEFycmF5PExhdExuZz47XHJcbiAgZ2V0VmlzaWJsZSgpOiBib29sZWFuO1xyXG4gIHNldERyYWdnYWJsZShkcmFnZ2FibGU6IGJvb2xlYW4pOiB2b2lkO1xyXG4gIHNldEVkaXRhYmxlKGVkaXRhYmxlOiBib29sZWFuKTogdm9pZDtcclxuICBzZXRNYXAobWFwOiBHb29nbGVNYXApOiB2b2lkO1xyXG4gIHNldE9wdGlvbnMob3B0aW9uczogUG9seWxpbmVPcHRpb25zKTogdm9pZDtcclxuICBzZXRQYXRoKHBhdGg6IEFycmF5PExhdExuZ3xMYXRMbmdMaXRlcmFsPik6IHZvaWQ7XHJcbiAgc2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBvbHlNb3VzZUV2ZW50IGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIHRyaWdnZXJzIG1vdXNlIGV2ZW50cyBvbiBhIHBvbHlsaW5lLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBQb2x5TW91c2VFdmVudCBleHRlbmRzIE1vdXNlRXZlbnQge1xyXG4gIGVkZ2U6IG51bWJlcjtcclxuICBwYXRoOiBudW1iZXI7XHJcbiAgdmVydGV4OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUG9seWdvbk9wdGlvbnMge1xyXG4gIGNsaWNrYWJsZT86IGJvb2xlYW47XHJcbiAgZHJhZ2dhYmxlPzogYm9vbGVhbjtcclxuICBlZGl0YWJsZT86IGJvb2xlYW47XHJcbiAgZmlsbENvbG9yPzogc3RyaW5nO1xyXG4gIGZpbGxPcGFjaXR5PzogbnVtYmVyO1xyXG4gIGdlb2Rlc2ljPzogYm9vbGVhbjtcclxuICBpY29uPzogQXJyYXk8SWNvblNlcXVlbmNlPjtcclxuICBtYXA/OiBHb29nbGVNYXA7XHJcbiAgcGF0aHM/OiBBcnJheTxMYXRMbmd8TGF0TG5nTGl0ZXJhbD58QXJyYXk8QXJyYXk8TGF0TG5nfExhdExuZ0xpdGVyYWw+PjtcclxuICBzdHJva2VDb2xvcj86IHN0cmluZztcclxuICBzdHJva2VPcGFjaXR5PzogbnVtYmVyO1xyXG4gIHN0cm9rZVdlaWdodD86IG51bWJlcjtcclxuICB2aXNpYmxlPzogYm9vbGVhbjtcclxuICB6SW5kZXg/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUG9seWdvbiBleHRlbmRzIE1WQ09iamVjdCB7XHJcbiAgekluZGV4OiBudW1iZXI7XHJcbiAgZ2V0RHJhZ2dhYmxlKCk6IGJvb2xlYW47XHJcbiAgZ2V0RWRpdGFibGUoKTogYm9vbGVhbjtcclxuICBnZXRNYXAoKTogR29vZ2xlTWFwO1xyXG4gIGdldFBhdGgoKTogQXJyYXk8TGF0TG5nPjtcclxuICBnZXRQYXRocygpOiBBcnJheTxBcnJheTxMYXRMbmc+PjtcclxuICBnZXRWaXNpYmxlKCk6IGJvb2xlYW47XHJcbiAgc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZTogYm9vbGVhbik6IHZvaWQ7XHJcbiAgc2V0RWRpdGFibGUoZWRpdGFibGU6IGJvb2xlYW4pOiB2b2lkO1xyXG4gIHNldE1hcChtYXA6IEdvb2dsZU1hcCk6IHZvaWQ7XHJcbiAgc2V0UGF0aChwYXRoOiBBcnJheTxMYXRMbmc+fEFycmF5PExhdExuZ3xMYXRMbmdMaXRlcmFsPik6IHZvaWQ7XHJcbiAgc2V0T3B0aW9ucyhvcHRpb25zOiBQb2x5Z29uT3B0aW9ucyk6IHZvaWQ7XHJcbiAgc2V0UGF0aHMocGF0aHM6IEFycmF5PEFycmF5PExhdExuZ3xMYXRMbmdMaXRlcmFsPj58QXJyYXk8TGF0TG5nfExhdExuZ0xpdGVyYWw+KTogdm9pZDtcclxuICBzZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEttbExheWVyIGV4dGVuZHMgTVZDT2JqZWN0IHtcclxuICBnZXREZWZhdWx0Vmlld3BvcnQoKTogTGF0TG5nQm91bmRzO1xyXG4gIGdldE1hcCgpOiBHb29nbGVNYXA7XHJcbiAgZ2V0TWV0YWRhdGEoKTogS21sTGF5ZXJNZXRhZGF0YTtcclxuICBnZXRTdGF0dXMoKTogS21sTGF5ZXJTdGF0dXM7XHJcbiAgZ2V0VXJsKCk6IHN0cmluZztcclxuICBnZXRaSW5kZXgoKTogbnVtYmVyO1xyXG4gIHNldE1hcChtYXA6IEdvb2dsZU1hcCk6IHZvaWQ7XHJcbiAgc2V0T3B0aW9ucyhvcHRpb25zOiBLbWxMYXllck9wdGlvbnMpOiB2b2lkO1xyXG4gIHNldFVybCh1cmw6IHN0cmluZyk6IHZvaWQ7XHJcbiAgc2V0WkluZGV4KHpJbmRleDogbnVtYmVyKTogdm9pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlP2hsPWRlI0ttbExheWVyU3RhdHVzXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBLbWxMYXllclN0YXR1cyA9ICdET0NVTUVOVF9OT1RfRk9VTkQnIHxcclxuICAgICdET0NVTUVOVF9UT09fTEFSR0UnIHwgJ0ZFVENIX0VSUk9SJyB8ICdJTlZBTElEX0RPQ1VNRU5UJyB8ICdJTlZBTElEX1JFUVVFU1QnIHxcclxuICAgICdMSU1JVFNfRVhDRUVERUQnIHwgJ09LJyB8ICdUSU1FRF9PVVQnIHwgJ1VOS05PV04nO1xyXG5cclxuLyoqXHJcbiAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlP2hsPWRlI0ttbExheWVyTWV0YWRhdGFcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgS21sTGF5ZXJNZXRhZGF0YSB7XHJcbiAgYXV0aG9yOiBLbWxBdXRob3I7XHJcbiAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICBoYXNTY3JlZW5PdmVybGF5czogYm9vbGVhbjtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgc25pcHBldDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEttbEF1dGhvciB7XHJcbiAgZW1haWw6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgdXJpOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgS21sTGF5ZXJPcHRpb25zIHtcclxuICBjbGlja2FibGU/OiBib29sZWFuO1xyXG4gIG1hcD86IEdvb2dsZU1hcDtcclxuICBwcmVzZXJ2ZVZpZXdwb3J0PzogYm9vbGVhbjtcclxuICBzY3JlZW5PdmVybGF5cz86IGJvb2xlYW47XHJcbiAgc3VwcHJlc3NJbmZvV2luZG93cz86IGJvb2xlYW47XHJcbiAgdXJsPzogc3RyaW5nO1xyXG4gIHpJbmRleD86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBLbWxGZWF0dXJlRGF0YSB7XHJcbiAgYXV0aG9yOiBLbWxBdXRob3I7XHJcbiAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICBpZDogc3RyaW5nO1xyXG4gIGluZm9XaW5kb3dIdG1sOiBzdHJpbmc7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIHNuaXBwZXQ6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBLbWxNb3VzZUV2ZW50IGV4dGVuZHMgTW91c2VFdmVudCB7XHJcbiAgZmVhdHVyZURhdGE6IEttbEZlYXR1cmVEYXRhO1xyXG4gIHBpeGVsT2Zmc2V0OiBTaXplO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERhdGEgZXh0ZW5kcyBNVkNPYmplY3Qge1xyXG4gIGZlYXR1cmVzOiBGZWF0dXJlW107XHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IERhdGFPcHRpb25zKTogdm9pZDtcclxuICBhZGRHZW9Kc29uKGdlb0pzb246IE9iamVjdCwgb3B0aW9ucz86IEdlb0pzb25PcHRpb25zKTogRmVhdHVyZVtdO1xyXG4gIHJlbW92ZShmZWF0dXJlOiBGZWF0dXJlKTogdm9pZDtcclxuICBzZXRDb250cm9sUG9zaXRpb24oY29udHJvbFBvc2l0aW9uOiBDb250cm9sUG9zaXRpb24pOiB2b2lkO1xyXG4gIHNldENvbnRyb2xzKGNvbnRyb2xzOiBzdHJpbmdbXSk6IHZvaWQ7XHJcbiAgc2V0RHJhd2luZ01vZGUoZHJhd2luZ01vZGU6IHN0cmluZyk6IHZvaWQ7XHJcbiAgc2V0TWFwKG1hcDogR29vZ2xlTWFwKTogdm9pZDtcclxuICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xyXG4gIC8qXHJcbiAgKiBUc2xpbnQgY29uZmlndXJhdGlvbiBjaGVjay1wYXJhbWV0ZXJzIHdpbGwgcHJvbXB0IGVycm9ycyBmb3IgdGhlc2UgbGluZXMgb2YgY29kZS5cclxuICAqIGh0dHBzOi8vcGFsYW50aXIuZ2l0aHViLmlvL3RzbGludC9ydWxlcy9uby11bnVzZWQtdmFyaWFibGUvXHJcbiAgKi9cclxuICBzZXRTdHlsZShzdHlsZTogKCkgPT4gdm9pZCk6IHZvaWQ7XHJcbiAgZm9yRWFjaChjYWxsYmFjazogKGZlYXR1cmU6IEZlYXR1cmUpID0+IHZvaWQpOiB2b2lkO1xyXG4gIC8qIHRzbGludDplbmFibGUgKi9cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGZWF0dXJlIGV4dGVuZHMgTVZDT2JqZWN0IHtcclxuICBpZD86IG51bWJlcnxzdHJpbmd8dW5kZWZpbmVkO1xyXG4gIGdlb21ldHJ5OiBHZW9tZXRyeTtcclxuICBwcm9wZXJ0aWVzOiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YU9wdGlvbnMge1xyXG4gIGNvbnRyb2xQb3NpdGlvbj86IENvbnRyb2xQb3NpdGlvbjtcclxuICBjb250cm9scz86IHN0cmluZ1tdO1xyXG4gIGRyYXdpbmdNb2RlPzogc3RyaW5nO1xyXG4gIGZlYXR1cmVGYWN0b3J5PzogKGdlb21ldHJ5OiBHZW9tZXRyeSkgPT4gRmVhdHVyZTtcclxuICBtYXA/OiBHb29nbGVNYXA7XHJcbiAgc3R5bGU/OiAoKSA9PiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERhdGFNb3VzZUV2ZW50IGV4dGVuZHMgTW91c2VFdmVudCB7XHJcbiAgZmVhdHVyZTogRmVhdHVyZTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHZW9Kc29uT3B0aW9ucyB7XHJcbiAgaWRQcm9wZXJ0eU5hbWU6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHZW9tZXRyeSB7XHJcbiAgdHlwZTogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogSWRlbnRpZmllcnMgdXNlZCB0byBzcGVjaWZ5IHRoZSBwbGFjZW1lbnQgb2YgY29udHJvbHMgb24gdGhlIG1hcC4gQ29udHJvbHMgYXJlXHJcbiAqIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gb3RoZXIgY29udHJvbHMgaW4gdGhlIHNhbWUgbGF5b3V0IHBvc2l0aW9uLiBDb250cm9scyB0aGF0XHJcbiAqIGFyZSBhZGRlZCBmaXJzdCBhcmUgcG9zaXRpb25lZCBjbG9zZXIgdG8gdGhlIGVkZ2Ugb2YgdGhlIG1hcC5cclxuICovXHJcbmV4cG9ydCBlbnVtIENvbnRyb2xQb3NpdGlvbiB7XHJcbiAgQk9UVE9NX0NFTlRFUixcclxuICBCT1RUT01fTEVGVCxcclxuICBCT1RUT01fUklHSFQsXHJcbiAgTEVGVF9CT1RUT00sXHJcbiAgTEVGVF9DRU5URVIsXHJcbiAgTEVGVF9UT1AsXHJcbiAgUklHSFRfQk9UVE9NLFxyXG4gIFJJR0hUX0NFTlRFUixcclxuICBSSUdIVF9UT1AsXHJcbiAgVE9QX0NFTlRFUixcclxuICBUT1BfTEVGVCxcclxuICBUT1BfUklHSFRcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTWFwVHlwZUlkIHtcclxuICAvKiogVGhpcyBtYXAgdHlwZSBkaXNwbGF5cyBhIHRyYW5zcGFyZW50IGxheWVyIG9mIG1ham9yIHN0cmVldHMgb24gc2F0ZWxsaXRlIGltYWdlcy4gKi9cclxuICBoeWJyaWQsXHJcbiAgLyoqIFRoaXMgbWFwIHR5cGUgZGlzcGxheXMgYSBub3JtYWwgc3RyZWV0IG1hcC4gKi9cclxuICByb2FkbWFwLFxyXG4gIC8qKiBUaGlzIG1hcCB0eXBlIGRpc3BsYXlzIHNhdGVsbGl0ZSBpbWFnZXMuICovXHJcbiAgc2F0ZWxsaXRlLFxyXG4gIC8qKiBUaGlzIG1hcCB0eXBlIGRpc3BsYXlzIG1hcHMgd2l0aCBwaHlzaWNhbCBmZWF0dXJlcyBzdWNoIGFzIHRlcnJhaW4gYW5kIHZlZ2V0YXRpb24uICovXHJcbiAgdGVycmFpblxyXG59XHJcblxyXG4vKioqKiogQ29udHJvbHMgKioqKiovXHJcbi8qKiBPcHRpb25zIGZvciB0aGUgcmVuZGVyaW5nIG9mIHRoZSBtYXAgdHlwZSBjb250cm9sLiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE1hcFR5cGVDb250cm9sT3B0aW9ucyB7XHJcbiAgLyoqIElEcyBvZiBtYXAgdHlwZXMgdG8gc2hvdyBpbiB0aGUgY29udHJvbC4gKi9cclxuICBtYXBUeXBlSWRzPzogKE1hcFR5cGVJZHxzdHJpbmcpW107XHJcbiAgLyoqXHJcbiAgICogUG9zaXRpb24gaWQuIFVzZWQgdG8gc3BlY2lmeSB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgb24gdGhlIG1hcC5cclxuICAgKiBUaGUgZGVmYXVsdCBwb3NpdGlvbiBpcyBUT1BfUklHSFQuXHJcbiAgICovXHJcbiAgcG9zaXRpb24/OiBDb250cm9sUG9zaXRpb247XHJcbiAgLyoqIFN0eWxlIGlkLiBVc2VkIHRvIHNlbGVjdCB3aGF0IHN0eWxlIG9mIG1hcCB0eXBlIGNvbnRyb2wgdG8gZGlzcGxheS4gKi9cclxuICBzdHlsZT86IE1hcFR5cGVDb250cm9sU3R5bGU7XHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIE1hcFR5cGVDb250cm9sU3R5bGUge1xyXG4gIERFRkFVTFQsXHJcbiAgRFJPUERPV05fTUVOVSxcclxuICBIT1JJWk9OVEFMX0JBUlxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE92ZXJ2aWV3TWFwQ29udHJvbE9wdGlvbnMge1xyXG4gIG9wZW5lZD86IGJvb2xlYW47XHJcbn1cclxuXHJcbi8qKiBPcHRpb25zIGZvciB0aGUgcmVuZGVyaW5nIG9mIHRoZSBwYW4gY29udHJvbC4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBQYW5Db250cm9sT3B0aW9ucyB7XHJcbiAgLyoqXHJcbiAgICogUG9zaXRpb24gaWQuIFVzZWQgdG8gc3BlY2lmeSB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgb24gdGhlIG1hcC5cclxuICAgKiBUaGUgZGVmYXVsdCBwb3NpdGlvbiBpcyBUT1BfTEVGVC5cclxuICAgKi9cclxuICBwb3NpdGlvbj86IENvbnRyb2xQb3NpdGlvbjtcclxufVxyXG5cclxuLyoqIE9wdGlvbnMgZm9yIHRoZSByZW5kZXJpbmcgb2YgdGhlIHJvdGF0ZSBjb250cm9sLiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFJvdGF0ZUNvbnRyb2xPcHRpb25zIHtcclxuICAvKipcclxuICAgKiBQb3NpdGlvbiBpZC4gVXNlZCB0byBzcGVjaWZ5IHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCBvbiB0aGUgbWFwLlxyXG4gICAqIFRoZSBkZWZhdWx0IHBvc2l0aW9uIGlzIFRPUF9MRUZULlxyXG4gICAqL1xyXG4gIHBvc2l0aW9uPzogQ29udHJvbFBvc2l0aW9uO1xyXG59XHJcblxyXG4vKiogT3B0aW9ucyBmb3IgdGhlIHJlbmRlcmluZyBvZiB0aGUgc2NhbGUgY29udHJvbC4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBTY2FsZUNvbnRyb2xPcHRpb25zIHtcclxuICAvKiogU3R5bGUgaWQuIFVzZWQgdG8gc2VsZWN0IHdoYXQgc3R5bGUgb2Ygc2NhbGUgY29udHJvbCB0byBkaXNwbGF5LiAqL1xyXG4gIHN0eWxlPzogU2NhbGVDb250cm9sU3R5bGU7XHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIFNjYWxlQ29udHJvbFN0eWxlIHtcclxuICBERUZBVUxUXHJcbn1cclxuXHJcbi8qKiBPcHRpb25zIGZvciB0aGUgcmVuZGVyaW5nIG9mIHRoZSBTdHJlZXQgVmlldyBwZWdtYW4gY29udHJvbCBvbiB0aGUgbWFwLiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFN0cmVldFZpZXdDb250cm9sT3B0aW9ucyB7XHJcbiAgLyoqXHJcbiAgICogUG9zaXRpb24gaWQuIFVzZWQgdG8gc3BlY2lmeSB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgb24gdGhlIG1hcC4gVGhlXHJcbiAgICogZGVmYXVsdCBwb3NpdGlvbiBpcyBlbWJlZGRlZCB3aXRoaW4gdGhlIG5hdmlnYXRpb24gKHpvb20gYW5kIHBhbikgY29udHJvbHMuXHJcbiAgICogSWYgdGhpcyBwb3NpdGlvbiBpcyBlbXB0eSBvciB0aGUgc2FtZSBhcyB0aGF0IHNwZWNpZmllZCBpbiB0aGVcclxuICAgKiB6b29tQ29udHJvbE9wdGlvbnMgb3IgcGFuQ29udHJvbE9wdGlvbnMsIHRoZSBTdHJlZXQgVmlldyBjb250cm9sIHdpbGwgYmVcclxuICAgKiBkaXNwbGF5ZWQgYXMgcGFydCBvZiB0aGUgbmF2aWdhdGlvbiBjb250cm9scy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGRpc3BsYXllZFxyXG4gICAqIHNlcGFyYXRlbHkuXHJcbiAgICovXHJcbiAgcG9zaXRpb24/OiBDb250cm9sUG9zaXRpb247XHJcbn1cclxuXHJcbi8qKiBPcHRpb25zIGZvciB0aGUgcmVuZGVyaW5nIG9mIHRoZSB6b29tIGNvbnRyb2wuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgWm9vbUNvbnRyb2xPcHRpb25zIHtcclxuICAvKipcclxuICAgKiBQb3NpdGlvbiBpZC4gVXNlZCB0byBzcGVjaWZ5IHRoZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCBvbiB0aGUgbWFwLlxyXG4gICAqIFRoZSBkZWZhdWx0IHBvc2l0aW9uIGlzIFRPUF9MRUZULlxyXG4gICAqL1xyXG4gIHBvc2l0aW9uPzogQ29udHJvbFBvc2l0aW9uO1xyXG4gIHN0eWxlPzogWm9vbUNvbnRyb2xTdHlsZTtcclxufVxyXG5cclxuZXhwb3J0IGVudW0gWm9vbUNvbnRyb2xTdHlsZSB7XHJcbiAgREVGQVVMVCxcclxuICBMQVJHRSxcclxuICBTTUFMTFxyXG59XHJcblxyXG4vKiogT3B0aW9ucyBmb3IgdGhlIHJlbmRlcmluZyBvZiB0aGUgZnVsbHNjcmVlbiBjb250cm9sLiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEZ1bGxzY3JlZW5Db250cm9sT3B0aW9ucyB7XHJcbiAgLyoqXHJcbiAgICogUG9zaXRpb24gaWQuIFVzZWQgdG8gc3BlY2lmeSB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wgb24gdGhlIG1hcC5cclxuICAgKiBUaGUgZGVmYXVsdCBwb3NpdGlvbiBpcyBSSUdIVF9UT1AuXHJcbiAgICovXHJcbiAgcG9zaXRpb24/OiBDb250cm9sUG9zaXRpb247XHJcbn1cclxuXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE92ZXJsYXlWaWV3IHtcclxuICAgIHB1YmxpYyBzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpOiB2b2lkO1xyXG4gICAgcHVibGljIGdldChrZXk6IHN0cmluZyk6IGFueTtcclxuICAgIHB1YmxpYyBzZXRWYWx1ZXMob3B0aW9uczogYW55KTogdm9pZDtcclxuICAgIHB1YmxpYyBnZXRQYW5lcygpOiBhbnk7XHJcbiAgICBwdWJsaWMgZ2V0UHJvamVjdGlvbigpOiBhbnk7XHJcbiAgICBwdWJsaWMgZ2V0TWFwKCk6IEdvb2dsZU1hcDtcclxufVxyXG4iLCJpbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcclxuaW1wb3J0IHsgSUJveCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWJveCc7XHJcbmltcG9ydCB7IElNYXBPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFwLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5pbXBvcnQgeyBNYXBUeXBlSWQgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFwLXR5cGUtaWQnO1xyXG5cclxuZGVjbGFyZSB2YXIgZ29vZ2xlOiBhbnk7XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgY29udGFpbnMgaGVscGVyZnVuY3Rpb25zIHRvIG1hcCB2YXJpb3VzIGludGVyZmFjZXMgdXNlZCB0byByZXByZXNlbnQgb3B0aW9ucyBhbmQgc3RydWN0dXJlcyBpbnRvIHRoZVxyXG4gKiBjb3JyZXNwb25kaW5nIEdvb2dsZSBNYXBzIHNwZWNpZmljIGltcGxlbWVudGF0aW9ucy5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdvb2dsZUNvbnZlcnNpb25zIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBmb3IgY29udmVyc2lvbiB0byBHb29nbGUgTWFwIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgX21hcE9wdGlvbnNBdHRyaWJ1dGVzOiBzdHJpbmdbXSA9IFtcclxuICAgICAgICAnYmFja2dyb3VuZENvbG9yJyxcclxuICAgICAgICAnY2VudGVyJyxcclxuICAgICAgICAnY2xpY2thYmxlSWNvbnMnLFxyXG4gICAgICAgICdkaXNhYmxlRGVmYXVsdFVJJyxcclxuICAgICAgICAnZGlzYWJsZURvdWJsZUNsaWNrWm9vbScsXHJcbiAgICAgICAgJ2RyYWdnYWJsZScsXHJcbiAgICAgICAgJ2RyYWdnYWJsZUN1cnNvcicsXHJcbiAgICAgICAgJ2RyYWdnaW5nQ3Vyc29yJyxcclxuICAgICAgICAnZGlzYWJsZVpvb21pbmcnLFxyXG4gICAgICAgICdmdWxsc2NyZWVuQ29udHJvbCcsXHJcbiAgICAgICAgJ2Z1bGxzY3JlZW5Db250cm9sT3B0aW9ucycsXHJcbiAgICAgICAgJ2dlc3R1cmVIYW5kbGluZycsXHJcbiAgICAgICAgJ2hlYWRpbmcnLFxyXG4gICAgICAgICdrZXlib2FyZFNob3J0Y3V0cycsXHJcbiAgICAgICAgJ21hcFR5cGVDb250cm9sJyxcclxuICAgICAgICAnbWFwVHlwZUNvbnRyb2xPcHRpb25zJyxcclxuICAgICAgICAnbWFwVHlwZUlkJyxcclxuICAgICAgICAnbWF4Wm9vbScsXHJcbiAgICAgICAgJ21pblpvb20nLFxyXG4gICAgICAgICdub0NsZWFyJyxcclxuICAgICAgICAncGFuQ29udHJvbCcsXHJcbiAgICAgICAgJ3BhbkNvbnRyb2xPcHRpb25zJyxcclxuICAgICAgICAncm90YXRlQ29udHJvbCcsXHJcbiAgICAgICAgJ3JvdGF0ZUNvbnRyb2xPcHRpb25zJyxcclxuICAgICAgICAnc2NhbGVDb250cm9sJyxcclxuICAgICAgICAnc2NhbGVDb250cm9sT3B0aW9ucycsXHJcbiAgICAgICAgJ3Njcm9sbHdoZWVsJyxcclxuICAgICAgICAnc2hvd01hcFR5cGVTZWxlY3RvcicsXHJcbiAgICAgICAgJ3N0cmVldFZpZXcnLFxyXG4gICAgICAgICdzdHJlZXRWaWV3Q29udHJvbCcsXHJcbiAgICAgICAgJ3N0cmVldFZpZXdDb250cm9sT3B0aW9ucycsXHJcbiAgICAgICAgJ3N0eWxlcycsXHJcbiAgICAgICAgJ3RpbHQnLFxyXG4gICAgICAgICd6b29tJyxcclxuICAgICAgICAnem9vbUNvbnRyb2wnLFxyXG4gICAgICAgICd6b29tQ29udHJvbE9wdGlvbnMnXHJcbiAgICBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5mb1dpbmRvdyBvcHRpb24gYXR0cmlidXRlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgZm9yIGNvbnZlcnNpb24gdG8gR29vZ2xlIE1hcCBwcm9wZXJ0aWVzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9pbmZvV2luZG93T3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xyXG4gICAgICAgICdhY3Rpb25zJyxcclxuICAgICAgICAnZGVzY3JpcHRpb24nLFxyXG4gICAgICAgICdodG1sQ29udGVudCcsXHJcbiAgICAgICAgJ2lkJyxcclxuICAgICAgICAncG9zaXRpb24nLFxyXG4gICAgICAgICdwaXhlbE9mZnNldCcsXHJcbiAgICAgICAgJ3Nob3dDbG9zZUJ1dHRvbicsXHJcbiAgICAgICAgJ3Nob3dQb2ludGVyJyxcclxuICAgICAgICAncHVzaHBpbicsXHJcbiAgICAgICAgJ3RpdGxlJyxcclxuICAgICAgICAndGl0bGVDbGlja0hhbmRsZXInLFxyXG4gICAgICAgICd0eXBlTmFtZScsXHJcbiAgICAgICAgJ3Zpc2libGUnLFxyXG4gICAgICAgICd3aWR0aCcsXHJcbiAgICAgICAgJ2hlaWdodCdcclxuICAgIF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXJrZXIgb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEdvb2dsZSBNYXAgcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfbWFya2VyT3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xyXG4gICAgICAgICdhbmNob3InLFxyXG4gICAgICAgICdwb3NpdGlvbicsXHJcbiAgICAgICAgJ3RpdGxlJyxcclxuICAgICAgICAndGV4dCcsXHJcbiAgICAgICAgJ2xhYmVsJyxcclxuICAgICAgICAnZHJhZ2dhYmxlJyxcclxuICAgICAgICAnaWNvbicsXHJcbiAgICAgICAgJ3dpZHRoJyxcclxuICAgICAgICAnaGVpZ2h0JyxcclxuICAgICAgICAnaWNvbkluZm8nLFxyXG4gICAgICAgICdtZXRhZGF0YScsXHJcbiAgICAgICAgJ3Zpc2libGUnXHJcbiAgICBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2x1c3RlciBvcHRpb24gYXR0cmlidXRlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgZm9yIGNvbnZlcnNpb24gdG8gR29vZ2xlIE1hcCBwcm9wZXJ0aWVzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9jbHVzdGVyT3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xyXG4gICAgICAgICdjYWxsYmFjaycsXHJcbiAgICAgICAgJ2NsdXN0ZXJlZFBpbkNhbGxiYWNrJyxcclxuICAgICAgICAnY2x1c3RlcmluZ0VuYWJsZWQnLFxyXG4gICAgICAgICdncmlkU2l6ZScsXHJcbiAgICAgICAgJ2xheWVyT2Zmc2V0JyxcclxuICAgICAgICAncGxhY2VtZW50TW9kZScsXHJcbiAgICAgICAgJ3Zpc2libGUnLFxyXG4gICAgICAgICd6SW5kZXgnXHJcbiAgICBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9seWdvbiBvcHRpb24gYXR0cmlidXRlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgZm9yIGNvbnZlcnNpb24gdG8gR29vZ2xlIE1hcCBwcm9wZXJ0aWVzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3RhdGljIF9wb2x5Z29uT3B0aW9uc0F0dHJpYnV0ZXM6IHN0cmluZ1tdID0gW1xyXG4gICAgICAgICdjbGlja2FibGUnLFxyXG4gICAgICAgICdkcmFnZ2FibGUnLFxyXG4gICAgICAgICdlZGl0YWJsZScsXHJcbiAgICAgICAgJ2ZpbGxDb2xvcicsXHJcbiAgICAgICAgJ2ZpbGxPcGFjaXR5JyxcclxuICAgICAgICAnZ2VvZGVzaWMnLFxyXG4gICAgICAgICdwYXRocycsXHJcbiAgICAgICAgJ3N0cm9rZUNvbG9yJyxcclxuICAgICAgICAnc3Ryb2tlT3BhY2l0eScsXHJcbiAgICAgICAgJ3N0cm9rZVdlaWdodCcsXHJcbiAgICAgICAgJ3Zpc2libGUnLFxyXG4gICAgICAgICd6SW5kZXgnXHJcbiAgICBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9seWxpbmUgb3B0aW9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGZvciBjb252ZXJzaW9uIHRvIEdvb2dsZSBNYXAgcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfcG9seWxpbmVPcHRpb25zQXR0cmlidXRlczogc3RyaW5nW10gPSBbXHJcbiAgICAgICAgJ2NsaWNrYWJsZScsXHJcbiAgICAgICAgJ2RyYWdnYWJsZScsXHJcbiAgICAgICAgJ2VkaXRhYmxlJyxcclxuICAgICAgICAnZ2VvZGVzaWMnLFxyXG4gICAgICAgICdzdHJva2VDb2xvcicsXHJcbiAgICAgICAgJ3N0cm9rZU9wYWNpdHknLFxyXG4gICAgICAgICdzdHJva2VXZWlnaHQnLFxyXG4gICAgICAgICd2aXNpYmxlJyxcclxuICAgICAgICAnekluZGV4J1xyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gSUJveCBvYmplY3QgdG8gYSBHb29nbGVNYXBUeXBlcy5MYXRMbmdCb3VuZHNMaXRlcmFsIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYm91bmRzIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVCb3VuZHMoYm91bmRzOiBJQm94KTogR29vZ2xlTWFwVHlwZXMuTGF0TG5nQm91bmRzTGl0ZXJhbCB7XHJcbiAgICAgICAgY29uc3QgYjogR29vZ2xlTWFwVHlwZXMuTGF0TG5nQm91bmRzTGl0ZXJhbCA9IHtcclxuICAgICAgICAgICAgZWFzdDogYm91bmRzLm1heExvbmdpdHVkZSxcclxuICAgICAgICAgICAgbm9ydGg6IGJvdW5kcy5tYXhMYXRpdHVkZSxcclxuICAgICAgICAgICAgc291dGg6IGJvdW5kcy5taW5MYXRpdHVkZSxcclxuICAgICAgICAgICAgd2VzdDogYm91bmRzLm1pbkxvbmdpdHVkZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBiO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhbiBJSW5mb1dpbmRvd09wdGlvbnMgb2JqZWN0IHRvIGEgR29vZ2xlTWFwVHlwZXMuSW5mb1dpbmRvd09wdGlvbnMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVJbmZvV2luZG93T3B0aW9ucyhvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMpOiBHb29nbGVNYXBUeXBlcy5JbmZvV2luZG93T3B0aW9ucyB7XHJcbiAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuSW5mb1dpbmRvd09wdGlvbnMgfCBhbnkgPSB7fTtcclxuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGsgPT4gR29vZ2xlQ29udmVyc2lvbnMuX2luZm9XaW5kb3dPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMSlcclxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChrID09PSAnaHRtbENvbnRlbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5jb250ZW50ID0gKDxhbnk+b3B0aW9ucylba107XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ba10gPSAoPGFueT5vcHRpb25zKVtrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG8uY29udGVudCA9PSBudWxsIHx8IG8uY29udGVudCA9PT0gJycpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgIT09ICcnICYmIG9wdGlvbnMuZGVzY3JpcHRpb24gIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBvLmNvbnRlbnQgPSBgJHtvcHRpb25zLnRpdGxlfTogJHtvcHRpb25zLmRlc2NyaXB0aW9ufWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5kZXNjcmlwdGlvbiAhPT0gJycpIHsgby5jb250ZW50ID0gb3B0aW9ucy5kZXNjcmlwdGlvbjsgfVxyXG4gICAgICAgICAgICBlbHNlIHsgby5jb250ZW50ID0gb3B0aW9ucy50aXRsZTsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gSUxhdExvbmcgb2JqZWN0IHRvIGEgR29vZ2xlTWFwVHlwZXMuTGF0TG5nTGl0ZXJhbCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxhdGxvbmcgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZUxvY2F0aW9uKGxhdGxvbmc6IElMYXRMb25nKTogR29vZ2xlTWFwVHlwZXMuTGF0TG5nTGl0ZXJhbCB7XHJcbiAgICAgICAgY29uc3QgbDogR29vZ2xlTWFwVHlwZXMuTGF0TG5nTGl0ZXJhbCA9IHsgbGF0OiBsYXRsb25nLmxhdGl0dWRlLCBsbmc6IGxhdGxvbmcubG9uZ2l0dWRlIH07XHJcbiAgICAgICAgcmV0dXJuIGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGFuIEdvb2dsZU1hcFR5cGVzLkxhdExuZ0xpdGVyYWwgb2JqZWN0IHRvIGEgSUxhdExvbmcgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXRsbmcgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZUxhdExuZyhsYXRsbmc6IEdvb2dsZU1hcFR5cGVzLkxhdExuZ0xpdGVyYWwpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgY29uc3QgbDogSUxhdExvbmcgPSB7IGxhdGl0dWRlOiBsYXRsbmcubGF0LCBsb25naXR1ZGU6IGxhdGxuZy5sbmcgfTtcclxuICAgICAgICByZXR1cm4gbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gSUxhdExvbmcgb2JqZWN0IHRvIGEgR29vZ2xlTWFwVHlwZXMuTGF0TG5nIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF0bG9uZyAtIE9iamVjdCB0byBiZSBtYXBwZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlTG9jYXRpb25PYmplY3QobGF0bG9uZzogSUxhdExvbmcpOiBHb29nbGVNYXBUeXBlcy5MYXRMbmcge1xyXG4gICAgICAgIGNvbnN0IGw6IEdvb2dsZU1hcFR5cGVzLkxhdExuZyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcobGF0bG9uZy5sYXRpdHVkZSwgbGF0bG9uZy5sb25naXR1ZGUpO1xyXG4gICAgICAgIHJldHVybiBsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBhbiBHb29nbGVNYXBUeXBlcy5MYXRMbmcgb2JqZWN0IHRvIGEgSUxhdExvbmcgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXRsbmcgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZUxhdExuZ09iamVjdChsYXRsbmc6IEdvb2dsZU1hcFR5cGVzLkxhdExuZyk6IElMYXRMb25nIHtcclxuICAgICAgICBjb25zdCBsOiBJTGF0TG9uZyA9IHsgbGF0aXR1ZGU6IGxhdGxuZy5sYXQoKSwgbG9uZ2l0dWRlOiBsYXRsbmcubG5nKCkgfTtcclxuICAgICAgICByZXR1cm4gbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gSUxhdExvbmcgYXJyYXkgdG8gYSBhcnJheSBvZiBHb29nbGVNYXBUeXBlcy5MYXRMbmcgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXRsb25nQXJyYXkgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0QXJyYXkobGF0bG9uZ0FycmF5OiBBcnJheTxJTGF0TG9uZz4pOiBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+IHtcclxuICAgICAgICAvLyB1c2UgZm9yIGxvb3AgZm9yIHBlcmZvcm1hbmNlIGluIGNhc2Ugd2UgZGVhbCB3aXRoIGxhcmdlIG51bWJlcnMgb2YgcG9pbnRzIGFuZCBwYXRocy4uLlxyXG4gICAgICAgIGNvbnN0IHA6IEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4gPSBuZXcgQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPigpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF0bG9uZ0FycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHAucHVzaChHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbk9iamVjdChsYXRsb25nQXJyYXlbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGEgTWFwVHlwZUlkIG9iamVjdCB0byBhIEdvb2dsZSBtYXB0eXBlIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFwVHlwZUlkIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gTWFwcGVkIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ29udmVyc2lvbnNcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBUcmFuc2xhdGVNYXBUeXBlSWQobWFwVHlwZUlkOiBNYXBUeXBlSWQpOiBzdHJpbmcge1xyXG4gICAgICAgIHN3aXRjaCAobWFwVHlwZUlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgTWFwVHlwZUlkLnJvYWQ6IHJldHVybiBHb29nbGVNYXBUeXBlcy5NYXBUeXBlSWRbR29vZ2xlTWFwVHlwZXMuTWFwVHlwZUlkLnJvYWRtYXBdO1xyXG4gICAgICAgICAgICBjYXNlIE1hcFR5cGVJZC5ncmF5c2NhbGU6IHJldHVybiBHb29nbGVNYXBUeXBlcy5NYXBUeXBlSWRbR29vZ2xlTWFwVHlwZXMuTWFwVHlwZUlkLnRlcnJhaW5dO1xyXG4gICAgICAgICAgICBjYXNlIE1hcFR5cGVJZC5oeWJyaWQ6IHJldHVybiBHb29nbGVNYXBUeXBlcy5NYXBUeXBlSWRbR29vZ2xlTWFwVHlwZXMuTWFwVHlwZUlkLmh5YnJpZF07XHJcbiAgICAgICAgICAgIGNhc2UgTWFwVHlwZUlkLm9yZG5hbmNlU3VydmV5OiByZXR1cm4gR29vZ2xlTWFwVHlwZXMuTWFwVHlwZUlkW0dvb2dsZU1hcFR5cGVzLk1hcFR5cGVJZC50ZXJyYWluXTtcclxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIEdvb2dsZU1hcFR5cGVzLk1hcFR5cGVJZFtHb29nbGVNYXBUeXBlcy5NYXBUeXBlSWQuc2F0ZWxsaXRlXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIGFuIElNYXJrZXJPcHRpb25zIG9iamVjdCB0byBhIEdvb2dsZU1hcFR5cGVzLk1hcmtlck9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT2JqZWN0IHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSB0aGF0IHdoZW4gcmVzb2x2ZWQgY29udGFpbnMgdGhlIG1hcHBlZCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlTWFya2VyT3B0aW9ucyhvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IEdvb2dsZU1hcFR5cGVzLk1hcmtlck9wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLk1hcmtlck9wdGlvbnMgfCBhbnkgPSB7fTtcclxuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGsgPT4gR29vZ2xlQ29udmVyc2lvbnMuX21hcmtlck9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKVxyXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdwb3NpdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXRsbmcgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbk9iamVjdChvcHRpb25zW2tdKTtcclxuICAgICAgICAgICAgICAgICAgICBvLnBvc2l0aW9uID0gbGF0bG5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb1trXSA9ICg8YW55Pm9wdGlvbnMpW2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYW4gSU1hcE9wdGlvbnMgb2JqZWN0IHRvIGEgR29vZ2xlTWFwVHlwZXMuTWFwT3B0aW9ucyBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZU9wdGlvbnMob3B0aW9uczogSU1hcE9wdGlvbnMpOiBHb29nbGVNYXBUeXBlcy5NYXBPcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5NYXBPcHRpb25zID0ge307XHJcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucylcclxuICAgICAgICAgICAgLmZpbHRlcihrID0+IEdvb2dsZUNvbnZlcnNpb25zLl9tYXBPcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMSlcclxuICAgICAgICAgICAgLmZvckVhY2goKGspID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChrID09PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uY2VudGVyID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24ob3B0aW9ucy5jZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoayA9PT0gJ21hcFR5cGVJZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLm1hcFR5cGVJZCA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU1hcFR5cGVJZChvcHRpb25zLm1hcFR5cGVJZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrID09PSAnZGlzYWJsZVpvb21pbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5nZXN0dXJlSGFuZGxpbmcgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgby56b29tQ29udHJvbCA9ICBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGsgPT09ICdzaG93TWFwVHlwZVNlbGVjdG9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG8ubWFwVHlwZUNvbnRyb2wgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICg8YW55Pm8pW2tdID0gKDxhbnk+b3B0aW9ucylba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlcyBhbiBhcnJheSBvZiBsb2NhdGlvbnMgb3IgYW4gYXJyYXkgb3IgYXJyYXlzIG9mIGxvY2F0aW9uIHRvIGFuZCBhcnJheSBvZiBhcnJheXMgb2YgQmluZyBNYXAgTG9jYXRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGhzIC0gSUxhdExvbmcgYmFzZWQgbG9jYXRpb25zIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcmV0dXJucyAtIGNvbnZlcnRlZCBsb2NhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNvbnZlcnNpb25zXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNsYXRlUGF0aHMocGF0aHM6IEFycmF5PElMYXRMb25nPiB8IEFycmF5PEFycmF5PElMYXRMb25nPj4pOiBBcnJheTxBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+PiB7XHJcbiAgICAgICAgY29uc3QgcDogQXJyYXk8QXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPj4gPSBuZXcgQXJyYXk8QXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPj4oKTtcclxuICAgICAgICBpZiAocGF0aHMgPT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheShwYXRocykgfHwgcGF0aHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHAucHVzaChuZXcgQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRoc1swXSkpIHtcclxuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9yIGFycmF5c1xyXG4gICAgICAgICAgICAvLyB1c2UgZm9yIGxvb3AgZm9yIHBlcmZvcm1hbmNlIGluIGNhc2Ugd2UgZGVhbCB3aXRoIGxhcmdlIG51bWJlcnMgb2YgcG9pbnRzIGFuZCBwYXRocy4uLlxyXG4gICAgICAgICAgICBjb25zdCBwMSA9IDxBcnJheTxBcnJheTxJTGF0TG9uZz4+PnBhdGhzO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwLnB1c2goR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb25PYmplY3RBcnJheShwMVtpXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXIgaXMgYSBzaW1wbGUgYXJyYXkuLi4uXHJcbiAgICAgICAgICAgIHAucHVzaChHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbk9iamVjdEFycmF5KDxBcnJheTxJTGF0TG9uZz4+cGF0aHMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgTWFwcyBhbiBJUG9seWdvbk9wdGlvbnMgb2JqZWN0IHRvIGEgR29vZ2xlTWFwVHlwZXMuUG9seWdvbk9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZVBvbHlnb25PcHRpb25zKG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IEdvb2dsZU1hcFR5cGVzLlBvbHlnb25PcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5Qb2x5Z29uT3B0aW9ucyB8IGFueSA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoayA9PiBHb29nbGVDb252ZXJzaW9ucy5fcG9seWdvbk9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xKVxyXG4gICAgICAgICAgICAuZm9yRWFjaCgoaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdwYXRocycpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXRocykpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucGF0aHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucGF0aHMgPSBuZXcgQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucGF0aHNbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucGF0aHMgPSBuZXcgQXJyYXk8QXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nTGl0ZXJhbD4+KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBmb3IgbG9vcCBmb3IgcGVyZm9ybWFuY2UgaW4gY2FzZSB3ZSBkZWFsIHdpdGggbGFyZ2UgbnVtYmVycyBvZiBwb2ludHMgYW5kIHBhdGhzLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcDEgPSA8QXJyYXk8QXJyYXk8SUxhdExvbmc+Pj5vcHRpb25zLnBhdGhzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvLnBhdGhzW2ldID0gbmV3IEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZ0xpdGVyYWw+KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHAxW2ldLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5wYXRoc1tpXVtqXSA9IHtsYXQ6IHAxW2ldW2pdLmxhdGl0dWRlLCBsbmc6IHAxW2ldW2pdLmxvbmdpdHVkZX07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucGF0aHMgPSBuZXcgQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nTGl0ZXJhbD4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGZvciBsb29wIGZvciBwZXJmb3JtYW5jZSBpbiBjYXNlIHdlIGRlYWwgd2l0aCBsYXJnZSBudW1iZXJzIG9mIHBvaW50cyBhbmQgcGF0aHMuLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwMSA9IDxBcnJheTxJTGF0TG9uZz4+b3B0aW9ucy5wYXRocztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgby5wYXRoc1tpXSA9IHtsYXQ6IHAxW2ldLmxhdGl0dWRlLCBsbmc6IHAxW2ldLmxvbmdpdHVkZX07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogIE1hcHMgYW4gSVBvbHlsaW5lT3B0aW9ucyBvYmplY3QgdG8gYSBHb29nbGVNYXBUeXBlcy5Qb2x5bGluZU9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPYmplY3QgdG8gYmUgbWFwcGVkLlxyXG4gICAgICogQHJldHVybnMgLSBNYXBwZWQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDb252ZXJzaW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zbGF0ZVBvbHlsaW5lT3B0aW9ucyhvcHRpb25zOiBJUG9seWxpbmVPcHRpb25zKTogR29vZ2xlTWFwVHlwZXMuUG9seWxpbmVPcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5Qb2x5bGluZU9wdGlvbnMgfCBhbnkgPSB7fTtcclxuICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGsgPT4gR29vZ2xlQ29udmVyc2lvbnMuX3BvbHlsaW5lT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTEpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKChrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBvW2tdID0gKDxhbnk+b3B0aW9ucylba107XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IElJbmZvV2luZG93T3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBHb29nbGVDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtY29udmVyc2lvbnMnO1xyXG5pbXBvcnQgeyBHb29nbGVNYXBTZXJ2aWNlfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uL2luZm8td2luZG93JztcclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5cclxuZGVjbGFyZSB2YXIgZ29vZ2xlOiBhbnk7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gZm9yIGEge0BsaW5rIEluZm9XaW5kb3d9fSBtb2RlbCBmb3IgR29vZ2xlIE1hcHMuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVJbmZvV2luZG93IGltcGxlbWVudHMgSW5mb1dpbmRvdyB7XHJcblxyXG4gICAgcHJpdmF0ZSBfaXNPcGVuOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBpbmZvIGJveCBpcyBjdXJyZW50bHkgb3Blbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvV0dvb2dsZUluZm9XaW5kb3dpbmRvd1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IElzT3BlbigpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAodGhpcy5faXNPcGVuID09PSB0cnVlKSB7IHJldHVybiB0cnVlOyB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdW5kZXJseWluZyBuYXRpdmUgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTmF0aXZlUHJpbWl0dmUoKTogR29vZ2xlTWFwVHlwZXMuSW5mb1dpbmRvdyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gY29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHb29nbGVJbmZvV2luZG93LlxyXG4gICAgICogQHBhcmFtIF9pbmZvV2luZG93IC0gQSB7QGxpbmsgR29vZ2xlTWFwVHlwZXMuSW5mb1dpbmRvd30gaW5zdGFuY2UgdW5kZXJseWluZyB0aGUgbW9kZWwuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEdvb2dsZU1hcFNlcnZpY2V9LlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUluZm9XaW5kb3dcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfaW5mb1dpbmRvdzogR29vZ2xlTWFwVHlwZXMuSW5mb1dpbmRvdywgcHJpdmF0ZSBfbWFwU2VydmljZTogR29vZ2xlTWFwU2VydmljZSkgeyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBJbmZvV2luZG93LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgZXZlbnQgZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBsaXN0ZW5lciAoZS5nLiBcImNsaWNrXCIpXHJcbiAgICAgKiBAcGFyYW0gZm4gLSBEZWxlZ2F0ZSBpbnZva2VkIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb1dpbmRvd1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkTGlzdGVuZXIoZXZlbnRUeXBlOiBzdHJpbmcsIGZuOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2luZm9XaW5kb3cuYWRkTGlzdGVuZXIoZXZlbnRUeXBlLCAoZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgPT09ICdjbG9zZWNsaWNrJykgeyB0aGlzLl9pc09wZW4gPSBmYWxzZTsgfVxyXG4gICAgICAgICAgICBmbihlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBDbG9zZXMgdGhlIGluZm8gd2luZG93LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvV2luZG93XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDbG9zZSgpIHtcclxuICAgICAgICB0aGlzLl9pc09wZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pbmZvV2luZG93LmNsb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgaW5mbyB3aW5kb3dcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIGluZm8gd2luZG93LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvV2luZG93XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRQb3NpdGlvbigpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgcmV0dXJuIEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxhdExuZ09iamVjdCh0aGlzLl9pbmZvV2luZG93LmdldFBvc2l0aW9uKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgdGhlIGluZm8gd2luZG93XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIFthbmNob3JdIC0gT3B0aW9uYWwgQW5jaG9yLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvV2luZG93XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBPcGVuKGFuY2hvcj86IGFueSkge1xyXG4gICAgICAgIHRoaXMuX21hcFNlcnZpY2UuTWFwUHJvbWlzZS50aGVuKG0gPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9pc09wZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9pbmZvV2luZG93Lm9wZW4obSwgYW5jaG9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IG9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIHNldC4gVGhpcyBvYmplY3Qgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgZXhpc3Rpbmcgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb1dpbmRvd1xyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5JbmZvV2luZG93T3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUluZm9XaW5kb3dPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2luZm9XaW5kb3cuc2V0T3B0aW9ucyhvKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IHBvc2l0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIC0gR2VvIGNvb3JkaW5hdGVzIGF0IHdoaWNoIHRvIGFuY2hvciB0aGUgaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUluZm9XaW5kb3dcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFBvc2l0aW9uKHBvc2l0aW9uOiBJTGF0TG9uZyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGw6IEdvb2dsZU1hcFR5cGVzLkxhdExuZ0xpdGVyYWwgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5faW5mb1dpbmRvdy5zZXRQb3NpdGlvbihsKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBHb29nbGVDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtY29udmVyc2lvbnMnO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbWFya2VyJztcclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHRoZSB7QGxpbmsgTWFya2VyfSBjb250cmFjdCBmb3IgdGhlIEdvb2dsZSBNYXBzIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXJrZXIgaW1wbGVtZW50cyBNYXJrZXIge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF9tZXRhZGF0YTogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XHJcbiAgICBwcml2YXRlIF9pc0ZpcnN0ID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9pc0xhc3QgPSB0cnVlO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBwcm9wZXJ0aWVzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBtYXJrZXIgaXMgdGhlIGZpcnN0IG1hcmtlciBpbiBhIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgSXNGaXJzdCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2lzRmlyc3Q7IH1cclxuICAgIHB1YmxpYyBzZXQgSXNGaXJzdCh2YWw6IGJvb2xlYW4pIHsgdGhpcy5faXNGaXJzdCA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIG1hcmtlciBpcyB0aGUgbGFzdCBtYXJrZXIgaW4gdGhlIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgSXNMYXN0KCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faXNMYXN0OyB9XHJcbiAgICBwdWJsaWMgc2V0IElzTGFzdCh2YWw6IGJvb2xlYW4pIHsgdGhpcy5faXNMYXN0ID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXJrZXIgbWV0YWRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE1ldGFkYXRhKCk6IE1hcDxzdHJpbmcsIGFueT4geyByZXR1cm4gdGhpcy5fbWV0YWRhdGE7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBwcmltaXR2ZSBpbXBsZW1lbnRpbmcgdGhlIG1hcmtlciwgaW4gdGhpcyBjYXNlIHtAbGluayBNaWNyb3NvZnQuTWFwcy5QdXNocGlufVxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IEdvb2dsZU1hcFR5cGVzLk1hcmtlciB7IHJldHVybiB0aGlzLl9tYXJrZXI7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIExvY2F0aW9uIG9mIHRoZSBtYXJrZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBMb2NhdGlvbigpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgY29uc3QgbDogR29vZ2xlTWFwVHlwZXMuTGF0TG5nID0gdGhpcy5fbWFya2VyLmdldFBvc2l0aW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGF0aXR1ZGU6IGwubGF0KCksXHJcbiAgICAgICAgICAgIGxvbmdpdHVkZTogbC5sbmcoKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlTWFya2VyLlxyXG4gICAgICogQHBhcmFtIF9tYXJrZXJcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcmtlcjogR29vZ2xlTWFwVHlwZXMuTWFya2VyKSB7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSBldmVudCBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGxpc3RlbmVyIChlLmcuIFwiY2xpY2tcIilcclxuICAgICAqIEBwYXJhbSBmbiAtIERlbGVnYXRlIGludm9rZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9tYXJrZXIuYWRkTGlzdGVuZXIoZXZlbnRUeXBlLCBmbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZU1hcmtlcigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9tYXJrZXIuc2V0TWFwKG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbWFya2VyIGxhYmVsXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TGFiZWwoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2VyLmdldExhYmVsKCkudGV4dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgbWFya2VyIGlzIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBtYXJrZXIgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlci5nZXRWaXNpYmxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBhbmNob3IgZm9yIHRoZSBtYXJrZXIuIFVzZSB0aGlzIHRvIGFkanVzdCB0aGUgcm9vdCBsb2NhdGlvbiBmb3IgdGhlIG1hcmtlciB0byBhY2NvbW9kYXRlIHZhcmlvdXMgbWFya2VyIGltYWdlIHNpemVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhbmNob3IgLSBQb2ludCBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlciBhbmNob3IuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0QW5jaG9yKGFuY2hvcjogYW55KTogdm9pZCB7XHJcbiAgICAgICAgLy8gbm90IGltcGxlbWVudGVkXHJcbiAgICAgICAgLy8gVE9ETzogd2UgbmVlZCB0byBzd2l0Y2ggdGhlIG1vZGVsIHRvIGNvbXBsZXggaWNvbnMgZm9yIGdvb2dsZSB0b1xyXG4gICAgICAgIC8vIHN1cHBvcnQgYW5jaG9ycywgc2l6ZXMgYW5kIG9yaWdpbnMuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvbWFya2Vyc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZHJhZ2dhYmlsaXR5IG9mIGEgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkcmFnZ2FibGUgLSBUcnVlIHRvIG1hcmsgdGhlIG1hcmtlciBhcyBkcmFnZ2FibGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXREcmFnZ2FibGUoZHJhZ2dhYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbWFya2VyLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaWNvbiBmb3IgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWNvbiAtIFN0cmluZyBjb250YWluaW5nIHRoZSBpY29uIGluIHZhcmlvdXMgZm9ybXMgKHVybCwgZGF0YSB1cmwsIGV0Yy4pXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0SWNvbihpY29uOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9tYXJrZXIuc2V0SWNvbihpY29uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1hcmtlciBsYWJlbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGFiZWwgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgbGFiZWwgdG8gc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldExhYmVsKGxhYmVsOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9tYXJrZXIuc2V0TGFiZWwobGFiZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWFya2VyIHBvc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXRMbmcgLSBHZW8gY29vcmRpbmF0ZXMgdG8gc2V0IHRoZSBtYXJrZXIgcG9zaXRpb24gdG8uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0UG9zaXRpb24obGF0TG5nOiBJTGF0TG9uZyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHA6IEdvb2dsZU1hcFR5cGVzLkxhdExuZyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0KGxhdExuZyk7XHJcbiAgICAgICAgdGhpcy5fbWFya2VyLnNldFBvc2l0aW9uKHApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWFya2VyIHRpdGxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0aXRsZSAtIFN0cmluZyBjb250YWluaW5nIHRoZSB0aXRsZSB0byBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0VGl0bGUodGl0bGU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX21hcmtlci5zZXRUaXRsZSh0aXRsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXJrZXIgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJTWFya2VyT3B0aW9uc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcmtlciBvcHRpb25zIHRvIHNldC4gVGhlIHN1cHBsaWVkIG9wdGlvbnMgYXJlXHJcbiAgICAgKiBtZXJnZWQgd2l0aCB0aGUgdW5kZXJseWluZyBtYXJrZXIgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRPcHRpb25zKG9wdGlvbnM6IElNYXJrZXJPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFya2VyT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU1hcmtlck9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fbWFya2VyLnNldE9wdGlvbnMobyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIG1hcmtlciBpcyB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2aXNpYmxlIC0gVHJ1ZSB0byBzZXQgdGhlIG1hcmtlciB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbWFya2VyLnNldFZpc2libGUodmlzaWJsZSk7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCAqIGFzIEdvb2dsZU1hcFR5cGVzIGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLXR5cGVzJztcclxuaW1wb3J0IHsgTWFwTGFiZWwgfSBmcm9tICcuLi9tYXAtbGFiZWwnO1xyXG5pbXBvcnQgeyBJTGFiZWxPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGFiZWwtb3B0aW9ucyc7XHJcbmRlY2xhcmUgdmFyIGdvb2dsZTogYW55O1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgbWFwIGEgbGFibGVkIHRvIGJlIHBsYWNlZCBvbiB0aGUgbWFwLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR29vZ2xlTWFwTGFiZWwgZXh0ZW5kcyBNYXBMYWJlbCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGxhYmVsIHN0eWxlIGZvciB0aGUgcGxhdGZvcm1cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcExhYmVsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgRGVmYXVsdExhYmVsU3R5bGUoKTogSUxhYmVsT3B0aW9ucyB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxyXG4gICAgICAgICAgICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXHJcbiAgICAgICAgICAgIGZvbnRDb2xvcjogJyNmZmZmZmYnLFxyXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDMsXHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiAnIzAwMDAwMCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWFwTGFiZWxcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIHByb3BlcnRpZXMgdG8gc2V0LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSB7XHJcbiAgICAgICAgb3B0aW9ucy5mb250U2l6ZSA9IG9wdGlvbnMuZm9udFNpemUgfHwgMTI7XHJcbiAgICAgICAgb3B0aW9ucy5mb250Q29sb3IgPSBvcHRpb25zLmZvbnRDb2xvciB8fCAnI2ZmZmZmZic7XHJcbiAgICAgICAgb3B0aW9ucy5zdHJva2VXZWlnaHQgPSBvcHRpb25zLnN0cm9rZVdlaWdodCB8fCAzO1xyXG4gICAgICAgIG9wdGlvbnMuc3Ryb2tlQ29sb3IgPSBvcHRpb25zLnN0cm9rZUNvbG9yIHx8ICcjMDAwMDAwJztcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHNldHRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSBzcGVjaWZ5aW5nIHRoZSBzZXR0aW5nLlxyXG4gICAgICogQHJldHVybnMgLSBUaGUgdmFsdWUgb2YgdGhlIHNldHRpbmcuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGFiZWxcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldChrZXk6IHN0cmluZyk6IGFueSB7XHJcbiAgICAgICAgcmV0dXJuICg8YW55PnRoaXMpLmdldChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbWFwIGFzc29jaXRlZCB3aXRoIHRoZSBsYWJlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwTGFiZWxcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldE1hcCgpOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXAge1xyXG4gICAgICAgIHJldHVybiAoPGFueT50aGlzKS5nZXRNYXAoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgdmFsdWUgZm9yIGEgc2V0dGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gS2V5IHNwZWNpZnlpbmcgdGhlIHNldHRpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbHVlIHRvIHNldC5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0KGtleTogc3RyaW5nLCB2YWw6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgJiYgdmFsLmhhc093blByb3BlcnR5KCdsYXRpdHVkZScpICYmIHZhbC5oYXNPd25Qcm9wZXJ0eSgnbG9uZ2l0dWRlJykpIHtcclxuICAgICAgICAgICAgdmFsID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyh2YWwubGF0aXR1ZGUsIHZhbC5sb25naXR1ZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5HZXQoa2V5KSAhPT0gdmFsKSB7XHJcbiAgICAgICAgICAgICg8YW55PnRoaXMpLnNldChrZXksIHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWFwIGZvciB0aGUgbGFiZWwuIFNldHRpbmdzIHRoaXMgdG8gbnVsbCByZW1vdmUgdGhlIGxhYmVsIGZyb20gaHRlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFwIC0gTWFwIHRvIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGFiZWwuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwTGFiZWxcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE1hcChtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCk6IHZvaWQge1xyXG4gICAgICAgICg8YW55PnRoaXMpLnNldE1hcChtYXApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBzZXR0aW5ncyB0byB0aGUgb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgc2V0dGluZ3Mga2V5IHZhbHVlIHBhaXJzLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRWYWx1ZXMob3B0aW9uczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSk6IHZvaWQge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKGtleSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgJiYgIG9wdGlvbnNba2V5XS5oYXNPd25Qcm9wZXJ0eSgnbGF0aXR1ZGUnKSAmJiAgb3B0aW9uc1trZXldLmhhc093blByb3BlcnR5KCdsb25naXR1ZGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoIG9wdGlvbnNba2V5XS5sYXRpdHVkZSwgIG9wdGlvbnNba2V5XS5sb25naXR1ZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuR2V0KGtleSkgPT09IG9wdGlvbnNba2V5XSkgeyBkZWxldGUgb3B0aW9uc1trZXldOyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgKDxhbnk+dGhpcykuc2V0VmFsdWVzKG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3RlY3RlZCBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBsYWJlbCBvbiB0aGUgbWFwLlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcExhYmVsXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBEcmF3KCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSAoPGFueT50aGlzKS5nZXRQcm9qZWN0aW9uKCk7XHJcbiAgICAgICAgY29uc3QgdmlzaWJpbGl0eTogc3RyaW5nID0gdGhpcy5HZXRWaXNpYmxlKCk7XHJcbiAgICAgICAgaWYgKCFwcm9qZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBtYXAgcHJvamVjdGlvbiBpcyBub3QgcmVhZHkgeWV0IHNvIGRvIG5vdGhpbmdcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2NhbnZhcykge1xyXG4gICAgICAgICAgICAvLyBvbkFkZCBoYXMgbm90IGJlZW4gY2FsbGVkIHlldC5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9IHRoaXMuX2NhbnZhcy5zdHlsZTtcclxuICAgICAgICBpZiAodmlzaWJpbGl0eSAhPT0gJycpIHtcclxuICAgICAgICAgICAgLy8gbGFiZWwgaXMgbm90IHZpc2libGUsIGRvbid0IGNhbGN1bGF0ZSBwb3NpdGlvbnMgZXRjLlxyXG4gICAgICAgICAgICBzdHlsZVsndmlzaWJpbGl0eSddID0gdmlzaWJpbGl0eTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG9mZnNldDogR29vZ2xlTWFwVHlwZXMuUG9pbnQgPSB0aGlzLkdldCgnb2Zmc2V0Jyk7XHJcbiAgICAgICAgbGV0IGxhdExuZzogR29vZ2xlTWFwVHlwZXMuTGF0TG5nfEdvb2dsZU1hcFR5cGVzLkxhdExuZ0xpdGVyYWwgPSB0aGlzLkdldCgncG9zaXRpb24nKTtcclxuICAgICAgICBpZiAoIWxhdExuZykgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAoIShsYXRMbmcgaW5zdGFuY2VvZiBnb29nbGUubWFwcy5MYXRMbmcpKSB7IGxhdExuZyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcobGF0TG5nLmxhdCwgbGF0TG5nLmxuZyk7IH1cclxuICAgICAgICBpZiAoIW9mZnNldCkgeyBvZmZzZXQgPSBuZXcgZ29vZ2xlLm1hcHMuUG9pbnQoMCwgMCk7IH1cclxuXHJcbiAgICAgICAgY29uc3QgcG9zID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbChsYXRMbmcpO1xyXG4gICAgICAgIHN0eWxlWyd0b3AnXSA9IChwb3MueSArIG9mZnNldC55KSArICdweCc7XHJcbiAgICAgICAgc3R5bGVbJ2xlZnQnXSA9IChwb3MueCArIG9mZnNldC54KSArICdweCc7XHJcbiAgICAgICAgc3R5bGVbJ3Zpc2liaWxpdHknXSA9IHZpc2liaWxpdHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBjYWxsZWQgd2hlbiB0aGUgbGFiZWwgaXMgYWRkZWQgdG8gdGhlIG1hcC4gR2VuZXJhdGVzIGFuZCBjb25maWd1cmVzXHJcbiAgICAgKiB0aGUgY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBMYWJlbFxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgT25BZGQoKSB7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgY29uc3Qgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24gPSB0aGlzLl9jYW52YXMuc3R5bGU7XHJcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5cclxuICAgICAgICBjb25zdCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XHJcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xyXG5cclxuICAgICAgICB0aGlzLkRyYXdDYW52YXMoKTtcclxuICAgICAgICBjb25zdCBwYW5lcyA9ICg8YW55PnRoaXMpLmdldFBhbmVzKCk7XHJcbiAgICAgICAgaWYgKHBhbmVzKSB7XHJcbiAgICAgICAgICAgIHBhbmVzLm92ZXJsYXlMYXllci5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgLy8gNDogZmxvYXRQYW5lIChpbmZvd2luZG93KVxyXG4gICAgICAgICAgICAgICAgLy8gMzogb3ZlcmxheU1vdXNlVGFyZ2V0IChtb3VzZSBldmVudHMpXHJcbiAgICAgICAgICAgICAgICAvLyAyOiBtYXJrZXJMYXllciAobWFya2VyIGltYWdlcylcclxuICAgICAgICAgICAgICAgIC8vIDE6IG92ZXJsYXlMYXllciAocG9seWdvbnMsIHBvbHlsaW5lcywgZ3JvdW5kIG92ZXJsYXlzLCB0aWxlIGxheWVyIG92ZXJsYXlzKVxyXG4gICAgICAgICAgICAgICAgLy8gMDogbWFwUGFuZSAobG93ZXN0IHBhbmUgYWJvdmUgdGhlIG1hcCB0aWxlcylcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZXh0ZW5kIHRoZSBPdmVybGF5VmlldyBpbnRvIHRoZSBNYXBMYWJlbFxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBtZXRob2RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBNaXhpbk1hcExhYmVsV2l0aE92ZXJsYXlWaWV3KCkge1xyXG4gICAgY29uc3QgeCA9IEdvb2dsZU1hcExhYmVsLnByb3RvdHlwZTtcclxuICAgIEdvb2dsZU1hcExhYmVsLnByb3RvdHlwZSA9IG5ldyBnb29nbGUubWFwcy5PdmVybGF5VmlldztcclxuICAgIGZvciAoY29uc3QgeSBpbiB4KSB7IGlmICgoPGFueT54KVt5XSAhPSBudWxsKSB7ICg8YW55Pkdvb2dsZU1hcExhYmVsLnByb3RvdHlwZSlbeV0gPSAoPGFueT54KVt5XTsgfX1cclxuICAgICg8YW55Pkdvb2dsZU1hcExhYmVsLnByb3RvdHlwZSlbJ2NoYW5nZWQnXSA9IHhbJ0NoYW5nZWQnXTtcclxuICAgICg8YW55Pkdvb2dsZU1hcExhYmVsLnByb3RvdHlwZSlbJ29uQWRkJ10gPSB4WydPbkFkZCddO1xyXG4gICAgKDxhbnk+R29vZ2xlTWFwTGFiZWwucHJvdG90eXBlKVsnZHJhdyddID0geFsnRHJhdyddO1xyXG4gICAgKDxhbnk+R29vZ2xlTWFwTGFiZWwucHJvdG90eXBlKVsnb25SZW1vdmUnXSA9IHhbJ09uUmVtb3ZlJ107XHJcbn1cclxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlnb25FdmVudCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlnb24tZXZlbnQnO1xyXG5pbXBvcnQgeyBHb29nbGVDb252ZXJzaW9ucyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtY29udmVyc2lvbnMnO1xyXG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vcG9seWdvbic7XHJcbmltcG9ydCB7IEdvb2dsZU1hcExhYmVsIH0gZnJvbSAnLi9nb29nbGUtbGFiZWwnO1xyXG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuLi8uLi9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLW1hcC10eXBlcyc7XHJcblxyXG5kZWNsYXJlIHZhciBnb29nbGU6IGFueTtcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBmb3IgYSBwb2x5Z29uIG1vZGVsIGZvciBHb29nbGUgTWFwcy5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdvb2dsZVBvbHlnb24gZXh0ZW5kcyBQb2x5Z29uIGltcGxlbWVudHMgUG9seWdvbiB7XHJcblxyXG4gICAgcHJpdmF0ZSBfdGl0bGU6IHN0cmluZyA9ICcnO1xyXG4gICAgcHJpdmF0ZSBfc2hvd0xhYmVsOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9zaG93VG9vbHRpcDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfbWF4Wm9vbTogbnVtYmVyID0gLTE7XHJcbiAgICBwcml2YXRlIF9taW5ab29tOiBudW1iZXIgPSAtMTtcclxuICAgIHByaXZhdGUgX2xhYmVsOiBHb29nbGVNYXBMYWJlbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIF90b29sdGlwOiBHb29nbGVNYXBMYWJlbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIF90b29sdGlwVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfaGFzVG9vbFRpcFJlY2VpdmVyOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9vcmlnaW5hbFBhdGg6IEFycmF5PEFycmF5PElMYXRMb25nPj47XHJcbiAgICBwcml2YXRlIF9tb3VzZU92ZXJMaXN0ZW5lcjogR29vZ2xlTWFwVHlwZXMuTWFwc0V2ZW50TGlzdGVuZXIgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfbW91c2VPdXRMaXN0ZW5lcjogR29vZ2xlTWFwVHlwZXMuTWFwc0V2ZW50TGlzdGVuZXIgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfbW91c2VNb3ZlTGlzdGVuZXI6IEdvb2dsZU1hcFR5cGVzLk1hcHNFdmVudExpc3RlbmVyID0gbnVsbDtcclxuICAgIHByaXZhdGUgX21ldGFkYXRhOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcclxuICAgIHByaXZhdGUgX2VkaXRpbmdDb21wbGV0ZUVtaXR0ZXI6IChldmVudDogSVBvbHlnb25FdmVudCkgPT4gdm9pZCA9IG51bGw7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4aW11bSB6b29tIGF0IHdoaWNoIHRoZSBsYWJlbCBpcyBkaXNwbGF5ZWQuIElnbm9yZWQgb3IgU2hvd0xhYmVsIGlzIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBMYWJlbE1heFpvb20oKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX21heFpvb207IH1cclxuICAgIHB1YmxpYyBzZXQgTGFiZWxNYXhab29tKHZhbDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5fbWF4Wm9vbSA9IHZhbDtcclxuICAgICAgICB0aGlzLk1hbmFnZUxhYmVsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gem9vbSBhdCB3aGljaCB0aGUgbGFiZWwgaXMgZGlzcGxheWVkLiBJZ25vcmVkIG9yIFNob3dMYWJlbCBpcyBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTGFiZWxNaW5ab29tKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9taW5ab29tOyB9XHJcbiAgICBwdWJsaWMgc2V0IExhYmVsTWluWm9vbSh2YWw6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX21pblpvb20gPSB2YWw7XHJcbiAgICAgICAgdGhpcy5NYW5hZ2VMYWJlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9seWdvbiBtZXRhZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBHb29sZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBNZXRhZGF0YSgpOiBNYXA8c3RyaW5nLCBhbnk+IHsgcmV0dXJuIHRoaXMuX21ldGFkYXRhOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgcHJpbWl0dmUgaW1wbGVtZW50aW5nIHRoZSBwb2x5Z29uLCBpbiB0aGlzIGNhc2Uge0BsaW5rIEdvb2dsZU1hcFR5cGVzLlBvbHlnb259XHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IEdvb2dsZU1hcFR5cGVzLlBvbHlnb24geyByZXR1cm4gdGhpcy5fcG9seWdvbjsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gc2hvdyB0aGUgbGFiZWxcclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXHJcbiAgICAgKiBAcHJvcGVydHlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBTaG93TGFiZWwoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9zaG93TGFiZWw7IH1cclxuICAgIHB1YmxpYyBzZXQgU2hvd0xhYmVsKHZhbDogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuX3Nob3dMYWJlbCA9IHZhbDtcclxuICAgICAgICB0aGlzLk1hbmFnZUxhYmVsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0byBzaG93IHRoZSB0b29sdGlwXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgU2hvd1Rvb2x0aXAoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9zaG93VG9vbHRpcDsgfVxyXG4gICAgcHVibGljIHNldCBTaG93VG9vbHRpcCh2YWw6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLl9zaG93VG9vbHRpcCA9IHZhbDtcclxuICAgICAgICB0aGlzLk1hbmFnZVRvb2x0aXAoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgdGl0bGUgb2ZmIHRoZSBwb2x5Z29uXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICogQHByb3BlcnR5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgVGl0bGUoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX3RpdGxlOyB9XHJcbiAgICBwdWJsaWMgc2V0IFRpdGxlKHZhbDogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fdGl0bGUgPSB2YWw7XHJcbiAgICAgICAgdGhpcy5NYW5hZ2VMYWJlbCgpO1xyXG4gICAgICAgIHRoaXMuTWFuYWdlVG9vbHRpcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIGNvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlUG9seWdvbi5cclxuICAgICAqIEBwYXJhbSBfcG9seWdvbiAtIFRoZSB7QGxpbmsgR29vZ2xlTWFwVHlwZXMuUG9seWdvbn0gdW5kZXJseWluZyB0aGUgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcG9seWdvbjogR29vZ2xlTWFwVHlwZXMuUG9seWdvbikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxQYXRoID0gdGhpcy5HZXRQYXRocygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGRlbGVnYXRlIGZvciBhbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gZm4gLSBEZWxlZ2F0ZSBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cclxuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkTGlzdGVuZXIoZXZlbnRUeXBlOiBzdHJpbmcsIGZuOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZEV2ZW50cyA9IFtcclxuICAgICAgICAgICAgJ2NsaWNrJyxcclxuICAgICAgICAgICAgJ2RibGNsaWNrJyxcclxuICAgICAgICAgICAgJ2RyYWcnLCAnZHJhZ2VuZCcsXHJcbiAgICAgICAgICAgICdkcmFnc3RhcnQnLFxyXG4gICAgICAgICAgICAnbW91c2Vkb3duJyxcclxuICAgICAgICAgICAgJ21vdXNlbW92ZScsXHJcbiAgICAgICAgICAgICdtb3VzZW91dCcsXHJcbiAgICAgICAgICAgICdtb3VzZW92ZXInLFxyXG4gICAgICAgICAgICAnbW91c2V1cCcsXHJcbiAgICAgICAgICAgICdyaWdodGNsaWNrJ1xyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKHN1cHBvcnRlZEV2ZW50cy5pbmRleE9mKGV2ZW50VHlwZSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvbHlnb24uYWRkTGlzdGVuZXIoZXZlbnRUeXBlLCBmbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudFR5cGUgPT09ICdwYXRoY2hhbmdlZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5fZWRpdGluZ0NvbXBsZXRlRW1pdHRlciA9IDwoZXZlbnQ6IElQb2x5Z29uRXZlbnQpID0+IHZvaWQ+Zm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlZCB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3BvbHlnb24uc2V0TWFwKG51bGwpO1xyXG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCkgeyB0aGlzLl9sYWJlbC5EZWxldGUoKTsgfVxyXG4gICAgICAgIGlmICh0aGlzLl90b29sdGlwKSB7IHRoaXMuX3Rvb2x0aXAuRGVsZXRlKCk7IH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWdvbiBpcyBkcmFnZ2FibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5Z29uIGlzIGRyYWdhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldERyYWdnYWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbi5nZXREcmFnZ2FibGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgcG9seWdvbiBwYXRoIGNhbiBiZSBlZGl0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwYXRoIGNhbiBiZSBlZGl0ZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0RWRpdGFibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb24uZ2V0RWRpdGFibGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlnb24gcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0cyBkZXNjcmliaW5nIHRoZSBwb2x5Z29uIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFBhdGgoKTogQXJyYXk8SUxhdExvbmc+IHtcclxuICAgICAgICBjb25zdCBwOiBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+ID0gdGhpcy5fcG9seWdvbi5nZXRQYXRoKCk7XHJcbiAgICAgICAgY29uc3QgcGF0aDogQXJyYXk8SUxhdExvbmc+ID0gbmV3IEFycmF5PElMYXRMb25nPigpO1xyXG4gICAgICAgIHAuZm9yRWFjaCh4ID0+IHBhdGgucHVzaCh7IGxhdGl0dWRlOiB4LmxhdCgpLCBsb25naXR1ZGU6IHgubG5nKCkgfSkpO1xyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9seWdvbiBwYXRocy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEFycmF5IG9mIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0cyBkZXNjcmliaW5nIG11bHRpcGxlIHBvbHlnb24gcGF0aHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFBhdGhzKCk6IEFycmF5PEFycmF5PElMYXRMb25nPj4ge1xyXG4gICAgICAgIGNvbnN0IHA6IEFycmF5PEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4+ID0gdGhpcy5fcG9seWdvbi5nZXRQYXRocygpO1xyXG4gICAgICAgIGNvbnN0IHBhdGhzOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+ID0gbmV3IEFycmF5PEFycmF5PElMYXRMb25nPj4oKTtcclxuICAgICAgICBwLmZvckVhY2goeCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGg6IEFycmF5PElMYXRMb25nPiA9IG5ldyBBcnJheTxJTGF0TG9uZz4oKTtcclxuICAgICAgICAgICAgeC5mb3JFYWNoKHkgPT4gcGF0aC5wdXNoKHsgbGF0aXR1ZGU6IHkubGF0KCksIGxvbmdpdHVkZTogeS5sbmcoKSB9KSk7XHJcbiAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwb2x5Z29uIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0VmlzaWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbi5nZXRWaXNpYmxlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgZHJhZ2FibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRyYWdnYWJsZSAtIFRydWUgdG8gbWFrZSB0aGUgcG9seWdvbiBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXREcmFnZ2FibGUoZHJhZ2dhYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fcG9seWdvbi5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2V0aGVyIHRoZSBwb2x5Z29uIHBhdGggaXMgZWRpdGFibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVkaXRhYmxlIC0gVHJ1ZSB0byBtYWtlIHBvbHlnb24gcGF0aCBlZGl0YWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRFZGl0YWJsZShlZGl0YWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5fcG9seWdvbi5nZXRFZGl0YWJsZSgpO1xyXG4gICAgICAgIHRoaXMuX3BvbHlnb24uc2V0RWRpdGFibGUoZWRpdGFibGUpO1xyXG4gICAgICAgIGlmIChwcmV2aW91cyAmJiAhZWRpdGFibGUgJiYgdGhpcy5fZWRpdGluZ0NvbXBsZXRlRW1pdHRlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9lZGl0aW5nQ29tcGxldGVFbWl0dGVyKHtcclxuICAgICAgICAgICAgICAgIENsaWNrOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgUG9seWdvbjogdGhpcyxcclxuICAgICAgICAgICAgICAgIE9yaWdpbmFsUGF0aDogdGhpcy5fb3JpZ2luYWxQYXRoLFxyXG4gICAgICAgICAgICAgICAgTmV3UGF0aDogdGhpcy5HZXRQYXRocygpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFBhdGggPSB0aGlzLkdldFBhdGhzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9seWdvbiBvcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSUxhdExvbmd9IG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zLiBUaGUgb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggaHRlIG9uZXNcclxuICAgICAqIGFscmVhZHkgb24gdGhlIHVuZGVybHlpbmcgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMob3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuUG9seWdvbk9wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5Z29uT3B0aW9ucyhvcHRpb25zKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvLmVkaXRhYmxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLlNldEVkaXRhYmxlKG8uZWRpdGFibGUpO1xyXG4gICAgICAgICAgICBkZWxldGUgby5lZGl0YWJsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3BvbHlnb24uc2V0T3B0aW9ucyhvKTtcclxuICAgICAgICBpZiAob3B0aW9ucy52aXNpYmxlICE9IG51bGwgJiYgdGhpcy5fc2hvd0xhYmVsICYmIHRoaXMuX2xhYmVsKSB7IHRoaXMuX2xhYmVsLlNldCgnaGlkZGVuJywgIW9wdGlvbnMudmlzaWJsZSk7IH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvbHlnb24gcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIEFuIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ30gKG9yIGFycmF5IG9mIGFycmF5cykgZGVzY3JpYmluZyB0aGUgcG9seWdvbnMgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0UGF0aChwYXRoOiBBcnJheTxJTGF0TG9uZz4pOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBwOiBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+ID0gbmV3IEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4oKTtcclxuICAgICAgICBwYXRoLmZvckVhY2goeCA9PiBwLnB1c2gobmV3IGdvb2dsZS5tYXBzLkxhdExuZyh4LmxhdGl0dWRlLCB4LmxvbmdpdHVkZSkpKTtcclxuICAgICAgICB0aGlzLl9wb2x5Z29uLnNldFBhdGgocCk7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxQYXRoID0gW3BhdGhdO1xyXG4gICAgICAgIGlmICh0aGlzLl9sYWJlbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jZW50cm9pZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuTWFuYWdlTGFiZWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHBvbHlnb24gcGF0aCBvciBwYXRocy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aHMgQW4gQXJyYXkgb2Yge0BsaW5rIElMYXRMb25nfVxyXG4gICAgICogKG9yIGFycmF5IG9mIGFycmF5cykgZGVzY3JpYmluZyB0aGUgcG9seWdvbnMgcGF0aChzKS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0UGF0aHMocGF0aHM6IEFycmF5PEFycmF5PElMYXRMb25nPj4gfCBBcnJheTxJTGF0TG9uZz4pOiB2b2lkIHtcclxuICAgICAgICBpZiAocGF0aHMgPT0gbnVsbCkgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aHMpKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRQYXRocyhuZXcgQXJyYXk8R29vZ2xlTWFwVHlwZXMuTGF0TG5nPigpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbC5EZWxldGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGhzWzBdKSkge1xyXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3IgYXJyYXlzXHJcbiAgICAgICAgICAgIGNvbnN0IHA6IEFycmF5PEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4+ID0gbmV3IEFycmF5PEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4+KCk7XHJcbiAgICAgICAgICAgICg8QXJyYXk8QXJyYXk8SUxhdExvbmc+Pj5wYXRocykuZm9yRWFjaChwYXRoID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IF9wOiBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+ID0gbmV3IEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4oKTtcclxuICAgICAgICAgICAgICAgIHBhdGguZm9yRWFjaCh4ID0+IF9wLnB1c2gobmV3IGdvb2dsZS5tYXBzLkxhdExuZyh4LmxhdGl0dWRlLCB4LmxvbmdpdHVkZSkpKTtcclxuICAgICAgICAgICAgICAgIHAucHVzaChfcCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29uLnNldFBhdGhzKHApO1xyXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFBhdGggPSA8QXJyYXk8QXJyYXk8SUxhdExvbmc+Pj5wYXRocztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jZW50cm9pZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLk1hbmFnZUxhYmVsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXIgaXMgYSBzaW1wbGUgYXJyYXkuLi4uXHJcbiAgICAgICAgICAgIHRoaXMuU2V0UGF0aCg8QXJyYXk8SUxhdExvbmc+PnBhdGhzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgdmlzaWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSAtIFRydWUgdG8gc2V0IHRoZSBwb2x5Z29uIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fcG9seWdvbi5zZXRWaXNpYmxlKHZpc2libGUpO1xyXG4gICAgICAgIGlmICh0aGlzLl9zaG93TGFiZWwgJiYgdGhpcy5fbGFiZWwpIHsgdGhpcy5fbGFiZWwuU2V0KCdoaWRkZW4nLCAhdmlzaWJsZSk7IH1cclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcml2YXRlIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uZmlndXJlcyB0aGUgbGFiZWwgZm9yIHRoZSBwb2x5Z29uXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIE1hbmFnZUxhYmVsKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLkdldFBhdGggPT0gbnVsbCB8fCB0aGlzLkdldFBhdGgoKS5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dMYWJlbCAmJiB0aGlzLl90aXRsZSAhPSBudWxsICYmIHRoaXMuX3RpdGxlICE9PSAnJykge1xyXG4gICAgICAgICAgICBjb25zdCBvOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fdGl0bGUsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb25PYmplY3QodGhpcy5DZW50cm9pZClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKG8ucG9zaXRpb24gPT0gbnVsbCkgeyByZXR1cm47IH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX21pblpvb20gIT09IC0xKSB7IG8ubWluWm9vbSA9IHRoaXMuX21pblpvb207IH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX21heFpvb20gIT09IC0xKSB7IG8ubWF4Wm9vbSA9IHRoaXMuX21heFpvb207IH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG8ubWFwID0gdGhpcy5OYXRpdmVQcmltaXR2ZS5nZXRNYXAoKTtcclxuICAgICAgICAgICAgICAgIG8uekluZGV4ID0gdGhpcy5OYXRpdmVQcmltaXR2ZS56SW5kZXggPyB0aGlzLk5hdGl2ZVByaW1pdHZlLnpJbmRleCArIDEgOiAxMDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYWJlbCA9IG5ldyBHb29nbGVNYXBMYWJlbChvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLlNldFZhbHVlcyhvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sYWJlbC5TZXQoJ2hpZGRlbicsICF0aGlzLkdldFZpc2libGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsLlNldE1hcChudWxsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgdGhlIHRvb2x0aXAgZm9yIHRoZSBwb2x5Z29uXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIE1hbmFnZVRvb2x0aXAoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dUb29sdGlwICYmIHRoaXMuX3RpdGxlICE9IG51bGwgJiYgdGhpcy5fdGl0bGUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG86IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLl90aXRsZSxcclxuICAgICAgICAgICAgICAgIGFsaWduOiAnbGVmdCcsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG5ldyBnb29nbGUubWFwcy5Qb2ludCgwLCAyNSksXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiaXNxdWUnLFxyXG4gICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDEyLFxyXG4gICAgICAgICAgICAgICAgZm9udENvbG9yOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXAgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgby5tYXAgPSB0aGlzLk5hdGl2ZVByaW1pdHZlLmdldE1hcCgpO1xyXG4gICAgICAgICAgICAgICAgby56SW5kZXggPSAxMDAwMDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwID0gbmV3IEdvb2dsZU1hcExhYmVsKG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXRWYWx1ZXMobyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlT3Zlckxpc3RlbmVyID0gdGhpcy5OYXRpdmVQcmltaXR2ZS5hZGRMaXN0ZW5lcignbW91c2VvdmVyJywgKGU6IEdvb2dsZU1hcFR5cGVzLk1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBlLmxhdExuZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90b29sdGlwVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lciA9IHRoaXMuTmF0aXZlUHJpbWl0dmUuYWRkTGlzdGVuZXIoJ21vdXNlbW92ZScsIChlOiBHb29nbGVNYXBUeXBlcy5Nb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7IHRoaXMuX3Rvb2x0aXAuU2V0KCdwb3NpdGlvbicsIGUubGF0TG5nKTsgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZU91dExpc3RlbmVyID0gdGhpcy5OYXRpdmVQcmltaXR2ZS5hZGRMaXN0ZW5lcignbW91c2VvdXQnLCAoZTogR29vZ2xlTWFwVHlwZXMuTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUb29sVGlwUmVjZWl2ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoIXRoaXMuX3Nob3dUb29sdGlwIHx8IHRoaXMuX3RpdGxlID09PSAnJyB8fCB0aGlzLl90aXRsZSA9PSBudWxsKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW91c2VPdXRMaXN0ZW5lcikgeyBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9tb3VzZU91dExpc3RlbmVyKTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlT3Zlckxpc3RlbmVyKSB7IGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX21vdXNlT3Zlckxpc3RlbmVyKTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyKSB7IGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX21vdXNlTW92ZUxpc3RlbmVyKTsgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0TWFwKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcclxuaW1wb3J0IHsgR29vZ2xlQ29udmVyc2lvbnMgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWNvbnZlcnNpb25zJztcclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5pbXBvcnQgeyBHb29nbGVNYXBMYWJlbCB9IGZyb20gJy4vZ29vZ2xlLWxhYmVsJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi9wb2x5bGluZSc7XHJcblxyXG5kZWNsYXJlIHZhciBnb29nbGU6IGFueTtcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBmb3IgYSBwb2x5bGluZSBtb2RlbCBmb3IgR29vZ2xlIE1hcHMuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVQb2x5bGluZSBleHRlbmRzIFBvbHlsaW5lIGltcGxlbWVudHMgUG9seWxpbmUge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF90aXRsZTogc3RyaW5nID0gJyc7XHJcbiAgICBwcml2YXRlIF9zaG93VG9vbHRpcDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcDogR29vZ2xlTWFwTGFiZWwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcFZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2hhc1Rvb2xUaXBSZWNlaXZlcjogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfbW91c2VPdmVyTGlzdGVuZXI6IEdvb2dsZU1hcFR5cGVzLk1hcHNFdmVudExpc3RlbmVyID0gbnVsbDtcclxuICAgIHByaXZhdGUgX21vdXNlT3V0TGlzdGVuZXI6IEdvb2dsZU1hcFR5cGVzLk1hcHNFdmVudExpc3RlbmVyID0gbnVsbDtcclxuICAgIHByaXZhdGUgX21vdXNlTW92ZUxpc3RlbmVyOiBHb29nbGVNYXBUeXBlcy5NYXBzRXZlbnRMaXN0ZW5lciA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9tZXRhZGF0YTogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvbHlsaW5lIG1ldGFkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTWV0YWRhdGEoKTogTWFwPHN0cmluZywgYW55PiB7IHJldHVybiB0aGlzLl9tZXRhZGF0YTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIHByaW1pdHZlIGltcGxlbWVudGluZyB0aGUgbWFya2VyLCBpbiB0aGlzIGNhc2Uge0BsaW5rIEdvb2dsZU1BcFR5cGVzLlBvbHlsaW5lfVxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBOYXRpdmVQcmltaXR2ZSgpOiBHb29nbGVNYXBUeXBlcy5Qb2x5bGluZSB7IHJldHVybiB0aGlzLl9wb2x5bGluZTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gc2hvdyB0aGUgdG9vbHRpcFxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IFNob3dUb29sdGlwKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc2hvd1Rvb2x0aXA7IH1cclxuICAgIHB1YmxpYyBzZXQgU2hvd1Rvb2x0aXAodmFsOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXAgPSB2YWw7XHJcbiAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHRpdGxlIG9mZiB0aGUgcG9seWdvblxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25cclxuICAgICAqIEBwcm9wZXJ0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IFRpdGxlKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl90aXRsZTsgfVxyXG4gICAgcHVibGljIHNldCBUaXRsZSh2YWw6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX3RpdGxlID0gdmFsO1xyXG4gICAgICAgIHRoaXMuTWFuYWdlVG9vbHRpcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIGNvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZVBvbHlnb24uXHJcbiAgICAgKiBAcGFyYW0gX3BvbHlsaW5lIC0gVGhlIHtAbGluayBHb29nbGVNQXBUeXBlcy5Qb2x5bGluZX0gdW5kZXJseWluZyB0aGUgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BvbHlsaW5lOiBHb29nbGVNYXBUeXBlcy5Qb2x5bGluZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgZGVsZWdhdGUgZm9yIGFuIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBTdHJpbmcgY29udGFpbmluZyB0aGUgZXZlbnQgbmFtZS5cclxuICAgICAqIEBwYXJhbSBmbiAtIERlbGVnYXRlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMaXN0ZW5lcihldmVudFR5cGU6IHN0cmluZywgZm46IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgc3VwcG9ydGVkRXZlbnRzID0gW1xyXG4gICAgICAgICAgICAnY2xpY2snLFxyXG4gICAgICAgICAgICAnZGJsY2xpY2snLFxyXG4gICAgICAgICAgICAnZHJhZycsICdkcmFnZW5kJyxcclxuICAgICAgICAgICAgJ2RyYWdzdGFydCcsXHJcbiAgICAgICAgICAgICdtb3VzZWRvd24nLFxyXG4gICAgICAgICAgICAnbW91c2Vtb3ZlJyxcclxuICAgICAgICAgICAgJ21vdXNlb3V0JyxcclxuICAgICAgICAgICAgJ21vdXNlb3ZlcicsXHJcbiAgICAgICAgICAgICdtb3VzZXVwJyxcclxuICAgICAgICAgICAgJ3JpZ2h0Y2xpY2snXHJcbiAgICAgICAgXTtcclxuICAgICAgICBpZiAoc3VwcG9ydGVkRXZlbnRzLmluZGV4T2YoZXZlbnRUeXBlKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9seWxpbmUuYWRkTGlzdGVuZXIoZXZlbnRUeXBlLCBmbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlZCB0aGUgcG9seWxpbmUuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lLnNldE1hcChudWxsKTtcclxuICAgICAgICBpZiAodGhpcy5fdG9vbHRpcCkgeyB0aGlzLl90b29sdGlwLkRlbGV0ZSgpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIGlzIGRyYWdnYWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIHBvbHlsaW5lIGlzIGRyYWdhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBvbHlsaW5lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXREcmFnZ2FibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lLmdldERyYWdnYWJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBwYXRoIGNhbiBiZSBlZGl0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSBwYXRoIGNhbiBiZSBlZGl0ZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldEVkaXRhYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5bGluZS5nZXRFZGl0YWJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9seWxpbmUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEFycmF5IG9mIHtAbGluayBJTGF0TG9uZ30gb2JqZWN0cyBkZXNjcmliaW5nIHRoZSBwb2x5bGluZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0UGF0aCgpOiBBcnJheTxJTGF0TG9uZz4ge1xyXG4gICAgICAgIGNvbnN0IHA6IEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4gPSB0aGlzLl9wb2x5bGluZS5nZXRQYXRoKCk7XHJcbiAgICAgICAgY29uc3QgcGF0aDogQXJyYXk8SUxhdExvbmc+ID0gbmV3IEFycmF5PElMYXRMb25nPigpO1xyXG4gICAgICAgIHAuZm9yRWFjaCh4ID0+IHBhdGgucHVzaCh7IGxhdGl0dWRlOiB4LmxhdCgpLCBsb25naXR1ZGU6IHgubG5nKCkgfSkpO1xyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgcG9seWxpbmUgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0VmlzaWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWxpbmUuZ2V0VmlzaWJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyBkcmFnYWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZHJhZ2dhYmxlIC0gVHJ1ZSB0byBtYWtlIHRoZSBwb2x5bGluZSBkcmFnYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0RHJhZ2dhYmxlKGRyYWdnYWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3ZXRoZXIgdGhlIHBvbHlsaW5lIHBhdGggaXMgZWRpdGFibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVkaXRhYmxlIC0gVHJ1ZSB0byBtYWtlIHBvbHlsaW5lIHBhdGggZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldEVkaXRhYmxlKGVkaXRhYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fcG9seWxpbmUuc2V0RWRpdGFibGUoZWRpdGFibGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9seWxpbmUgb3B0aW9uc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElMYXRMb25nfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucy4gVGhlIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGh0ZSBvbmVzXHJcbiAgICAgKiBhbHJlYWR5IG9uIHRoZSB1bmRlcmx5aW5nIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhvcHRpb25zOiBJUG9seWxpbmVPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuUG9seWxpbmVPcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWxpbmVPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lLnNldE9wdGlvbnMobyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucGF0aCkge1xyXG4gICAgICAgICAgICB0aGlzLlNldFBhdGgoPEFycmF5PElMYXRMb25nPj5vcHRpb25zLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvbHlsaW5lIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBBbiBBcnJheSBvZiB7QGxpbmsgSUxhdExvbmd9IChvciBhcnJheSBvZiBhcnJheXMpIGRlc2NyaWJpbmcgdGhlIHBvbHlsaW5lcyBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQb2x5bGluZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0UGF0aChwYXRoOiBBcnJheTxJTGF0TG9uZz4pOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBwOiBBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+ID0gbmV3IEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4oKTtcclxuICAgICAgICBwYXRoLmZvckVhY2goeCA9PiBwLnB1c2gobmV3IGdvb2dsZS5tYXBzLkxhdExuZyh4LmxhdGl0dWRlLCB4LmxvbmdpdHVkZSkpKTtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZS5zZXRQYXRoKHApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBpcyB2aXNpYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2aXNpYmxlIC0gVHJ1ZSB0byBzZXQgdGhlIHBvbHlsaW5lIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lLnNldFZpc2libGUodmlzaWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogQ29uZmlndXJlcyB0aGUgdG9vbHRpcCBmb3IgdGhlIHBvbHlsaW5lXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBNYW5hZ2VUb29sdGlwKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9zaG93VG9vbHRpcCAmJiB0aGlzLl90aXRsZSAhPSBudWxsICYmIHRoaXMuX3RpdGxlICE9PSAnJykge1xyXG4gICAgICAgICAgICBjb25zdCBvOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fdGl0bGUsXHJcbiAgICAgICAgICAgICAgICBhbGlnbjogJ2xlZnQnLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBuZXcgZ29vZ2xlLm1hcHMuUG9pbnQoMCwgMjUpLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnYmlzcXVlJyxcclxuICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMixcclxuICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogJyMwMDAwMDAnLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG8ubWFwID0gdGhpcy5OYXRpdmVQcmltaXR2ZS5nZXRNYXAoKTtcclxuICAgICAgICAgICAgICAgIG8uekluZGV4ID0gMTAwMDAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcCA9IG5ldyBHb29nbGVNYXBMYWJlbChvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0VmFsdWVzKG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZU92ZXJMaXN0ZW5lciA9IHRoaXMuTmF0aXZlUHJpbWl0dmUuYWRkTGlzdGVuZXIoJ21vdXNlb3ZlcicsIChlOiBHb29nbGVNYXBUeXBlcy5Nb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ3Bvc2l0aW9uJywgZS5sYXRMbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VNb3ZlTGlzdGVuZXIgPSB0aGlzLk5hdGl2ZVByaW1pdHZlLmFkZExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZTogR29vZ2xlTWFwVHlwZXMuTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwVmlzaWJsZSkgeyB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBlLmxhdExuZyk7IH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VPdXRMaXN0ZW5lciA9IHRoaXMuTmF0aXZlUHJpbWl0dmUuYWRkTGlzdGVuZXIoJ21vdXNlb3V0JywgKGU6IEdvb2dsZU1hcFR5cGVzLk1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVG9vbFRpcFJlY2VpdmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKCF0aGlzLl9zaG93VG9vbHRpcCB8fCB0aGlzLl90aXRsZSA9PT0gJycgfHwgdGhpcy5fdGl0bGUgPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vdXNlT3V0TGlzdGVuZXIpIHsgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5fbW91c2VPdXRMaXN0ZW5lcik7IH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU92ZXJMaXN0ZW5lcikgeyBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9tb3VzZU92ZXJMaXN0ZW5lcik7IH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lcikgeyBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9tb3VzZU1vdmVMaXN0ZW5lcik7IH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1Rvb2xUaXBSZWNlaXZlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldE1hcChudWxsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJTWFwRXZlbnRMb29rdXAgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXAtZXZlbnQtbG9va3VwJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNvbnRzdGFudCB0cmFuc2xhdGVzIHRoZSBhYnN0cmFjdCBtYXAgZXZlbnRzIGludG8gdGhlaXIgY29ycmVzcG9uZGluZyBnb29nbGUgbWFwXHJcbiAqIGVxdWl2YWxlbnRzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEdvb2dsZU1hcEV2ZW50c0xvb2t1cDogSU1hcEV2ZW50TG9va3VwID0ge1xyXG4gICAgY2xpY2sgOiAgICAgICAgICAgICAnY2xpY2snLFxyXG4gICAgZGJsY2xpY2sgOiAgICAgICAgICAnZGJsY2xpY2snLFxyXG4gICAgcmlnaHRjbGljayA6ICAgICAgICAncmlnaHRjbGljaycsXHJcbiAgICByZXNpemUgOiAgICAgICAgICAgICdyZXNpemUnLFxyXG4gICAgYm91bmRzY2hhbmdlZCA6ICAgICAnYm91bmRzX2NoYW5nZWQnLFxyXG4gICAgY2VudGVyY2hhbmdlZCA6ICAgICAnY2VudGVyX2NoYW5nZWQnLFxyXG4gICAgem9vbWNoYW5nZWQgOiAgICAgICAnem9vbV9jaGFuZ2VkJyxcclxuICAgIG1vdXNlb3ZlcjogICAgICAgICAgJ21vdXNlb3ZlcicsXHJcbiAgICBtb3VzZW91dCA6ICAgICAgICAgICdtb3VzZW91dCcsXHJcbiAgICBtb3VzZW1vdmUgOiAgICAgICAgICdtb3VzZW1vdmUnLFxyXG4gICAgaW5mb3dpbmRvd2Nsb3NlOiAgICAnY2xvc2VjbGljaydcclxufTtcclxuIiwiaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgR29vZ2xlQ29udmVyc2lvbnMgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWNvbnZlcnNpb25zJztcclxuaW1wb3J0IHsgQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uL2NhbnZhcy1vdmVybGF5JztcclxuaW1wb3J0IHsgTWFwTGFiZWwgfSBmcm9tICcuLi9tYXAtbGFiZWwnO1xyXG5pbXBvcnQgeyBHb29nbGVNYXBMYWJlbCB9IGZyb20gJy4vZ29vZ2xlLWxhYmVsJztcclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5kZWNsYXJlIHZhciBnb29nbGU6IGFueTtcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRpbmcgYSBjYW52YXMgb3ZlcmxheSB0byBiZSBwbGFjZWQgb24gdGhlIG1hcCBmb3IgR29vZ2xlIE1hcHMuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVDYW52YXNPdmVybGF5IGV4dGVuZHMgQ2FudmFzT3ZlcmxheSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gZmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX3ZpZXdDaGFuZ2VFbmRFdmVudDogR29vZ2xlTWFwVHlwZXMuTWFwc0V2ZW50TGlzdGVuZXI7XHJcbiAgICBwcml2YXRlIF9tYXBSZXNpemVFdmVudDogR29vZ2xlTWFwVHlwZXMuTWFwc0V2ZW50TGlzdGVuZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBHb29nbGVDYW52YXNPdmVybGF5IGNsYXNzLlxyXG4gICAgICogQHBhcmFtIGRyYXdDYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNhbnZhcyBpcyByZWFkeSB0byBiZVxyXG4gICAgICogcmVuZGVyZWQgZm9yIHRoZSBjdXJyZW50IG1hcCB2aWV3LlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNhbnZhc092ZXJsYXlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZHJhd0NhbGxiYWNrOiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4gdm9pZCkge1xyXG4gICAgICAgIHN1cGVyKGRyYXdDYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBjbGljayBsb2NhdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlIC0gVGhlIG1vdXNlIGV2ZW50LlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2xpY2tlZCBtYXJrZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2FudmFzT3ZlcmxheVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZTogR29vZ2xlTWFwVHlwZXMuTW91c2VFdmVudCk6IElMYXRMb25nIHtcclxuICAgICAgICBpZiAoIWUpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICBpZiAoIWUubGF0TG5nKSB7IHJldHVybiBudWxsOyB9XHJcbiAgICAgICAgaWYgKCFlLmxhdExuZy5sYXQgfHwgIWUubGF0TG5nLmxuZykgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgICAgIHJldHVybiB7IGxhdGl0dWRlOiBlLmxhdExuZy5sYXQoKSwgbG9uZ2l0dWRlOiBlLmxhdExuZy5sbmcoKSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbWFwIGFzc29jaXRlZCB3aXRoIHRoZSBsYWJlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TWFwKCk6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCB7XHJcbiAgICAgICAgcmV0dXJuICg8YW55PnRoaXMpLmdldE1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIE1hcExhYmVsIGluc3RhbmNlIGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgdG9vbHRpcC5cclxuICAgICAqIFRoaXMgbWV0aG9kIG9ubHkgZ2VuZXJhdGVzIHRoZSBtYXAgbGFiZWwuIENvbnRlbnQgYW5kIHBsYWNlbWVudCBpcyB0aGUgcmVzcG9uc2liaWxpdHlcclxuICAgICAqIG9mIHRoZSBjYWxsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBUaGUgbGFiZWwgdG8gYmUgdXNlZCBmb3IgdGhlIHRvb2x0aXAuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0VG9vbFRpcE92ZXJsYXkoKTogTWFwTGFiZWwge1xyXG4gICAgICAgIGNvbnN0IG86IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7XHJcbiAgICAgICAgICAgIGFsaWduOiAnbGVmdCcsXHJcbiAgICAgICAgICAgIG9mZnNldDogbmV3IGdvb2dsZS5tYXBzLlBvaW50KDAsIDI1KSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnYmlzcXVlJyxcclxuICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgICAgIGZvbnRDb2xvcjogJyMwMDAwMDAnLFxyXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDBcclxuICAgICAgICB9O1xyXG4gICAgICAgIG8uekluZGV4ID0gMTAwMDAwO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsOiBNYXBMYWJlbCA9IG5ldyBHb29nbGVNYXBMYWJlbChvKTtcclxuICAgICAgICBsYWJlbC5TZXRNYXAodGhpcy5HZXRNYXAoKSk7XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGN1c3RvbSBvdmVybGF5IGlzIGFkZGVkIHRvIHRoZSBtYXAuIFRyaWdnZXJzIE9ubG9hZC4uLi5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDYW52YXNPdmVybGF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBPbkFkZCgpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci5PbkFkZCgpO1xyXG4gICAgICAgIHRoaXMuT25Mb2FkKCk7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnpJbmRleCA9ICcxMDAnO1xyXG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBjYW52YXMgYWJvdmUgcHJpbWl0aXZlcyBzdWNoIGFzIHBvbHlnb25zLlxyXG5cclxuICAgICAgICAvLyBzZXQgdGhlIG92ZXJsYXkgdG8gcmVhZHkgc3RhdGVcclxuICAgICAgICB0aGlzLl9yZWFkeVJlc29sdmVyKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIHRoZSBjYW52YXMgbmVlZHMgdG8gYmUgcmVkcmF3bi4gVGhpcyBtZXRob2QgZG9lcyBub3QgZG8gdGhlIGFjdHVhbFxyXG4gICAgICogdXBkYXRlLCBpdCBzaW1wbHkgc2NhbGVzIHRoZSBjYW52YXMuIFRoZSBhY3R1YWwgcmVkcmF3IGhhcHBlbnMgb25jZSB0aGUgbWFwIGlzIGlkbGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2FudmFzT3Zlcmx5XHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBPbkRyYXcoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgaXNTdHJlZXRWaWV3OiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgbWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXAgPSB0aGlzLkdldE1hcCgpO1xyXG5cclxuICAgICAgICBpZiAoaXNTdHJlZXRWaWV3KSB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IHNob3cgdGhlIGNhbnZhcyBpZiB0aGUgbWFwIGlzIGluIFN0cmVldHNpZGUgbW9kZS5cclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZS1kcmF3aW5nIHRoZSBjYW52YXMgYXMgaXQgbW92ZXMgd291bGQgYmUgdG9vIHNsb3cuIEluc3RlYWQsIHNjYWxlIGFuZCB0cmFuc2xhdGUgY2FudmFzIGVsZW1lbnQuXHJcbiAgICAgICAgICAgIC8vIFVwb24gaWRsZSBvciBkcmFnIGVuZCwgd2UgY2FuIHRoZW4gcmVkcmF3IHRoZSBjYW52YXMuLi4uXHJcbiAgICAgICAgICAgIGNvbnN0IHpvb21DdXJyZW50OiBudW1iZXIgPSBtYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgICAgICBjb25zdCBjZW50ZXJDdXJyZW50OiBHb29nbGVNYXBUeXBlcy5MYXRMbmcgPSBtYXAuZ2V0Q2VudGVyKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgbWFwIHNjYWxlIGJhc2VkIG9uIHpvb20gbGV2ZWwgZGlmZmVyZW5jZS5cclxuICAgICAgICAgICAgY29uc3Qgc2NhbGU6IG51bWJlciA9IE1hdGgucG93KDIsIHpvb21DdXJyZW50IC0gdGhpcy5fem9vbVN0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2NhbGVkIGRpbWVuc2lvbnMgb2YgdGhlIGNhbnZhcy5cclxuICAgICAgICAgICAgY29uc3QgZWw6IEhUTUxEaXZFbGVtZW50ID0gbWFwLmdldERpdigpO1xyXG4gICAgICAgICAgICBjb25zdCB3OiBudW1iZXIgPSBlbC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgY29uc3QgaDogbnVtYmVyID0gZWwub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCBuZXdXaWR0aDogbnVtYmVyID0gdyAqIHNjYWxlO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdIZWlnaHQ6IG51bWJlciA9IGggKiBzY2FsZTtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBvZmZzZXQgb2YgY2FudmFzIGJhc2VkIG9uIHpvb20gYW5kIGNlbnRlciBvZmZzZXRzLlxyXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0aW9uID0gKDxhbnk+dGhpcykuZ2V0UHJvamVjdGlvbigpO1xyXG4gICAgICAgICAgICBjb25zdCBjYyA9IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwoY2VudGVyQ3VycmVudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNhbnZhcyBDU1MgcG9zaXRpb24gYW5kIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgICAgIHRoaXMuVXBkYXRlUG9zaXRpb24oY2MueCAtIG5ld1dpZHRoIC8gMiwgY2MueSAtIG5ld0hlaWdodCAvIDIsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbnZhc092ZXJsYXkgbG9hZGVkLCBhdHRhY2ggbWFwIGV2ZW50cyBmb3IgdXBkYXRpbmcgY2FudmFzLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNhbnZhc092ZXJsYXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIE9uTG9hZCgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBpc1N0cmVldFZpZXc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCA9ICg8YW55PnRoaXMpLmdldE1hcCgpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgdGhpcy5fem9vbVN0YXJ0ID0gbWFwLmdldFpvb20oKTtcclxuICAgICAgICBjb25zdCBjOiBHb29nbGVNYXBUeXBlcy5MYXRMbmcgPSBtYXAuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgdGhpcy5fY2VudGVyU3RhcnQgPSB7XHJcbiAgICAgICAgICAgIGxhdGl0dWRlOiBjLmxhdCgpLFxyXG4gICAgICAgICAgICBsb25naXR1ZGU6IGMubG5nKClcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBXaGVuIHRoZSBtYXAgc3RvcHMgbW92aW5nLCByZW5kZXIgbmV3IGRhdGEgb24gdGhlIGNhbnZhcy5cclxuICAgICAgICB0aGlzLl92aWV3Q2hhbmdlRW5kRXZlbnQgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdpZGxlJywgKGU6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLlVwZGF0ZUNhbnZhcygpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5IHdoZW4gdGhlIG1hcCBpcyByZXNpemVkLlxyXG4gICAgICAgIHRoaXMuX21hcFJlc2l6ZUV2ZW50ID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAncmVzaXplJywgKGU6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLlVwZGF0ZUNhbnZhcygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXNzb2NpYXRlcyB0aGUgY25hdmFzIG92ZXJsYXkgd2l0aCBhIG1hcC5cclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDYW52YXNPdmVybGF5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRNYXAobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApOiB2b2lkIHtcclxuICAgICAgICAoPGFueT50aGlzKS5zZXRNYXAobWFwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm90ZWN0ZWQgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2hlcyB0aGUgY2FudmFzIHRvIHRoZSBtYXAuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgU2V0Q2FudmFzRWxlbWVudChlbDogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBwYW5lcyA9ICg8YW55PnRoaXMpLmdldFBhbmVzKCk7XHJcbiAgICAgICAgaWYgKHBhbmVzKSB7XHJcbiAgICAgICAgICAgIGlmIChlbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwYW5lcy5vdmVybGF5TGF5ZXIuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gICAgICAgICAgICAgICAgLy8gNDogZmxvYXRQYW5lIChpbmZvd2luZG93KVxyXG4gICAgICAgICAgICAgICAgLy8gMzogb3ZlcmxheU1vdXNlVGFyZ2V0IChtb3VzZSBldmVudHMpXHJcbiAgICAgICAgICAgICAgICAvLyAyOiBtYXJrZXJMYXllciAobWFya2VyIGltYWdlcylcclxuICAgICAgICAgICAgICAgIC8vIDE6IG92ZXJsYXlMYXllciAocG9seWdvbnMsIHBvbHlsaW5lcywgZ3JvdW5kIG92ZXJsYXlzLCB0aWxlIGxheWVyIG92ZXJsYXlzKVxyXG4gICAgICAgICAgICAgICAgLy8gMDogbWFwUGFuZSAobG93ZXN0IHBhbmUgYWJvdmUgdGhlIG1hcCB0aWxlcylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhbmVzLm92ZXJsYXlMYXllci5yZW1vdmVDaGlsZCh0aGlzLl9jYW52YXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIHRoZSBtYXAgZXZlbnQgaGFuZGxlcnMuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgUmVtb3ZlRXZlbnRIYW5kbGVycygpOiB2b2lkIHtcclxuICAgICAgICAvLyBSZW1vdmUgYWxsIGV2ZW50IGhhbmRsZXJzIGZyb20gdGhlIG1hcC5cclxuICAgICAgICBpZiAodGhpcy5fdmlld0NoYW5nZUVuZEV2ZW50KSB7IGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuX3ZpZXdDaGFuZ2VFbmRFdmVudCk7IH1cclxuICAgICAgICBpZiAodGhpcy5fbWFwUmVzaXplRXZlbnQpIHsgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5fbWFwUmVzaXplRXZlbnQpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBDYW52YXMgc2l6ZSBiYXNlZCBvbiB0aGUgbWFwIHNpemUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzT3ZlcmxheVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgUmVzaXplKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwID0gKDxhbnk+dGhpcykuZ2V0TWFwKCk7XHJcblxyXG4gICAgICAgIC8vIENsZWFyIGNhbnZhcyBieSB1cGRhdGluZyBkaW1lbnNpb25zLiBUaGlzIGFsc28gZW5zdXJlcyBjYW52YXMgc3RheXMgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgbWFwLlxyXG4gICAgICAgIGNvbnN0IGVsOiBIVE1MRGl2RWxlbWVudCA9IG1hcC5nZXREaXYoKTtcclxuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSBlbC5vZmZzZXRXaWR0aDtcclxuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgQ2FudmFzLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc092ZXJsYXlcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIFVwZGF0ZUNhbnZhcygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCA9ICg8YW55PnRoaXMpLmdldE1hcCgpO1xyXG5cclxuICAgICAgICAvLyBPbmx5IHJlbmRlciB0aGUgY2FudmFzIGlmIGl0IGlzbid0IGluIHN0cmVldHNpZGUgbW9kZS5cclxuICAgICAgICBpZiAodHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzZXQgQ1NTIHBvc2l0aW9uIGFuZCBkaW1lbnNpb25zIG9mIGNhbnZhcy5cclxuICAgICAgICAgICAgY29uc3QgZWw6IEhUTUxEaXZFbGVtZW50ID0gbWFwLmdldERpdigpO1xyXG4gICAgICAgICAgICBjb25zdCB3OiBudW1iZXIgPSBlbC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgY29uc3QgaDogbnVtYmVyID0gZWwub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCBjZW50ZXJQb2ludCA9ICg8YW55PnRoaXMpLmdldFByb2plY3Rpb24oKS5mcm9tTGF0TG5nVG9EaXZQaXhlbChtYXAuZ2V0Q2VudGVyKCkpO1xyXG4gICAgICAgICAgICB0aGlzLlVwZGF0ZVBvc2l0aW9uKChjZW50ZXJQb2ludC54IC0gdyAvIDIpLCAoY2VudGVyUG9pbnQueSAtIGggLyAyKSwgdywgaCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWRyYXcgdGhlIGNhbnZhcy5cclxuICAgICAgICAgICAgdGhpcy5SZWRyYXcodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgbWFwIHZpZXcgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgIHRoaXMuX3pvb21TdGFydCA9IG1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGM6IEdvb2dsZU1hcFR5cGVzLkxhdExuZyA9IG1hcC5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fY2VudGVyU3RhcnQgPSB7XHJcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogYy5sYXQoKSxcclxuICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogYy5sbmcoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBleHRlbmQgdGhlIE92ZXJsYXlWaWV3IGludG8gdGhlIENhbnZhc092ZXJsYXlcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAbWV0aG9kXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTWl4aW5DYW52YXNPdmVybGF5KCkge1xyXG4gICAgY29uc3QgeCA9IEdvb2dsZUNhbnZhc092ZXJsYXkucHJvdG90eXBlO1xyXG4gICAgR29vZ2xlQ2FudmFzT3ZlcmxheS5wcm90b3R5cGUgPSA8YW55PiBuZXcgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcoKTtcclxuICAgIGZvciAoY29uc3QgeSBpbiB4KSB7IGlmICgoPGFueT54KVt5XSAhPSBudWxsKSB7ICg8YW55Pkdvb2dsZUNhbnZhc092ZXJsYXkucHJvdG90eXBlKVt5XSA9ICg8YW55PngpW3ldOyB9fVxyXG4gICAgKDxhbnk+R29vZ2xlQ2FudmFzT3ZlcmxheS5wcm90b3R5cGUpWydvbkFkZCddID0geFsnT25BZGQnXTtcclxuICAgICg8YW55Pkdvb2dsZUNhbnZhc092ZXJsYXkucHJvdG90eXBlKVsnZHJhdyddID0geFsnT25EcmF3J107XHJcbiAgICAoPGFueT5Hb29nbGVDYW52YXNPdmVybGF5LnByb3RvdHlwZSlbJ29uUmVtb3ZlJ10gPSB4WydPblJlbW92ZSddO1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi9tYXJrZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEluZm9Cb3hTZXJ2aWNlIH0gZnJvbSAnLi9pbmZvYm94LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuL2xheWVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBDbHVzdGVyU2VydmljZSB9IGZyb20gJy4vY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUG9seWdvblNlcnZpY2UgfSBmcm9tICcuL3BvbHlnb24uc2VydmljZSc7XHJcbmltcG9ydCB7IFBvbHlsaW5lU2VydmljZSB9IGZyb20gJy4vcG9seWxpbmUuc2VydmljZSc7XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyBhIGZhY3RvcnkgdG8gY3JlYXRlIGFsbCB0aGUgaW1wbGVtZW50YXRpb24gc3BlY2lmYyBzZXJ2aWNlcyBmb3IgYSBtYXAgaW1wbGVtZW50YXRpb25cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE1hcFNlcnZpY2VGYWN0b3J5IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIG1hcCBzZXJ2aWNlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50aW5nIGEgc3BlY2lmaWMgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBDcmVhdGUoKTogTWFwU2VydmljZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIGNsdXN0ZXIgc2VydmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIENsdXN0ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZUZhY3RvcnlcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgQ3JlYXRlQ2x1c3RlclNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlKTogQ2x1c3RlclNlcnZpY2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBpbmZvIGJveCBzZXJ2aWNlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhoIHVuZGVybHlpbmcgbWFwIGFyY2h0aWN0dXJlLlxyXG4gICAgICogQHBhcmFtIG1hcmtlciAtIHtAbGluayBNYXJrZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhoIHVuZGVybHlpbmcgbWFya2VyIGFyY2h0aWN0dXJlLlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSW5mb0JveFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBDcmVhdGVJbmZvQm94U2VydmljZShtYXA6IE1hcFNlcnZpY2UsIG1hcmtlcjogTWFya2VyU2VydmljZSk6IEluZm9Cb3hTZXJ2aWNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgbGF5ZXIgc2VydmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIExheWVyU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZUxheWVyU2VydmljZShtYXA6IE1hcFNlcnZpY2UpOiBMYXllclNlcnZpY2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBtYXJrZXIgc2VydmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cclxuICAgICAqIEBwYXJhbSBsYXllcnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICAgICAqIEBwYXJhbSBjbHVzdGVycyAgLSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgTWFya2VyU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZU1hcmtlclNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlLCBsYXllcnM6IExheWVyU2VydmljZSwgY2x1c3RlcnM6IENsdXN0ZXJTZXJ2aWNlKTogTWFya2VyU2VydmljZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIHBvbHlnb24gc2VydmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cclxuICAgICAqIEBwYXJhbSBsYXllcnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIFBvbHlnb25TZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZUZhY3RvcnlcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgQ3JlYXRlUG9seWdvblNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlLCBsYXllcnM6IExheWVyU2VydmljZSk6IFBvbHlnb25TZXJ2aWNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgcG9seWxpbmUgc2VydmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cclxuICAgICAqIEBwYXJhbSBsYXllcnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIFBvbHlsaW5lU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZVBvbHlsaW5lU2VydmljZShtYXA6IE1hcFNlcnZpY2UsIGxheWVyczogTGF5ZXJTZXJ2aWNlKTogUG9seWxpbmVTZXJ2aWNlO1xyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJTWFwT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcC1vcHRpb25zJztcclxuaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElTaXplIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pc2l6ZSc7XHJcbmltcG9ydCB7IElCb3ggfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lib3gnO1xyXG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbW9kZWxzL21hcmtlcic7XHJcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vbW9kZWxzL2xheWVyJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi9tb2RlbHMvcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vbW9kZWxzL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uL21vZGVscy9jYW52YXMtb3ZlcmxheSc7XHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgY2xhc3MgdG8gaW1wbGVtZW50IG1hcCBhcGkuIEEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIGJlIGNyZWF0ZWQgZm9yIGVhY2hcclxuICogTWFwIHByb3ZpZGVyIHN1cHBvcnRlZCAoZS5nLiBCaW5nLCBHb29sZ2UsIEVTUkkpXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNYXBTZXJ2aWNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgcHJvcGVydGllc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBNYXAgY29udHJvbCBpbnN0YW5jZSB1bmRlcmx5aW5nIHRoZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0IE1hcEluc3RhbmNlKCk6IGFueTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBQcm9taXNlIGZvciBhIE1hcCBjb250cm9sIGluc3RhbmNlIHVuZGVybHlpbmcgdGhlIGltcGxlbWVudGF0aW9uLiBVc2UgdGhpcyBpbnN0ZWFkIG9mIHtAbGluayBNYXBJbnN0YW5jZX0gaWYgeW91XHJcbiAgICAgKiBhcmUgbm90IHN1cmUgaWYgYW5kIHdoZW4gdGhlIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0IE1hcFByb21pc2UoKTogUHJvbWlzZTxhbnk+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbWFwcyBwaHlzaWNhbCBzaXplLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBnZXQgTWFwU2l6ZSgpOiBJU2l6ZTtcclxuXHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHMgYW5kIE1hcFNlcnZpY2UgaW50ZXJmYWNlIGltcGxlbWVudGF0aW9uXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSByYW5kb20gZ2VvIGxvY2F0aW9ucyBmaWxsaW5nIHRoZSBib3VuZGluZyBib3guXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvdW50IC0gbnVtYmVyIG9mIGxvY2F0aW9ucyB0byByZXR1cm5cclxuICAgICAqIEBwYXJhbSBib3VuZHMgIC0gYm91bmRpbmcgYm94LlxyXG4gICAgICogQHJldHVybnMgLSBBcnJheSBvZiBnZW8gbG9jYXRpb25zLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBHZXRSYW5kb25Mb2NhdGlvbnMoY291bnQ6IG51bWJlciwgYm91bmRzOiBJQm94KTogQXJyYXk8SUxhdExvbmc+IHtcclxuICAgICAgICBjb25zdCBhOiBBcnJheTxJTGF0TG9uZz4gPSBbXTtcclxuICAgICAgICBjb25zdCBfZ2V0UmFuZG9tTG9jYXRpb24gPSAoYjogSUJveCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsYXQ6IG51bWJlciA9IE1hdGgucmFuZG9tKCkgKiAoYi5tYXhMYXRpdHVkZSAtIGIubWluTGF0aXR1ZGUpICsgYi5taW5MYXRpdHVkZTtcclxuICAgICAgICAgICAgbGV0IGxuZzogbnVtYmVyID0gMDtcclxuICAgICAgICAgICAgaWYgKGNyb3NzZXNEYXRlTGluZSkge1xyXG4gICAgICAgICAgICAgICAgbG5nID0gTWF0aC5yYW5kb20oKSAqIChiLm1pbkxvbmdpdHVkZSArIDM2MCAtIGIubWF4TG9uZ2l0dWRlKSArIGIubWF4TG9uZ2l0dWRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxuZyA+IDE4MCkgeyBsbmcgPSBsbmcgLSAzNjA7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxuZyA9IE1hdGgucmFuZG9tKCkgKiAoYi5tYXhMb25naXR1ZGUgLSBiLm1pbkxvbmdpdHVkZSkgKyBiLm1pbkxvbmdpdHVkZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwOiBJTGF0TG9uZyA9IHsgbGF0aXR1ZGU6IGxhdCwgbG9uZ2l0dWRlOiBsbmcgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgY3Jvc3Nlc0RhdGVMaW5lOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmIChib3VuZHMgPT0gbnVsbCkgeyBib3VuZHMgPSA8SUJveD57XHJcbiAgICAgICAgICAgICAgICBtYXhMYXRpdHVkZTogMzYwLFxyXG4gICAgICAgICAgICAgICAgbWluTGF0aXR1ZGU6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXhMb25naXR1ZGU6IDE3MCxcclxuICAgICAgICAgICAgICAgIG1pbkxvbmdpdHVkZTogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYm91bmRzLmNlbnRlci5sb25naXR1ZGUgPCBib3VuZHMubWluTG9uZ2l0dWRlICB8fCBib3VuZHMuY2VudGVyLmxvbmdpdHVkZSA+IGJvdW5kcy5tYXhMb25naXR1ZGUpIHsgY3Jvc3Nlc0RhdGVMaW5lID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmICghY291bnQgfHwgY291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW19nZXRSYW5kb21Mb2NhdGlvbihib3VuZHMpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBjb3VudDsgcisrKSB7IGEucHVzaChfZ2V0UmFuZG9tTG9jYXRpb24oYm91bmRzKSk7IH1cclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjYW52YXMgb3ZlcmxheSBsYXllciB0byBwZXJmb3JtIGN1c3RvbSBkcmF3aW5nIG92ZXIgdGhlIG1hcCB3aXRoIG91dFxyXG4gICAgICogc29tZSBvZiB0aGUgb3ZlcmhlYWQgYXNzb2NpYXRlZCB3aXRoIGdvaW5nIHRocm91Z2ggdGhlIE1hcCBvYmplY3RzLlxyXG4gICAgICogQHBhcmFtIGRyYXdDYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNhbnZhcyBpcyByZWFkeSB0byBiZVxyXG4gICAgICogcmVuZGVyZWQgZm9yIHRoZSBjdXJyZW50IG1hcCB2aWV3LlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIENhbnZhc092ZXJsYXl9IG9iamVjdC5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IENyZWF0ZUNhbnZhc092ZXJsYXkoZHJhd0NhbGxiYWNrOiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4gdm9pZCk6IFByb21pc2U8Q2FudmFzT3ZlcmxheT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGNsdXN0ZXIgbGF5ZXIgd2l0aGluIHRoZSBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLiBTZWUge0BsaW5rIElDbHVzdGVyT3B0aW9uc30uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgTGF5ZXJ9IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBsYXllciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgQ3JlYXRlQ2x1c3RlckxheWVyKG9wdGlvbnM6IElMYXllck9wdGlvbnMpOiBQcm9taXNlPExheWVyPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5mb3JtYXRpb24gd2luZG93IGZvciBhIG1hcCBwb3NpdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBbb3B0aW9uc10gLSBJbmZvd2luZG93IG9wdGlvbnMuIFNlZSB7QGxpbmsgSUluZm9XaW5kb3dPcHRpb25zfVxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIEluZm9XaW5kb3d9IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIG5hdHZpZSBpbmZvYm94IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBDcmVhdGVJbmZvV2luZG93KG9wdGlvbnM/OiBJSW5mb1dpbmRvd09wdGlvbnMpOiBQcm9taXNlPEluZm9XaW5kb3c+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG1hcCBsYXllciB3aXRoaW4gdGhlIG1hcCBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGF5ZXIuIFNlZSB7QGxpbmsgSUxheWVyT3B0aW9uc31cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBMYXllcn0gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgbmF0aXZlIGxheWVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBDcmVhdGVMYXllcihvcHRpb25zOiBJTGF5ZXJPcHRpb25zKTogUHJvbWlzZTxMYXllcj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVsIC0gSFRNTCBlbGVtZW50IHRvIGhvc3QgdGhlIG1hcC5cclxuICAgICAqIEBwYXJhbSBtYXBPcHRpb25zIC0gTWFwIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIG1hcCBoYXMgYmVlbiBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZU1hcChlbDogSFRNTEVsZW1lbnQsIG1hcE9wdGlvbnM6IElNYXBPcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtYXAgbWFya2VyIHdpdGhpbiB0aGUgbWFwIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gW29wdGlvbnM9PElNYXJrZXJPcHRpb25zPnt9XSAtIE9wdGlvbnMgZm9yIHRoZSBtYXJrZXIuIFNlZSB7QGxpbmsgSU1hcmtlck9wdGlvbnN9LlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIE1hcmtlcn0gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgbmF0aXZlIHB1c2hwaW4gb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZU1hcmtlcihvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IFByb21pc2U8TWFya2VyPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBwb2x5Z29uIHdpdGhpbiB0aGUgbWFwIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIHBvbHlnb24uIFNlZSB7QGxpbmsgSVBvbHlnb25PcHRpb25zfS5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBQb2x5Z29ufSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBuYXRpdmUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBDcmVhdGVQb2x5Z29uKG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IFByb21pc2U8UG9seWdvbj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcG9seWxpbmUgd2l0aGluIHRoZSBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgcG9seWxpbmUuIFNlZSB7QGxpbmsgSVBvbHlsaW5lT3B0aW9uc30uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgUG9seWxpbmV9IG9iamVjdCAob3IgYW4gYXJyYXkgdGhlcmVvZiBmb3IgY29tcGxleCBwYXRocyksXHJcbiAgICAgKiB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgbmF0aXZlIHBvbHlsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZVBvbHlsaW5lKG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGEgbGF5ZXIgZnJvbSB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIExheWVyIHRvIGRlbGV0ZS4gU2VlIHtAbGluayBMYXllcn0uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgZnVsbGZpbGxlZCB3aGVuIHRoZSBsYXllciBoYXMgYmVlbiByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IERlbGV0ZUxheWVyKGxheWVyOiBMYXllcik6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYW9zZSB0aGUgbWFwIGFuZCBhc3NvY2lhdGVkIHJlc291cmVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IERpc3Bvc2VNYXAoKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgbWFwIGJvdW5kc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHNjcmVlbi4gU2VlIHtAbGluayBJQm94fS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBHZXRCb3VuZHMoKTogUHJvbWlzZTxJQm94PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgbWFwIGNlbnRlclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBnb2UgbG9jYXRpb24gb2YgdGhlIGNlbnRlci4gU2VlIHtAbGluayBJTGF0TG9uZ30uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgR2V0Q2VudGVyKCk6IFByb21pc2U8SUxhdExvbmc+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHpvb20gbGV2ZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgR2V0Wm9vbSgpOiBQcm9taXNlPG51bWJlcj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm92aWRlcyBhIGNvbnZlcnNpb24gb2YgZ2VvIGNvb3JkaW5hdGVzIHRvIHBpeGVscyBvbiB0aGUgbWFwIGNvbnRyb2wuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvYyAtIFRoZSBnZW8gY29vcmRpbmF0ZXMgdG8gdHJhbnNsYXRlLlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGFuIHtAbGluayBJUG9pbnR9IGludGVyZmFjZSByZXByZXNlbnRpbmcgdGhlIHBpeGVscy4gVGhpcyBwcm9taXNlIHJlc29sdmVzIHRvIG51bGxcclxuICAgICAqIGlmIHRoZSBnb2UgY29vcmRpbmF0ZXMgYXJlIG5vdCBpbiB0aGUgdmlldyBwb3J0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IExvY2F0aW9uVG9Qb2ludChsb2M6IElMYXRMb25nKTogUHJvbWlzZTxJUG9pbnQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgYSBjb252ZXJzaW9uIG9mIGdlbyBjb29yZGluYXRlcyB0byBwaXhlbHMgb24gdGhlIG1hcCBjb250cm9sLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2MgLSBUaGUgZ2VvIGNvb3JkaW5hdGVzIHRvIHRyYW5zbGF0ZS5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhbiB7QGxpbmsgSVBvaW50fSBpbnRlcmZhY2UgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgTG9jYXRpb25zVG9Qb2ludHMobG9jczogQXJyYXk8SUxhdExvbmc+KTogUHJvbWlzZTxBcnJheTxJUG9pbnQ+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENlbnRlcnMgdGhlIG1hcCBvbiBhIGdlbyBsb2NhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF0TG5nIC0gR2VvQ29vcmRpbmF0ZXMgYXJvdW5kIHdoaWNoIHRvIGNlbnRlciB0aGUgbWFwLiBTZWUge0BsaW5rIElMYXRMb25nfVxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBjZW50ZXIgb3BlcmF0aW9ucyBoYXMgYmVlbiBjb21wbGV0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgU2V0Q2VudGVyKGxhdExuZzogSUxhdExvbmcpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZ2VuZXJpYyBtYXAgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IFNldE1hcE9wdGlvbnMob3B0aW9uczogSU1hcE9wdGlvbnMpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmlldyBvcHRpb25zIG9mIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBTZXRWaWV3T3B0aW9ucyhvcHRpb25zOiBJTWFwT3B0aW9ucyk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHpvb20gLSBab29tIGxldmVsIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBQcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCBvbmNlIHRoZSB6b29tIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBTZXRab29tKHpvb206IG51bWJlcik6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGV2ZW50IHN1YnNjcmlwdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKGUuZy4gJ2NsaWNrJylcclxuICAgICAqIEByZXR1cm5zIC0gQW4gb2JzZXJ2YWJsZSBvZiB0cHllIEUgdGhhdCBmaXJlcyB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgU3Vic2NyaWJlVG9NYXBFdmVudDxFPihldmVudE5hbWU6IHN0cmluZyk6IE9ic2VydmFibGU8RT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyB0aGUgZ2l2ZW4gZXZlbnQgbmFtZSBvbiB0aGUgbWFwIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBFdmVudCB0byB0cmlnZ2VyLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIG9uY2UgdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBUcmlnZ2VyTWFwRXZlbnQoZXZlbnROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvaW50JztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbW9kZWxzL21hcmtlcic7XHJcbmltcG9ydCB7IE1hcE1hcmtlckRpcmVjdGl2ZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvbWFwLW1hcmtlcic7XHJcblxyXG4vKipcclxuICogVGhlIGFic3RyYWN0IGNsYXNzIHJlcHJlc2VudHMgdGhlIGNvbnRyYWN0IGRlZmludGlvbnMgZm9yIGEgbWFya2VyIHNlcnZpY2UgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYW4gYWN1dGFseSB1bmRlcmx5aW5nXHJcbiAqIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNYXJrZXJTZXJ2aWNlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBtYXJrZXIuIERlcGVuZGluZyBvbiB0aGUgbWFya2VyIGNvbnRleHQsIHRoZSBtYXJrZXIgd2lsbCBlaXRoZXIgYnkgYWRkZWQgdG8gdGhlIG1hcCBvciBhIGNvcnJlY3Nwb25kaW5nIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG1hcmtlciAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSB0byBiZSBhZGRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQWRkTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIChlLmcuICdjbGljaycpXHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0gVGhlIHtAbGluayBNYXBNYXJrZXJ9IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE9ic2VydmFibGUgZW1pdGluZyBhbiBpbnN0YW5jZSBvZiBUIGVhY2ggdGltZSB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBDcmVhdGVFdmVudE9ic2VydmFibGU8VD4oZXZlbnROYW1lOiBzdHJpbmcsIG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogT2JzZXJ2YWJsZTxUPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgYSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0ge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgbWFya2VyIGhhcyBiZWVuIGRlbGV0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IERlbGV0ZU1hcmtlcihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlciBvbiB0aGUgY2xpY2sgbG9jYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBlIC0gVGhlIG1vdXNlIGV2ZW50LlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2xpY2tlZCBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnR8IGFueSk6IElMYXRMb25nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyB0aGUgbWFya2VyIG1vZGVsIGZvciB0aGUgbWFya2VyIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IGZvciB3aGljaCB0byBvYnRhaW4gdGhlIG1hcmtlciBtb2RlbC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSB7QGxpbmsgTWFya2VyfSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgdW5kZXJseWluZyBwbGF0Zm9ybS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgR2V0TmF0aXZlTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTxNYXJrZXI+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyB0aGUgbWFya2VyIHBpeGVsIGxvY2F0aW9uIGZvciB0aGUgbWFya2VyIG9uIHRoZSBjbGljayBsb2NhdGlvblxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgcGl4ZWxzIG9mIHRoZSBtYXJrZXIgb24gdGhlIG1hcCBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IEdldFBpeGVsc0Zyb21DbGljayhlOiBNb3VzZUV2ZW50fCBhbnkpOiBJUG9pbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIGdlbyBsb2NhdGlvbiB0byBhIHBpeGVsIGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBtYXAgY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIHRhcmdldCAtIEVpdGhlciBhIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9yIGEge0BsaW5rIElMYXRMb25nfVxyXG4gICAgICogZm9yIHRoZSBiYXNpcyBvZiB0cmFuc2xhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIGEge0BsaW5rIElQb2ludH1cclxuICAgICAqIHdpdGggdGhlIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSBNYXBNYXJrZXJEaXJlY3RpdmUgb3IgSUxhdExvbmcgcmVsYXRpdmUgdG8gdGhlIG1hcCBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IExvY2F0aW9uVG9Qb2ludCh0YXJnZXQ6IE1hcE1hcmtlckRpcmVjdGl2ZSB8IElMYXRMb25nKTogUHJvbWlzZTxJUG9pbnQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgYW5jaG9yIHBvc2l0aW9uIGZvciB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgdGhlIGFuY2hvci5cclxuICAgICAqIEFuY2hvciBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBhbmNob3IgcG9zaXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgVXBkYXRlQW5jaG9yKG1ha2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB3aGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgZHJhZ2FiaWxpdHkuXHJcbiAgICAgKiBEcmFnYWJpbGl0eSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBtYXJrZXIgaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgVXBkYXRlRHJhZ2dhYmxlKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIEljb24gb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBpY29uLlxyXG4gICAgICogSWNvbiBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBpY29uIGluZm9ybWF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFVwZGF0ZUljb24obWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgbGFiZWwgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBsYWJlbC5cclxuICAgICAqIExhYmVsIGluZm9ybWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGxhYmVsIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFVwZGF0ZUxhYmVsKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBjb29yZGluYXRlcy5cclxuICAgICAqIENvb3JkaW5hdGUgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgcG9zaXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgVXBkYXRlTWFya2VyUG9zaXRpb24obWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgdGl0bGUgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSB0aXRsZS5cclxuICAgICAqIFRpdGxlIGluZm9ybWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIHRpdGxlIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFVwZGF0ZVRpdGxlKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZpc2liaWxpdHkgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSB2aXNpYmlsaXR5LlxyXG4gICAgICogVmlzaWJpbGl0eSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSB2aXNpYmlsaXR5IGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IFVwZGF0ZVZpc2libGUobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSW5mb0JveENvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudHMvaW5mb2JveCc7XHJcbmltcG9ydCB7IElJbmZvV2luZG93T3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vbW9kZWxzL2luZm8td2luZG93JztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGRlZmluZXMgdGhlIGNvbnRyYWN0IGZvciBhbiBJbmZvQm94U2VydmljZS4gRWFjaCBNYXAgQXJjaGl0ZWN0dXJlIHByb3ZpZGVyIGlzIGV4cGVjdGVkIHRoZSBmdXJuaXNoIGEgY29uY3JldGUgaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbmZvQm94U2VydmljZSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGluZm8gd2luZG93IHRvIHRoZSBtYXAgb3IgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gaW5mbyAtIHtAbGluayBJbmZvQm94Q29tcG9uZW50fSBjb21wb25lbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5mb2JveC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgQWRkSW5mb1dpbmRvdyhpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyBhbiBpbmZvYm94IHRoYXQgaXMgb3Blbi5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBpbmZvIC0ge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGNvbXBvbmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbmZvYm94LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGluZm9ib3ggaGFzIGJlZW4gY2xvc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBDbG9zZShpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSB0byBldmVudHMgb24gdGhlIGluZm93aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIChlLmcuICdjbGljaycpXHJcbiAgICAgKiBAcGFyYW0gaW5mb0NvbXBvbmVudCAtIFRoZSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBldmVudC5cclxuICAgICAqIEByZXR1cm5zIC0gT2JzZXJ2YWJsZSBlbWl0aW5nIGFuIGluc3RhbmNlIG9mIFQgZWFjaCB0aW1lIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IENyZWF0ZUV2ZW50T2JzZXJ2YWJsZTxUPihldmVudDogc3RyaW5nLCBpbmZvQm94Q29tcG9uZW50OiBJbmZvQm94Q29tcG9uZW50KTogT2JzZXJ2YWJsZTxUPjtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGFuIGluZm9ib3guXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gaW5mbyAtIHtAbGluayBJbmZvQm94Q29tcG9uZW50fSBjb21wb25lbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5mb2JveC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBpbmZvYm94IGhhcyBiZWVuIGRlbGV0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IERlbGV0ZUluZm9XaW5kb3coaW5mbzogSW5mb0JveENvbXBvbmVudCk6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVucyBhbiBpbmZvYm94IHRoYXQgaXMgY2xvc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGluZm8gLSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gY29tcG9uZW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluZm9ib3guXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBoYXMgYmVlbiBvcGVuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IE9wZW4oaW5mbzogSW5mb0JveENvbXBvbmVudCwgbG9jPzogSUxhdExvbmcpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaW5mb2JveCBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGluZm8gLSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gY29tcG9uZW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluZm9ib3guXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJSW5mb1dpbmRvd09wdGlvbnN9IG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zIHRvIHNldC4gT3B0aW9ucyBwcm92aWRlZCBhcmVcclxuICAgICAqIG1lcmdlZCB3aXRoIHRoZSBleGlzdGluZyBvcHRpb25zIG9mIHRoZSB1bmRlcmx5aW5nIGluZm9ib3guXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBvcHRpb25zIGhhdmUgYmVlbiB1cGRhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBTZXRPcHRpb25zKGluZm86IEluZm9Cb3hDb21wb25lbnQsIG9wdGlvbnM6IElJbmZvV2luZG93T3B0aW9ucyk6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBpbmZvYm94IGJhc2VkIG9uIHRoZSBwcm9wZXJ0aWVzIHNldCBvbiB0aGUgSW5mb0JveCBjb21wb25lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gaW5mbyAtIHtAbGluayBJbmZvQm94Q29tcG9uZW50fSBjb21wb25lbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5mb2JveC5cclxuICAgICAqIEBwYXJhbSBsYXRsbmcgLSBUaGUgcG9zaXRpb24gdG8gc2V0XHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBwb3NpdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBTZXRQb3NpdGlvbihpbmZvOiBJbmZvQm94Q29tcG9uZW50LCBsYXRsbmc/OiBJTGF0TG9uZyk6IFByb21pc2U8dm9pZD47XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTWFya2VySWNvbkluZm8gfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXJrZXItaWNvbi1pbmZvJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbW9kZWxzL21hcmtlcic7XHJcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuLi9tb2RlbHMvcG9seWdvbic7XHJcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi4vbW9kZWxzL3BvbHlsaW5lJztcclxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9tb2RlbHMvbGF5ZXInO1xyXG5pbXBvcnQgeyBNYXBMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvbWFwLWxheWVyJztcclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBjbGFzcyB0byB0byBkZWZpbmUgdGhlIGxheWVyIHNlcnZpY2UgY29udHJhY3QuIE11c3QgYmUgcmVhbGl6ZWQgYnkgaW1wbGVtZW50aW5nIHByb3ZpZGVyLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTGF5ZXJTZXJ2aWNlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBsYXllciB0byB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gTWFwTGF5ZXJEaXJlY3RpdmUgY29tcG9uZW50IG9iamVjdC5cclxuICAgICAqIEdlbmVyYWxseSwgTWFwTGF5ZXJEaXJlY3RpdmUgd2lsbCBiZSBpbmplY3RlZCB3aXRoIGFuIGluc3RhbmNlIG9mIHRoZVxyXG4gICAgICogTGF5ZXJTZXJ2aWNlIGFuZCB0aGVuIHNlbGYgcmVnaXN0ZXIgb24gaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQWRkTGF5ZXIobGF5ZXI6IE1hcExheWVyRGlyZWN0aXZlKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBtYXJrZXIgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIG1hcmtlci5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTWFya2VyIG9wdGlvbnMgZGVmaW5pbmcgdGhlIG1hcmtlci5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgTWFya2VyIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IENyZWF0ZU1hcmtlcihsYXllcjogbnVtYmVyLCBvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IFByb21pc2U8TWFya2VyPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBtYXJrZXJzLiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGFycmF5cyBvZiBtYXJrZXJzIHRvIGJlIHVzZWQgaW4gYnVsa1xyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTWFya2VyIG9wdGlvbnMgZGVmaW5pbmcgdGhlIG1hcmtlcnMuXHJcbiAgICAgKiBAcGFyYW0gbWFya2VySWNvbiAtIE9wdGlvbmFsIGluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGN1c3RvbSBtYXJrZXJzLiBUaGlzIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgbWFya2Vycy5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBhcnJheXMgb2YgdGhlIE1hcmtlciBtb2RlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQ3JlYXRlTWFya2VycyhvcHRpb25zOiBBcnJheTxJTWFya2VyT3B0aW9ucz4sIG1hcmtlckljb24/OiBJTWFya2VySWNvbkluZm8pOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHBvbHlnb24gdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIGxpbmUuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlnb24gb3B0aW9ucyBkZWZpbmluZyB0aGUgbGluZS5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgUG9seWdvbiBtb2RlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBDcmVhdGVQb2x5Z29uKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IFByb21pc2U8UG9seWdvbj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuYm91bmQgcG9seWdvbnMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIHBvbHlnb25zIHRvIGJlIHVzZWQgaW4gYnVsa1xyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWdvbi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWdvbiBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5Z29ucy5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBhcnJheXMgb2YgdGhlIFBvbHlnb24gbW9kZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IENyZWF0ZVBvbHlnb25zKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlnb24+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBwb2x5bGluZSB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgbGluZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgbWFya2VyLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGluc3RhbmNlIG9mIHRoZSBQb2x5bGluZSAob3IgYW5cclxuICAgICAqIGFycmF5IG9mIHBvbHlsaW5lcyBmb3IgY29tcGxleCBwYXRocykgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQ3JlYXRlUG9seWxpbmUobGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmJvdW5kIHBvbHlsaW5lcy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWxpbmVzIHRvIGJlIHVzZWQgaW4gYnVsa1xyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWxpbmVzLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5bGluZSBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5bGluZXMuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gYXJyYXlzIG9mIHRoZSBQb2x5bGluZSBtb2RlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIExheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQ3JlYXRlUG9seWxpbmVzKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5bGluZU9wdGlvbnM+KTogUHJvbWlzZTxBcnJheTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIGxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgbGF5ZXIgaGFzIGJlZW4gcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBEZWxldGVMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgTGF5ZXIgbW9kZWwgcmVwcmVzZW50ZWQgYnkgdGhpcyBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYXllciAtIE1hcExheWVyRGlyZWN0aXZlIGNvbXBvbmVudCBvYmplY3Qgb3IgTWFwTGF5ZXJJZCBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIGxheWVyIG1vZGVsLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIHJlc29sdmVkIGNvbnRhaW5zIHRoZSBMYXllciBtb2RlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGF5ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBHZXROYXRpdmVMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmV8bnVtYmVyKTogUHJvbWlzZTxMYXllcj47XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgTWFwUG9seWdvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL2NvbXBvbmVudHMvbWFwLXBvbHlnb24nO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBhYnN0cmFjdCBjbGFzcyByZXByZXNlbnRzIHRoZSBjb250cmFjdCBkZWZpbnRpb25zIGZvciBhIHBvbHlnb24gc2VydmljZSB0byBiZSBpbXBsZW1lbnRlZCBieSBhbiBhY3V0YWx5IHVuZGVybHlpbmdcclxuICogbWFwIGFyY2hpdGVjdHVyZS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBvbHlnb25TZXJ2aWNlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIHBvbHlnb24gdG8gYSBtYXAuIERlcGVuZGluZyBvbiB0aGUgcG9seWdvbiBjb250ZXh0LCB0aGUgcG9seWdvbiB3aWxsIGVpdGhlciBieSBhZGRlZCB0byB0aGUgbWFwIG9yIGFcclxuICAgKiBjb3JyZWNzcG9uZGluZyBsYXllci5cclxuICAgKlxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwYXJhbSBwb2x5Z29uIC0gVGhlIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSB0byBiZSBhZGRlZC5cclxuICAgKlxyXG4gICAqIEBtZW1iZXJvZiBQb2x5Z29uU2VydmljZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBhYnN0cmFjdCBBZGRQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiB2b2lkO1xyXG5cclxuICAvKipcclxuICAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGRlbGVnYXRlIGZvciBhIG1hcmtlci5cclxuICAgICpcclxuICAgICogQGFic3RyYWN0XHJcbiAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgKGUuZy4gJ2NsaWNrJylcclxuICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgZXZlbnQuXHJcbiAgICAqIEByZXR1cm5zIC0gT2JzZXJ2YWJsZSBlbWl0aW5nIGFuIGluc3RhbmNlIG9mIFQgZWFjaCB0aW1lIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAqXHJcbiAgICAqIEBtZW1iZXJvZiBQb2x5Z29uU2VydmljZVxyXG4gICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogT2JzZXJ2YWJsZTxUPjtcclxuXHJcbiAgLyoqXHJcbiAgICAqIERlbGV0ZXMgYSBwb2x5Z29uLlxyXG4gICAgKlxyXG4gICAgKiBAYWJzdHJhY3RcclxuICAgICogQHBhcmFtIHBvbHlnb24gLSB7QGxpbmsgTWFwUG9seWdvbkRpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cclxuICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5Z29uIGhhcyBiZWVuIGRlbGV0ZWQuXHJcbiAgICAqXHJcbiAgICAqIEBtZW1iZXJvZiBQb2x5Z29uU2VydmljZVxyXG4gICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgRGVsZXRlUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgLyoqXHJcbiAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXJrZXIgb24gdGhlIGNsaWNrIGxvY2F0aW9uXHJcbiAgICpcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cclxuICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIG1hcmtlci5cclxuICAgKlxyXG4gICAqIEBtZW1iZXJvZiBNYXJrZXJTZXJ2aWNlXHJcbiAgICovXHJcbiAgcHVibGljIGFic3RyYWN0IEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnQgfCBhbnkpOiBJTGF0TG9uZztcclxuXHJcbiAgLyoqXHJcbiAgICogT2J0YWlucyB0aGUgcG9seWdvbiBtb2RlbCBmb3IgdGhlIHBvbHlnb24gYWxsb3dpbmcgYWNjZXNzIHRvIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBmdW5jdGlvbmF0aWxpeS5cclxuICAgKlxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwYXJhbSBwb2x5Z29uIC0gVGhlIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gb2J0YWluIHRoZSBwb2x5Z29uIG1vZGVsLlxyXG4gICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSB7QGxpbmsgUG9seWdvbn0gaW1wbGVtZW50YXRpb24gb2YgdGhlIHVuZGVybHlpbmcgcGxhdGZvcm0uXHJcbiAgICpcclxuICAgKiBAbWVtYmVyb2YgUG9seWdvblNlcnZpY2VcclxuICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgR2V0TmF0aXZlUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogUHJvbWlzZTxQb2x5Z29uPjtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBwb2x5Z29uIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcGFyYW0gcG9seWdvbiAtIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElQb2x5Z29uT3B0aW9uc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIE9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcclxuICAgKiBvcHRpb25zIGFscmVhZHkgb24gdGhlIHVuZGVybHlpbmcgb2JqZWN0LlxyXG4gICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWdvbiBvcHRpb25zIGhhdmUgYmVlbiBzZXQuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyb2YgUG9seWdvblNlcnZpY2VcclxuICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgU2V0T3B0aW9ucyhwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlLCBvcHRpb25zOiBJUG9seWdvbk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSBQb2x5Z29uIHBhdGhcclxuICAgKlxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwYXJhbSBwb2x5Z29uIC0ge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXHJcbiAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5Z29uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyb2YgUG9seWdvblNlcnZpY2VcclxuICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgVXBkYXRlUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uL21vZGVscy9wb2x5bGluZSc7XHJcbmltcG9ydCB7IE1hcFBvbHlsaW5lRGlyZWN0aXZlIH0gZnJvbSAnLi4vY29tcG9uZW50cy9tYXAtcG9seWxpbmUnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBhYnN0cmFjdCBjbGFzcyByZXByZXNlbnRzIHRoZSBjb250cmFjdCBkZWZpbnRpb25zIGZvciBhIHBvbHlsaW5lIHNlcnZpY2UgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYW4gYWN1dGFseSB1bmRlcmx5aW5nXHJcbiAqIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQb2x5bGluZVNlcnZpY2Uge1xyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgcG9seWxpbmUgdG8gYSBtYXAuIERlcGVuZGluZyBvbiB0aGUgcG9seWxpbmUgY29udGV4dCwgdGhlIHBvbHlsaW5lIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYVxyXG4gICAqIGNvcnJlY3Nwb25kaW5nIGxheWVyLlxyXG4gICAqXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgYWRkZWQuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyb2YgUG9seWxpbmVTZXJ2aWNlXHJcbiAgICovXHJcbiAgcHVibGljIGFic3RyYWN0IEFkZFBvbHlsaW5lKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSk6IHZvaWQ7XHJcblxyXG4gIC8qKlxyXG4gICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgZGVsZWdhdGUgZm9yIGEgbWFya2VyLlxyXG4gICAgKlxyXG4gICAgKiBAYWJzdHJhY3RcclxuICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciAoZS5nLiAnY2xpY2snKVxyXG4gICAgKiBAcGFyYW0gcG9seWxpbmUgLSBUaGUge0BsaW5rIE1hcFBvbHlsaW5lRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGV2ZW50LlxyXG4gICAgKiBAcmV0dXJucyAtIE9ic2VydmFibGUgZW1pdGluZyBhbiBpbnN0YW5jZSBvZiBUIGVhY2ggdGltZSB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgKlxyXG4gICAgKiBAbWVtYmVyb2YgUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAqL1xyXG4gIHB1YmxpYyBhYnN0cmFjdCBDcmVhdGVFdmVudE9ic2VydmFibGU8VD4oZXZlbnROYW1lOiBzdHJpbmcsIHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSk6IE9ic2VydmFibGU8VD47XHJcblxyXG4gIC8qKlxyXG4gICAgKiBEZWxldGVzIGEgcG9seWxpbmUuXHJcbiAgICAqXHJcbiAgICAqIEBhYnN0cmFjdFxyXG4gICAgKiBAcGFyYW0gcG9seWxpbmUgLSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWxpbmUgaGFzIGJlZW4gZGVsZXRlZC5cclxuICAgICpcclxuICAgICogQG1lbWJlcm9mIFBvbHlsaW5lU2VydmljZVxyXG4gICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgRGVsZXRlUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgLyoqXHJcbiAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXJrZXIgb24gdGhlIGNsaWNrIGxvY2F0aW9uXHJcbiAgICpcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cclxuICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIG1hcmtlci5cclxuICAgKlxyXG4gICAqIEBtZW1iZXJvZiBNYXJrZXJTZXJ2aWNlXHJcbiAgICovXHJcbiAgcHVibGljIGFic3RyYWN0IEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnQgfCBhbnkpOiBJTGF0TG9uZztcclxuXHJcbiAgLyoqXHJcbiAgICogT2J0YWlucyB0aGUgcG9seWxpbmUgbW9kZWwgZm9yIHRoZSBwb2x5bGluZSBhbGxvd2luZyBhY2Nlc3MgdG8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uYXRpbGl5LlxyXG4gICAqXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgcG9seWxpbmUgbW9kZWwuXHJcbiAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBQb2x5bGluZX0gaW1wbGVtZW50YXRpb24gKG9yIGFuXHJcbiAgICogYXJyYXkgb2YgcG9seWxpbmVzKSBmb3IgY29tcGxleCBwYXRocyBvZiB0aGUgdW5kZXJseWluZyBwbGF0Zm9ybS5cclxuICAgKlxyXG4gICAqIEBtZW1iZXJvZiBQb2x5bGluZVNlcnZpY2VcclxuICAgKi9cclxuICBwdWJsaWMgYWJzdHJhY3QgR2V0TmF0aXZlUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogUHJvbWlzZTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+O1xyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIHBvbHlsaW5lIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcGFyYW0gcG9seWxpbmUgLSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSVBvbHlsaW5lT3B0aW9uc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIE9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcclxuICAgKiBvcHRpb25zIGFscmVhZHkgb24gdGhlIHVuZGVybHlpbmcgb2JqZWN0LlxyXG4gICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWxpbmUgb3B0aW9ucyBoYXZlIGJlZW4gc2V0LlxyXG4gICAqXHJcbiAgICogQG1lbWJlcm9mIFBvbHlsaW5lU2VydmljZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBhYnN0cmFjdCBTZXRPcHRpb25zKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSwgb3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIFBvbHlsaW5lIHBhdGhcclxuICAgKlxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwYXJhbSBwb2x5bGluZSAtIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgdXBkYXRlZC5cclxuICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlsaW5lIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyb2YgUG9seWxpbmVTZXJ2aWNlXHJcbiAgICovXHJcbiAgcHVibGljIGFic3RyYWN0IFVwZGF0ZVBvbHlsaW5lKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD47XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTWFya2VySWNvbkluZm8gfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXJrZXItaWNvbi1pbmZvJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbW9kZWxzL21hcmtlcic7XHJcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vbW9kZWxzL2xheWVyJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi9tb2RlbHMvcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuLi9jb21wb25lbnRzL2NsdXN0ZXItbGF5ZXInO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuL2xheWVyLnNlcnZpY2UnO1xyXG5cclxuLyoqXHJcbiAqIEFic3RyYWN0IGNsYXNzIHRvIHRvIGRlZmluZSB0ZWggY2x1c3RlciBsYXllciBzZXJ2aWNlIGNvbnRyYWN0LiBNdXN0IGJlIHJlYWxpemVkIGJ5IGltcGxlbWVudGluZyBwcm92aWRlci5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENsdXN0ZXJTZXJ2aWNlIGV4dGVuZHMgTGF5ZXJTZXJ2aWNlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGUgaW5pdGlhbCBzZXQgb2YgZW50aXRpZXNcclxuICAgICAqIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgY2x1c3Rlci4gVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBhcyBhZGRpbmcgYW4gZW50aXRpeSB3aWxsIHJlY2FsY3VsYXRlIGFsbCBjbHVzdGVycy5cclxuICAgICAqIEFzIHN1Y2gsIFN0b3BDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGFkZGluZyBtYW55IGVudGl0aWVzIGFuZCBTdGFydENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBvbmNlIGFkZGluZyBpc1xyXG4gICAgICogY29tcGxldGUgdG8gcmVjYWxjdWxhdGUgdGhlIGNsdXN0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIENsdXN0ZXJMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBTdGFydENsdXN0ZXJpbmcobGF5ZXI6IENsdXN0ZXJMYXllckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgYXMgYWRkaW5nIGFuIGVudGl0aXkgd2lsbCByZWNhbGN1bGF0ZSBhbGwgY2x1c3RlcnMuXHJcbiAgICAgKiBBcyBzdWNoLCBTdG9wQ2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhZGRpbmcgbWFueSBlbnRpdGllcyBhbmQgU3RhcnRDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgb25jZSBhZGRpbmcgaXNcclxuICAgICAqIGNvbXBsZXRlIHRvIHJlY2FsY3VsYXRlIHRoZSBjbHVzdGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUgY29tcG9uZW50IG9iamVjdCBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgU3RvcENsdXN0ZXJpbmcobGF5ZXI6IENsdXN0ZXJMYXllckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD47XHJcblxyXG59XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG4vKipcclxuICogSW5mb0JveEFjdGlvbiByZW5kZXJzIGFuIGFjdGlvbiBpbiBhbiBpbmZvIHdpbmRvdyB7QGxpbmsgSW5mb0JveH1cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbiAqIGltcG9ydCB7TWFwQ29tcG9uZW50LCBNYXBNYXJrZXJEaXJlY3RpdmUsIEluZm9Cb3hDb21wb25lbnQsIEluZm9Cb3hBY3Rpb25EaXJlY3RpdmV9IGZyb20gJy4uLic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcclxuICogIHN0eWxlczogW2BcclxuICogICAgLm1hcC1jb250YWluZXIgeyBoZWlnaHQ6IDMwMHB4OyB9XHJcbiAqICBgXSxcclxuICogIHRlbXBsYXRlOiBgXHJcbiAqICAgIDx4LW1hcCBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbWm9vbV09XCJ6b29tXCI+XHJcbiAqICAgICAgPHgtbWFwLW1hcmtlciBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbTGFiZWxdPVwiJ00nXCI+XHJcbiAqICAgICAgICA8eC1pbmZvLWJveD5cclxuICogICAgICAgICAgPHgtaW5mby1ib3gtYWN0aW9uIFtMYWJlbF09XCJhY3Rpb25sYWJlbFwiIChBY3Rpb25DbGlja2VkKT1cImFjdGlvbkNsaWNrZWQodGhpcylcIj48L3gtaW5mby1ib3gtYWN0aW9uPlxyXG4gKiAgICAgICAgPC94LWluZm8tYm94PlxyXG4gKiAgICAgIDwveC1tYXAtbWFya2VyPlxyXG4gKiAgICA8L3gtbWFwPlxyXG4gKiAgYFxyXG4gKiB9KVxyXG4gKiBgYGBcclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ3gtaW5mby1ib3gtYWN0aW9uJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGFiZWwgdG8gZGlzcGxheSBvbiB0aGUgYWN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hBY3Rpb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgIExhYmVsOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBhY3Rpb24gaGFzIGJlZW4gY2xpY2tlZFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94QWN0aW9uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKVxyXG4gICAgQWN0aW9uQ2xpY2tlZDogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG5cclxufVxyXG4iLCJpbXBvcnQge1xyXG4gICAgQWZ0ZXJWaWV3SW5pdCxcclxuICAgIENvbXBvbmVudCxcclxuICAgIENvbnRlbnRDaGlsZHJlbixcclxuICAgIEVsZW1lbnRSZWYsXHJcbiAgICBFdmVudEVtaXR0ZXIsXHJcbiAgICBJbnB1dCxcclxuICAgIE9uQ2hhbmdlcyxcclxuICAgIE9uRGVzdHJveSxcclxuICAgIE91dHB1dCxcclxuICAgIFF1ZXJ5TGlzdCxcclxuICAgIFNpbXBsZUNoYW5nZSxcclxuICAgIFZpZXdDaGlsZCxcclxuICAgIFZpZXdFbmNhcHN1bGF0aW9uXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IElJbmZvV2luZG93T3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWluZm8td2luZG93LW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJbmZvQm94U2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2luZm9ib3guc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcE1hcmtlckRpcmVjdGl2ZSB9IGZyb20gJy4vbWFwLW1hcmtlcic7XHJcbmltcG9ydCB7IEluZm9Cb3hBY3Rpb25EaXJlY3RpdmUgfSBmcm9tICcuL2luZm9ib3gtYWN0aW9uJztcclxuXHJcbi8qKlxyXG4gKiBpbnRlcm5hbCBjb3VudGVyIHRvIHVzZSBhcyBpZHMgZm9yIG11bHRpcGxlIGluZm9ib3hlcy5cclxuICovXHJcbmxldCBpbmZvQm94SWQgPSAwO1xyXG5cclxuLyoqXHJcbiAqIEluZm9Cb3ggcmVuZGVycyBhIGluZm8gd2luZG93IGluc2lkZSBhIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9yIHN0YW5kYWxvbmUuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG4gKiBpbXBvcnQge01hcENvbXBvbmVudCwgTWFwTWFya2VyRGlyZWN0aXZlLCBJbmZvQm94Q29tcG9uZW50LCBJbmZvQm94QWN0aW9uRGlyZWN0aXZlfSBmcm9tICcuLi4nO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXHJcbiAqICBzdHlsZXM6IFtgXHJcbiAqICAgIC5tYXAtY29udGFpbmVyIHsgaGVpZ2h0OiAzMDBweDsgfVxyXG4gKiBgXSxcclxuICogIHRlbXBsYXRlOiBgXHJcbiAqICAgIDx4LW1hcCBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbWm9vbV09XCJ6b29tXCI+XHJcbiAqICAgICAgPHgtbWFwLW1hcmtlciBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbTGFiZWxdPVwiJ00nXCI+XHJcbiAqICAgICAgICA8eC1pbmZvLWJveCBbRGlzYWJsZUF1dG9QYW5dPVwidHJ1ZVwiPlxyXG4gKiAgICAgICAgICBIaSwgdGhpcyBpcyB0aGUgY29udGVudCBvZiB0aGUgPHN0cm9uZz5pbmZvIHdpbmRvdzwvc3Ryb25nPlxyXG4gKiAgICAgICAgIDwveC1pbmZvLWJveD5cclxuICogICAgICAgPC94LW1hcC1tYXJrZXI+XHJcbiAqICAgICA8L3gtbWFwPlxyXG4gKiAgYFxyXG4gKiB9KVxyXG4gKiBgYGBcclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3gtaW5mby1ib3gnLFxyXG4gICAgdGVtcGxhdGU6IGBcclxuICAgICAgICA8ZGl2ICNpbmZvQm94Q29udGVudCBjbGFzcz0naW5mby1ib3gtY29udGVudCc+XHJcbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cclxuICAgICAgICA8L2Rpdj5gLFxyXG4gICAgc3R5bGVzOiBbYFxyXG4gICAgICAgIHgtbWFwIC5NaWNyb3NvZnRNYXAgLkluZm9ib3ggLmluZm9ib3gtdGl0bGUgeyBwYWRkaW5nOiAxMHB4IDEwcHggNXB4IDEwcHggfVxyXG4gICAgICAgIHgtbWFwIC5NaWNyb3NvZnRNYXAgLkluZm9ib3ggLmluZm9ib3gtaW5mbyB7IHBhZGRpbmc6IDNweCAxMHB4IDEwcHggMTBweCB9XHJcbiAgICAgICAgeC1tYXAgLk1pY3Jvc29mdE1hcCAuSW5mb2JveCAuaW5mb2JveC1hY3Rpb25zIHsgaGVpZ2h0OiBhdXRvIH1cclxuICAgIGBdLFxyXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxyXG59KVxyXG5leHBvcnQgY2xhc3MgSW5mb0JveENvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0IHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfaW5mb0JveEFkZGVkVG9NYW5hZ2VyID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9pZDogc3RyaW5nID0gKGluZm9Cb3hJZCsrKS50b1N0cmluZygpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSFRNTCBjb25lbnQgb2YgdGhlIGluZm9ib3hcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBAVmlld0NoaWxkKCdpbmZvQm94Q29udGVudCcpIHByaXZhdGUgX2NvbnRlbnQ6IEVsZW1lbnRSZWY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBaZXJvIG9yIG1vcmUgYWN0aW9ucyB0byBzaG93IG9uIHRoZSBpbmZvIHdpbmRvd1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBDb250ZW50Q2hpbGRyZW4oSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSkgcHVibGljIEluZm9XaW5kb3dBY3Rpb25zOiBRdWVyeUxpc3Q8SW5mb0JveEFjdGlvbkRpcmVjdGl2ZT47XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxhdGl0dWRlIHBvc2l0aW9uIG9mIHRoZSBpbmZvIHdpbmRvdyAob25seSB1c2VmdWxsIGlmIHlvdSB1c2UgaXQgb3VzaWRlIG9mIGEge0BsaW5rIE1hcE1hcmtlcn0pLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBMYXRpdHVkZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvbmdpdHVkZSBwb3NpdGlvbiBvZiB0aGUgaW5mbyB3aW5kb3cgKG9ubHkgdXNlZnVsbCBpZiB5b3UgdXNlIGl0IG91c2lkZSBvZiBhIHtAbGluayBNYXBNYXJrZXJ9KS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTG9uZ2l0dWRlOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGl0bGUgdG8gZGlzcGxheSBpbiB0aGUgaW5mbyB3aW5kb3dcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgVGl0bGU6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiB0byBkaXNwbGF5IGluIHRoZSBpbmZvIHdpbmRvdy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgRGVzY3JpcHRpb246IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGUgYXV0by1wYW4gb24gb3Blbi4gQnkgZGVmYXVsdCwgdGhlIGluZm8gd2luZG93IHdpbGwgcGFuIHRoZSBtYXAgc28gdGhhdCBpdCBpcyBmdWxseVxyXG4gICAgICogdmlzaWJsZSB3aGVuIGl0IG9wZW5zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBEaXNhYmxlQXV0b1BhbjogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqICBNYXhpbXVtIHdpZHRoIG9mIHRoZSBpbmZvd2luZG93LCByZWdhcmRsZXNzIG9mIGNvbnRlbnQncyB3aWR0aC4gVGhpcyB2YWx1ZSBpcyBvbmx5IGNvbnNpZGVyZWRcclxuICAgICAqICBpZiBpdCBpcyBzZXQgYmVmb3JlIGEgY2FsbCB0byBvcGVuLiBUbyBjaGFuZ2UgdGhlIG1heGltdW0gd2lkdGggd2hlbiBjaGFuZ2luZyBjb250ZW50LCBjYWxsXHJcbiAgICAgKiAgY2xvc2UsIHVwZGF0ZSBtYXhXaWR0aCwgYW5kIHRoZW4gb3Blbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTWF4V2lkdGg6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZSB3aGV0aGVyIG9ubHkgb25lIGluZm9ib3ggY2FuIGJlIG9wZW4gYXQgYSB0aW1lLiBOb3RlIHRoYXQgQU5ZIGluZm8gYm94IHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBNb2RhbCA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyB0aGUgbWFya2VyIHRoYXQgaXMgdGhlIGhvc3Qgb2YgdGhlIGluZm8gd2luZG93IChpZiBhdmFpbGFibGUpXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIEhvc3RNYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgdmlzaWJpbGl0eSBvZiBpbmZvYm94XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFZpc2libGUgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvcml6b250YWwgb2Zmc2V0IG9mIHRoZSBpbmZvYm94IGZyb20gdGhlIGhvc3QgbWFya2VyIGxhdC9sb25nIG9yIHRoZSBzZXBlY2lmaWVkIGNvb3JkaW5hdGVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyB4T2Zmc2V0OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJ0aWNhbCBvZmZzZXQgZm9yIHRoZSBpbmZvYm94IGZyb20gdGhlIGhvc3QgbWFya2VyIGxhdC9sb25nIG9yIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIHlPZmZzZXQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgaWYgb3RoZXIgaW5mbyBib3hlcyBzaG91bGQgYmUgY2xvc2VkIGJlZm9yZSBvcGVuaW5nIHRoaXMgb25lXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIENsb3NlSW5mb0JveGVzT25PcGVuID0gdHJ1ZTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBEZWxlZ2F0ZSBkZWZpbnRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIGluZm8gd2luZG93IGlzIGNsb3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgcHVibGljIEluZm9Cb3hDbG9zZTogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnMuXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIEhUTUwgY29udGVudCBvZiB0aGUgaW5mbyBib3guXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IEh0bWxDb250ZW50KCk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQubmF0aXZlRWxlbWVudCAmJiB0aGlzLl9jb250ZW50Lm5hdGl2ZUVsZW1lbnQuaW5uZXJUZXh0ICYmIHRoaXMuX2NvbnRlbnQubmF0aXZlRWxlbWVudC5pbm5lclRleHQudHJpbSgpICE9PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5uYXRpdmVFbGVtZW50Lm91dGVySFRNTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgSWQgb2YgdGhlIGluZm8gYm94IGFzIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZCgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5faWQ7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEluZm9Cb3hDb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gX2luZm9Cb3hTZXJ2aWNlIC0gQ29uY3JldGUge0BsaW5rIEluZm9Cb3hTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdW5kZXJseWluZyBNYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2luZm9Cb3hTZXJ2aWNlOiBJbmZvQm94U2VydmljZSkgeyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoZSBJbmZvYm94LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDbG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5mb0JveFNlcnZpY2UuQ2xvc2UodGhpcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuSW5mb0JveENsb3NlLmVtaXQodGhpcy5faWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIG9uIGFmdGVyIGNvbXBvbmVudCB2aWV3IGFzIGJlZW4gaW5pdGlhbGl6ZWQuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcclxuICAgICAgICB0aGlzLl9pbmZvQm94U2VydmljZS5BZGRJbmZvV2luZG93KHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2luZm9Cb3hBZGRlZFRvTWFuYWdlciA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5IYW5kbGVFdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5nZXMgdG8gdGhlIGRhdGFib3VkIHByb3BlcnRpZXMgb2NjdXIuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0gQ2hhbmdlcyB0aGF0IGhhdmUgb2NjdXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiB7IFtrZXk6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbmZvQm94QWRkZWRUb01hbmFnZXIpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgaWYgKChjaGFuZ2VzWydsYXRpdHVkZSddIHx8IGNoYW5nZXNbJ2xvbmdpdHVkZSddKSAmJiB0eXBlb2YgdGhpcy5MYXRpdHVkZSA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuTG9uZ2l0dWRlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLl9pbmZvQm94U2VydmljZS5TZXRQb3NpdGlvbih0aGlzLCB7XHJcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogY2hhbmdlc1snbGF0aXR1ZGUnXS5jdXJyZW50VmFsdWUsXHJcbiAgICAgICAgICAgICAgICBsb25naXR1ZGU6IGNoYW5nZXNbJ2xvbmdpdHVkZSddLmN1cnJlbnRWYWx1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5TZXRJbmZvV2luZG93T3B0aW9ucyhjaGFuZ2VzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBvbiBjb21wb25lbnQgZGVzdHJ1Y3Rpb24uIEZyZWVzIHRoZSByZXNvdXJjZXMgdXNlZCBieSB0aGUgY29tcG9uZW50LiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHsgdGhpcy5faW5mb0JveFNlcnZpY2UuRGVsZXRlSW5mb1dpbmRvdyh0aGlzKTsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgYSBjbG9zZWQgaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIFtsb2NdICAtIHtAbGluayBJTGF0TG9uZyB9IHJlcHJlc2VudGluZyBwb3NpdGlvbiBvbiB3aGljaCB0byBvcGVuIHRoZSB3aW5kb3cuXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGluZm9ib3ggaGFzIGJlZW4gb3BlbmVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBPcGVuKGxvYz86IElMYXRMb25nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9Cb3hTZXJ2aWNlLk9wZW4odGhpcywgbG9jKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluZm8gYm94LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbmZvIGJveC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVG9TdHJpbmcoKTogc3RyaW5nIHsgcmV0dXJuICdJbmZvQm94Q29tcG9uZW50LScgKyB0aGlzLl9pZDsgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyB0aGUgbWFwIGNsaWNrIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgSGFuZGxlRXZlbnRzKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2luZm9Cb3hTZXJ2aWNlLkNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnaW5mb3dpbmRvd2Nsb3NlJywgdGhpcykuc3Vic2NyaWJlKGUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLkluZm9Cb3hDbG9zZS5lbWl0KHRoaXMuX2lkKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IG9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2hhbmdlc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94Q29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgU2V0SW5mb1dpbmRvd09wdGlvbnMoY2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IElJbmZvV2luZG93T3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGlmIChjaGFuZ2VzWyd0aXRsZSddKSB7IG9wdGlvbnMudGl0bGUgPSB0aGlzLlRpdGxlOyB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ2Rlc2NyaXB0aW9uJ10pIHsgb3B0aW9ucy5kZXNjcmlwdGlvbiA9IHRoaXMuRGVzY3JpcHRpb247IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snZGlzYWJsZUF1dG9QYW4nXSkgeyBvcHRpb25zLmRpc2FibGVBdXRvUGFuID0gdGhpcy5EaXNhYmxlQXV0b1BhbjsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWyd2aXNpYmxlJ10pIHsgb3B0aW9ucy52aXNpYmxlID0gdGhpcy5WaXNpYmxlOyB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ3hPZmZzZXQnXSB8fCBjaGFuZ2VzWyd5T2Zmc2V0J10pIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGl4ZWxPZmZzZXQgPT0gbnVsbCkgeyBvcHRpb25zLnBpeGVsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07IH1cclxuICAgICAgICAgICAgb3B0aW9ucy5waXhlbE9mZnNldC54ID0gdGhpcy54T2Zmc2V0O1xyXG4gICAgICAgICAgICBvcHRpb25zLnBpeGVsT2Zmc2V0LnkgPSB0aGlzLnlPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2luZm9Cb3hTZXJ2aWNlLlNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICAgIERpcmVjdGl2ZSwgU2ltcGxlQ2hhbmdlLCBJbnB1dCwgT3V0cHV0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyxcclxuICAgIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBBZnRlckNvbnRlbnRJbml0LCBWaWV3Q29udGFpbmVyUmVmXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgdGltZXIgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9pbnQnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJTWFya2VyRXZlbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXJrZXItZXZlbnQnO1xyXG5pbXBvcnQgeyBJTWFya2VySWNvbkluZm8gfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXJrZXItaWNvbi1pbmZvJztcclxuaW1wb3J0IHsgTWFya2VyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL21hcmtlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSW5mb0JveENvbXBvbmVudCB9IGZyb20gJy4vaW5mb2JveCc7XHJcblxyXG4vKipcclxuICogaW50ZXJuYWwgY291bnRlciB0byB1c2UgYXMgaWRzIGZvciBtYXJrZXIuXHJcbiAqL1xyXG5sZXQgbWFya2VySWQgPSAwO1xyXG5cclxuLyoqXHJcbiAqIE1hcE1hcmtlckRpcmVjdGl2ZSByZW5kZXJzIGEgbWFwIG1hcmtlciBpbnNpZGUgYSB7QGxpbmsgTWFwQ29tcG9uZW50fS5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbiAqIGltcG9ydCB7TWFwQ29tcG9uZW50LCBNYXBNYXJrZXJEaXJlY3RpdmV9IGZyb20gJy4uLic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcclxuICogIHN0eWxlczogW2BcclxuICogICAubWFwLWNvbnRhaW5lciB7XHJcbiAqICAgICBoZWlnaHQ6IDMwMHB4O1xyXG4gKiAgIH1cclxuICogYF0sXHJcbiAqIHRlbXBsYXRlOiBgXHJcbiAqICAgPHgtbWFwIFtMYXRpdHVkZV09XCJsYXRcIiBbTG9uZ2l0dWRlXT1cImxuZ1wiIFtab29tXT1cInpvb21cIj5cclxuICogICAgICA8eC1tYXAtbWFya2VyIFtMYXRpdHVkZV09XCJsYXRcIiBbTG9uZ2l0dWRlXT1cImxuZ1wiIFtMYWJlbF09XCInTSdcIj48L3gtbWFwLW1hcmtlcj5cclxuICogICA8L3gtbWFwPlxyXG4gKiBgXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAneC1tYXAtbWFya2VyJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgTWFwTWFya2VyRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkNoYW5nZXMsIEFmdGVyQ29udGVudEluaXQge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF9jbGlja1RpbWVvdXQ6IFN1YnNjcmlwdGlvbiA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9ldmVudHM6IFN1YnNjcmlwdGlvbltdID0gW107XHJcbiAgICBwcml2YXRlIF9pZDogc3RyaW5nO1xyXG4gICAgcHJpdmF0ZSBfaW5DbHVzdGVyTGF5ZXIgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2luQ3VzdG9tTGF5ZXIgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFueSBJbmZvQm94IHRoYXQgaXMgYSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhlIG1hcmtlclxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQENvbnRlbnRDaGlsZChJbmZvQm94Q29tcG9uZW50KSBwcm90ZWN0ZWQgX2luZm9Cb3g6IEluZm9Cb3hDb21wb25lbnQ7XHJcblxyXG4gICAgcHJpdmF0ZSBfbGF5ZXJJZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBfbWFya2VyQWRkZWRUb01hbmdlciA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogIEljb24gYW5jaG9yIHJlbGF0aXZlIHRvIG1hcmtlciByb290XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgQW5jaG9yOiBJUG9pbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBkYmxjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIERibENsaWNrOiBFdmVudEVtaXR0ZXI8SU1hcmtlckV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SU1hcmtlckV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyByZXBlYXRlZGx5IGZpcmVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgRHJhZzogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIERyYWdFbmQ6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0cnVlLCB0aGUgbWFya2VyIGNhbiBiZSBkcmFnZ2VkLiBEZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIERyYWdnYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIERyYWdTdGFydDogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiBhIG1hcmtlciBpY29uIGlzIGJlaW5nIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgcHVibGljIER5bmFtaWNNYXJrZXJDcmVhdGVkOiBFdmVudEVtaXR0ZXI8SU1hcmtlckljb25JbmZvPiA9IG5ldyBFdmVudEVtaXR0ZXI8SU1hcmtlckljb25JbmZvPigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWNvbiBoZWlnaHRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBIZWlnaHQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZm9ybWF0aW9uIGZvciBkeW5hbWljLCBjdXN0b20gY3JlYXRlZCBpY29ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBJY29uSW5mbzogSU1hcmtlckljb25JbmZvO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWNvbiAodGhlIFVSTCBvZiB0aGUgaW1hZ2UpIGZvciB0aGUgZm9yZWdyb3VuZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBJY29uVXJsOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcnVlIHRvIGluZGljaWF0ZSB3aGV0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IG1hcmtlciBpbiBhIHNldC5cclxuICAgICAqIFVzZSB0aGlzIGZvciBidWxrIG9wZXJhdGlvbnMgKHBhcnRpY3VsYXJpbHkgY2x1c3RlcmluZykgdG8gZW5zdXJlIHBlcmZvcm1hbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIElzRmlyc3RJblNldCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJ1ZSB0byBpbmRpY2lhdGUgd2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IG1hcmtlciBpbiBhIHNldC5cclxuICAgICAqIFVzZSB0aGlzIGZvciBidWxrIG9wZXJhdGlvbnMgKHBhcnRpY3VsYXJpbHkgY2x1c3RlcmluZykgdG8gZW5zdXJlIHBlcmZvcm1hbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIElzTGFzdEluU2V0ID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsYWJlbCAoYSBzaW5nbGUgdXBwZXJjYXNlIGNoYXJhY3RlcikgZm9yIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTGFiZWw6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsYXRpdHVkZSBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIExhdGl0dWRlOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbG9uZ2l0dWRlIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTG9uZ2l0dWRlOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgcHVibGljIE1hcmtlckNsaWNrOiBFdmVudEVtaXR0ZXI8SU1hcmtlckV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SU1hcmtlckV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJiaXRhcnkgbWV0YWRhdGEgdG8gYXNzaWduIHRvIHRoZSBNYXJrZXIuIFRoaXMgaXMgdXNlZnVsIGZvciBldmVudHNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBNZXRhZGF0YTogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZWRvd24gZXZlbnQgaXMgZmlyZWQgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBNb3VzZURvd246IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZW1vdmUgZXZlbnQgaXMgZmlyZWQgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBNb3VzZU1vdmU6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIG1hcmtlciBtb3VzZW91dC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBNb3VzZU91dDogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gbWFya2VyIG1vdXNlb3Zlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBNb3VzZU92ZXI6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZSB0aGUgRE9NIG1vdXNldXAgZXZlbnQgaXMgZmlyZWQgb24gdGhlIG1hcmtlclxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIE1vdXNlVXA6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW4gaXMgZmlyZWQgd2hlbiB0aGUgbWFya2VyIGlzIHJpZ2h0LWNsaWNrZWQgb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgUmlnaHRDbGljazogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUaGUgdGl0bGUgb2YgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBUaXRsZTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbWFya2VyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgVmlzaWJsZTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEljb24gV2lkdGhcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBXaWR0aDogbnVtYmVyO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIERlbGVnYXRlc1xyXG4gICAgLy8vXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzd2hldGhlciB0aGUgbWFya2VyIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gdGhlIG1hcmtlciBzZXJ2aWNlIGFuZCBpcyByZWFkeSBmb3IgdXNlLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IEFkZGVkVG9NYW5hZ2VyKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fbWFya2VyQWRkZWRUb01hbmdlcjsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaWQgb2YgdGhlIG1hcmtlciBhcyBhIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZCgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5faWQ7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgbWFya2VyIGlzIGluIGEgY2x1c3RlciBsYXllci4gU2VlIHtAbGluayBDbHVzdGVyTGF5ZXJ9LlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IEluQ2x1c3RlckxheWVyKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faW5DbHVzdGVyTGF5ZXI7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgbWFya2VyIGlzIGluIGEgY3VzdG9tIGxheWVyLiBTZWUge0BsaW5rIE1hcExheWVyfS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJbkN1c3RvbUxheWVyKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faW5DdXN0b21MYXllcjsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0cyB0aGUgaWQgb2YgdGhlIExheWVyIHRoZSBtYXJrZXIgYmVsb25ncyB0by5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBMYXllcklkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9sYXllcklkOyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBNYXBNYXJrZXJEaXJlY3RpdmUuXHJcbiAgICAgKiBAcGFyYW0gX21hcmtlclNlcnZpY2UgLSBDb25jcmVhdGUgaW1wbGVtZW50YXRpb24gb2YgYSB7QGxpbmsgTWFya2VyU2VydmljZX0uXHJcbiAgICAgKiBAcGFyYW0gX2NvbnRhaW5lclJlZiAtIFZpZXcgY29udGFpbmVyIGhvc3RpbmcgdGhlIG1hcmtlci5cclxuICAgICAqIFVzZWQgdG8gZGV0ZXJtaW5lIHBhcmVudCBsYXllciB0aHJvdWdoIG1hcmt1cC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcmtlclNlcnZpY2U6IE1hcmtlclNlcnZpY2UsIHByaXZhdGUgX2NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge1xyXG4gICAgICAgIHRoaXMuX2lkID0gKG1hcmtlcklkKyspLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlcyBhIG1hcmtlciBnZW8gbG9jYXRpb24gdG8gYSBwaXhlbCBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgbWFwIHZpZXdwb3J0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBbbG9jXSAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzLiBJZiBudWxsLCB0aGUgbWFya2VyJ3MgY29vcmRpbmF0ZXMgYXJlIHVzZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyBhbiB7QGxpbmsgSVBvaW50fSByZXByZXNlbnRpbmcgdGhlIHBpeGVsIGNvb3JkaW5hdGVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIExvY2F0aW9uVG9QaXhlbChsb2M/OiBJTGF0TG9uZyk6IFByb21pc2U8SVBvaW50PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlclNlcnZpY2UuTG9jYXRpb25Ub1BvaW50KGxvYyA/IGxvYyA6IHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFmdGVyIENvbXBvbmVudCBjb250ZW50IGluaXRpYWxpemF0aW9uLiBQYXJ0IG9mIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcclxuICAgICAgICBpZiAodGhpcy5faW5mb0JveCAhPSBudWxsKSB7IHRoaXMuX2luZm9Cb3guSG9zdE1hcmtlciA9IHRoaXM7IH1cclxuICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5hbWU6IHN0cmluZyA9IHRoaXMuX2NvbnRhaW5lclJlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudC50YWdOYW1lO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSAneC1jbHVzdGVyLWxheWVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5DbHVzdGVyTGF5ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3gtbWFwLWxheWVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5DdXN0b21MYXllciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJJZCA9IE51bWJlcih0aGlzLl9jb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQuYXR0cmlidXRlc1snbGF5ZXJJZCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9tYXJrZXJBZGRlZFRvTWFuZ2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtlclNlcnZpY2UuQWRkTWFya2VyKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJBZGRlZFRvTWFuZ2VyID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5BZGRFdmVudExpc3RlbmVycygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWN0cyB0byBjaGFuZ2VzIGluIGRhdGEtYm91bmQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50IGFuZCBhY3R1YXRlcyBwcm9wZXJ0eSBjaGFuZ2VzIGluIHRoZSB1bmRlcmxpbmcgbGF5ZXIgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoYW5nZXMgLSBjb2xsZWN0aW9uIG9mIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5MYXRpdHVkZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHRoaXMuTG9uZ2l0dWRlICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fbWFya2VyQWRkZWRUb01hbmdlcikgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snTGF0aXR1ZGUnXSB8fCBjaGFuZ2VzWydMb25naXR1ZGUnXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZU1hcmtlclBvc2l0aW9uKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snVGl0bGUnXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZVRpdGxlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snTGFiZWwnXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZUxhYmVsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snRHJhZ2dhYmxlJ10pIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFya2VyU2VydmljZS5VcGRhdGVEcmFnZ2FibGUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydJY29uVXJsJ10gfHwgY2hhbmdlc1snSWNvbkluZm8nXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZUljb24odGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydBbmNob3InXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZUFuY2hvcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ1Zpc2libGUnXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLlVwZGF0ZVZpc2libGUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIG9uIGNvbXBvbmVudCBkZXN0cnVjdGlvbi4gRnJlZXMgdGhlIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBjb21wb25lbnQuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9tYXJrZXJTZXJ2aWNlLkRlbGV0ZU1hcmtlcih0aGlzKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgocykgPT4gcy51bnN1YnNjcmliZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE1hcmtlciBJZC5cclxuICAgICAqIEByZXR1cm5zIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgaWQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcgeyByZXR1cm4gJ01hcE1hcmtlci0nICsgdGhpcy5faWQudG9TdHJpbmcoKTsgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHZhcmlvdXMgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBBZGRFdmVudExpc3RlbmVycygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBfZ2V0RXZlbnRBcmc6IChlOiBNb3VzZUV2ZW50KSA9PiBJTWFya2VyRXZlbnQgPSBlID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIE1hcmtlcjogdGhpcyxcclxuICAgICAgICAgICAgICAgIENsaWNrOiBlLFxyXG4gICAgICAgICAgICAgICAgTG9jYXRpb246IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZSksXHJcbiAgICAgICAgICAgICAgICBQaXhlbHM6IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0UGl4ZWxzRnJvbUNsaWNrKGUpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2godGhpcy5fbWFya2VyU2VydmljZS5DcmVhdGVFdmVudE9ic2VydmFibGUoJ2NsaWNrJywgdGhpcykuc3Vic2NyaWJlKChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIC8vL1xyXG4gICAgICAgICAgICAvLy8gdGhpcyBpcyBuZWNlc3Nhcnkgc2luY2UgbWFwIHdpbGwgdHJlYXQgYSBkb3VibGVjbGljayBmaXJzdCBhcyB0d28gY2xpY2tzLi4uJ1xyXG4gICAgICAgICAgICAvLy9cclxuICAgICAgICAgICAgdGhpcy5fY2xpY2tUaW1lb3V0ID0gdGltZXIoMzAwKS5zdWJzY3JpYmUobiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5mb0JveCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5mb0JveC5PcGVuKHRoaXMuX21hcmtlclNlcnZpY2UuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5NYXJrZXJDbGljay5lbWl0KF9nZXRFdmVudEFyZyhlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2godGhpcy5fbWFya2VyU2VydmljZS5DcmVhdGVFdmVudE9ic2VydmFibGUoJ2RibGNsaWNrJywgdGhpcykuc3Vic2NyaWJlKChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbGlja1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NsaWNrVGltZW91dC51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2xpY2tUaW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLkRibENsaWNrLmVtaXQoX2dldEV2ZW50QXJnKGUpKTtcclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLkRyYWcuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnZW5kJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLkRyYWdFbmQuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnc3RhcnQnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZ1N0YXJ0LmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vkb3duJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlRG93bi5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlbW92ZScsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU1vdmUuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW91dCcsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU91dC5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlb3ZlcicsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU92ZXIuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZXVwJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlVXAuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdyaWdodGNsaWNrJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlJpZ2h0Q2xpY2suZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgob2JqKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9zID0gdGhpcy5fbWFya2VyU2VydmljZS5DcmVhdGVFdmVudE9ic2VydmFibGUob2JqLm5hbWUsIHRoaXMpLnN1YnNjcmliZShvYmouaGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKG9zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICAgIENvbXBvbmVudCxcclxuICAgIEV2ZW50RW1pdHRlcixcclxuICAgIE9uQ2hhbmdlcyxcclxuICAgIE9uSW5pdCxcclxuICAgIE9uRGVzdHJveSxcclxuICAgIFNpbXBsZUNoYW5nZSxcclxuICAgIFZpZXdDaGlsZCxcclxuICAgIENvbnRlbnRDaGlsZHJlbixcclxuICAgIElucHV0LFxyXG4gICAgT3V0cHV0LFxyXG4gICAgRWxlbWVudFJlZixcclxuICAgIEhvc3RCaW5kaW5nLFxyXG4gICAgVmlld0VuY2Fwc3VsYXRpb24sXHJcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICAgIE5nWm9uZVxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlRmFjdG9yeSB9IGZyb20gJy4uL3NlcnZpY2VzL21hcHNlcnZpY2VmYWN0b3J5JztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFya2VyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL21hcmtlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9pbmZvYm94LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUG9seWdvblNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9wb2x5bGluZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQ2x1c3RlclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9jbHVzdGVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJQm94IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pYm94JztcclxuaW1wb3J0IHsgSU1hcE9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ltYXAtb3B0aW9ucyc7XHJcbmltcG9ydCB7IE1hcFR5cGVJZCB9IGZyb20gJy4uL21vZGVscy9tYXAtdHlwZS1pZCc7XHJcbmltcG9ydCB7IE1hcE1hcmtlckRpcmVjdGl2ZSB9IGZyb20gJy4vbWFwLW1hcmtlcic7XHJcblxyXG4vKipcclxuICogUmVuZGVycyBhIG1hcCBiYXNlZCBvbiBhIGdpdmVuIHByb3ZpZGVyLlxyXG4gKiAqKkltcG9ydGFudCBub3RlKio6IFRvIGJlIGFibGUgc2VlIGEgbWFwIGluIHRoZSBicm93c2VyLCB5b3UgaGF2ZSB0byBkZWZpbmUgYSBoZWlnaHQgZm9yIHRoZSBDU1NcclxuICogY2xhc3MgYG1hcC1jb250YWluZXJgLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuICogaW1wb3J0IHtNYXBDb21wb25lbnR9IGZyb20gJy4uLic7XHJcbiAqXHJcbiAqIEBDb21wb25lbnQoe1xyXG4gKiAgc2VsZWN0b3I6ICdteS1tYXAnLFxyXG4gKiAgc3R5bGVzOiBbYFxyXG4gKiAgICAubWFwLWNvbnRhaW5lciB7IGhlaWdodDogMzAwcHg7IH1cclxuICogYF0sXHJcbiAqICB0ZW1wbGF0ZTogYFxyXG4gKiAgICA8eC1tYXAgW0xhdGl0dWRlXT1cImxhdFwiIFtMb25naXR1ZGVdPVwibG5nXCIgW1pvb21dPVwiem9vbVwiPjwveC1tYXA+XHJcbiAqICBgXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAneC1tYXAnLFxyXG4gICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgeyBwcm92aWRlOiBNYXBTZXJ2aWNlLCBkZXBzOiBbTWFwU2VydmljZUZhY3RvcnldLCB1c2VGYWN0b3J5OiBNYXBTZXJ2aWNlQ3JlYXRvciB9LFxyXG4gICAgICAgIHsgcHJvdmlkZTogTWFya2VyU2VydmljZSwgZGVwczogW01hcFNlcnZpY2VGYWN0b3J5LCBNYXBTZXJ2aWNlLCBMYXllclNlcnZpY2UsIENsdXN0ZXJTZXJ2aWNlXSwgdXNlRmFjdG9yeTogTWFya2VyU2VydmljZUZhY3RvcnkgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHByb3ZpZGU6IEluZm9Cb3hTZXJ2aWNlLCBkZXBzOiBbTWFwU2VydmljZUZhY3RvcnksIE1hcFNlcnZpY2UsXHJcbiAgICAgICAgICAgICAgICBNYXJrZXJTZXJ2aWNlXSwgdXNlRmFjdG9yeTogSW5mb0JveFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7IHByb3ZpZGU6IExheWVyU2VydmljZSwgZGVwczogW01hcFNlcnZpY2VGYWN0b3J5LCBNYXBTZXJ2aWNlXSwgdXNlRmFjdG9yeTogTGF5ZXJTZXJ2aWNlRmFjdG9yeSB9LFxyXG4gICAgICAgIHsgcHJvdmlkZTogQ2x1c3RlclNlcnZpY2UsIGRlcHM6IFtNYXBTZXJ2aWNlRmFjdG9yeSwgTWFwU2VydmljZV0sIHVzZUZhY3Rvcnk6IENsdXN0ZXJTZXJ2aWNlRmFjdG9yeSB9LFxyXG4gICAgICAgIHsgcHJvdmlkZTogUG9seWdvblNlcnZpY2UsIGRlcHM6IFtNYXBTZXJ2aWNlRmFjdG9yeSwgTWFwU2VydmljZSwgTGF5ZXJTZXJ2aWNlXSwgdXNlRmFjdG9yeTogUG9seWdvblNlcnZpY2VGYWN0b3J5IH0sXHJcbiAgICAgICAgeyBwcm92aWRlOiBQb2x5bGluZVNlcnZpY2UsIGRlcHM6IFtNYXBTZXJ2aWNlRmFjdG9yeSwgTWFwU2VydmljZSwgTGF5ZXJTZXJ2aWNlXSwgdXNlRmFjdG9yeTogUG9seWxpbmVTZXJ2aWNlRmFjdG9yeSB9XHJcbiAgICBdLFxyXG4gICAgdGVtcGxhdGU6IGBcclxuICAgICAgICA8ZGl2ICNjb250YWluZXIgY2xhc3M9J21hcC1jb250YWluZXItaW5uZXInPjwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9J21hcC1jb250ZW50Jz5cclxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgYCxcclxuICAgIHN0eWxlczogW2BcclxuICAgICAgICAubWFwLWNvbnRhaW5lci1pbm5lciB7IHdpZHRoOiBpbmhlcml0OyBoZWlnaHQ6IGluaGVyaXQ7IH1cclxuICAgICAgICAubWFwLWNvbnRhaW5lci1pbm5lciBkaXYgeyBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0OyB9XHJcbiAgICAgICAgLm1hcC1jb250ZW50IHsgZGlzcGxheTpub25lOyB9XHJcbiAgICBgXSxcclxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTWFwQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkluaXQsIE9uRGVzdHJveSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2xvbmdpdHVkZSA9IDA7XHJcbiAgICBwcml2YXRlIF9sYXRpdHVkZSA9IDA7XHJcbiAgICBwcml2YXRlIF96b29tID0gMDtcclxuICAgIHByaXZhdGUgX2NsaWNrVGltZW91dDogbnVtYmVyIHwgTm9kZUpTLlRpbWVyO1xyXG4gICAgcHJpdmF0ZSBfb3B0aW9uczogSU1hcE9wdGlvbnMgPSB7fTtcclxuICAgIHByaXZhdGUgX2JveDogSUJveCA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9tYXBQcm9taXNlOiBQcm9taXNlPHZvaWQ+O1xyXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5tYXAtY29udGFpbmVyJykgcHVibGljIF9jb250YWluZXJDbGFzczogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBAVmlld0NoaWxkKCdjb250YWluZXInKSBwcml2YXRlIF9jb250YWluZXI6IEVsZW1lbnRSZWY7XHJcbiAgICBAQ29udGVudENoaWxkcmVuKE1hcE1hcmtlckRpcmVjdGl2ZSkgcHJpdmF0ZSBfbWFya2VyczogQXJyYXk8TWFwTWFya2VyRGlyZWN0aXZlPjtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldHMgdGhlIG1heGltdW0gYW5kIG1pbmltdW0gYm91bmRpbmcgYm94IGZvciBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgcHVibGljIGdldCBCb3goKTogSUJveCB7IHJldHVybiB0aGlzLl9ib3g7IH1cclxuICAgIHB1YmxpYyBzZXQgQm94KHZhbDogSUJveCkgeyB0aGlzLl9ib3ggPSB2YWw7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGF0aXR1ZGUgdGhhdCBzZXRzIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgZ2V0IExhdGl0dWRlKCk6IG51bWJlciB8IHN0cmluZyB7IHJldHVybiB0aGlzLl9sb25naXR1ZGU7IH1cclxuICAgIHB1YmxpYyBzZXQgTGF0aXR1ZGUodmFsdWU6IG51bWJlciB8IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2xhdGl0dWRlID0gdGhpcy5Db252ZXJ0VG9EZWNpbWFsKHZhbHVlKTtcclxuICAgICAgICB0aGlzLlVwZGF0ZUNlbnRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBsb25naXR1ZGUgdGhhdCBzZXRzIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgZ2V0IExvbmdpdHVkZSgpOiBudW1iZXIgfCBzdHJpbmcgeyByZXR1cm4gdGhpcy5fbG9uZ2l0dWRlOyB9XHJcbiAgICBwdWJsaWMgc2V0IExvbmdpdHVkZSh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fbG9uZ2l0dWRlID0gdGhpcy5Db252ZXJ0VG9EZWNpbWFsKHZhbHVlKTtcclxuICAgICAgICB0aGlzLlVwZGF0ZUNlbnRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIGdlbmVyYWwgbWFwIE9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgZ2V0IE9wdGlvbnMoKTogSU1hcE9wdGlvbnMgeyByZXR1cm4gdGhpcy5fb3B0aW9uczsgfVxyXG4gICAgcHVibGljIHNldCBPcHRpb25zKHZhbDogSU1hcE9wdGlvbnMpIHsgdGhpcy5fb3B0aW9ucyA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGA4YC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgZ2V0IFpvb20oKTogbnVtYmVyIHwgc3RyaW5nIHsgcmV0dXJuIHRoaXMuX3pvb207IH1cclxuICAgIHB1YmxpYyBzZXQgWm9vbSh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fem9vbSA9IHRoaXMuQ29udmVydFRvRGVjaW1hbCh2YWx1ZSwgOCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl96b29tID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlNldFpvb20odGhpcy5fem9vbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGlzIGZpcmVkIHdoZW4gdGhlIG1hcCBib3VuZGluZyBib3ggY2hhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKVxyXG4gICAgQm91bmRzQ2hhbmdlOiBFdmVudEVtaXR0ZXI8SUJveD4gPSBuZXcgRXZlbnRFbWl0dGVyPElCb3g+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgaXMgZmlyZWQgd2hlbiB0aGUgbWFwIGNlbnRlciBjaGFuZ2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpXHJcbiAgICBDZW50ZXJDaGFuZ2U6IEV2ZW50RW1pdHRlcjxJTGF0TG9uZz4gPSBuZXcgRXZlbnRFbWl0dGVyPElMYXRMb25nPigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwIChidXQgbm90IHdoZW4gdGhleSBjbGljayBvbiBhXHJcbiAgICAgKiBtYXJrZXIgb3IgaW5mb1dpbmRvdykuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KClcclxuICAgIE1hcENsaWNrOiBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyBvbiB0aGUgbWFwIChidXQgbm90IHdoZW4gdGhleSBjbGlja1xyXG4gICAgICogb24gYSBtYXJrZXIgb3IgaW5mb1dpbmRvdykuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KClcclxuICAgIE1hcERibENsaWNrOiBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgcmlnaHQtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXHJcbiAgICAgKiBvbiBhIG1hcmtlciBvciBpbmZvV2luZG93KS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKVxyXG4gICAgTWFwUmlnaHRDbGljazogRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZS1jbGlja3Mgb24gdGhlIG1hcCAoYnV0IG5vdCB3aGVuIHRoZXkgY2xpY2tcclxuICAgICAqIG9uIGEgbWFya2VyIG9yIGluZm9XaW5kb3cpLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpXHJcbiAgICBNYXBNb3VzZU92ZXI6IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXHJcbiAgICAgKiBvbiBhIG1hcmtlciBvciBpbmZvV2luZG93KS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKVxyXG4gICAgTWFwTW91c2VPdXQ6IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBkb3VibGUtY2xpY2tzIG9uIHRoZSBtYXAgKGJ1dCBub3Qgd2hlbiB0aGV5IGNsaWNrXHJcbiAgICAgKiBvbiBhIG1hcmtlciBvciBpbmZvV2luZG93KS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKVxyXG4gICAgTWFwTW91c2VNb3ZlOiBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZXZlbnQgZW1pdHRlciBpcyBmaXJlZCB3aGVuIHRoZSBtYXAgc2VydmljZSBpcyBhdmFpbGFibGUgYW5kIHRoZSBtYXBzIGhhcyBiZWVuXHJcbiAgICAgKiBJbml0aWFsaXplZCAoYnV0IG5vdCBuZWNlc3NhcmlseSBjcmVhdGVkKS4gSXQgY29udGFpbnMgYSBQcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIHJldHVybnNcclxuICAgICAqIHRoZSBtYWluIG1hcCBvYmplY3Qgb2YgdGhlIHVuZGVybHlpbmcgcGxhdGZvcm0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KClcclxuICAgIE1hcFByb21pc2U6IEV2ZW50RW1pdHRlcjxQcm9taXNlPGFueT4+ID0gbmV3IEV2ZW50RW1pdHRlcjxQcm9taXNlPGFueT4+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaWl0ZXIgaXMgZmlyZWQgd2hlbiB0aGUgbWFwIHpvb20gY2hhbmdlc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpXHJcbiAgICBab29tQ2hhbmdlOiBFdmVudEVtaXR0ZXI8TnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8TnVtYmVyPigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGlzIGZpcmVkIHdoZW4gdGhlIG1hcCBzZXJ2aWNlIGlzIGF2YWlsYWJsZSBhbmQgdGhlIG1hcHMgaGFzIGJlZW5cclxuICAgICAqIEluaXRpYWxpemVkXHJcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKVxyXG4gICAgTWFwU2VydmljZTogRXZlbnRFbWl0dGVyPE1hcFNlcnZpY2U+ID0gbmV3IEV2ZW50RW1pdHRlcjxNYXBTZXJ2aWNlPigpO1xyXG5cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1hcENvbXBvbmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSBDb25jcmV0ZWQgaW1wbGVtZW50YXRpb24gb2YgYSBtYXAgc2VydmljZSBmb3IgdGhlIHVuZGVybHlpbmcgbWFwcyBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR2VuZXJhbGx5IHByb3ZpZGVkIHZpYSBpbmplY3Rpb25zLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHsgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBvbiBDb21wb25lbnQgaW5pdGlhbGl6YXRpb24uIFBhcnQgb2YgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5Jbml0TWFwSW5zdGFuY2UodGhpcy5fY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuTWFwUHJvbWlzZS5lbWl0KHRoaXMuX21hcFNlcnZpY2UuTWFwUHJvbWlzZSk7XHJcbiAgICAgICAgdGhpcy5NYXBTZXJ2aWNlLmVtaXQodGhpcy5fbWFwU2VydmljZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiBjaGFuZ2VzIHRvIHRoZSBkYXRhYm91ZCBwcm9wZXJ0aWVzIG9jY3VyLiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyAtIENoYW5nZXMgdGhhdCBoYXZlIG9jY3VyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBbcHJvcE5hbWU6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21hcFByb21pc2UpIHtcclxuICAgICAgICAgICAgaWYgKGNoYW5nZXNbJ0JveCddKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm94ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlNldFZpZXdPcHRpb25zKDxJTWFwT3B0aW9ucz57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kczogdGhpcy5fYm94XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoYW5nZXNbJ09wdGlvbnMnXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TZXRNYXBPcHRpb25zKHRoaXMuX29wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIG9uIGNvbXBvbmVudCBkZXN0cnVjdGlvbi4gRnJlZXMgdGhlIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBjb21wb25lbnQuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX21hcFNlcnZpY2UuRGlzcG9zZU1hcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcnMgYSByZXNpemUgZXZlbnQgb24gdGhlIG1hcCBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGdldHMgcmVzb2x2ZWQgYWZ0ZXIgdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVHJpZ2dlclJlc2l6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICAvLyBOb3RlOiBXaGVuIHdlIHdvdWxkIHRyaWdnZXIgdGhlIHJlc2l6ZSBldmVudCBhbmQgc2hvdyB0aGUgbWFwIGluIHRoZSBzYW1lIHR1cm4gKHdoaWNoIGlzIGFcclxuICAgICAgICAvLyBjb21tb24gY2FzZSBmb3IgdHJpZ2dlcmluZyBhIHJlc2l6ZSBldmVudCksIHRoZW4gdGhlIHJlc2l6ZSBldmVudCB3b3VsZCBub3RcclxuICAgICAgICAvLyB3b3JrICh0byBzaG93IHRoZSBtYXApLCBzbyB3ZSB0cmlnZ2VyIHRoZSBldmVudCBpbiBhIHRpbWVvdXQuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoXHJcbiAgICAgICAgICAgICAgICAoKSA9PiB7IHJldHVybiB0aGlzLl9tYXBTZXJ2aWNlLlRyaWdnZXJNYXBFdmVudCgncmVzaXplJykudGhlbigoKSA9PiByZXNvbHZlKCkpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcml2YXRlIG1ldGhvZHMuXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgbnVtYmVyLWlzaCB2YWx1ZSB0byBhIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydC5cclxuICAgICAqIEBwYXJhbSBbZGVmYXVsdFZhbHVlPW51bGxdIC0gRGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgdGhlIGNvbnZlcnNpb24gY2Fubm90IGJlIHBlcmZvcm1lZC5cclxuICAgICAqIEByZXR1cm5zIC0gQ29udmVydGVkIG51bWJlciBvZiB0aGUgZGVmYXVsdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgQ29udmVydFRvRGVjaW1hbCh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBkZWZhdWx0VmFsdWU6IG51bWJlciA9IG51bGwpOiBudW1iZXIge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDxudW1iZXI+dmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyB0aGUgbWFwIGNsaWNrIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgSGFuZGxlTWFwQ2xpY2tFdmVudHMoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TdWJzY3JpYmVUb01hcEV2ZW50PGFueT4oJ2NsaWNrJykuc3Vic2NyaWJlKGUgPT4ge1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBzaW5jZSBiaW5nIHdpbGwgdHJlYXQgYSBkb3VibGVjbGljayBmaXJzdCBhcyB0d28gY2xpY2tzLi4uJ1xyXG4gICAgICAgICAgICAvLy9cclxuICAgICAgICAgICAgdGhpcy5fY2xpY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLk1hcENsaWNrLmVtaXQoPE1vdXNlRXZlbnQ+ZSk7XHJcbiAgICAgICAgICAgIH0sIDMwMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TdWJzY3JpYmVUb01hcEV2ZW50PGFueT4oJ2RibGNsaWNrJykuc3Vic2NyaWJlKGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2xpY2tUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoPE5vZGVKUy5UaW1lcj50aGlzLl9jbGlja1RpbWVvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuTWFwRGJsQ2xpY2suZW1pdCg8TW91c2VFdmVudD5lKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlN1YnNjcmliZVRvTWFwRXZlbnQ8YW55PigncmlnaHRjbGljaycpLnN1YnNjcmliZShlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5NYXBSaWdodENsaWNrLmVtaXQoPE1vdXNlRXZlbnQ+ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TdWJzY3JpYmVUb01hcEV2ZW50PGFueT4oJ21vdXNlb3ZlcicpLnN1YnNjcmliZShlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5NYXBNb3VzZU92ZXIuZW1pdCg8TW91c2VFdmVudD5lKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlN1YnNjcmliZVRvTWFwRXZlbnQ8YW55PignbW91c2VvdXQnKS5zdWJzY3JpYmUoZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuTWFwTW91c2VPdXQuZW1pdCg8TW91c2VFdmVudD5lKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlN1YnNjcmliZVRvTWFwRXZlbnQ8YW55PignbW91c2Vtb3ZlJykuc3Vic2NyaWJlKGUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLk1hcE1vdXNlTW92ZS5lbWl0KDxNb3VzZUV2ZW50PmUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZWdhdGUgaGFuZGxpbmcgbWFwIGNlbnRlciBjaGFuZ2UgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBIYW5kbGVNYXBCb3VuZHNDaGFuZ2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TdWJzY3JpYmVUb01hcEV2ZW50PHZvaWQ+KCdib3VuZHNjaGFuZ2VkJykuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZS5HZXRCb3VuZHMoKS50aGVuKChib3VuZHM6IElCb3gpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuQm91bmRzQ2hhbmdlLmVtaXQoYm91bmRzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxlZ2F0ZSBoYW5kbGluZyBtYXAgY2VudGVyIGNoYW5nZSBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIEhhbmRsZU1hcENlbnRlckNoYW5nZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLlN1YnNjcmliZVRvTWFwRXZlbnQ8dm9pZD4oJ2NlbnRlcmNoYW5nZWQnKS5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkdldENlbnRlcigpLnRoZW4oKGNlbnRlcjogSUxhdExvbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYXRpdHVkZSAhPT0gY2VudGVyLmxhdGl0dWRlIHx8IHRoaXMuX2xvbmdpdHVkZSAhPT0gY2VudGVyLmxvbmdpdHVkZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhdGl0dWRlID0gY2VudGVyLmxhdGl0dWRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdpdHVkZSA9IGNlbnRlci5sb25naXR1ZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5DZW50ZXJDaGFuZ2UuZW1pdCg8SUxhdExvbmc+eyBsYXRpdHVkZTogdGhpcy5fbGF0aXR1ZGUsIGxvbmdpdHVkZTogdGhpcy5fbG9uZ2l0dWRlIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGVnYXRlIGhhbmRsaW5nIG1hcCB6b29tIGNoYW5nZSBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcENvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIEhhbmRsZU1hcFpvb21DaGFuZ2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TdWJzY3JpYmVUb01hcEV2ZW50PHZvaWQ+KCd6b29tY2hhbmdlZCcpLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuR2V0Wm9vbSgpLnRoZW4oKHo6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pvb20gIT09IHopIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b29tID0gejtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLlpvb21DaGFuZ2UuZW1pdCh6KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbCAtIEh0bWwgZWxlbWVudHMgd2hpY2ggd2lsbCBob3N0IHRoZSBtYXAgY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBDb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBJbml0TWFwSW5zdGFuY2UoZWw6IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmNlbnRlciA9PSBudWxsKSB7IHRoaXMuX29wdGlvbnMuY2VudGVyID0geyBsYXRpdHVkZTogdGhpcy5fbGF0aXR1ZGUsIGxvbmdpdHVkZTogdGhpcy5fbG9uZ2l0dWRlIH07IH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuem9vbSA9PSBudWxsKSB7IHRoaXMuX29wdGlvbnMuem9vbSA9IHRoaXMuX3pvb207IH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubWFwVHlwZUlkID09IG51bGwpIHsgdGhpcy5fb3B0aW9ucy5tYXBUeXBlSWQgPSBNYXBUeXBlSWQuaHlicmlkOyB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib3ggIT0gbnVsbCkgeyB0aGlzLl9vcHRpb25zLmJvdW5kcyA9IHRoaXMuX2JveDsgfVxyXG4gICAgICAgICAgICB0aGlzLl9tYXBQcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVNYXAoZWwsIHRoaXMuX29wdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLkhhbmRsZU1hcENlbnRlckNoYW5nZSgpO1xyXG4gICAgICAgICAgICB0aGlzLkhhbmRsZU1hcEJvdW5kc0NoYW5nZSgpO1xyXG4gICAgICAgICAgICB0aGlzLkhhbmRsZU1hcFpvb21DaGFuZ2UoKTtcclxuICAgICAgICAgICAgdGhpcy5IYW5kbGVNYXBDbGlja0V2ZW50cygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgbWFwIGNlbnRlciBiYXNlZCBvbiB0aGUgZ2VvIHByb3BlcnRpZXMgb2YgdGhlIGNvbXBvbmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQ29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgVXBkYXRlQ2VudGVyKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fbGF0aXR1ZGUgIT09ICdudW1iZXInIHx8IHR5cGVvZiB0aGlzLl9sb25naXR1ZGUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbWFwU2VydmljZS5TZXRDZW50ZXIoe1xyXG4gICAgICAgICAgICBsYXRpdHVkZTogdGhpcy5fbGF0aXR1ZGUsXHJcbiAgICAgICAgICAgIGxvbmdpdHVkZTogdGhpcy5fbG9uZ2l0dWRlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIGNsdXN0ZXIgc2VydmljZSBpbnN0YW5jZS4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBvZiBjb25zdHJhaW50cyB3aXRoIEFPVCB0aGF0IGRvIG5vIGFsbG93XHJcbiAqIHVzIHRvIHVzZSBsYW1kYSBmdW5jdGlvbnMgaW5saW5lLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSBmIC0gVGhlIHtAbGluayBNYXBTZXJ2aWNlRmFjdG9yeX0gaW1wbGVtZW50YXRpb24uXHJcbiAqIEBwYXJhbSBtIC0gQSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuXHJcbiAqIEByZXR1cm5zIC0gQSBjb25jcmV0ZSBpbnN0YW5jZSBvZiBhIENsdXN0ZXIgU2VydmljZSBiYXNlZCBvbiB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gQ2x1c3RlclNlcnZpY2VGYWN0b3J5KGY6IE1hcFNlcnZpY2VGYWN0b3J5LCBtOiBNYXBTZXJ2aWNlKTogQ2x1c3RlclNlcnZpY2UgeyByZXR1cm4gZi5DcmVhdGVDbHVzdGVyU2VydmljZShtKTsgfVxyXG5cclxuLyoqXHJcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBpbmZvYm94IHNlcnZpY2UgaW5zdGFuY2UuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgY29uc3RyYWludHMgd2l0aCBBT1QgdGhhdCBkbyBubyBhbGxvd1xyXG4gKiB1cyB0byB1c2UgbGFtZGEgZnVuY3Rpb25zIGlubGluZS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0gZiAtIFRoZSB7QGxpbmsgTWFwU2VydmljZUZhY3Rvcnl9IGltcGxlbWVudGF0aW9uLlxyXG4gKiBAcGFyYW0gbSAtIEEge0BsaW5rIE1hcFNlcnZpY2V9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gbSAtIEEge0BsaW5rIE1hcmtlclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gKiBAcmV0dXJucyAtIEEgY29uY3JldGUgaW5zdGFuY2Ugb2YgYSBJbmZvQm94IFNlcnZpY2UgYmFzZWQgb24gdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBJbmZvQm94U2VydmljZUZhY3RvcnkoZjogTWFwU2VydmljZUZhY3RvcnksIG06IE1hcFNlcnZpY2UsXHJcbiAgICBtYTogTWFya2VyU2VydmljZSk6IEluZm9Cb3hTZXJ2aWNlIHsgcmV0dXJuIGYuQ3JlYXRlSW5mb0JveFNlcnZpY2UobSwgbWEpOyB9XHJcblxyXG4vKipcclxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIGxheWVyIHNlcnZpY2UgaW5zdGFuY2UuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgY29uc3RyYWludHMgd2l0aCBBT1QgdGhhdCBkbyBubyBhbGxvd1xyXG4gKiB1cyB0byB1c2UgbGFtZGEgZnVuY3Rpb25zIGlubGluZS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0gZiAtIFRoZSB7QGxpbmsgTWFwU2VydmljZUZhY3Rvcnl9IGltcGxlbWVudGF0aW9uLlxyXG4gKiBAcGFyYW0gbSAtIEEge0BsaW5rIE1hcFNlcnZpY2V9IGluc3RhbmNlLlxyXG4gKiBAcmV0dXJucyAtIEEgY29uY3JldGUgaW5zdGFuY2Ugb2YgYSBMYXllciBTZXJ2aWNlIGJhc2VkIG9uIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTGF5ZXJTZXJ2aWNlRmFjdG9yeShmOiBNYXBTZXJ2aWNlRmFjdG9yeSwgbTogTWFwU2VydmljZSk6IExheWVyU2VydmljZSB7IHJldHVybiBmLkNyZWF0ZUxheWVyU2VydmljZShtKTsgfVxyXG5cclxuLyoqXHJcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBtYXAgc2VydmljZSBpbnN0YW5jZS4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBvZiBjb25zdHJhaW50cyB3aXRoIEFPVCB0aGF0IGRvIG5vIGFsbG93XHJcbiAqIHVzIHRvIHVzZSBsYW1kYSBmdW5jdGlvbnMgaW5saW5lLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSBmIC0gVGhlIHtAbGluayBNYXBTZXJ2aWNlRmFjdG9yeX0gaW1wbGVtZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIC0gQSBjb25jcmV0ZSBpbnN0YW5jZSBvZiBhIE1hcFNlcnZpY2UgYmFzZWQgb24gdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBNYXBTZXJ2aWNlQ3JlYXRvcihmOiBNYXBTZXJ2aWNlRmFjdG9yeSk6IE1hcFNlcnZpY2UgeyByZXR1cm4gZi5DcmVhdGUoKTsgfVxyXG5cclxuLyoqXHJcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBtYXJrZXIgc2VydmljZSBpbnN0YW5jZS4gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBvZiBjb25zdHJhaW50cyB3aXRoIEFPVCB0aGF0IGRvIG5vIGFsbG93XHJcbiAqIHVzIHRvIHVzZSBsYW1kYSBmdW5jdGlvbnMgaW5saW5lLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSBmIC0gVGhlIHtAbGluayBNYXBTZXJ2aWNlRmFjdG9yeX0gaW1wbGVtZW50YXRpb24uXHJcbiAqIEBwYXJhbSBtIC0gQSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSBsIC0gQSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGMgLSBBIHtAbGluayBDbHVzdGVyU2VydmljZX0gaW5zdGFuY2UuXHJcbiAqIEByZXR1cm5zIC0gQSBjb25jcmV0ZSBpbnN0YW5jZSBvZiBhIE1hcmtlciBTZXJ2aWNlIGJhc2VkIG9uIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gTWFya2VyU2VydmljZUZhY3RvcnkoZjogTWFwU2VydmljZUZhY3RvcnksIG06IE1hcFNlcnZpY2UsIGw6IExheWVyU2VydmljZSwgYzogQ2x1c3RlclNlcnZpY2UpOiBNYXJrZXJTZXJ2aWNlIHtcclxuICAgIHJldHVybiBmLkNyZWF0ZU1hcmtlclNlcnZpY2UobSwgbCwgYyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgcG9seWdvbiBzZXJ2aWNlIGluc3RhbmNlLiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIG9mIGNvbnN0cmFpbnRzIHdpdGggQU9UIHRoYXQgZG8gbm8gYWxsb3dcclxuICogdXMgdG8gdXNlIGxhbWRhIGZ1bmN0aW9ucyBpbmxpbmUuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIGYgLSBUaGUge0BsaW5rIE1hcFNlcnZpY2VGYWN0b3J5fSBpbXBsZW1lbnRhdGlvbi5cclxuICogQHBhcmFtIG0gLSBBIHtAbGluayBNYXBTZXJ2aWNlfSBpbnN0YW5jZS5cclxuICogQHBhcmFtIGwgLSBBIHtAbGluayBMYXllclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gKiBAcmV0dXJucyAtIEEgY29uY3JldGUgaW5zdGFuY2Ugb2YgYSBQb2x5Z29uIFNlcnZpY2UgYmFzZWQgb24gdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBQb2x5Z29uU2VydmljZUZhY3RvcnkoZjogTWFwU2VydmljZUZhY3RvcnksIG06IE1hcFNlcnZpY2UsIGw6IExheWVyU2VydmljZSk6IFBvbHlnb25TZXJ2aWNlIHtcclxuICAgIHJldHVybiBmLkNyZWF0ZVBvbHlnb25TZXJ2aWNlKG0sIGwpO1xyXG59XHJcblxyXG4vKipcclxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIHBvbHlsaW5lIHNlcnZpY2UgaW5zdGFuY2UuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgY29uc3RyYWludHMgd2l0aCBBT1QgdGhhdCBkbyBubyBhbGxvd1xyXG4gKiB1cyB0byB1c2UgbGFtZGEgZnVuY3Rpb25zIGlubGluZS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0gZiAtIFRoZSB7QGxpbmsgTWFwU2VydmljZUZhY3Rvcnl9IGltcGxlbWVudGF0aW9uLlxyXG4gKiBAcGFyYW0gbSAtIEEge0BsaW5rIE1hcFNlcnZpY2V9IGluc3RhbmNlLlxyXG4gKiBAcGFyYW0gbCAtIEEge0BsaW5rIExheWVyU2VydmljZX0gaW5zdGFuY2UuXHJcbiAqIEByZXR1cm5zIC0gQSBjb25jcmV0ZSBpbnN0YW5jZSBvZiBhIFBvbHlsaW5lIFNlcnZpY2UgYmFzZWQgb24gdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBQb2x5bGluZVNlcnZpY2VGYWN0b3J5KGY6IE1hcFNlcnZpY2VGYWN0b3J5LCBtOiBNYXBTZXJ2aWNlLCBsOiBMYXllclNlcnZpY2UpOiBQb2x5bGluZVNlcnZpY2Uge1xyXG4gICAgcmV0dXJuIGYuQ3JlYXRlUG9seWxpbmVTZXJ2aWNlKG0sIGwpO1xyXG59XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBPbkluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBBZnRlckNvbnRlbnRJbml0LCBTaW1wbGVDaGFuZ2UsXHJcbiAgICBDb250ZW50Q2hpbGRyZW4sIElucHV0LCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2xheWVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBNYXJrZXJEaXJlY3RpdmUgfSBmcm9tICcuL21hcC1tYXJrZXInO1xyXG5cclxuLyoqXHJcbiAqIGludGVybmFsIGNvdW50ZXIgdG8gdXNlIGFzIGlkcyBmb3IgbXVsdGlwbGUgbGF5ZXJzLlxyXG4gKi9cclxubGV0IGxheWVySWQgPSAwO1xyXG5cclxuLyoqXHJcbiAqIE1hcExheWVyRGlyZWN0aXZlIGNyZWF0ZXMgYSBsYXllciBvbiBhIHtAbGluayBNYXBDb21wb25lbnR9LlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuICogaW1wb3J0IHtNYXBDb21wb25lbnQsIE1hcE1hcmtlckRpcmVjdGl2ZX0gZnJvbSAnLi4uJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICBzZWxlY3RvcjogJ215LW1hcC1jbXAnLFxyXG4gKiAgc3R5bGVzOiBbYFxyXG4gKiAgIC5tYXAtY29udGFpbmVyIHtcclxuICogICAgIGhlaWdodDogMzAwcHg7XHJcbiAqICAgfVxyXG4gKiBgXSxcclxuICogdGVtcGxhdGU6IGBcclxuICogICA8eC1tYXAgW0xhdGl0dWRlXT0nbGF0JyBbTG9uZ2l0dWRlXT0nbG5nJyBbWm9vbV09J3pvb20nPlxyXG4gKiAgICAgPHgtbWFwLWxheWVyIFtWaXNpYmxlXT0ndmlzaWJsZSc+XHJcbiAqICAgICAgICAgPHgtbWFwLW1hcmtlciBbTGF0aXR1ZGVdPSdsYXQnIFtMb25naXR1ZGVdPSdsbmcnIFtMYWJlbF09JydNJyc+PC94LW1hcC1tYXJrZXI+XHJcbiAqICAgICA8L3gtbWFwLWxheWVyPlxyXG4gKiAgIDwveC1tYXA+XHJcbiAqIGBcclxuICogfSlcclxuICogYGBgXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICd4LW1hcC1sYXllcidcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hcExheWVyRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByb3RlY3RlZCBfdmlzaWJsZSA9IHRydWU7XHJcbiAgICBwcm90ZWN0ZWQgX2FkZGVkVG9NYW5hZ2VyID0gZmFsc2U7XHJcbiAgICBwcm90ZWN0ZWQgX2lkOiBudW1iZXI7XHJcblxyXG4gICAgQENvbnRlbnRDaGlsZHJlbihNYXBNYXJrZXJEaXJlY3RpdmUpIHByb3RlY3RlZCBfbWFya2VyczogQXJyYXk8TWFwTWFya2VyRGlyZWN0aXZlPjtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBsYXllciB2aXNpYmlsaXR5LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgVmlzaWJsZSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3Zpc2libGU7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IFZpc2libGUodmFsOiBib29sZWFuKSB7IHRoaXMuX3Zpc2libGUgPSB2YWw7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxheWVyIGlkLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcExheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgSWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2lkOyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBNYXBMYXllckRpcmVjdGl2ZS5cclxuICAgICAqIEBwYXJhbSBfbGF5ZXJTZXJ2aWNlIC0gQ29uY3JldGVkIGltcGxlbWVudGF0aW9uIG9mIGEgbGF5ZXIgc2VydmljZSBmb3IgdGhlIHVuZGVybHlpbmcgbWFwcyBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICAgKiBHZW5lcmFsbHkgcHJvdmlkZWQgdmlhIGluamVjdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0gX2NvbnRhaW5lclJlZiAtIFJlZmVyZW5jZSB0byB0aGUgY29udGFpbmVyIGhvc3RpbmcgdGhlIG1hcCBjYW52YXMuIEdlbmVyYWxseSBwcm92aWRlZCB2aWEgaW5qZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgX2xheWVyU2VydmljZTogTGF5ZXJTZXJ2aWNlLCBwcm90ZWN0ZWQgX2NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge1xyXG4gICAgICAgIHRoaXMuX2lkID0gbGF5ZXJJZCsrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBvbiBDb21wb25lbnQgaW5pdGlhbGl6YXRpb24uIFBhcnQgb2YgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcExheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9jb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50LmF0dHJpYnV0ZXNbJ2xheWVySWQnXSA9IHRoaXMuX2lkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJTZXJ2aWNlLkFkZExheWVyKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2FkZGVkVG9NYW5hZ2VyID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5nZXMgdG8gdGhlIGRhdGFib3VkIHByb3BlcnRpZXMgb2NjdXIuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0gQ2hhbmdlcyB0aGF0IGhhdmUgb2NjdXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHsgW3Byb3BOYW1lOiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSk6IHZvaWQge1xyXG4gICAgICAgIGlmICghdGhpcy5fYWRkZWRUb01hbmFnZXIpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ1Zpc2libGUnXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllclNlcnZpY2UuR2V0TmF0aXZlTGF5ZXIodGhpcykudGhlbihsID0+IHtcclxuICAgICAgICAgICAgICAgIGwuU2V0VmlzaWJsZSghbC5HZXRWaXNpYmxlKCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgb24gY29tcG9uZW50IGRlc3RydWN0aW9uLiBGcmVlcyB0aGUgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGNvbXBvbmVudC4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJTZXJ2aWNlLkRlbGV0ZUxheWVyKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IElDbHVzdGVySWNvbkluZm8gfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ljbHVzdGVyLWljb24taW5mbyc7XHJcbmltcG9ydCB7IERpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBPbkluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2UsXHJcbiAgICBDb250ZW50Q2hpbGRyZW4sIElucHV0LCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IENsdXN0ZXJQbGFjZW1lbnRNb2RlIH0gZnJvbSAnLi4vbW9kZWxzL2NsdXN0ZXItcGxhY2VtZW50LW1vZGUnO1xyXG5pbXBvcnQgeyBDbHVzdGVyQ2xpY2tBY3Rpb24gfSBmcm9tICcuLi9tb2RlbHMvY2x1c3Rlci1jbGljay1hY3Rpb24nO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElDbHVzdGVyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWNsdXN0ZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mb30gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbWFya2VyLWljb24taW5mbyc7XHJcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSVNwaWRlckNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pc3BpZGVyLWNsdXN0ZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IE1hcE1hcmtlckRpcmVjdGl2ZSB9IGZyb20gJy4vbWFwLW1hcmtlcic7XHJcbmltcG9ydCB7IE1hcExheWVyRGlyZWN0aXZlIH0gZnJvbSAnLi9tYXAtbGF5ZXInO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIENyZWF0ZXMgYSBjbHVzdGVyIGxheWVyIG9uIGEge0BsaW5rIE1hcENvbXBvbmVudH0uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG4gKiBpbXBvcnQge01hcENvbXBvbmVudCwgTWFwTWFya2VyRGlyZWN0aXZlfSBmcm9tICcuLi4nO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXHJcbiAqICBzdHlsZXM6IFtgXHJcbiAqICAgLm1hcC1jb250YWluZXIge1xyXG4gKiAgICAgaGVpZ2h0OiAzMDBweDtcclxuICogICB9XHJcbiAqIGBdLFxyXG4gKiB0ZW1wbGF0ZTogYFxyXG4gKiAgIDx4LW1hcCBbTGF0aXR1ZGVdPSdsYXQnIFtMb25naXR1ZGVdPSdsbmcnIFtab29tXT0nem9vbSc+XHJcbiAqICAgICA8eC1jbHVzdGVyLWxheWVyIFtWaXNpYmxlXT0ndmlzaWJsZSc+XHJcbiAqICAgICAgICAgPHgtbWFwLW1hcmtlciBbTGF0aXR1ZGVdPSdsYXQnIFtMb25naXR1ZGVdPSdsbmcnIFtMYWJlbF09JydNJyc+PC94LW1hcC1tYXJrZXI+XHJcbiAqICAgICA8L3gtY2x1c3Rlci1sYXllcj5cclxuICogICA8L3gtbWFwPlxyXG4gKiBgXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAneC1jbHVzdGVyLWxheWVyJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgQ2x1c3RlckxheWVyRGlyZWN0aXZlIGV4dGVuZHMgTWFwTGF5ZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfY2x1c3RlcmluZ0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgcHJpdmF0ZSBfY2x1c3RlclBsYWNlbWVudE1vZGU6IENsdXN0ZXJQbGFjZW1lbnRNb2RlID0gQ2x1c3RlclBsYWNlbWVudE1vZGUuTWVhblZhbHVlO1xyXG4gICAgcHJpdmF0ZSBfY2x1c3RlckNsaWNrQWN0aW9uOiBDbHVzdGVyQ2xpY2tBY3Rpb24gPSBDbHVzdGVyQ2xpY2tBY3Rpb24uWm9vbUludG9DbHVzdGVyO1xyXG4gICAgcHJpdmF0ZSBfc3BpZGVyQ2x1c3Rlck9wdGlvbnM6IElTcGlkZXJDbHVzdGVyT3B0aW9ucztcclxuICAgIHByaXZhdGUgX3pJbmRleDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBfZ3JpZFNpemU6IG51bWJlcjtcclxuICAgIHByaXZhdGUgX2xheWVyT2Zmc2V0OiBJUG9pbnQ7XHJcbiAgICBwcml2YXRlIF9pY29uSW5mbzogSU1hcmtlckljb25JbmZvO1xyXG4gICAgcHJpdmF0ZSBfbWluaW11bUNsdXN0ZXJTaXplOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9zdHlsZXM6IEFycmF5PElDbHVzdGVySWNvbkluZm8+O1xyXG4gICAgcHJpdmF0ZSBfdXNlRHluYW1pY1NpemVNYXJrZXIgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2R5bmFtaWNNYXJrZXJCYXNlU2l6ZSA9IDE4O1xyXG4gICAgcHJpdmF0ZSBfZHluYW1pY01hcmtlclJhbmdlczogTWFwPG51bWJlciwgc3RyaW5nPiA9IG5ldyBNYXA8bnVtYmVyLCBzdHJpbmc+KFtcclxuICAgICAgICBbMTAsICdyZ2JhKDIwLCAxODAsIDIwLCAwLjUpJ10sXHJcbiAgICAgICAgWzEwMCwgJ3JnYmEoMjU1LCAyMTAsIDQwLCAwLjUpJ10sXHJcbiAgICAgICAgW051bWJlci5NQVhfU0FGRV9JTlRFR0VSICwgJ3JnYmEoMjU1LCA0MCwgNDAsIDAuNSknXVxyXG4gICAgXSk7XHJcbiAgICBwcml2YXRlIF96b29tT25DbGljayA9IHRydWU7XHJcbiAgICBwcml2YXRlIF9pY29uQ3JlYXRpb25DYWxsYmFjazogKG06IEFycmF5PE1hcmtlcj4sIGk6IElNYXJrZXJJY29uSW5mbykgPT4gc3RyaW5nO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlZmludGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB0aGUgQ2x1c3RlciBDbGljayBBY3Rpb24ge0BsaW5rIENsdXN0ZXJDbGlja0FjdGlvbn0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgQ2x1c3RlckNsaWNrQWN0aW9uKCk6IENsdXN0ZXJDbGlja0FjdGlvbiAgeyByZXR1cm4gdGhpcy5fY2x1c3RlckNsaWNrQWN0aW9uOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBDbHVzdGVyQ2xpY2tBY3Rpb24odmFsOiBDbHVzdGVyQ2xpY2tBY3Rpb24pIHsgdGhpcy5fY2x1c3RlckNsaWNrQWN0aW9uID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0aGUgY2x1c3RlcmluZyBsYXllciBlbmFibGVzIGNsdXN0ZXJpbmcuIFdoZW4gc2V0IHRvIGZhbHNlLCB0aGUgbGF5ZXJcclxuICAgICAqIGJlaGF2ZXMgbGlrZSBhIGdlbmVyaWMgbGF5ZXIuIFRoaXMgaXMgaGFuZHkgaWYgeW91IHdhbnQgdG8gcHJldmVudCBjbHVzdGVyaW5nIGF0IGNlcnRhaW4gem9vbSBsZXZlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgQ2x1c3RlcmluZ0VuYWJsZWQoKTogYm9vbGVhbiAgeyByZXR1cm4gdGhpcy5fY2x1c3RlcmluZ0VuYWJsZWQ7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IENsdXN0ZXJpbmdFbmFibGVkKHZhbDogYm9vbGVhbikgeyB0aGlzLl9jbHVzdGVyaW5nRW5hYmxlZCA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBjbHVzdGVyIHBsYWNlbWVudCBtb2RlLiB7QGxpbmsgQ2x1c3RlclBsYWNlbWVudE1vZGV9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgQ2x1c3RlclBsYWNlbWVudE1vZGUoKTogQ2x1c3RlclBsYWNlbWVudE1vZGUgIHsgcmV0dXJuIHRoaXMuX2NsdXN0ZXJQbGFjZW1lbnRNb2RlOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBDbHVzdGVyUGxhY2VtZW50TW9kZSh2YWw6IENsdXN0ZXJQbGFjZW1lbnRNb2RlKSB7IHRoaXMuX2NsdXN0ZXJQbGFjZW1lbnRNb2RlID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGNhbGxiYWNrIGludm9rZWQgdG8gY3JlYXRlIGEgY3VzdG9tIGNsdXN0ZXIgbWFya2VyLiBOb3RlIHRoYXQgd2hlbiB7QGxpbmsgVXNlRHluYW1pY1NpemVNYXJrZXJzfSBpcyBlbmFibGVkLFxyXG4gICAgICogeW91IGNhbm5vdCBzZXQgYSBjdXN0b20gbWFya2VyIGNhbGxiYWNrLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgICAgICBwdWJsaWMgZ2V0IEN1c3RvbU1hcmtlckNhbGxiYWNrKCk6IChtOiBBcnJheTxNYXJrZXI+LCBpOiBJTWFya2VySWNvbkluZm8pID0+IHN0cmluZyAgeyByZXR1cm4gdGhpcy5faWNvbkNyZWF0aW9uQ2FsbGJhY2s7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IEN1c3RvbU1hcmtlckNhbGxiYWNrKHZhbDogKG06IEFycmF5PE1hcmtlcj4sIGk6IElNYXJrZXJJY29uSW5mbykgPT4gc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl91c2VEeW5hbWljU2l6ZU1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3coXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKGBZb3UgY2Fubm90IHNldCBhIGN1c3RvbSBtYXJrZXIgY2FsbGJhY2sgd2hlbiBVc2VEeW5hbWljU2l6ZU1hcmtlcnMgaXMgc2V0IHRvIHRydWUuXHJcbiAgICAgICAgICAgICAgICAgICAgU2V0IFVzZUR5bmFtaWNTaXplTWFrZXJzIHRvIGZhbHNlLmApXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2ljb25DcmVhdGlvbkNhbGxiYWNrID0gdmFsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmFzZSBzaXplIG9mIGR5bmFtaWMgbWFya2VycyBpbiBwaXhlbHMuIFRoZSBhY3R1YWx5IHNpemUgb2YgdGhlIGR5bmFtaWMgbWFya2VyIGlzIGJhc2VkIG9uIHRoaXMuXHJcbiAgICAgKiBTZWUge0BsaW5rIFVzZUR5bmFtaWNTaXplTWFya2Vyc30uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgRHluYW1pY01hcmtlckJhc2VTaXplKCk6IG51bWJlciAgeyByZXR1cm4gdGhpcy5fZHluYW1pY01hcmtlckJhc2VTaXplOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBEeW5hbWljTWFya2VyQmFzZVNpemUodmFsOiBudW1iZXIpIHsgdGhpcy5fZHluYW1pY01hcmtlckJhc2VTaXplID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHJhbmdlcyB0byB1c2UgdG8gY2FsY3VsYXRlIGJyZWFrcG9pbnRzIGFuZCBjb2xvcnMgZm9yIGR5bmFtaWMgbWFya2Vycy5cclxuICAgICAqIFRoZSBtYXAgY29udGFpbnMga2V5L3ZhbHVlIHBhaXJzLCB3aXRoIHRoZSBrZXlzIGJlaW5nXHJcbiAgICAgKiB0aGUgYnJlYWtwb2ludCBzaXplcyBhbmQgdGhlIHZhbHVlcyB0aGUgY29sb3JzIHRvIGJlIHVzZWQgZm9yIHRoZSBkeW5hbWljIG1hcmtlciBpbiB0aGF0IHJhbmdlLiBTZWUge0BsaW5rIFVzZUR5bmFtaWNTaXplTWFya2Vyc30uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgRHluYW1pY01hcmtlclJhbmdlcygpOiBNYXA8bnVtYmVyLCBzdHJpbmc+ICB7IHJldHVybiB0aGlzLl9keW5hbWljTWFya2VyUmFuZ2VzOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBEeW5hbWljTWFya2VyUmFuZ2VzKHZhbDogTWFwPG51bWJlciwgc3RyaW5nPikgeyB0aGlzLl9keW5hbWljTWFya2VyUmFuZ2VzID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGdyaWQgc2l6ZSB0byBiZSB1c2VkIGZvciBjbHVzdGVyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgICAgICBwdWJsaWMgZ2V0IEdyaWRTaXplKCk6IG51bWJlciAgeyByZXR1cm4gdGhpcy5fZ3JpZFNpemU7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IEdyaWRTaXplKHZhbDogbnVtYmVyKSB7IHRoaXMuX2dyaWRTaXplID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIEljb25JbmZvIHRvIGJlIHVzZWQgdG8gY3JlYXRlIGEgY3VzdG9tIGNsdXN0ZXIgbWFya2VyLiBTdXBwb3J0cyBmb250LWJhc2VkLCBTVkcsIGdyYXBoaWNzIGFuZCBtb3JlLlxyXG4gICAgICogU2VlIHtAbGluayBJTWFya2VySWNvbkluZm99LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgICAgICBwdWJsaWMgZ2V0IEljb25JbmZvKCk6IElNYXJrZXJJY29uSW5mbyAgeyByZXR1cm4gdGhpcy5faWNvbkluZm87IH1cclxuICAgICAgICBwdWJsaWMgc2V0IEljb25JbmZvKHZhbDogSU1hcmtlckljb25JbmZvKSB7IHRoaXMuX2ljb25JbmZvID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgQW4gb2Zmc2V0IGFwcGxpZWQgdG8gdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBMYXllck9mZnNldCgpOiBJUG9pbnQgIHsgcmV0dXJuIHRoaXMuX2xheWVyT2Zmc2V0OyB9XHJcbiAgICAgICAgcHVibGljIHNldCBMYXllck9mZnNldCh2YWw6IElQb2ludCkgeyB0aGlzLl9sYXllck9mZnNldCA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHBpbnMgcmVxdWlyZWQgdG8gZm9ybSBhIGNsdXN0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgICAgICBwdWJsaWMgZ2V0IE1pbmltdW1DbHVzdGVyU2l6ZSgpOiBudW1iZXIgIHsgcmV0dXJuIHRoaXMuX21pbmltdW1DbHVzdGVyU2l6ZTsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgTWluaW11bUNsdXN0ZXJTaXplKHZhbDogbnVtYmVyKSB7IHRoaXMuX21pbmltdW1DbHVzdGVyU2l6ZSA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBvcHRpb25zIGZvciBzcGlkZXIgY2x1c3RlcmluZyBiZWhhdmlvci4gU2VlIHtAbGluayBJU3BpZGVyQ2x1c3Rlck9wdGlvbnN9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgU3BpZGVyQ2x1c3Rlck9wdGlvbnMoKTogSVNwaWRlckNsdXN0ZXJPcHRpb25zIHsgcmV0dXJuIHRoaXMuX3NwaWRlckNsdXN0ZXJPcHRpb25zOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBTcGlkZXJDbHVzdGVyT3B0aW9ucyh2YWw6IElTcGlkZXJDbHVzdGVyT3B0aW9ucykgeyB0aGlzLl9zcGlkZXJDbHVzdGVyT3B0aW9ucyA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBjbHVzdGVyIHN0eWxlc1xyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgU3R5bGVzKCk6IEFycmF5PElDbHVzdGVySWNvbkluZm8+IHsgcmV0dXJuIHRoaXMuX3N0eWxlczsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgU3R5bGVzKHZhbDogQXJyYXk8SUNsdXN0ZXJJY29uSW5mbz4pIHsgdGhpcy5fc3R5bGVzID0gdmFsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0byB1c2UgZHluYW1pYyBtYXJrZXJzLiBEeW5hbWljIG1hcmtlcnMgY2hhbmdlIGluIHNpemUgYW5kIGNvbG9yIGRlcGVuZGluZyBvbiB0aGUgbnVtYmVyIG9mXHJcbiAgICAgKiBwaW5zIGluIHRoZSBjbHVzdGVyLiBJZiBzZXQgdG8gdHJ1ZSwgdGhpcyB3aWxsIHRha2UgcHJlY2VuZGVuY2Ugb3ZlciBhbnkgY3VzdG9tIG1hcmtlciBjcmVhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBVc2VEeW5hbWljU2l6ZU1hcmtlcnMoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl91c2VEeW5hbWljU2l6ZU1hcmtlcjsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgVXNlRHluYW1pY1NpemVNYXJrZXJzKHZhbDogYm9vbGVhbikge1xyXG4gICAgICAgICAgICB0aGlzLl91c2VEeW5hbWljU2l6ZU1hcmtlciA9IHZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbkNyZWF0aW9uQ2FsbGJhY2sgPSAobTogQXJyYXk8TWFya2VyPiwgaW5mbzogSU1hcmtlckljb25JbmZvKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENsdXN0ZXJMYXllckRpcmVjdGl2ZS5DcmVhdGVEeW5hbWljU2l6ZU1hcmtlcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5sZW5ndGgsIGluZm8sIHRoaXMuX2R5bmFtaWNNYXJrZXJCYXNlU2l6ZSwgdGhpcy5fZHluYW1pY01hcmtlclJhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB6LWluZGV4IG9mIHRoZSBsYXllci4gSWYgbm90IHVzZWQsIGxheWVycyBnZXQgc3RhY2tlZCBpbiB0aGUgb3JkZXIgY3JlYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBaSW5kZXgoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX3pJbmRleDsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgWkluZGV4KHZhbDogbnVtYmVyKSB7IHRoaXMuX3pJbmRleCA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdGhlIGNsdXN0ZXIgc2hvdWxkIHpvb20gaW4gb24gY2xpY2tcclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgICAgICBwdWJsaWMgZ2V0IFpvb21PbkNsaWNrKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fem9vbU9uQ2xpY2s7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IFpvb21PbkNsaWNrKHZhbDogYm9vbGVhbikgeyB0aGlzLl96b29tT25DbGljayA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgZHluYW1pYyBzaXplIG1hcmtlciB0byBiZSB1c2VkIGZvciBjbHVzdGVyIG1hcmtlcnMgaWYgVXNlRHluYW1pY1NpemVNYXJrZXJzIGlzIHNldCB0byB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzaXplIC0gVGhlIG51bWJlciBvZiBtYXJrZXJzIGluIHRoZSBjbHVzdGVyLlxyXG4gICAgICogQHBhcmFtIGluZm8gIC0gVGhlIGljb24gaW5mbyB0byBiZSB1c2VkLiBUaGlzIHdpbGwgYmUgaHlkcmF0ZWQgd2l0aFxyXG4gICAgICogdGhlIGFjdHVhbHkgZGltZW5zaW9ucyBvZiB0aGUgY3JlYXRlZCBtYXJrZXJzIGFuZCBpcyB1c2VkIGJ5IHRoZSB1bmRlcmx5aW5nIG1vZGVsL3NlcnZpY2VzXHJcbiAgICAgKiB0byBjb3JyZWN0bHkgb2Zmc2V0IHRoZSBtYXJrZXIgZm9yIGNvcnJlY3QgcG9zaXRpb25pbmcuXHJcbiAgICAgKiBAcGFyYW0gYmFzZU1hcmtlclNpemUgLSBUaGUgYmFzZSBzaXplIGZvciBkeW5taWMgbWFya2Vycy5cclxuICAgICAqIEBwYXJhbSByYW5nZXMgLSBUaGUgcmFuZ2VzIHRvIHVzZSB0byBjYWxjdWxhdGUgYnJlYWtwb2ludHMgYW5kIGNvbG9ycyBmb3IgZHluYW1pYyBtYXJrZXJzLlxyXG4gICAgICogVGhlIG1hcCBjb250YWlucyBrZXkvdmFsdWUgcGFpcnMsIHdpdGggdGhlIGtleXMgYmVpbmdcclxuICAgICAqIHRoZSBicmVha3BvaW50IHNpemVzIGFuZCB0aGUgdmFsdWVzIHRoZSBjb2xvcnMgdG8gYmUgdXNlZCBmb3IgdGhlIGR5bmFtaWMgbWFya2VyIGluIHRoYXQgcmFuZ2UuXHJcbiAgICAgKiBAcmV0dXJucyAtIEFuIHN0cmluZyBjb250YWluaW5nIHRoZSBTVkcgZm9yIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENyZWF0ZUR5bmFtaWNTaXplTWFya2VyKHNpemU6IG51bWJlciwgaW5mbzogSU1hcmtlckljb25JbmZvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlTWFya2VyU2l6ZTogbnVtYmVyLCByYW5nZXM6IE1hcDxudW1iZXIsIHN0cmluZz4pOiBzdHJpbmcge1xyXG4gICAgICAgIGNvbnN0IG1yOiBudW1iZXIgPSBiYXNlTWFya2VyU2l6ZTtcclxuICAgICAgICBjb25zdCBvdXRsaW5lOiBudW1iZXIgPSBtciAqIDAuMzU7XHJcbiAgICAgICAgY29uc3QgdG90YWw6IG51bWJlciA9IHNpemU7XHJcbiAgICAgICAgY29uc3QgcjogbnVtYmVyID0gTWF0aC5sb2codG90YWwpIC8gTWF0aC5sb2coMTApICogNSArIG1yO1xyXG4gICAgICAgIGNvbnN0IGQ6IG51bWJlciA9IHIgKiAyO1xyXG4gICAgICAgIGxldCBmaWxsQ29sb3I6IHN0cmluZztcclxuICAgICAgICByYW5nZXMuZm9yRWFjaCgodiwgaykgPT4ge1xyXG4gICAgICAgICAgICBpZiAodG90YWwgPD0gayAmJiAhZmlsbENvbG9yKSB7IGZpbGxDb2xvciA9IHY7IH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWZpbGxDb2xvcikgeyBmaWxsQ29sb3IgPSAncmdiYSgyMCwgMTgwLCAyMCwgMC41KSc7IH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuIFNWRyBzdHJpbmcgb2YgdHdvIGNpcmNsZXMsIG9uZSBvbiB0b3Agb2YgdGhlIG90aGVyLCB3aXRoIHRoZSBzcGVjaWZpZWQgcmFkaXVzIGFuZCBjb2xvci5cclxuICAgICAgICBjb25zdCBzdmc6IEFycmF5PGFueT4gPSBbYDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB3aWR0aD0nJHtkfScgaGVpZ2h0PScke2R9Jz5gLFxyXG4gICAgICAgICAgICBgPGNpcmNsZSBjeD0nJHtyfScgY3k9JyR7cn0nIHI9JyR7cn0nIGZpbGw9JyR7ZmlsbENvbG9yfScvPmAsXHJcbiAgICAgICAgICAgIGA8Y2lyY2xlIGN4PScke3J9JyBjeT0nJHtyfScgcj0nJHtyIC0gb3V0bGluZX0nIGZpbGw9JyR7ZmlsbENvbG9yfScvPmAsXHJcbiAgICAgICAgICAgIGA8L3N2Zz5gXTtcclxuICAgICAgICBpbmZvLnNpemUgPSB7IHdpZHRoOiBkLCBoZWlnaHQ6IGQgfTtcclxuICAgICAgICBpbmZvLm1hcmtlck9mZnNldFJhdGlvID0geyB4OiAwLjUsIHk6IDAuNSB9O1xyXG4gICAgICAgIGluZm8udGV4dE9mZnNldCA9IHsgeDogMCwgeTogciAtIDggfTtcclxuICAgICAgICByZXR1cm4gc3ZnLmpvaW4oJycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBfbGF5ZXJTZXJ2aWNlIC0gQ29uY3JldGVkIGltcGxlbWVudGF0aW9uIG9mIGEgY2x1c3RlciBsYXllciBzZXJ2aWNlIGZvciB0aGUgdW5kZXJseWluZyBtYXBzXHJcbiAgICAgKiBpbXBsZW1lbnRhdGlvbnMuIEdlbmVyYWxseSBwcm92aWRlZCB2aWEgaW5qZWN0aW9ucy5cclxuICAgICAqIEBwYXJhbSBfY29udGFpbmVyUmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIHZpZXcgY29udGFpbmVyIG9mIHRoZSBsYXllci4gR2VuZXJhbGx5IHByb3ZpZGVkIHZpYSBpbmplY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfbGF5ZXJTZXJ2aWNlOiBDbHVzdGVyU2VydmljZSwgX2NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge1xyXG4gICAgICAgIHN1cGVyKF9sYXllclNlcnZpY2UsIF9jb250YWluZXJSZWYpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWN0cyB0byBjaGFuZ2VzIGluIGRhdGEtYm91bmQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50IGFuZCBhY3R1YXRlcyBwcm9wZXJ0eSBjaGFuZ2VzIGluIHRoZSB1bmRlcmxpbmcgbGF5ZXIgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoYW5nZXMgLSBjb2xsZWN0aW9uIG9mIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENsdXN0ZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBbcHJvcE5hbWU6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZFRvTWFuYWdlcikgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snQ2x1c3RlckNsaWNrQWN0aW9uJ10pIHtcclxuICAgICAgICAgICAgdGhyb3cgKFxyXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKCdZb3UgY2Fubm90IGNoYW5nZSB0aGUgQ2x1c3RlckNsaWNrQWN0aW9uIGFmdGVyIHRoZSBsYXllciBoYXMgYmVlbiBhZGRlZCB0byB0aGUgbGF5ZXJzZXJ2aWNlLicpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBvcHRpb25zOiBJQ2x1c3Rlck9wdGlvbnMgPSB7IGlkOiB0aGlzLl9pZCB9O1xyXG4gICAgICAgIGlmIChjaGFuZ2VzWydDbHVzdGVyaW5nRW5hYmxlZCddKSB7IG9wdGlvbnMuY2x1c3RlcmluZ0VuYWJsZWQgPSB0aGlzLl9jbHVzdGVyaW5nRW5hYmxlZDsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydHcmlkU2l6ZSddKSB7IG9wdGlvbnMuZ3JpZFNpemUgPSB0aGlzLl9ncmlkU2l6ZTsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydMYXllck9mZnNldCddKSB7IG9wdGlvbnMubGF5ZXJPZmZzZXQgPSB0aGlzLl9sYXllck9mZnNldDsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydTcGlkZXJDbHVzdGVyT3B0aW9ucyddKSB7IG9wdGlvbnMuc3BpZGVyQ2x1c3Rlck9wdGlvbnMgPSB0aGlzLl9zcGlkZXJDbHVzdGVyT3B0aW9uczsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydaSW5kZXgnXSkgeyBvcHRpb25zLnpJbmRleCA9IHRoaXMuX3pJbmRleDsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydWaXNpYmxlJ10pIHsgb3B0aW9ucy52aXNpYmxlID0gdGhpcy5fdmlzaWJsZTsgfVxyXG5cclxuICAgICAgICB0aGlzLl9sYXllclNlcnZpY2UuR2V0TmF0aXZlTGF5ZXIodGhpcykudGhlbigobDogTGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgbC5TZXRPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQge1xyXG4gICAgRGlyZWN0aXZlLCBJbnB1dCwgT3V0cHV0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgVmlld0NvbnRhaW5lclJlZixcclxuICAgIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBBZnRlckNvbnRlbnRJbml0LCBTaW1wbGVDaGFuZ2VzXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElQb2x5Z29uRXZlbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5Z29uLWV2ZW50JztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgUG9seWdvblNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJbmZvQm94Q29tcG9uZW50IH0gZnJvbSAnLi9pbmZvYm94JztcclxuXHJcbmxldCBwb2x5Z29uSWQgPSAwO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIE1hcFBvbHlnb25EaXJlY3RpdmUgcmVuZGVycyBhIHBvbHlnb24gaW5zaWRlIGEge0BsaW5rIE1hcENvbXBvbmVudH0uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG4gKiBpbXBvcnQge01hcENvbXBvbmVudCwgTWFwUG9seWdvbkRpcmVjdGl2ZX0gZnJvbSAnLi4uJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICBzZWxlY3RvcjogJ215LW1hcCxcclxuICogIHN0eWxlczogW2BcclxuICogICAubWFwLWNvbnRhaW5lciB7IGhlaWdodDogMzAwcHg7IH1cclxuICogYF0sXHJcbiAqIHRlbXBsYXRlOiBgXHJcbiAqICAgPHgtbWFwIFtMYXRpdHVkZV09XCJsYXRcIiBbTG9uZ2l0dWRlXT1cImxuZ1wiIFtab29tXT1cInpvb21cIj5cclxuICogICAgICA8eC1tYXAtcG9seWdvbiBbUGF0aHNdPVwicGF0aFwiPjwveC1tYXAtcG9seWdvbj5cclxuICogICA8L3gtbWFwPlxyXG4gKiBgXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAneC1tYXAtcG9seWdvbidcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hcFBvbHlnb25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgQWZ0ZXJDb250ZW50SW5pdCB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2luQ3VzdG9tTGF5ZXIgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2lkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9sYXllcklkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9hZGRlZFRvU2VydmljZSA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfZXZlbnRzOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEFueSBJbmZvQm94IHRoYXQgaXMgYSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhlIHBvbHlnb25cclxuICAgIC8vL1xyXG4gICAgQENvbnRlbnRDaGlsZChJbmZvQm94Q29tcG9uZW50KSBwcm90ZWN0ZWQgX2luZm9Cb3g6IEluZm9Cb3hDb21wb25lbnQ7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdGhpcyBQb2x5Z29uIGhhbmRsZXMgbW91c2UgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBDbGlja2FibGUgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIGNhbiBkcmFnIHRoaXMgc2hhcGUgb3ZlciB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBEcmFnZ2FibGUgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciBjYW4gZWRpdCB0aGlzIHNoYXBlIGJ5IGRyYWdnaW5nIHRoZSBjb250cm9sXHJcbiAgICAgKiBwb2ludHMgc2hvd24gYXQgdGhlIHZlcnRpY2VzIGFuZCBvbiBlYWNoIHNlZ21lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIEVkaXRhYmxlID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmlsbCBjb2xvciBvZiB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgRmlsbENvbG9yOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmlsbCBvcGFjaXR5IGJldHdlZW4gMC4wIGFuZCAxLjBcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgRmlsbE9wYWNpdHk6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gdHJ1ZSwgZWRnZXMgb2YgdGhlIHBvbHlnb24gYXJlIGludGVycHJldGVkIGFzIGdlb2Rlc2ljIGFuZCB3aWxsXHJcbiAgICAgKiBmb2xsb3cgdGhlIGN1cnZhdHVyZSBvZiB0aGUgRWFydGguIFdoZW4gZmFsc2UsIGVkZ2VzIG9mIHRoZSBwb2x5Z29uIGFyZVxyXG4gICAgICogcmVuZGVyZWQgYXMgc3RyYWlnaHQgbGluZXMgaW4gc2NyZWVuIHNwYWNlLiBOb3RlIHRoYXQgdGhlIHNoYXBlIG9mIGFcclxuICAgICAqIGdlb2Rlc2ljIHBvbHlnb24gbWF5IGFwcGVhciB0byBjaGFuZ2Ugd2hlbiBkcmFnZ2VkLCBhcyB0aGUgZGltZW5zaW9uc1xyXG4gICAgICogYXJlIG1haW50YWluZWQgcmVsYXRpdmUgdG8gdGhlIHN1cmZhY2Ugb2YgdGhlIGVhcnRoLiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgR2VvZGVzaWMgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbWF4aW11bSB6b29tIGF0IHdoaWNoIHRoZSBwb2x5Z29uIGxhYmxlIGlzIHZpc2libGUuIElnbm9yZWQgaWYgU2hvd0xhYmVsIGlzIGZhbHNlLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIExhYmVsTWF4Wm9vbTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtaW5pbXVtIHpvb20gYXQgd2hpY2ggdGhlIHBvbHlnb24gbGFibGUgaXMgdmlzaWJsZS4gSWdub3JlZCBpZiBTaG93TGFiZWwgaXMgZmFsc2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTGFiZWxNaW5ab29tOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcmJpdGFyeSBtZXRhZGF0YSB0byBhc3NpZ24gdG8gdGhlIFBvbHlnb24uIFRoaXMgaXMgdXNlZnVsIGZvciBldmVudHNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTWV0YWRhdGE6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yZGVyZWQgc2VxdWVuY2Ugb2YgY29vcmRpbmF0ZXMgdGhhdCBkZXNpZ25hdGVzIGEgY2xvc2VkIGxvb3AuXHJcbiAgICAgKiBVbmxpa2UgcG9seWxpbmVzLCBhIHBvbHlnb24gbWF5IGNvbnNpc3Qgb2Ygb25lIG9yIG1vcmUgcGF0aHMuXHJcbiAgICAgKiBBcyBhIHJlc3VsdCwgdGhlIHBhdGhzIHByb3BlcnR5IG1heSBzcGVjaWZ5IG9uZSBvciBtb3JlIGFycmF5cyBvZlxyXG4gICAgICogTGF0TG5nIGNvb3JkaW5hdGVzLiBQYXRocyBhcmUgY2xvc2VkIGF1dG9tYXRpY2FsbHk7IGRvIG5vdCByZXBlYXQgdGhlXHJcbiAgICAgKiBmaXJzdCB2ZXJ0ZXggb2YgdGhlIHBhdGggYXMgdGhlIGxhc3QgdmVydGV4LiBTaW1wbGUgcG9seWdvbnMgbWF5IGJlXHJcbiAgICAgKiBkZWZpbmVkIHVzaW5nIGEgc2luZ2xlIGFycmF5IG9mIExhdExuZ3MuIE1vcmUgY29tcGxleCBwb2x5Z29ucyBtYXlcclxuICAgICAqIHNwZWNpZnkgYW4gYXJyYXkgb2YgYXJyYXlzIChmb3IgaW5uZXIgbG9vcHMgKS4gQW55IHNpbXBsZSBhcnJheXMgYXJlIGNvbnZlcnRlZCBpbnRvIEFycmF5cy5cclxuICAgICAqIEluc2VydGluZyBvciByZW1vdmluZyBMYXRMbmdzIGZyb20gdGhlIEFycmF5IHdpbGwgYXV0b21hdGljYWxseSB1cGRhdGVcclxuICAgICAqIHRoZSBwb2x5Z29uIG9uIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFBhdGhzOiBBcnJheTxJTGF0TG9uZz4gfCBBcnJheTxBcnJheTxJTGF0TG9uZz4+ID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgdGhlIHRpdGxlIGFzIHRoZSBsYWJlbCBvbiB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU2hvd0xhYmVsOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBzaG93IHRoZSB0aXRsZSBvZiB0aGUgcG9seWdvbiBhcyB0aGUgdG9vbHRpcCBvbiB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU2hvd1Rvb2x0aXA6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0cm9rZSBjb2xvci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU3Ryb2tlQ29sb3I6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdHJva2Ugb3BhY2l0eSBiZXR3ZWVuIDAuMCBhbmQgMS4wXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFN0cm9rZU9wYWNpdHk6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdHJva2Ugd2lkdGggaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBTdHJva2VXZWlnaHQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0aXRsZSBvZiB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgVGl0bGU6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBwb2x5Z29uIGlzIHZpc2libGUgb24gdGhlIG1hcC4gRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgVmlzaWJsZTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB6SW5kZXggY29tcGFyZWQgdG8gb3RoZXIgcG9seXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIHpJbmRleDogbnVtYmVyO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIERlbGVnYXRlIGRlZmluaXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIGNsaWNrIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBDbGljazogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gZGJsY2xpY2sgZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIERibENsaWNrOiBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIHJlcGVhdGVkbHkgZmlyZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIHBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIERyYWc6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgRHJhZ0VuZDogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgRHJhZ1N0YXJ0OiBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZWRvd24gZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIE1vdXNlRG93bjogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vtb3ZlIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBNb3VzZU1vdmU6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gUG9seWdvbiBtb3VzZW91dC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgTW91c2VPdXQ6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gUG9seWdvbiBtb3VzZW92ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIE1vdXNlT3ZlcjogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGUgdGhlIERPTSBtb3VzZXVwIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIE1vdXNlVXA6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIFBvbHlnb24gaXMgcmlnaHQtY2xpY2tlZCBvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgUmlnaHRDbGljazogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGVkaXRpbmcgaGFzIGNvbXBsZXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgUGF0aENoYW5nZWQ6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5Z29uIGhhcyBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB0aGUgc2VydmljZS5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBBZGRlZFRvU2VydmljZSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2FkZGVkVG9TZXJ2aWNlOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGlkIG9mIHRoZSBwb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5faWQ7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGlkIG9mIHRoZSBwb2x5Z29uIGFzIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZEFzU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9pZC50b1N0cmluZygpOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlnb24gaXMgaW4gYSBjdXN0b20gbGF5ZXIuIFNlZSB7QGxpbmsgTWFwTGF5ZXJ9LlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJbkN1c3RvbUxheWVyKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5faW5DdXN0b21MYXllcjsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZ2V0cyB0aGUgaWQgb2YgdGhlIExheWVyIHRoZSBwb2x5Z29uIGJlbG9uZ3MgdG8uXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IExheWVySWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2xheWVySWQ7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1hcFBvbHlnb25EaXJlY3RpdmUuXHJcbiAgICAgKiBAcGFyYW0gX3BvbHlnb25NYW5hZ2VyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25EaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcG9seWdvblNlcnZpY2U6IFBvbHlnb25TZXJ2aWNlLCBwcml2YXRlIF9jb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYpIHtcclxuICAgICAgICB0aGlzLl9pZCA9IHBvbHlnb25JZCsrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBhZnRlciB0aGUgY29udGVudCBpbnRpYWxpemF0aW9uIG9mIHRoZSBkaXJlY3RpdmUgaXMgY29tcGxldGUuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5hbWU6IHN0cmluZyA9IHRoaXMuX2NvbnRhaW5lclJlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudC50YWdOYW1lO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSAneC1tYXAtbGF5ZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbkN1c3RvbUxheWVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVySWQgPSBOdW1iZXIodGhpcy5fY29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LmF0dHJpYnV0ZXNbJ2xheWVySWQnXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZFRvU2VydmljZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29uU2VydmljZS5BZGRQb2x5Z29uKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9hZGRlZFRvU2VydmljZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuQWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gY2hhbmdlcyB0byB0aGUgZGF0YWJvdWQgcHJvcGVydGllcyBvY2N1ci4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoYW5nZXMgLSBDaGFuZ2VzIHRoYXQgaGF2ZSBvY2N1cmVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiBhbnkge1xyXG4gICAgICAgIGlmICghdGhpcy5fYWRkZWRUb1NlcnZpY2UpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIGNvbnN0IG86IElQb2x5Z29uT3B0aW9ucyA9IHRoaXMuR2VuZXJhdGVQb2x5Z29uQ2hhbmdlU2V0KGNoYW5nZXMpO1xyXG4gICAgICAgIGlmIChvICE9IG51bGwpIHsgdGhpcy5fcG9seWdvblNlcnZpY2UuU2V0T3B0aW9ucyh0aGlzLCBvKTsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydQYXRocyddICYmICFjaGFuZ2VzWydQYXRocyddLmlzRmlyc3RDaGFuZ2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29uU2VydmljZS5VcGRhdGVQb2x5Z29uKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcG95Z29uIGlzIGJlaW5nIGRlc3Ryb3llZC4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuIFJlbGVhc2UgcmVzb3VyY2VzLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9wb2x5Z29uU2VydmljZS5EZWxldGVQb2x5Z29uKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5mb3JFYWNoKChzKSA9PiBzLnVuc3Vic2NyaWJlKCkpO1xyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIC8vLyByZW1vdmUgZXZlbnQgc3Vic2NyaXB0aW9uc1xyXG4gICAgICAgIC8vL1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaXJlcyB1cCB0aGUgZXZlbnQgcmVjZWl2ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgQWRkRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgY29uc3QgX2dldEV2ZW50QXJnOiAoZTogTW91c2VFdmVudCkgPT4gSVBvbHlnb25FdmVudCA9IGUgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgUG9seWdvbjogdGhpcyxcclxuICAgICAgICAgICAgICAgIENsaWNrOiBlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9ldmVudHMucHVzaCh0aGlzLl9wb2x5Z29uU2VydmljZS5DcmVhdGVFdmVudE9ic2VydmFibGUoJ2NsaWNrJywgdGhpcykuc3Vic2NyaWJlKChldjogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0OiBNYXBQb2x5Z29uRGlyZWN0aXZlID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2luZm9Cb3ggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5mb0JveC5PcGVuKHRoaXMuX3BvbHlnb25TZXJ2aWNlLkdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGV2KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5DbGljay5lbWl0KF9nZXRFdmVudEFyZyhldikpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBjb25zdCBoYW5kbGVycyA9IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnZGJsY2xpY2snLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRGJsQ2xpY2suZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLkRyYWcuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnZW5kJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLkRyYWdFbmQuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnc3RhcnQnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZ1N0YXJ0LmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vkb3duJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlRG93bi5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlbW92ZScsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU1vdmUuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW91dCcsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU91dC5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlb3ZlcicsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Nb3VzZU92ZXIuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZXVwJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlVXAuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdyaWdodGNsaWNrJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlJpZ2h0Q2xpY2suZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdwYXRoY2hhbmdlZCcsIGhhbmRsZXI6IChldjogSVBvbHlnb25FdmVudCkgPT4gdGhpcy5QYXRoQ2hhbmdlZC5lbWl0KGV2KSB9XHJcbiAgICAgICAgXTtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChvYmopID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3MgPSB0aGlzLl9wb2x5Z29uU2VydmljZS5DcmVhdGVFdmVudE9ic2VydmFibGUob2JqLm5hbWUsIHRoaXMpLnN1YnNjcmliZShvYmouaGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKG9zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgSVBvbHlnb24gb3B0aW9uIGNoYW5nZXNldCBmcm9tIGRpcmVjdGl2ZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyAtIHtAbGluayBTaW1wbGVDaGFuZ2VzfSBpZGVudGlmeWluZyB0aGUgY2hhbmdlcyB0aGF0IG9jY3VyZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJUG9seWdvbk9wdGlvbnN9IGNvbnRhaW5pbmcgdGhlIHBvbHlnb24gb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIEdlbmVyYXRlUG9seWdvbkNoYW5nZVNldChjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogSVBvbHlnb25PcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zOiBJUG9seWdvbk9wdGlvbnMgPSB7IGlkOiB0aGlzLl9pZCB9O1xyXG4gICAgICAgIGxldCBoYXNPcHRpb25zOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0NsaWNrYWJsZSddKSB7IG9wdGlvbnMuY2xpY2thYmxlID0gdGhpcy5DbGlja2FibGU7IGhhc09wdGlvbnMgPSB0cnVlOyB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0RyYWdnYWJsZSddKSB7IG9wdGlvbnMuZHJhZ2dhYmxlID0gdGhpcy5EcmFnZ2FibGU7IGhhc09wdGlvbnMgPSB0cnVlOyB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0VkaXRhYmxlJ10pIHsgb3B0aW9ucy5lZGl0YWJsZSA9IHRoaXMuRWRpdGFibGU7IGhhc09wdGlvbnMgPSB0cnVlOyB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0ZpbGxDb2xvciddIHx8IGNoYW5nZXNbJ0ZpbGxPcGFjaXR5J10pIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5maWxsQ29sb3IgPSB0aGlzLkZpbGxDb2xvcjtcclxuICAgICAgICAgICAgb3B0aW9ucy5maWxsT3BhY2l0eSA9IHRoaXMuRmlsbE9wYWNpdHk7XHJcbiAgICAgICAgICAgIGhhc09wdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snR2VvZGVzaWMnXSkgeyBvcHRpb25zLmdlb2Rlc2ljID0gdGhpcy5HZW9kZXNpYzsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snTGFiZWxNYXhab29tJ10pIHsgb3B0aW9ucy5sYWJlbE1heFpvb20gPSB0aGlzLkxhYmVsTWF4Wm9vbTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snTGFiZWxNaW5ab29tJ10pIHsgb3B0aW9ucy5sYWJlbE1pblpvb20gPSB0aGlzLkxhYmVsTWluWm9vbTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU2hvd1Rvb2x0aXAnXSkgeyBvcHRpb25zLnNob3dUb29sdGlwID0gdGhpcy5TaG93VG9vbHRpcDsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU2hvd0xhYmVsJ10pIHsgb3B0aW9ucy5zaG93TGFiZWwgPSB0aGlzLlNob3dMYWJlbDsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU3Ryb2tlQ29sb3InXSB8fCBjaGFuZ2VzWydTdHJva2VPcGFjaXR5J10pIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5zdHJva2VDb2xvciA9IHRoaXMuU3Ryb2tlQ29sb3I7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc3Ryb2tlT3BhY2l0eSA9IHRoaXMuU3Ryb2tlT3BhY2l0eTtcclxuICAgICAgICAgICAgaGFzT3B0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydTdHJva2VXZWlnaHQnXSkgeyBvcHRpb25zLnN0cm9rZVdlaWdodCA9IHRoaXMuU3Ryb2tlV2VpZ2h0OyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydUaXRsZSddKSB7IG9wdGlvbnMudGl0bGUgPSB0aGlzLlRpdGxlOyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydWaXNpYmxlJ10pIHsgb3B0aW9ucy52aXNpYmxlID0gdGhpcy5WaXNpYmxlOyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWyd6SW5kZXgnXSkgeyBvcHRpb25zLnpJbmRleCA9IHRoaXMuekluZGV4OyBoYXNPcHRpb25zID0gdHJ1ZTsgfVxyXG4gICAgICAgIHJldHVybiBoYXNPcHRpb25zID8gb3B0aW9ucyA6IG51bGw7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgICBEaXJlY3RpdmUsIElucHV0LCBPdXRwdXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBWaWV3Q29udGFpbmVyUmVmLFxyXG4gICAgRXZlbnRFbWl0dGVyLCBDb250ZW50Q2hpbGQsIEFmdGVyQ29udGVudEluaXQsIFNpbXBsZUNoYW5nZXNcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvaW50JztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9wb2x5bGluZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lRXZlbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1ldmVudCc7XHJcbmltcG9ydCB7IEluZm9Cb3hDb21wb25lbnQgfSBmcm9tICcuL2luZm9ib3gnO1xyXG5cclxubGV0IHBvbHlsaW5lSWQgPSAwO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIE1hcFBvbHlsaW5lRGlyZWN0aXZlIHJlbmRlcnMgYSBwb2x5bGluZSBpbnNpZGUgYSB7QGxpbmsgTWFwQ29tcG9uZW50fS5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbiAqIGltcG9ydCB7TWFwQ29tcG9uZW50LCBNYXBQb2x5bGluZURpcmVjdGl2ZX0gZnJvbSAnLi4uJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICBzZWxlY3RvcjogJ215LW1hcCxcclxuICogIHN0eWxlczogW2BcclxuICogICAubWFwLWNvbnRhaW5lciB7IGhlaWdodDogMzAwcHg7IH1cclxuICogYF0sXHJcbiAqIHRlbXBsYXRlOiBgXHJcbiAqICAgPHgtbWFwIFtMYXRpdHVkZV09XCJsYXRcIiBbTG9uZ2l0dWRlXT1cImxuZ1wiIFtab29tXT1cInpvb21cIj5cclxuICogICAgICA8eC1tYXAtcG9seWxpbmUgW1BhdGhzXT1cInBhdGhcIj48L3gtbWFwLXBvbHlsaW5lPlxyXG4gKiAgIDwveC1tYXA+XHJcbiAqIGBcclxuICogfSlcclxuICogYGBgXHJcbiAqXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICd4LW1hcC1wb2x5bGluZSdcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hcFBvbHlsaW5lRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkNoYW5nZXMsIEFmdGVyQ29udGVudEluaXQge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF9pbkN1c3RvbUxheWVyID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9pZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBfbGF5ZXJJZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBfYWRkZWRUb1NlcnZpY2UgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2V2ZW50czogU3Vic2NyaXB0aW9uW10gPSBbXTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBBbnkgSW5mb0JveCB0aGF0IGlzIGEgZGlyZWN0IGNoaWxkcmVuIG9mIHRoZSBwb2x5bGluZVxyXG4gICAgLy8vXHJcbiAgICBAQ29udGVudENoaWxkKEluZm9Cb3hDb21wb25lbnQpIHByb3RlY3RlZCBfaW5mb0JveDogSW5mb0JveENvbXBvbmVudDtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgd2hldGhlciB0aGlzIFBvbHlsaW5lIGhhbmRsZXMgbW91c2UgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgQ2xpY2thYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciBjYW4gZHJhZyB0aGlzIHNoYXBlIG92ZXIgdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIERyYWdnYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSB1c2VyIGNhbiBlZGl0IHRoaXMgc2hhcGUgYnkgZHJhZ2dpbmcgdGhlIGNvbnRyb2xcclxuICAgICAqIHBvaW50cyBzaG93biBhdCB0aGUgdmVydGljZXMgYW5kIG9uIGVhY2ggc2VnbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIEVkaXRhYmxlID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIHRydWUsIGVkZ2VzIG9mIHRoZSBwb2x5bGluZSBhcmUgaW50ZXJwcmV0ZWQgYXMgZ2VvZGVzaWMgYW5kIHdpbGxcclxuICAgICAqIGZvbGxvdyB0aGUgY3VydmF0dXJlIG9mIHRoZSBFYXJ0aC4gV2hlbiBmYWxzZSwgZWRnZXMgb2YgdGhlIHBvbHlsaW5lIGFyZVxyXG4gICAgICogcmVuZGVyZWQgYXMgc3RyYWlnaHQgbGluZXMgaW4gc2NyZWVuIHNwYWNlLiBOb3RlIHRoYXQgdGhlIHNoYXBlIG9mIGFcclxuICAgICAqIGdlb2Rlc2ljIHBvbHlsaW5lIG1heSBhcHBlYXIgdG8gY2hhbmdlIHdoZW4gZHJhZ2dlZCwgYXMgdGhlIGRpbWVuc2lvbnNcclxuICAgICAqIGFyZSBtYWludGFpbmVkIHJlbGF0aXZlIHRvIHRoZSBzdXJmYWNlIG9mIHRoZSBlYXJ0aC4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBHZW9kZXNpYyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJiaXRhcnkgbWV0YWRhdGEgdG8gYXNzaWduIHRvIHRoZSBQb2x5bGluZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGV2ZW50c1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTWV0YWRhdGE6IE1hcDxzdHJpbmcsIGFueT4gPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yZGVyZWQgc2VxdWVuY2Ugb2YgY29vcmRpbmF0ZXMgdGhhdCBkZXNpZ25hdGVzIGEgcG9seWxpbmUuXHJcbiAgICAgKiBTaW1wbGUgcG9seWxpbmVzIG1heSBiZSBkZWZpbmVkIHVzaW5nIGEgc2luZ2xlIGFycmF5IG9mIExhdExuZ3MuIE1vcmVcclxuICAgICAqIGNvbXBsZXggcG9seWxpbmVzIG1heSBzcGVjaWZ5IGFuIGFycmF5IG9mIGFycmF5cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFBhdGg6IEFycmF5PElMYXRMb25nPiB8IEFycmF5PEFycmF5PElMYXRMb25nPj4gPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyB0aGUgdGl0bGUgb2YgdGhlIHBvbHlsaW5lIGFzIHRoZSB0b29sdGlwIG9uIHRoZSBwb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU2hvd1Rvb2x0aXA6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0cm9rZSBjb2xvci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFN0cm9rZUNvbG9yOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3Ryb2tlIG9wYWNpdHkgYmV0d2VlbiAwLjAgYW5kIDEuMFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU3Ryb2tlT3BhY2l0eTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0cm9rZSB3aWR0aCBpbiBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBTdHJva2VXZWlnaHQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0aXRsZSBvZiB0aGUgcG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFRpdGxlOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgcG9seWxpbmUgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgVmlzaWJsZTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB6SW5kZXggY29tcGFyZWQgdG8gb3RoZXIgcG9seXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyB6SW5kZXg6IG51bWJlcjtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBEZWxlZ2F0ZSBkZWZpbml0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBDbGljazogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBkYmxjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBEYmxDbGljazogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIHJlcGVhdGVkbHkgZmlyZWQgd2hpbGUgdGhlIHVzZXIgZHJhZ3MgdGhlIHBvbHlsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgRHJhZzogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIHBvbHlsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgRHJhZ0VuZDogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBwb2x5bGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIERyYWdTdGFydDogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZWRvd24gZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgTW91c2VEb3duOiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBNb3VzZU1vdmU6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBQb2x5bGluZSBtb3VzZW91dC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIE1vdXNlT3V0OiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gUG9seWxpbmUgbW91c2VvdmVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgTW91c2VPdmVyOiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWxpbmVcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIE1vdXNlVXA6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVuIGlzIGZpcmVkIHdoZW4gdGhlIFBvbHlsaW5lIGlzIHJpZ2h0LWNsaWNrZWQgb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBSaWdodENsaWNrOiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBwb2x5bGluZSBoYXMgYmVlbiByZWdpc3RlcmVkIHdpdGggdGhlIHNlcnZpY2UuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IEFkZGVkVG9TZXJ2aWNlKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fYWRkZWRUb1NlcnZpY2U7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaWQgb2YgdGhlIHBvbHlsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgSWQoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2lkOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBpZCBvZiB0aGUgcG9seWxpbmUgYXMgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZEFzU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9pZC50b1N0cmluZygpOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHBvbHlsaW5lIGlzIGluIGEgY3VzdG9tIGxheWVyLiBTZWUge0BsaW5rIE1hcExheWVyfS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IEluQ3VzdG9tTGF5ZXIoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9pbkN1c3RvbUxheWVyOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXRzIHRoZSBpZCBvZiB0aGUgTGF5ZXIgdGhlIHBvbHlsaW5lIGJlbG9uZ3MgdG8uXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBMYXllcklkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9sYXllcklkOyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBNYXBQb2x5bGluZURpcmVjdGl2ZS5cclxuICAgICAqIEBwYXJhbSBfcG9seWxpbmVNYW5hZ2VyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BvbHlsaW5lU2VydmljZTogUG9seWxpbmVTZXJ2aWNlLCBwcml2YXRlIF9jb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYpIHtcclxuICAgICAgICB0aGlzLl9pZCA9IHBvbHlsaW5lSWQrKztcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgdGhlIGNvbnRlbnQgaW50aWFsaXphdGlvbiBvZiB0aGUgZGlyZWN0aXZlIGlzIGNvbXBsZXRlLiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50TmFtZTogc3RyaW5nID0gdGhpcy5fY29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LnRhZ05hbWU7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd4LW1hcC1sYXllcicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luQ3VzdG9tTGF5ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJJZCA9IE51bWJlcih0aGlzLl9jb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQuYXR0cmlidXRlc1snbGF5ZXJJZCddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2FkZGVkVG9TZXJ2aWNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lU2VydmljZS5BZGRQb2x5bGluZSh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fYWRkZWRUb1NlcnZpY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLkFkZEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIGNoYW5nZXMgdG8gdGhlIGRhdGFib3VkIHByb3BlcnRpZXMgb2NjdXIuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0gQ2hhbmdlcyB0aGF0IGhhdmUgb2NjdXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IGFueSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZFRvU2VydmljZSkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgY29uc3QgbzogSVBvbHlsaW5lT3B0aW9ucyA9IHRoaXMuR2VuZXJhdGVQb2x5bGluZUNoYW5nZVNldChjaGFuZ2VzKTtcclxuICAgICAgICBpZiAobyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lU2VydmljZS5TZXRPcHRpb25zKHRoaXMsIG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snUGF0aCddICYmICFjaGFuZ2VzWydQYXRoJ10uaXNGaXJzdENoYW5nZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lU2VydmljZS5VcGRhdGVQb2x5bGluZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcG9seWxpbmUgaXMgYmVpbmcgZGVzdHJveWVkLiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS4gUmVsZWFzZSByZXNvdXJjZXMuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZURpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZVNlcnZpY2UuRGVsZXRlUG9seWxpbmUodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLmZvckVhY2goKHMpID0+IHMudW5zdWJzY3JpYmUoKSk7XHJcbiAgICAgICAgICAgIC8vL1xyXG4gICAgICAgICAgICAvLy8gcmVtb3ZlIGV2ZW50IHN1YnNjcmlwdGlvbnNcclxuICAgICAgICAgICAgLy8vXHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdpcmVzIHVwIHRoZSBldmVudCByZWNlaXZlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgQWRkRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgY29uc3QgX2dldEV2ZW50QXJnOiAoZTogTW91c2VFdmVudCkgPT4gSVBvbHlsaW5lRXZlbnQgPSBlID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIFBvbHlsaW5lOiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgQ2xpY2s6IGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lU2VydmljZS5DcmVhdGVFdmVudE9ic2VydmFibGUoJ2NsaWNrJywgdGhpcykuc3Vic2NyaWJlKChldjogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5mb0JveCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmZvQm94Lk9wZW4odGhpcy5fcG9seWxpbmVTZXJ2aWNlLkdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGV2KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5DbGljay5lbWl0KF9nZXRFdmVudEFyZyhldikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdkYmxjbGljaycsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5EYmxDbGljay5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWcnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZy5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWdlbmQnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZ0VuZC5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWdzdGFydCcsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5EcmFnU3RhcnQuZW1pdChfZ2V0RXZlbnRBcmcoZXYpKSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZWRvd24nLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuTW91c2VEb3duLmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vtb3ZlJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlTW92ZS5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlb3V0JywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlT3V0LmVtaXQoX2dldEV2ZW50QXJnKGV2KSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdmVyJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLk1vdXNlT3Zlci5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNldXAnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuTW91c2VVcC5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ3JpZ2h0Y2xpY2snLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuUmlnaHRDbGljay5lbWl0KF9nZXRFdmVudEFyZyhldikpIH0sXHJcbiAgICAgICAgXTtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChvYmopID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3MgPSB0aGlzLl9wb2x5bGluZVNlcnZpY2UuQ3JlYXRlRXZlbnRPYnNlcnZhYmxlKG9iai5uYW1lLCB0aGlzKS5zdWJzY3JpYmUob2JqLmhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMucHVzaChvcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIElQb2x5bGluZSBvcHRpb24gY2hhbmdlc2V0IGZyb20gZGlyZWN0aXZlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0ge0BsaW5rIFNpbXBsZUNoYW5nZXN9IGlkZW50aWZ5aW5nIHRoZSBjaGFuZ2VzIHRoYXQgb2NjdXJlZC5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIElQb2x5bGluZU9wdGlvbnN9IGNvbnRhaW5pbmcgdGhlIHBvbHlsaW5lIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgR2VuZXJhdGVQb2x5bGluZUNoYW5nZVNldChjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogSVBvbHlsaW5lT3B0aW9ucyB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyA9IHsgaWQ6IHRoaXMuX2lkIH07XHJcbiAgICAgICAgbGV0IGhhc09wdGlvbnM6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICBpZiAoY2hhbmdlc1snQ2xpY2thYmxlJ10pIHsgb3B0aW9ucy5jbGlja2FibGUgPSB0aGlzLkNsaWNrYWJsZTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snRHJhZ2dhYmxlJ10pIHsgb3B0aW9ucy5kcmFnZ2FibGUgPSB0aGlzLkRyYWdnYWJsZTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snRWRpdGFibGUnXSkgeyBvcHRpb25zLmVkaXRhYmxlID0gdGhpcy5FZGl0YWJsZTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snR2VvZGVzaWMnXSkgeyBvcHRpb25zLmdlb2Rlc2ljID0gdGhpcy5HZW9kZXNpYzsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU2hvd1Rvb2x0aXAnXSkgeyBvcHRpb25zLnNob3dUb29sdGlwID0gdGhpcy5TaG93VG9vbHRpcDsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU3Ryb2tlQ29sb3InXSkgeyBvcHRpb25zLnN0cm9rZUNvbG9yID0gdGhpcy5TdHJva2VDb2xvcjsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU3Ryb2tlT3BhY2l0eSddKSB7IG9wdGlvbnMuc3Ryb2tlT3BhY2l0eSA9IHRoaXMuU3Ryb2tlT3BhY2l0eTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU3Ryb2tlV2VpZ2h0J10pIHsgb3B0aW9ucy5zdHJva2VXZWlnaHQgPSB0aGlzLlN0cm9rZVdlaWdodDsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snVGl0bGUnXSkgeyBvcHRpb25zLnRpdGxlID0gdGhpcy5UaXRsZTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snVmlzaWJsZSddKSB7IG9wdGlvbnMudmlzaWJsZSA9IHRoaXMuVmlzaWJsZTsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snekluZGV4J10pIHsgb3B0aW9ucy56SW5kZXggPSB0aGlzLnpJbmRleDsgaGFzT3B0aW9ucyA9IHRydWU7IH1cclxuICAgICAgICByZXR1cm4gaGFzT3B0aW9ucyA/IG9wdGlvbnMgOiBudWxsO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQge1xyXG4gICAgRGlyZWN0aXZlLCBTaW1wbGVDaGFuZ2UsIElucHV0LCBPdXRwdXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzLFxyXG4gICAgRXZlbnRFbWl0dGVyLCBDb250ZW50Q2hpbGQsIEFmdGVyQ29udGVudEluaXQsIFZpZXdDb250YWluZXJSZWYsIE5nWm9uZVxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElNYXJrZXJFdmVudCB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1ldmVudCc7XHJcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF5ZXJPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF5ZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBJQ2x1c3Rlckljb25JbmZvIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pY2x1c3Rlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBJQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2ljbHVzdGVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbWFya2VyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQ2x1c3RlclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9jbHVzdGVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBDbHVzdGVyQ2xpY2tBY3Rpb24gfSBmcm9tICcuLi9tb2RlbHMvY2x1c3Rlci1jbGljay1hY3Rpb24nO1xyXG5pbXBvcnQgeyBDbHVzdGVyUGxhY2VtZW50TW9kZSB9IGZyb20gJy4uL21vZGVscy9jbHVzdGVyLXBsYWNlbWVudC1tb2RlJztcclxuaW1wb3J0IHsgQ2x1c3RlckxheWVyRGlyZWN0aXZlIH0gZnJvbSAnLi9jbHVzdGVyLWxheWVyJztcclxuXHJcbi8qKlxyXG4gKiBpbnRlcm5hbCBjb3VudGVyIHRvIHVzZSBhcyBpZHMgZm9yIG1hcmtlci5cclxuICovXHJcbmxldCBsYXllcklkID0gMTAwMDAwMDtcclxuXHJcbi8qKlxyXG4gKiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZSBwZXJmb3JtYW50bHkgcmVuZGVycyBhIGxhcmdlIHNldCBvZiBtYXAgbWFya2VyIGluc2lkZSBhIHtAbGluayBNYXBDb21wb25lbnR9LlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuICogaW1wb3J0IHtNYXBDb21wb25lbnQsIE1hcE1hcmtlckRpcmVjdGl2ZX0gZnJvbSAnLi4uJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICBzZWxlY3RvcjogJ215LW1hcC1jbXAnLFxyXG4gKiAgc3R5bGVzOiBbYFxyXG4gKiAgIC5tYXAtY29udGFpbmVyIHtcclxuICogICAgIGhlaWdodDogMzAwcHg7XHJcbiAqICAgfVxyXG4gKiBgXSxcclxuICogdGVtcGxhdGU6IGBcclxuICogICA8eC1tYXAgW0xhdGl0dWRlXT1cImxhdFwiIFtMb25naXR1ZGVdPVwibG5nXCIgW1pvb21dPVwiem9vbVwiPlxyXG4gKiAgICAgIDx4LW1hcC1tYXJrZXItbGF5ZXIgW01hcmtlck9wdGlvbnNdPVwiX21hcmtlcnNcIj48L3gtbWFwLW1hcmtlci1sYXllcj5cclxuICogICA8L3gtbWFwPlxyXG4gKiBgXHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAneC1tYXAtbWFya2VyLWxheWVyJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgQWZ0ZXJDb250ZW50SW5pdCB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2lkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9sYXllclByb21pc2U6IFByb21pc2U8TGF5ZXI+O1xyXG4gICAgcHJpdmF0ZSBfc2VydmljZTogTGF5ZXJTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBfc3R5bGVzOiBBcnJheTxJQ2x1c3Rlckljb25JbmZvPjtcclxuICAgIHByaXZhdGUgX3VzZUR5bmFtaWNTaXplTWFya2VyID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9keW5hbWljTWFya2VyQmFzZVNpemUgPSAxODtcclxuICAgIHByaXZhdGUgX2R5bmFtaWNNYXJrZXJSYW5nZXM6IE1hcDxudW1iZXIsIHN0cmluZz4gPSBuZXcgTWFwPG51bWJlciwgc3RyaW5nPihbXHJcbiAgICAgICAgWzEwLCAncmdiYSgyMCwgMTgwLCAyMCwgMC41KSddLFxyXG4gICAgICAgIFsxMDAsICdyZ2JhKDI1NSwgMjEwLCA0MCwgMC41KSddLFxyXG4gICAgICAgIFtOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAsICdyZ2JhKDI1NSwgNDAsIDQwLCAwLjUpJ11cclxuICAgIF0pO1xyXG4gICAgcHJpdmF0ZSBfaWNvbkNyZWF0aW9uQ2FsbGJhY2s6IChtOiBBcnJheTxNYXJrZXI+LCBpOiBJTWFya2VySWNvbkluZm8pID0+IHN0cmluZztcclxuICAgIHByaXZhdGUgX3N0cmVhbWluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfbWFya2VyczogQXJyYXk8SU1hcmtlck9wdGlvbnM+ID0gbmV3IEFycmF5PElNYXJrZXJPcHRpb25zPigpO1xyXG4gICAgcHJpdmF0ZSBfbWFya2Vyc0xhc3Q6IEFycmF5PElNYXJrZXJPcHRpb25zPiA9IG5ldyBBcnJheTxJTWFya2VyT3B0aW9ucz4oKTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHRoZSBDbHVzdGVyIENsaWNrIEFjdGlvbiB7QGxpbmsgQ2x1c3RlckNsaWNrQWN0aW9ufS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIENsdXN0ZXJDbGlja0FjdGlvbjogQ2x1c3RlckNsaWNrQWN0aW9uID0gIENsdXN0ZXJDbGlja0FjdGlvbi5ab29tSW50b0NsdXN0ZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIEljb25JbmZvIHRvIGJlIHVzZWQgdG8gY3JlYXRlIGEgY3VzdG9tIGNsdXN0ZXIgbWFya2VyLiBTdXBwb3J0cyBmb250LWJhc2VkLCBTVkcsIGdyYXBoaWNzIGFuZCBtb3JlLlxyXG4gICAgICogU2VlIHtAbGluayBJTWFya2VySWNvbkluZm99LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgQ2x1c3Rlckljb25JbmZvOiBJTWFya2VySWNvbkluZm87XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGNsdXN0ZXIgcGxhY2VtZW50IG1vZGUuIHtAbGluayBDbHVzdGVyUGxhY2VtZW50TW9kZX1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgIHB1YmxpYyBDbHVzdGVyUGxhY2VtZW50TW9kZTogQ2x1c3RlclBsYWNlbWVudE1vZGUgPSBDbHVzdGVyUGxhY2VtZW50TW9kZS5NZWFuVmFsdWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGNhbGxiYWNrIGludm9rZWQgdG8gY3JlYXRlIGEgY3VzdG9tIGNsdXN0ZXIgbWFya2VyLiBOb3RlIHRoYXQgd2hlbiB7QGxpbmsgVXNlRHluYW1pY1NpemVNYXJrZXJzfSBpcyBlbmFibGVkLFxyXG4gICAgICogeW91IGNhbm5vdCBzZXQgYSBjdXN0b20gbWFya2VyIGNhbGxiYWNrLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgQ3VzdG9tTWFya2VyQ2FsbGJhY2soKTogKG06IEFycmF5PE1hcmtlcj4sIGk6IElNYXJrZXJJY29uSW5mbykgPT4gc3RyaW5nICB7IHJldHVybiB0aGlzLl9pY29uQ3JlYXRpb25DYWxsYmFjazsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgQ3VzdG9tTWFya2VyQ2FsbGJhY2sodmFsOiAobTogQXJyYXk8TWFya2VyPiwgaTogSU1hcmtlckljb25JbmZvKSA9PiBzdHJpbmcpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3VzZUR5bmFtaWNTaXplTWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyhcclxuICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoYFlvdSBjYW5ub3Qgc2V0IGEgY3VzdG9tIG1hcmtlciBjYWxsYmFjayB3aGVuIFVzZUR5bmFtaWNTaXplTWFya2VycyBpcyBzZXQgdG8gdHJ1ZS5cclxuICAgICAgICAgICAgICAgICAgICBTZXQgVXNlRHluYW1pY1NpemVNYWtlcnMgdG8gZmFsc2UuYClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faWNvbkNyZWF0aW9uQ2FsbGJhY2sgPSB2YWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBiYXNlIHNpemUgb2YgZHluYW1pYyBtYXJrZXJzIGluIHBpeGVscy4gVGhlIGFjdHVhbHkgc2l6ZSBvZiB0aGUgZHluYW1pYyBtYXJrZXIgaXMgYmFzZWQgb24gdGhpcy5cclxuICAgICAqIFNlZSB7QGxpbmsgVXNlRHluYW1pY1NpemVNYXJrZXJzfS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBEeW5hbWljTWFya2VyQmFzZVNpemUoKTogbnVtYmVyICB7IHJldHVybiB0aGlzLl9keW5hbWljTWFya2VyQmFzZVNpemU7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IER5bmFtaWNNYXJrZXJCYXNlU2l6ZSh2YWw6IG51bWJlcikgeyB0aGlzLl9keW5hbWljTWFya2VyQmFzZVNpemUgPSB2YWw7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgcmFuZ2VzIHRvIHVzZSB0byBjYWxjdWxhdGUgYnJlYWtwb2ludHMgYW5kIGNvbG9ycyBmb3IgZHluYW1pYyBtYXJrZXJzLlxyXG4gICAgICogVGhlIG1hcCBjb250YWlucyBrZXkvdmFsdWUgcGFpcnMsIHdpdGggdGhlIGtleXMgYmVpbmdcclxuICAgICAqIHRoZSBicmVha3BvaW50IHNpemVzIGFuZCB0aGUgdmFsdWVzIHRoZSBjb2xvcnMgdG8gYmUgdXNlZCBmb3IgdGhlIGR5bmFtaWMgbWFya2VyIGluIHRoYXQgcmFuZ2UuIFNlZSB7QGxpbmsgVXNlRHluYW1pY1NpemVNYXJrZXJzfS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2x1c3RlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBEeW5hbWljTWFya2VyUmFuZ2VzKCk6IE1hcDxudW1iZXIsIHN0cmluZz4gIHsgcmV0dXJuIHRoaXMuX2R5bmFtaWNNYXJrZXJSYW5nZXM7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IER5bmFtaWNNYXJrZXJSYW5nZXModmFsOiBNYXA8bnVtYmVyLCBzdHJpbmc+KSB7IHRoaXMuX2R5bmFtaWNNYXJrZXJSYW5nZXMgPSB2YWw7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgbGF5ZXIgY2x1c3RlcnMuIFRoaXMgcHJvcGVydHkgY2FuIG9ubHkgYmUgc2V0IG9uIGNyZWF0aW9uIG9mIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIEVuYWJsZUNsdXN0ZXJpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZ3JpZCBzaXplIHRvIGJlIHVzZWQgZm9yIGNsdXN0ZXJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBHcmlkU2l6ZTogbnVtYmVyID0gMTUwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBJY29uSW5mbyB0byBiZSB1c2VkIHRvIGNyZWF0ZSBhIGN1c3RvbSBtYXJrZXIgaW1hZ2VzLiBTdXBwb3J0cyBmb250LWJhc2VkLCBTVkcsIGdyYXBoaWNzIGFuZCBtb3JlLlxyXG4gICAgICogU2VlIHtAbGluayBJTWFya2VySWNvbkluZm99LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgSWNvbkluZm86IElNYXJrZXJJY29uSW5mbztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyBBbiBvZmZzZXQgYXBwbGllZCB0byB0aGUgcG9zaXRpb25pbmcgb2YgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTGF5ZXJPZmZzZXQ6IElQb2ludCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgSU1hcmtlck9wdGlvbnMgYXJyYXkgaG9sZGluZyB0aGUgbWFya2VyIGluZm8uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBNYXJrZXJPcHRpb25zKCk6IEFycmF5PElNYXJrZXJPcHRpb25zPiB7IHJldHVybiB0aGlzLl9tYXJrZXJzOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBNYXJrZXJPcHRpb25zKHZhbDogQXJyYXk8SU1hcmtlck9wdGlvbnM+KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdHJlYW1pbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnNMYXN0LnB1c2goLi4udmFsLnNsaWNlKDApKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMucHVzaCguLi52YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya2VycyA9IHZhbC5zbGljZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY2x1c3RlciBzdHlsZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgICAgICBwdWJsaWMgZ2V0IFN0eWxlcygpOiBBcnJheTxJQ2x1c3Rlckljb25JbmZvPiB7IHJldHVybiB0aGlzLl9zdHlsZXM7IH1cclxuICAgICAgICBwdWJsaWMgc2V0IFN0eWxlcyh2YWw6IEFycmF5PElDbHVzdGVySWNvbkluZm8+KSB7IHRoaXMuX3N0eWxlcyA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRvIHRyZWF0IGNoYW5nZXMgaW4gdGhlIE1hcmtlck9wdGlvbnMgYXMgc3RyZWFtcyBvZiBuZXcgbWFya2Vycy4gSW4gdGhzaSBtb2RlLCBjaGFuZ2luZyB0aGVcclxuICAgICAqIEFycmF5IHN1cHBsaWVkIGluIE1hcmtlck9wdGlvbnMgd2lsbCBiZSBpbmNyZW1lbnRhbGx5IGRyYXduIG9uIHRoZSBtYXAgYXMgb3Bwb3NlZCB0byByZXBsYWNlIHRoZSBtYXJrZXJzIG9uIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBUcmVhdE5ld01hcmtlck9wdGlvbnNBc1N0cmVhbSgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3N0cmVhbWluZzsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgVHJlYXROZXdNYXJrZXJPcHRpb25zQXNTdHJlYW0odmFsOiBib29sZWFuKSB7IHRoaXMuX3N0cmVhbWluZyA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHdoZXRoZXIgdG8gdXNlIGR5bmFtaWMgbWFya2Vycy4gRHluYW1pYyBtYXJrZXJzIGNoYW5nZSBpbiBzaXplIGFuZCBjb2xvciBkZXBlbmRpbmcgb24gdGhlIG51bWJlciBvZlxyXG4gICAgICogcGlucyBpbiB0aGUgY2x1c3Rlci4gSWYgc2V0IHRvIHRydWUsIHRoaXMgd2lsbCB0YWtlIHByZWNlbmRlbmNlIG92ZXIgYW55IGN1c3RvbSBtYXJrZXIgY3JlYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBVc2VEeW5hbWljU2l6ZU1hcmtlcnMoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl91c2VEeW5hbWljU2l6ZU1hcmtlcjsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgVXNlRHluYW1pY1NpemVNYXJrZXJzKHZhbDogYm9vbGVhbikge1xyXG4gICAgICAgICAgICB0aGlzLl91c2VEeW5hbWljU2l6ZU1hcmtlciA9IHZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbkNyZWF0aW9uQ2FsbGJhY2sgPSAobTogQXJyYXk8TWFya2VyPiwgaW5mbzogSU1hcmtlckljb25JbmZvKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENsdXN0ZXJMYXllckRpcmVjdGl2ZS5DcmVhdGVEeW5hbWljU2l6ZU1hcmtlcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5sZW5ndGgsIGluZm8sIHRoaXMuX2R5bmFtaWNNYXJrZXJCYXNlU2l6ZSwgdGhpcy5fZHluYW1pY01hcmtlclJhbmdlcyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbWFya2VyIGxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBWaXNpYmxlOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB6LWluZGV4IG9mIHRoZSBsYXllci4gSWYgbm90IHVzZWQsIGxheWVycyBnZXQgc3RhY2tlZCBpbiB0aGUgb3JkZXIgY3JlYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFpJbmRleDogbnVtYmVyID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB3aGV0aGVyIHRoZSBjbHVzdGVyIHNob3VsZCB6b29tIGluIG9uIGNsaWNrXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQElucHV0KCkgcHVibGljIFpvb21PbkNsaWNrOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRGVsZWdhdGVzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgZHluYW1pYyBpY29uIGZvciBhIG1hcmtlciBpcyBiZWluZyBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgcHVibGljIER5bmFtaWNNYXJrZXJDcmVhdGVkOiBFdmVudEVtaXR0ZXI8SU1hcmtlckljb25JbmZvPiA9IG5ldyBFdmVudEVtaXR0ZXI8SU1hcmtlckljb25JbmZvPigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBhIG1hcmtlciBpbiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBwdWJsaWMgTWFya2VyQ2xpY2s6IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTWFya2VyRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgYSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBwdWJsaWMgRHJhZ0VuZDogRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNYXJrZXJFdmVudD4oKTtcclxuXHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGlkIG9mIHRoZSBtYXJrZXIgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5faWQ7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlLlxyXG4gICAgICogQHBhcmFtIF9tYXJrZXJTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE1hcmtlclNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIF9sYXllclNlcnZpY2UgLSBDb25jcmVhdGUgaW1wbGVtZW50YXRpb24gb2YgYSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfS5cclxuICAgICAqIEBwYXJhbSBfY2x1c3RlclNlcnZpY2UgLSBDb25jcmVhdGUgaW1wbGVtZW50YXRpb24gb2YgYSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE1hcFNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE5nWm9uZX0gc2VydmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJpdmF0ZSBfbWFya2VyU2VydmljZTogTWFya2VyU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF9sYXllclNlcnZpY2U6IExheWVyU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF9jbHVzdGVyU2VydmljZTogQ2x1c3RlclNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcclxuICAgICAgICB0aGlzLl9pZCA9IGxheWVySWQrKztcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGVzIGEgZ2VvIGxvY2F0aW9uIHRvIGEgcGl4ZWwgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIG1hcCB2aWV3cG9ydC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gW2xvY10gLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcy5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIGFuIHtAbGluayBJUG9pbnR9IHJlcHJlc2VudGluZyB0aGUgcGl4ZWwgY29vcmRpbmF0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBMb2NhdGlvblRvUGl4ZWwobG9jOiBJTGF0TG9uZyk6IFByb21pc2U8SVBvaW50PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlclNlcnZpY2UuTG9jYXRpb25Ub1BvaW50KGxvYyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgQ29tcG9uZW50IGNvbnRlbnQgaW5pdGlhbGl6YXRpb24uIFBhcnQgb2YgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXJPcHRpb25zOiBJTGF5ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogdGhpcy5faWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmYWtlTGF5ZXJEaXJlY3RpdmU6IGFueSA9IHtcclxuICAgICAgICAgICAgICAgIElkIDogdGhpcy5faWQsXHJcbiAgICAgICAgICAgICAgICBWaXNpYmxlOiB0aGlzLlZpc2libGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLkVuYWJsZUNsdXN0ZXJpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyU2VydmljZS5BZGRMYXllcihmYWtlTGF5ZXJEaXJlY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlLkdldE5hdGl2ZUxheWVyKGZha2VMYXllckRpcmVjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXJ2aWNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmFrZUxheWVyRGlyZWN0aXZlLkxheWVyT2Zmc2V0ID0gdGhpcy5MYXllck9mZnNldDtcclxuICAgICAgICAgICAgICAgIGZha2VMYXllckRpcmVjdGl2ZS5aSW5kZXggPSB0aGlzLlpJbmRleDtcclxuICAgICAgICAgICAgICAgIGZha2VMYXllckRpcmVjdGl2ZS5DbHVzdGVyaW5nRW5hYmxlZCA9IHRoaXMuRW5hYmxlQ2x1c3RlcmluZztcclxuICAgICAgICAgICAgICAgIGZha2VMYXllckRpcmVjdGl2ZS5DbHVzdGVyUGxhY2VtZW50TW9kZSA9IHRoaXMuQ2x1c3RlclBsYWNlbWVudE1vZGU7XHJcbiAgICAgICAgICAgICAgICBmYWtlTGF5ZXJEaXJlY3RpdmUuR3JpZFNpemUgPSB0aGlzLkdyaWRTaXplO1xyXG4gICAgICAgICAgICAgICAgZmFrZUxheWVyRGlyZWN0aXZlLkNsdXN0ZXJDbGlja0FjdGlvbiA9IHRoaXMuQ2x1c3RlckNsaWNrQWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgZmFrZUxheWVyRGlyZWN0aXZlLkljb25JbmZvID0gdGhpcy5DbHVzdGVySWNvbkluZm87XHJcbiAgICAgICAgICAgICAgICBmYWtlTGF5ZXJEaXJlY3RpdmUuQ3VzdG9tTWFya2VyQ2FsbGJhY2sgPSB0aGlzLkN1c3RvbU1hcmtlckNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgICAgZmFrZUxheWVyRGlyZWN0aXZlLlVzZUR5bmFtaWNTaXplTWFya2VycyA9IHRoaXMuVXNlRHluYW1pY1NpemVNYXJrZXJzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2x1c3RlclNlcnZpY2UuQWRkTGF5ZXIoZmFrZUxheWVyRGlyZWN0aXZlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZSA9IHRoaXMuX2NsdXN0ZXJTZXJ2aWNlLkdldE5hdGl2ZUxheWVyKGZha2VMYXllckRpcmVjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXJ2aWNlID0gdGhpcy5fY2x1c3RlclNlcnZpY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlLnRoZW4obCA9PiB7XHJcbiAgICAgICAgICAgICAgICBsLlNldFZpc2libGUodGhpcy5WaXNpYmxlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLk1hcmtlck9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuVXBkYXRlTWFya2VycygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgb24gY29tcG9uZW50IGRlc3RydWN0aW9uLiBGcmVlcyB0aGUgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGNvbXBvbmVudC4gUGFydCBvZiB0aGUgbmcgQ29tcG9uZW50IGxpZmUgY3ljbGUuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlLnRoZW4obCA9PiB7XHJcbiAgICAgICAgICAgIGwuRGVsZXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFjdHMgdG8gY2hhbmdlcyBpbiBkYXRhLWJvdW5kIHByb3BlcnRpZXMgb2YgdGhlIGNvbXBvbmVudCBhbmQgYWN0dWF0ZXMgcHJvcGVydHkgY2hhbmdlcyBpbiB0aGUgdW5kZXJsaW5nIGxheWVyIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0gY29sbGVjdGlvbiBvZiBjaGFuZ2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xyXG4gICAgICAgIGxldCBzaG91bGRTZXRPcHRpb25zOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgbzogSUNsdXN0ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogdGhpcy5faWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChjaGFuZ2VzWydNYXJrZXJPcHRpb25zJ10pIHtcclxuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlVwZGF0ZU1hcmtlcnMoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydWaXNpYmxlJ10gJiYgIWNoYW5nZXNbJ1Zpc2libGUnXS5maXJzdENoYW5nZSkge1xyXG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4gbC5TZXRWaXNpYmxlKHRoaXMuVmlzaWJsZSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0VuYWJsZUNsdXN0ZXJpbmcnXSAmJiAhY2hhbmdlc1snRW5hYmxlQ2x1c3RlcmluZyddLmZpcnN0Q2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGlmICgnU3RvcENsdXN0ZXJpbmcnIGluIHRoaXMuX3NlcnZpY2UpIHtcclxuICAgICAgICAgICAgICAgIG8uY2x1c3RlcmluZ0VuYWJsZWQgPSB0aGlzLkVuYWJsZUNsdXN0ZXJpbmc7XHJcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRPcHRpb25zID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgY2hhbmdlIEVuYWJsZUNsdXN0ZXJpbmcgYWZ0ZXIgdGhlIGxheWVyIGhhcyBiZWVuIGNyZWF0ZWQuJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VzWydDbHVzdGVyUGxhY2VtZW50TW9kZSddICYmICFjaGFuZ2VzWydDbHVzdGVyUGxhY2VtZW50TW9kZSddLmZpcnN0Q2hhbmdlICYmICdTdG9wQ2x1c3RlcmluZycgaW4gdGhpcy5fc2VydmljZSkge1xyXG4gICAgICAgICAgICBvLnBsYWNlbWVudE1vZGUgPSB0aGlzLkNsdXN0ZXJQbGFjZW1lbnRNb2RlO1xyXG4gICAgICAgICAgICBzaG91bGRTZXRPcHRpb25zID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0dyaWRTaXplJ10gJiYgIWNoYW5nZXNbJ0dyaWRTaXplJ10uZmlyc3RDaGFuZ2UgJiYgJ1N0b3BDbHVzdGVyaW5nJyBpbiB0aGlzLl9zZXJ2aWNlKSB7XHJcbiAgICAgICAgICAgIG8uZ3JpZFNpemUgPSB0aGlzLkdyaWRTaXplO1xyXG4gICAgICAgICAgICBzaG91bGRTZXRPcHRpb25zID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ0NsdXN0ZXJDbGlja0FjdGlvbiddICYmICFjaGFuZ2VzWydDbHVzdGVyQ2xpY2tBY3Rpb24nXS5maXJzdENoYW5nZSAmJiAnU3RvcENsdXN0ZXJpbmcnIGluIHRoaXMuX3NlcnZpY2UpIHtcclxuICAgICAgICAgICAgby56b29tT25DbGljayA9IHRoaXMuQ2x1c3RlckNsaWNrQWN0aW9uID09PSBDbHVzdGVyQ2xpY2tBY3Rpb24uWm9vbUludG9DbHVzdGVyO1xyXG4gICAgICAgICAgICBzaG91bGRTZXRPcHRpb25zID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChjaGFuZ2VzWydaSW5kZXgnXSAmJiAhY2hhbmdlc1snWkluZGV4J10uZmlyc3RDaGFuZ2UpIHx8XHJcbiAgICAgICAgICAgIChjaGFuZ2VzWydMYXllck9mZnNldCddICYmICFjaGFuZ2VzWydMYXllck9mZnNldCddLmZpcnN0Q2hhbmdlKSB8fFxyXG4gICAgICAgICAgICAoY2hhbmdlc1snSWNvbkluZm8nXSAmJiAhY2hhbmdlc1snSWNvbkluZm8nXS5maXJzdENoYW5nZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignWW91IGNhbm5vdCBjaGFuZ2UgWkluZGV4IG9yIExheWVyT2Zmc2V0IGFmdGVyIHRoZSBsYXllciBoYXMgYmVlbiBjcmVhdGVkLicpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzaG91bGRTZXRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmFrZUxheWVyRGlyZWN0aXZlOiBhbnkgPSB7SWQgOiB0aGlzLl9pZH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllclByb21pc2UudGhlbihsID0+IGwuU2V0T3B0aW9ucyhvKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE1hcmtlciBJZC5cclxuICAgICAqIEByZXR1cm5zIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXJrZXIgaWQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiAnTWFwTWFya2VyTGF5ZXItJyArIHRoaXMuX2lkLnRvU3RyaW5nKCk7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcml2YXRlIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB2YXJpb3VzIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbSAtIHRoZSBtYXJrZXIgZm9yIHdoaWNoIHRvIGFkZCB0aGUgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgQWRkRXZlbnRMaXN0ZW5lcnMobTogTWFya2VyKTogdm9pZCB7XHJcbiAgICAgICAgbS5BZGRMaXN0ZW5lcignY2xpY2snLCAoZTogTW91c2VFdmVudCkgPT4gdGhpcy5NYXJrZXJDbGljay5lbWl0KHtcclxuICAgICAgICAgICAgICAgIE1hcmtlcjogbSxcclxuICAgICAgICAgICAgICAgIENsaWNrOiBlLFxyXG4gICAgICAgICAgICAgICAgTG9jYXRpb246IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZSksXHJcbiAgICAgICAgICAgICAgICBQaXhlbHM6IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0UGl4ZWxzRnJvbUNsaWNrKGUpXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICBtLkFkZExpc3RlbmVyKCdkcmFnZW5kJywgKGU6IE1vdXNlRXZlbnQpID0+IHRoaXMuRHJhZ0VuZC5lbWl0KHtcclxuICAgICAgICAgICAgICAgIE1hcmtlcjogbSxcclxuICAgICAgICAgICAgICAgIENsaWNrOiBlLFxyXG4gICAgICAgICAgICAgICAgTG9jYXRpb246IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZSksXHJcbiAgICAgICAgICAgICAgICBQaXhlbHM6IHRoaXMuX21hcmtlclNlcnZpY2UuR2V0UGl4ZWxzRnJvbUNsaWNrKGUpXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgb3IgdXBkYXRlcyB0aGUgbWFya2VycyBiYXNlZCBvbiB0aGUgbWFya2VyIG9wdGlvbnMuIFRoaXMgd2lsbCBwbGFjZSB0aGUgbWFya2VycyBvbiB0aGUgbWFwXHJcbiAgICAgKiBhbmQgcmVnaXN0ZXIgdGhlIGFzc29jaWF0ZWQgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIFVwZGF0ZU1hcmtlcnMoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xheWVyUHJvbWlzZSA9PSBudWxsKSB7IHJldHVybjsgfVxyXG4gICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXJzOiBBcnJheTxJTWFya2VyT3B0aW9ucz4gPSB0aGlzLl9zdHJlYW1pbmcgPyB0aGlzLl9tYXJrZXJzTGFzdC5zcGxpY2UoMCkgOiB0aGlzLl9tYXJrZXJzO1xyXG5cclxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIHByb21pc2UgZm9yIHRoZSBtYXJrZXJzXHJcbiAgICAgICAgICAgIGNvbnN0IG1wOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+ID0gdGhpcy5fc2VydmljZS5DcmVhdGVNYXJrZXJzKG1hcmtlcnMsIHRoaXMuSWNvbkluZm8pO1xyXG5cclxuICAgICAgICAgICAgLy8gc2V0IG1hcmtlcnMgb25jZSBwcm9taXNlcyBhcmUgZnVsbGZpbGxlZC5cclxuICAgICAgICAgICAgbXAudGhlbihtID0+IHtcclxuICAgICAgICAgICAgICAgIG0uZm9yRWFjaChtYXJrZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZEV2ZW50TGlzdGVuZXJzKG1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0cmVhbWluZyA/IGwuQWRkRW50aXRpZXMobSkgOiBsLlNldEVudGl0aWVzKG0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICAgIERpcmVjdGl2ZSwgU2ltcGxlQ2hhbmdlLCBJbnB1dCwgT3V0cHV0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyxcclxuICAgIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBBZnRlckNvbnRlbnRJbml0LCBWaWV3Q29udGFpbmVyUmVmLCBOZ1pvbmUsXHJcbiAgICBTaW1wbGVDaGFuZ2VzXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElTaXplIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pc2l6ZSc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElQb2x5Z29uRXZlbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2x5Z29uLWV2ZW50JztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGFiZWxPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGFiZWwtb3B0aW9ucyc7XHJcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2xheWVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuLi9tb2RlbHMvcG9seWdvbic7XHJcbmltcG9ydCB7IE1hcExhYmVsIH0gZnJvbSAnLi4vbW9kZWxzL21hcC1sYWJlbCc7XHJcbmltcG9ydCB7IENhbnZhc092ZXJsYXkgfSBmcm9tICcuLi9tb2RlbHMvY2FudmFzLW92ZXJsYXknO1xyXG5cclxuLyoqXHJcbiAqIGludGVybmFsIGNvdW50ZXIgdG8gdXNlIGFzIGlkcyBmb3IgcG9seWdvbnMuXHJcbiAqL1xyXG5sZXQgbGF5ZXJJZCA9IDEwMDAwMDA7XHJcblxyXG4vKipcclxuICogTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlIHBlcmZvcm1hbnRseSByZW5kZXJzIGEgbGFyZ2Ugc2V0IG9mIHBvbHlnb25zIG9uIGEge0BsaW5rIE1hcENvbXBvbmVudH0uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG4gKiBpbXBvcnQge01hcENvbXBvbmVudH0gZnJvbSAnLi4uJztcclxuICpcclxuICogQENvbXBvbmVudCh7XHJcbiAqICBzZWxlY3RvcjogJ215LW1hcC1jbXAnLFxyXG4gKiAgc3R5bGVzOiBbYFxyXG4gKiAgIC5tYXAtY29udGFpbmVyIHtcclxuICogICAgIGhlaWdodDogMzAwcHg7XHJcbiAqICAgfVxyXG4gKiBgXSxcclxuICogdGVtcGxhdGU6IGBcclxuICogICA8eC1tYXAgW0xhdGl0dWRlXT1cImxhdFwiIFtMb25naXR1ZGVdPVwibG5nXCIgW1pvb21dPVwiem9vbVwiPlxyXG4gKiAgICAgIDx4LW1hcC1wb2x5Z29uLWxheWVyIFtQb2x5Z29uT3B0aW9uc109XCJfcG9seWdvbnNcIj48L3gtbWFwLXBvbHlnb24tbGF5ZXI+XHJcbiAqICAgPC94LW1hcD5cclxuICogYFxyXG4gKiB9KVxyXG4gKiBgYGBcclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ3gtbWFwLXBvbHlnb24tbGF5ZXInXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgQWZ0ZXJDb250ZW50SW5pdCB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2lkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9sYXllclByb21pc2U6IFByb21pc2U8TGF5ZXI+O1xyXG4gICAgcHJpdmF0ZSBfc2VydmljZTogTGF5ZXJTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBfY2FudmFzOiBDYW52YXNPdmVybGF5O1xyXG4gICAgcHJpdmF0ZSBfbGFiZWxzOiBBcnJheTx7bG9jOiBJTGF0TG9uZywgdGl0bGU6IHN0cmluZ30+ID0gbmV3IEFycmF5PHtsb2M6IElMYXRMb25nLCB0aXRsZTogc3RyaW5nfT4oKTtcclxuICAgIHByaXZhdGUgX3Rvb2x0aXA6IE1hcExhYmVsO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcFN1YnNjcmlwdGlvbnM6IEFycmF5PFN1YnNjcmlwdGlvbj4gPSBuZXcgQXJyYXk8U3Vic2NyaXB0aW9uPigpO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcFZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2RlZmF1bHRPcHRpb25zOiBJTGFiZWxPcHRpb25zID0ge1xyXG4gICAgICAgIGZvbnRTaXplOiAxMSxcclxuICAgICAgICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXHJcbiAgICAgICAgc3Ryb2tlV2VpZ2h0OiAyLFxyXG4gICAgICAgIHN0cm9rZUNvbG9yOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgZm9udENvbG9yOiAnI2ZmZmZmZidcclxuICAgIH07XHJcbiAgICBwcml2YXRlIF9zdHJlYW1pbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX3BvbHlnb25zOiBBcnJheTxJUG9seWdvbk9wdGlvbnM+ID0gbmV3IEFycmF5PElQb2x5Z29uT3B0aW9ucz4oKTtcclxuICAgIHByaXZhdGUgX3BvbHlnb25zTGFzdDogQXJyYXk8SVBvbHlnb25PcHRpb25zPiA9IG5ldyBBcnJheTxJUG9seWdvbk9wdGlvbnM+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG1heGltdW0gem9vbSBhdCB3aGljaCB0aGUgcG9seWdvbiBsYWJlbHMgYXJlIHZpc2libGUuIElnbm9yZWQgaWYgU2hvd0xhYmVsIGlzIGZhbHNlLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTGFiZWxNYXhab29tOiBudW1iZXIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbWluaW11bSB6b29tIGF0IHdoaWNoIHRoZSBwb2x5Z29uIGxhYmVscyBhcmUgdmlzaWJsZS4gSWdub3JlZCBpZiBTaG93TGFiZWwgaXMgZmFsc2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBMYWJlbE1pblpvb206IG51bWJlciA9IC0xO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VwY2lmaWVzIHN0eWxlaW5nIG9wdGlvbnMgZm9yIG9uLW1hcCBwb2x5Z29uIGxhYmVscy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBMYWJlbE9wdGlvbnM6IElMYWJlbE9wdGlvbnM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgQW4gb2Zmc2V0IGFwcGxpZWQgdG8gdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBMYXllck9mZnNldDogSVBvaW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHBvbHlnb24gb3B0aW9ucyByZXByZXNlbnRpbmcgdGhlIHBvbHlnb25zIGluIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBQb2x5Z29uT3B0aW9ucygpOiBBcnJheTxJUG9seWdvbk9wdGlvbnM+IHsgcmV0dXJuIHRoaXMuX3BvbHlnb25zOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBQb2x5Z29uT3B0aW9ucyh2YWw6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmVhbWluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9seWdvbnNMYXN0LnB1c2goLi4udmFsLnNsaWNlKDApKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlnb25zLnB1c2goLi4udmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlnb25zID0gdmFsLnNsaWNlKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBzaG93IHRoZSBwb2x5Z29uIHRpdGxlcyBhcyB0aGUgbGFiZWxzIG9uIHRoZSBwb2x5Z29ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBTaG93TGFiZWxzOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgdGhlIHRpdGxlcyBvZiB0aGUgcG9seWdvc24gYXMgdGhlIHRvb2x0aXBzIG9uIHRoZSBwb2x5Z29ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBTaG93VG9vbHRpcHM6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIHRvIHRyZWF0IGNoYW5nZXMgaW4gdGhlIFBvbHlnb25PcHRpb25zIGFzIHN0cmVhbXMgb2YgbmV3IG1hcmtlcnMuIEluIHRoaXMgbW9kZSwgY2hhbmdpbmcgdGhlXHJcbiAgICAgKiBBcnJheSBzdXBwbGllZCBpbiBQb2x5Z29uT3B0aW9ucyB3aWxsIGJlIGluY3JlbWVudGFsbHkgZHJhd24gb24gdGhlIG1hcCBhcyBvcHBvc2VkIHRvIHJlcGxhY2UgdGhlIHBvbHlnb25zIG9uIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgVHJlYXROZXdQb2x5Z29uT3B0aW9uc0FzU3RyZWFtKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc3RyZWFtaW5nOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBUcmVhdE5ld1BvbHlnb25PcHRpb25zQXNTdHJlYW0odmFsOiBib29sZWFuKSB7IHRoaXMuX3N0cmVhbWluZyA9IHZhbDsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbWFya2VyIGxheWVyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgVmlzaWJsZTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgei1pbmRleCBvZiB0aGUgbGF5ZXIuIElmIG5vdCB1c2VkLCBsYXllcnMgZ2V0IHN0YWNrZWQgaW4gdGhlIG9yZGVyIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgWkluZGV4OiBudW1iZXIgPSAwO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIERlbGVnYXRlc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGEgcG9seWdvbiBpbiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgcHVibGljIFBvbHlnb25DbGljazogRXZlbnRFbWl0dGVyPElQb2x5Z29uRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gZGJsY2xpY2sgZXZlbnQgaXMgZmlyZWQgb24gYSBwb2x5Z29uIGluIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBQb2x5Z29uRGJsQ2xpY2s6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiBhIHBvbHlnb24gaW4gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIFBvbHlnb25Nb3VzZU1vdmU6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gbW91c2VvdXQgb24gYSBwb2x5Z29uIGluIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBQb2x5Z29uTW91c2VPdXQ6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gbW91c2VvdmVyIG9uIGEgcG9seWdvbiBpbiBhIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIFBvbHlnb25Nb3VzZU92ZXI6IEV2ZW50RW1pdHRlcjxJUG9seWdvbkV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlnb25FdmVudD4oKTtcclxuXHJcblxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBpZCBvZiB0aGUgbWFya2VyIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IElkKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9pZDsgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlLlxyXG4gICAgICogQHBhcmFtIF9sYXllclNlcnZpY2UgLSBDb25jcmVhdGUgaW1wbGVtZW50YXRpb24gb2YgYSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfS5cclxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIENvbmNyZWF0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHtAbGluayBNYXBTZXJ2aWNlfS5cclxuICAgICAqIEBwYXJhbSBfem9uZSAtIENvbmNyZWF0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHtAbGluayBOZ1pvbmV9IHNlcnZpY2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgX2xheWVyU2VydmljZTogTGF5ZXJTZXJ2aWNlLFxyXG4gICAgICAgIHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICAgICAgdGhpcy5faWQgPSBsYXllcklkKys7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFmdGVyIENvbXBvbmVudCBjb250ZW50IGluaXRpYWxpemF0aW9uLiBQYXJ0IG9mIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcclxuICAgICAgICBjb25zdCBsYXllck9wdGlvbnM6IElMYXllck9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGlkOiB0aGlzLl9pZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZha2VMYXllckRpcmVjdGl2ZTogYW55ID0ge1xyXG4gICAgICAgICAgICAgICAgSWQgOiB0aGlzLl9pZCxcclxuICAgICAgICAgICAgICAgIFZpc2libGU6IHRoaXMuVmlzaWJsZSxcclxuICAgICAgICAgICAgICAgIExheWVyT2Zmc2V0OiB0aGlzLkxheWVyT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgWkluZGV4OiB0aGlzLlpJbmRleFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllclNlcnZpY2UuQWRkTGF5ZXIoZmFrZUxheWVyRGlyZWN0aXZlKTtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlLkdldE5hdGl2ZUxheWVyKGZha2VMYXllckRpcmVjdGl2ZSk7XHJcblxyXG4gICAgICAgICAgICBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllclByb21pc2UsXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZUNhbnZhc092ZXJsYXkoZWwgPT4gdGhpcy5EcmF3TGFiZWxzKGVsKSlcclxuICAgICAgICAgICAgXSkudGhlbih2YWx1ZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzWzBdLlNldFZpc2libGUodGhpcy5WaXNpYmxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IHZhbHVlc1sxXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5fY2FudmFzUmVhZHkudGhlbihiID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwID0gdGhpcy5fY2FudmFzLkdldFRvb2xUaXBPdmVybGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKHRoaXMuU2hvd1Rvb2x0aXBzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuUG9seWdvbk9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuVXBkYXRlUG9seWdvbnMoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIG9uIGNvbXBvbmVudCBkZXN0cnVjdGlvbi4gRnJlZXMgdGhlIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBjb21wb25lbnQuIFBhcnQgb2YgdGhlIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX3Rvb2x0aXBTdWJzY3JpcHRpb25zLmZvckVhY2gocyA9PiBzLnVuc3Vic2NyaWJlKCkpO1xyXG4gICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4ge1xyXG4gICAgICAgICAgICBsLkRlbGV0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLl9jYW52YXMpIHsgdGhpcy5fY2FudmFzLkRlbGV0ZSgpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFjdHMgdG8gY2hhbmdlcyBpbiBkYXRhLWJvdW5kIHByb3BlcnRpZXMgb2YgdGhlIGNvbXBvbmVudCBhbmQgYWN0dWF0ZXMgcHJvcGVydHkgY2hhbmdlcyBpbiB0aGUgdW5kZXJsaW5nIGxheWVyIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIC0gY29sbGVjdGlvbiBvZiBjaGFuZ2VzLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlnb25MYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xyXG4gICAgICAgIGlmIChjaGFuZ2VzWydQb2x5Z29uT3B0aW9ucyddKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5VcGRhdGVQb2x5Z29ucygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ1Zpc2libGUnXSAmJiAhY2hhbmdlc1snVmlzaWJsZSddLmZpcnN0Q2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4gbC5TZXRWaXNpYmxlKHRoaXMuVmlzaWJsZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKGNoYW5nZXNbJ1pJbmRleCddICYmICFjaGFuZ2VzWydaSW5kZXgnXS5maXJzdENoYW5nZSkgfHxcclxuICAgICAgICAgICAgKGNoYW5nZXNbJ0xheWVyT2Zmc2V0J10gJiYgIWNoYW5nZXNbJ0xheWVyT2Zmc2V0J10uZmlyc3RDaGFuZ2UpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgY2hhbmdlIFpJbmRleCBvciBMYXllck9mZnNldCBhZnRlciB0aGUgbGF5ZXIgaGFzIGJlZW4gY3JlYXRlZC4nKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoY2hhbmdlc1snU2hvd0xhYmVscyddICYmICFjaGFuZ2VzWydTaG93TGFiZWxzJ10uZmlyc3RDaGFuZ2UpIHx8XHJcbiAgICAgICAgICAgIChjaGFuZ2VzWydMYWJlbE1pblpvb20nXSAmJiAhY2hhbmdlc1snTGFiZWxNaW5ab29tJ10uZmlyc3RDaGFuZ2UpIHx8XHJcbiAgICAgICAgICAgIChjaGFuZ2VzWydMYWJlbE1heFpvb20nXSAmJiAhY2hhbmdlc1snTGFiZWxNYXhab29tJ10uZmlyc3RDaGFuZ2UpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYW52YXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5SZWRyYXcodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXNbJ1Nob3dUb29sdGlwcyddICYmIHRoaXMuX3Rvb2x0aXApIHtcclxuICAgICAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKGNoYW5nZXNbJ1Nob3dUb29sdGlwcyddLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgTWFya2VyIElkLlxyXG4gICAgICogQHJldHVybnMgLSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hcmtlciBpZC5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7IHJldHVybiAnTWFwUG9seWdvbkxheWVyLScgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdmFyaW91cyBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHAgLSB0aGUgcG9seWdvbiBmb3Igd2hpY2ggdG8gYWRkIHRoZSBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgQWRkRXZlbnRMaXN0ZW5lcnMocDogUG9seWdvbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdjbGljaycsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Qb2x5Z29uQ2xpY2suZW1pdCh7UG9seWdvbjogcCwgQ2xpY2s6IGV2fSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnZGJsY2xpY2snLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuUG9seWdvbkRibENsaWNrLmVtaXQoe1BvbHlnb246IHAsIENsaWNrOiBldn0pIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlbW92ZScsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Qb2x5Z29uTW91c2VNb3ZlLmVtaXQoe1BvbHlnb246IHAsIENsaWNrOiBldn0pIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlb3V0JywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlBvbHlnb25Nb3VzZU91dC5lbWl0KHtQb2x5Z29uOiBwLCBDbGljazogZXZ9KSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW92ZXInLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuUG9seWdvbk1vdXNlT3Zlci5lbWl0KHtQb2x5Z29uOiBwLCBDbGljazogZXZ9KSB9XHJcbiAgICAgICAgXTtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChvYmopID0+IHAuQWRkTGlzdGVuZXIob2JqLm5hbWUsIG9iai5oYW5kbGVyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgcG9seWdvbiBsYWJlbHMuIENhbGxlZCBieSB0aGUgQ2FudmFzIG92ZXJsYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVsIC0gVGhlIGNhbnZhcyBvbiB3aGljaCB0byBkcmF3IHRoZSBsYWJlbHMuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgRHJhd0xhYmVscyhlbDogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5TaG93TGFiZWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuR2V0Wm9vbSgpLnRoZW4oeiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5MYWJlbE1pblpvb20gPD0geiAmJiB0aGlzLkxhYmVsTWF4Wm9vbSA+PSB6KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBlbC5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuX2xhYmVscy5tYXAoeCA9PiB4LnRpdGxlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkxvY2F0aW9uc1RvUG9pbnRzKHRoaXMuX2xhYmVscy5tYXAoeCA9PiB4LmxvYykpLnRoZW4obG9jcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpemU6IElTaXplID0gdGhpcy5fbWFwU2VydmljZS5NYXBTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbG9jcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZHJhdyB0aGUgcG9pbnQgaWYgaXQgaXMgbm90IGluIHZpZXcuIFRoaXMgZ3JlYXRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZSB3aGVuIHpvb21lZCBpbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NzW2ldLnggPj0gMCAmJiBsb2NzW2ldLnkgPj0gMCAmJiBsb2NzW2ldLnggPD0gc2l6ZS53aWR0aCAmJiBsb2NzW2ldLnkgPD0gc2l6ZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkRyYXdUZXh0KGN0eCwgbG9jc1tpXSwgbGFiZWxzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgbGFiZWwgdGV4dCBhdCB0aGUgYXBwcm9wcmlhdGUgcGxhY2Ugb24gdGhlIGNhbnZhcy5cclxuICAgICAqIEBwYXJhbSBjdHggLSBDYW52YXMgZHJhd2luZyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGxvYyAtIFBpeGVsIGxvY2F0aW9uIG9uIHRoZSBjYW52YXMgd2hlcmUgdG8gY2VudGVyIHRoZSB0ZXh0LlxyXG4gICAgICogQHBhcmFtIHRleHQgLSBUZXh0IHRvIGRyYXcuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgRHJhd1RleHQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGxvYzogSVBvaW50LCB0ZXh0OiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgbG86IElMYWJlbE9wdGlvbnMgPSB0aGlzLkxhYmVsT3B0aW9ucztcclxuICAgICAgICBpZiAobG8gPT0gbnVsbCAmJiB0aGlzLl90b29sdGlwKSB7IGxvID0gdGhpcy5fdG9vbHRpcC5EZWZhdWx0TGFiZWxTdHlsZTsgfVxyXG4gICAgICAgIGlmIChsbyA9PSBudWxsKSB7IGxvID0gdGhpcy5fZGVmYXVsdE9wdGlvbnM7IH1cclxuXHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbG8uc3Ryb2tlQ29sb3I7XHJcbiAgICAgICAgY3R4LmZvbnQgPSBgJHtsby5mb250U2l6ZX1weCAke2xvLmZvbnRGYW1pbHl9YDtcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgY29uc3Qgc3Ryb2tlV2VpZ2h0OiBudW1iZXIgPSBsby5zdHJva2VXZWlnaHQ7XHJcbiAgICAgICAgaWYgKHRleHQgJiYgc3Ryb2tlV2VpZ2h0ICYmIHN0cm9rZVdlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2VXZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlVGV4dCh0ZXh0LCBsb2MueCwgbG9jLnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbG8uZm9udENvbG9yO1xyXG4gICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LCBsb2MueCwgbG9jLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFuYWdlcyB0aGUgdG9vbHRpcCBhbmQgdGhlIGF0dGFjaG1lbnQgb2YgdGhlIGFzc29jaWF0ZWQgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzaG93IC0gVHJ1ZSB0byBlbmFibGUgdGhlIHRvb2x0aXAsIGZhbHNlIHRvIGRpc2FibGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWdvbkxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgTWFuYWdlVG9vbHRpcChzaG93OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHNob3cgJiYgdGhpcy5fY2FudmFzKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZCB0b29sdGlwIHN1YnNjcmlwdGlvbnNcclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwU3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuUG9seWdvbk1vdXNlTW92ZS5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2M6IElMYXRMb25nID0gdGhpcy5fY2FudmFzLkdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGUuQ2xpY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdwb3NpdGlvbicsIGxvYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLlBvbHlnb25Nb3VzZU92ZXIuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuUG9seWdvbi5UaXRsZSAmJiBlLlBvbHlnb24uVGl0bGUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYzogSUxhdExvbmcgPSB0aGlzLl9jYW52YXMuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZS5DbGljayk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ3RleHQnLCBlLlBvbHlnb24uVGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdwb3NpdGlvbicsIGxvYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90b29sdGlwVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBTdWJzY3JpcHRpb25zLnB1c2godGhpcy5Qb2x5Z29uTW91c2VPdXQuYXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0b29sdGlwIHN1YnNjcmlwdGlvbnNcclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFN1YnNjcmlwdGlvbnMuZm9yRWFjaChzID0+IHMudW5zdWJzY3JpYmUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBTdWJzY3JpcHRpb25zLnNwbGljZSgwKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgb3IgdXBkYXRlcyB0aGUgcG9seWdvbnMgYmFzZWQgb24gdGhlIHBvbHlnb24gb3B0aW9ucy4gVGhpcyB3aWxsIHBsYWNlIHRoZSBwb2x5Z29ucyBvbiB0aGUgbWFwXHJcbiAgICAgKiBhbmQgcmVnaXN0ZXIgdGhlIGFzc29jaWF0ZWQgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBVcGRhdGVQb2x5Z29ucygpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fbGF5ZXJQcm9taXNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sYXllclByb21pc2UudGhlbihsID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9seWdvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4gPSB0aGlzLl9zdHJlYW1pbmcgPyB0aGlzLl9wb2x5Z29uc0xhc3Quc3BsaWNlKDApIDogdGhpcy5fcG9seWdvbnM7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RyZWFtaW5nKSB7IHRoaXMuX2xhYmVscy5zcGxpY2UoMCk7IH1cclxuXHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSBwcm9taXNlIGZvciB0aGUgbWFya2Vyc1xyXG4gICAgICAgICAgICBjb25zdCBscDogUHJvbWlzZTxBcnJheTxQb2x5Z29uPj4gPSB0aGlzLl9zZXJ2aWNlLkNyZWF0ZVBvbHlnb25zKGwuR2V0T3B0aW9ucygpLmlkLCBwb2x5Z29ucyk7XHJcblxyXG4gICAgICAgICAgICAvLyBzZXQgbWFya2VycyBvbmNlIHByb21pc2VzIGFyZSBmdWxsZmlsbGVkLlxyXG4gICAgICAgICAgICBscC50aGVuKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgcC5mb3JFYWNoKHBvbHkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2x5LlRpdGxlICE9IG51bGwgJiYgcG9seS5UaXRsZS5sZW5ndGggPiAwKSB7IHRoaXMuX2xhYmVscy5wdXNoKHtsb2M6IHBvbHkuQ2VudHJvaWQsIHRpdGxlOiBwb2x5LlRpdGxlfSk7IH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZEV2ZW50TGlzdGVuZXJzKHBvbHkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJlYW1pbmcgPyBsLkFkZEVudGl0aWVzKHApIDogbC5TZXRFbnRpdGllcyhwKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYW52YXMpIHsgdGhpcy5fY2FudmFzLlJlZHJhdyghdGhpcy5fc3RyZWFtaW5nKTsgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICAgIERpcmVjdGl2ZSwgU2ltcGxlQ2hhbmdlLCBJbnB1dCwgT3V0cHV0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyxcclxuICAgIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBBZnRlckNvbnRlbnRJbml0LCBWaWV3Q29udGFpbmVyUmVmLCBOZ1pvbmUsXHJcbiAgICBTaW1wbGVDaGFuZ2VzXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElTaXplIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pc2l6ZSc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElQb2x5bGluZUV2ZW50IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtZXZlbnQnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElMYXllck9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2lsYXllci1vcHRpb25zJztcclxuaW1wb3J0IHsgSUxhYmVsT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaWxhYmVsLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9tb2RlbHMvbGF5ZXInO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uL21vZGVscy9wb2x5bGluZSc7XHJcbmltcG9ydCB7IE1hcExhYmVsIH0gZnJvbSAnLi4vbW9kZWxzL21hcC1sYWJlbCc7XHJcbmltcG9ydCB7IENhbnZhc092ZXJsYXkgfSBmcm9tICcuLi9tb2RlbHMvY2FudmFzLW92ZXJsYXknO1xyXG5cclxuLyoqXHJcbiAqIGludGVybmFsIGNvdW50ZXIgdG8gdXNlIGFzIGlkcyBmb3IgcG9seWxpbmVzLlxyXG4gKi9cclxubGV0IGxheWVySWQgPSAxMDAwMDAwO1xyXG5cclxuLyoqXHJcbiAqIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmUgcGVyZm9ybWFudGx5IHJlbmRlcnMgYSBsYXJnZSBzZXQgb2YgcG9seWxpbmUgb24gYSB7QGxpbmsgTWFwQ29tcG9uZW50fS5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbiAqIGltcG9ydCB7TWFwQ29tcG9uZW50fSBmcm9tICcuLi4nO1xyXG4gKlxyXG4gKiBAQ29tcG9uZW50KHtcclxuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXHJcbiAqICBzdHlsZXM6IFtgXHJcbiAqICAgLm1hcC1jb250YWluZXIge1xyXG4gKiAgICAgaGVpZ2h0OiAzMDBweDtcclxuICogICB9XHJcbiAqIGBdLFxyXG4gKiB0ZW1wbGF0ZTogYFxyXG4gKiAgIDx4LW1hcCBbTGF0aXR1ZGVdPVwibGF0XCIgW0xvbmdpdHVkZV09XCJsbmdcIiBbWm9vbV09XCJ6b29tXCI+XHJcbiAqICAgICAgPHgtbWFwLXBvbHlsaW5lLWxheWVyIFtQb2x5Z29uT3B0aW9uc109XCJfcG9seWxpbmVcIj48L3gtbWFwLXBvbHlsaW5lLWxheWVyPlxyXG4gKiAgIDwveC1tYXA+XHJcbiAqIGBcclxuICogfSlcclxuICogYGBgXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICd4LW1hcC1wb2x5bGluZS1sYXllcidcclxufSlcclxuZXhwb3J0IGNsYXNzIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgQWZ0ZXJDb250ZW50SW5pdCB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2lkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIF9sYXllclByb21pc2U6IFByb21pc2U8TGF5ZXI+O1xyXG4gICAgcHJpdmF0ZSBfc2VydmljZTogTGF5ZXJTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBfY2FudmFzOiBDYW52YXNPdmVybGF5O1xyXG4gICAgcHJpdmF0ZSBfbGFiZWxzOiBBcnJheTx7bG9jOiBJTGF0TG9uZywgdGl0bGU6IHN0cmluZ30+ID0gbmV3IEFycmF5PHtsb2M6IElMYXRMb25nLCB0aXRsZTogc3RyaW5nfT4oKTtcclxuICAgIHByaXZhdGUgX3Rvb2x0aXA6IE1hcExhYmVsO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcFN1YnNjcmlwdGlvbnM6IEFycmF5PFN1YnNjcmlwdGlvbj4gPSBuZXcgQXJyYXk8U3Vic2NyaXB0aW9uPigpO1xyXG4gICAgcHJpdmF0ZSBfdG9vbHRpcFZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2RlZmF1bHRPcHRpb25zOiBJTGFiZWxPcHRpb25zID0ge1xyXG4gICAgICAgIGZvbnRTaXplOiAxMSxcclxuICAgICAgICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXHJcbiAgICAgICAgc3Ryb2tlV2VpZ2h0OiAyLFxyXG4gICAgICAgIHN0cm9rZUNvbG9yOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgZm9udENvbG9yOiAnI2ZmZmZmZidcclxuICAgIH07XHJcbiAgICBwcml2YXRlIF9zdHJlYW1pbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX3BvbHlsaW5lczogQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4gPSBuZXcgQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4oKTtcclxuICAgIHByaXZhdGUgX3BvbHlsaW5lc0xhc3Q6IEFycmF5PElQb2x5bGluZU9wdGlvbnM+ID0gbmV3IEFycmF5PElQb2x5bGluZU9wdGlvbnM+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG1heGltdW0gem9vbSBhdCB3aGljaCB0aGUgcG9seWxpbmUgbGFiZWxzIGFyZSB2aXNpYmxlLiBJZ25vcmVkIGlmIFNob3dMYWJlbCBpcyBmYWxzZS5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBMYWJlbE1heFpvb206IG51bWJlciA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtaW5pbXVtIHpvb20gYXQgd2hpY2ggdGhlIHBvbHlsaW5lIGxhYmVscyBhcmUgdmlzaWJsZS4gSWdub3JlZCBpZiBTaG93TGFiZWwgaXMgZmFsc2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTGFiZWxNaW5ab29tOiBudW1iZXIgPSAtMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlcGNpZmllcyBzdHlsZWluZyBvcHRpb25zIGZvciBvbi1tYXAgcG9seWxpbmUgbGFiZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBMYWJlbE9wdGlvbnM6IElMYWJlbE9wdGlvbnM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgQW4gb2Zmc2V0IGFwcGxpZWQgdG8gdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgTGF5ZXJPZmZzZXQ6IElQb2ludCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBwb2x5bGluZSBvcHRpb25zIHJlcHJlc2VudGluZyB0aGUgcG9seWxpbmVzIGluIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgICAgIHB1YmxpYyBnZXQgUG9seWxpbmVPcHRpb25zKCk6IEFycmF5PElQb2x5bGluZU9wdGlvbnM+IHsgcmV0dXJuIHRoaXMuX3BvbHlsaW5lczsgfVxyXG4gICAgICAgIHB1YmxpYyBzZXQgUG9seWxpbmVPcHRpb25zKHZhbDogQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0cmVhbWluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9seWxpbmVzTGFzdC5wdXNoKC4uLnZhbC5zbGljZSgwKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2x5bGluZXMucHVzaCguLi52YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9seWxpbmVzID0gdmFsLnNsaWNlKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBzaG93IHRoZSBwb2x5bGluZXMgdGl0bGVzIGFzIHRoZSBsYWJlbHMgb24gdGhlIHBvbHlsaW5lcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU2hvd0xhYmVsczogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBzaG93IHRoZSB0aXRsZXMgb2YgdGhlIHBvbHlsaW5lcyBhcyB0aGUgdG9vbHRpcHMgb24gdGhlIHBvbHlsaW5lcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgU2hvd1Rvb2x0aXBzOiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciB0byB0cmVhdCBjaGFuZ2VzIGluIHRoZSBQb2x5bGluZU9wdGlvbnMgYXMgc3RyZWFtcyBvZiBuZXcgbWFya2Vycy4gSW4gdGhpcyBtb2RlLCBjaGFuZ2luZyB0aGVcclxuICAgICAqIEFycmF5IHN1cHBsaWVkIGluIFBvbHlsaW5lT3B0aW9ucyB3aWxsIGJlIGluY3JlbWVudGFsbHkgZHJhd24gb24gdGhlIG1hcCBhcyBvcHBvc2VkIHRvIHJlcGxhY2UgdGhlIHBvbHlsaW5lcyBvbiB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICAgICAgcHVibGljIGdldCBUcmVhdE5ld1BvbHlsaW5lT3B0aW9uc0FzU3RyZWFtKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fc3RyZWFtaW5nOyB9XHJcbiAgICAgICAgcHVibGljIHNldCBUcmVhdE5ld1BvbHlsaW5lT3B0aW9uc0FzU3RyZWFtKHZhbDogYm9vbGVhbikgeyB0aGlzLl9zdHJlYW1pbmcgPSB2YWw7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIG1hcmtlciBsYXllclxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHB1YmxpYyBWaXNpYmxlOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB6LWluZGV4IG9mIHRoZSBsYXllci4gSWYgbm90IHVzZWQsIGxheWVycyBnZXQgc3RhY2tlZCBpbiB0aGUgb3JkZXIgY3JlYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKSBwdWJsaWMgWkluZGV4OiBudW1iZXIgPSAwO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIERlbGVnYXRlc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGEgcG9seWxpbmUgaW4gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBwdWJsaWMgUG9seWxpbmVDbGljazogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBkYmxjbGljayBldmVudCBpcyBmaXJlZCBvbiBhIHBvbHlsaW5lIGluIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBAT3V0cHV0KCkgUG9seWxpbmVEYmxDbGljazogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZW1vdmUgZXZlbnQgaXMgZmlyZWQgb24gYSBwb2x5bGluZSBpbiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIFBvbHlsaW5lTW91c2VNb3ZlOiBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4oKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gbW91c2VvdXQgb24gYSBwb2x5bGluZSBpbiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgQE91dHB1dCgpIFBvbHlsaW5lTW91c2VPdXQ6IEV2ZW50RW1pdHRlcjxJUG9seWxpbmVFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCBvbiBtb3VzZW92ZXIgb24gYSBwb2x5bGluZSBpbiBhIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIEBPdXRwdXQoKSBQb2x5bGluZU1vdXNlT3ZlcjogRXZlbnRFbWl0dGVyPElQb2x5bGluZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8SVBvbHlsaW5lRXZlbnQ+KCk7XHJcblxyXG5cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaWQgb2YgdGhlIHBvbHlsaW5lIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBJZCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5faWQ7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmUuXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyU2VydmljZSAtIENvbmNyZWF0ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHtAbGluayBMYXllclNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE1hcFNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gQ29uY3JlYXRlIGltcGxlbWVudGF0aW9uIG9mIGEge0BsaW5rIE5nWm9uZX0gc2VydmljZS5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgX2xheWVyU2VydmljZTogTGF5ZXJTZXJ2aWNlLFxyXG4gICAgICAgIHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICAgICAgdGhpcy5faWQgPSBsYXllcklkKys7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFmdGVyIENvbXBvbmVudCBjb250ZW50IGluaXRpYWxpemF0aW9uLiBQYXJ0IG9mIG5nIENvbXBvbmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXJPcHRpb25zOiBJTGF5ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogdGhpcy5faWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmYWtlTGF5ZXJEaXJlY3RpdmU6IGFueSA9IHtcclxuICAgICAgICAgICAgICAgIElkIDogdGhpcy5faWQsXHJcbiAgICAgICAgICAgICAgICBWaXNpYmxlOiB0aGlzLlZpc2libGUsXHJcbiAgICAgICAgICAgICAgICBMYXllck9mZnNldDogdGhpcy5MYXllck9mZnNldCxcclxuICAgICAgICAgICAgICAgIFpJbmRleDogdGhpcy5aSW5kZXhcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJTZXJ2aWNlLkFkZExheWVyKGZha2VMYXllckRpcmVjdGl2ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZSA9IHRoaXMuX2xheWVyU2VydmljZS5HZXROYXRpdmVMYXllcihmYWtlTGF5ZXJEaXJlY3RpdmUpO1xyXG5cclxuICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZUNhbnZhc092ZXJsYXkoZWwgPT4gdGhpcy5EcmF3TGFiZWxzKGVsKSlcclxuICAgICAgICAgICAgICAgIF0pLnRoZW4odmFsdWVzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbMF0uU2V0VmlzaWJsZSh0aGlzLlZpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IHZhbHVlc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuX2NhbnZhc1JlYWR5LnRoZW4oYiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAgPSB0aGlzLl9jYW52YXMuR2V0VG9vbFRpcE92ZXJsYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NYW5hZ2VUb29sdGlwKHRoaXMuU2hvd1Rvb2x0aXBzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5Qb2x5bGluZU9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLlVwZGF0ZVBvbHlsaW5lcygpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fc2VydmljZSA9IHRoaXMuX2xheWVyU2VydmljZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBvbiBjb21wb25lbnQgZGVzdHJ1Y3Rpb24uIEZyZWVzIHRoZSByZXNvdXJjZXMgdXNlZCBieSB0aGUgY29tcG9uZW50LiBQYXJ0IG9mIHRoZSBuZyBDb21wb25lbnQgbGlmZSBjeWNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fdG9vbHRpcFN1YnNjcmlwdGlvbnMuZm9yRWFjaChzID0+IHMudW5zdWJzY3JpYmUoKSk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlLnRoZW4obCA9PiB7XHJcbiAgICAgICAgICAgIGwuRGVsZXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhcykgeyB0aGlzLl9jYW52YXMuRGVsZXRlKCk7IH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWN0cyB0byBjaGFuZ2VzIGluIGRhdGEtYm91bmQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50IGFuZCBhY3R1YXRlcyBwcm9wZXJ0eSBjaGFuZ2VzIGluIHRoZSB1bmRlcmxpbmcgbGF5ZXIgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNoYW5nZXMgLSBjb2xsZWN0aW9uIG9mIGNoYW5nZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xyXG4gICAgICAgIGlmIChjaGFuZ2VzWydQb2x5bGluZU9wdGlvbnMnXSkge1xyXG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuVXBkYXRlUG9seWxpbmVzKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snVmlzaWJsZSddICYmICFjaGFuZ2VzWydWaXNpYmxlJ10uZmlyc3RDaGFuZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXJQcm9taXNlLnRoZW4obCA9PiBsLlNldFZpc2libGUodGhpcy5WaXNpYmxlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoY2hhbmdlc1snWkluZGV4J10gJiYgIWNoYW5nZXNbJ1pJbmRleCddLmZpcnN0Q2hhbmdlKSB8fFxyXG4gICAgICAgICAgICAoY2hhbmdlc1snTGF5ZXJPZmZzZXQnXSAmJiAhY2hhbmdlc1snTGF5ZXJPZmZzZXQnXS5maXJzdENoYW5nZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignWW91IGNhbm5vdCBjaGFuZ2UgWkluZGV4IG9yIExheWVyT2Zmc2V0IGFmdGVyIHRoZSBsYXllciBoYXMgYmVlbiBjcmVhdGVkLicpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChjaGFuZ2VzWydTaG93TGFiZWxzJ10gJiYgIWNoYW5nZXNbJ1Nob3dMYWJlbHMnXS5maXJzdENoYW5nZSkgfHxcclxuICAgICAgICAgICAgKGNoYW5nZXNbJ0xhYmVsTWluWm9vbSddICYmICFjaGFuZ2VzWydMYWJlbE1pblpvb20nXS5maXJzdENoYW5nZSkgfHxcclxuICAgICAgICAgICAgKGNoYW5nZXNbJ0xhYmVsTWF4Wm9vbSddICYmICFjaGFuZ2VzWydMYWJlbE1heFpvb20nXS5maXJzdENoYW5nZSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NhbnZhcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLlJlZHJhdyh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlc1snU2hvd1Rvb2x0aXBzJ10gJiYgdGhpcy5fdG9vbHRpcCkge1xyXG4gICAgICAgICAgICB0aGlzLk1hbmFnZVRvb2x0aXAoY2hhbmdlc1snU2hvd1Rvb2x0aXBzJ10uY3VycmVudFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMYXllciBJZC5cclxuICAgICAqIEByZXR1cm5zIC0gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsYXllciBpZC5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcgeyByZXR1cm4gJ01hcFBvbHlsaW5lTGF5ZXItJyArIHRoaXMuX2lkLnRvU3RyaW5nKCk7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcml2YXRlIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB2YXJpb3VzIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIHBvbHlsaW5lcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcCAtIHRoZSBwb2x5bGluZSBmb3Igd2hpY2ggdG8gYWRkIHRoZSBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIEFkZEV2ZW50TGlzdGVuZXJzKHA6IFBvbHlsaW5lKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBbXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2NsaWNrJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlBvbHlsaW5lQ2xpY2suZW1pdCh7UG9seWxpbmU6IHAsIENsaWNrOiBldn0pIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2RibGNsaWNrJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlBvbHlsaW5lRGJsQ2xpY2suZW1pdCh7UG9seWxpbmU6IHAsIENsaWNrOiBldn0pIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlbW92ZScsIGhhbmRsZXI6IChldjogTW91c2VFdmVudCkgPT4gdGhpcy5Qb2x5bGluZU1vdXNlTW92ZS5lbWl0KHtQb2x5bGluZTogcCwgQ2xpY2s6IGV2fSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdXQnLCBoYW5kbGVyOiAoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMuUG9seWxpbmVNb3VzZU91dC5lbWl0KHtQb2x5bGluZTogcCwgQ2xpY2s6IGV2fSkgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdmVyJywgaGFuZGxlcjogKGV2OiBNb3VzZUV2ZW50KSA9PiB0aGlzLlBvbHlsaW5lTW91c2VPdmVyLmVtaXQoe1BvbHlsaW5lOiBwLCBDbGljazogZXZ9KSB9XHJcbiAgICAgICAgXTtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChvYmopID0+IHAuQWRkTGlzdGVuZXIob2JqLm5hbWUsIG9iai5oYW5kbGVyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgcG9seWxpbmUgbGFiZWxzLiBDYWxsZWQgYnkgdGhlIENhbnZhcyBvdmVybGF5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbCAtIFRoZSBjYW52YXMgb24gd2hpY2ggdG8gZHJhdyB0aGUgbGFiZWxzLlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFBvbHlsaW5lTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBEcmF3TGFiZWxzKGVsOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLlNob3dMYWJlbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZS5HZXRab29tKCkudGhlbih6ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLkxhYmVsTWluWm9vbSA8PSB6ICYmIHRoaXMuTGFiZWxNYXhab29tID49IHopIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGVsLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5fbGFiZWxzLm1hcCh4ID0+IHgudGl0bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuTG9jYXRpb25zVG9Qb2ludHModGhpcy5fbGFiZWxzLm1hcCh4ID0+IHgubG9jKSkudGhlbihsb2NzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZTogSVNpemUgPSB0aGlzLl9tYXBTZXJ2aWNlLk1hcFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsb2NzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkcmF3IHRoZSBwb2ludCBpZiBpdCBpcyBub3QgaW4gdmlldy4gVGhpcyBncmVhdGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlIHdoZW4gem9vbWVkIGluLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY3NbaV0ueCA+PSAwICYmIGxvY3NbaV0ueSA+PSAwICYmIGxvY3NbaV0ueCA8PSBzaXplLndpZHRoICYmIGxvY3NbaV0ueSA8PSBzaXplLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRHJhd1RleHQoY3R4LCBsb2NzW2ldLCBsYWJlbHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBsYWJlbCB0ZXh0IGF0IHRoZSBhcHByb3ByaWF0ZSBwbGFjZSBvbiB0aGUgY2FudmFzLlxyXG4gICAgICogQHBhcmFtIGN0eCAtIENhbnZhcyBkcmF3aW5nIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gbG9jIC0gUGl4ZWwgbG9jYXRpb24gb24gdGhlIGNhbnZhcyB3aGVyZSB0byBjZW50ZXIgdGhlIHRleHQuXHJcbiAgICAgKiBAcGFyYW0gdGV4dCAtIFRleHQgdG8gZHJhdy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBEcmF3VGV4dChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgbG9jOiBJUG9pbnQsIHRleHQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBsbzogSUxhYmVsT3B0aW9ucyA9IHRoaXMuTGFiZWxPcHRpb25zO1xyXG4gICAgICAgIGlmIChsbyA9PSBudWxsICYmIHRoaXMuX3Rvb2x0aXApIHsgbG8gPSB0aGlzLl90b29sdGlwLkRlZmF1bHRMYWJlbFN0eWxlOyB9XHJcbiAgICAgICAgaWYgKGxvID09IG51bGwpIHsgbG8gPSB0aGlzLl9kZWZhdWx0T3B0aW9uczsgfVxyXG5cclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsby5zdHJva2VDb2xvcjtcclxuICAgICAgICBjdHguZm9udCA9IGAke2xvLmZvbnRTaXplfXB4ICR7bG8uZm9udEZhbWlseX1gO1xyXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICBjb25zdCBzdHJva2VXZWlnaHQ6IG51bWJlciA9IGxvLnN0cm9rZVdlaWdodDtcclxuICAgICAgICBpZiAodGV4dCAmJiBzdHJva2VXZWlnaHQgJiYgc3Ryb2tlV2VpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdlaWdodDtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHRleHQsIGxvYy54LCBsb2MueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsby5mb250Q29sb3I7XHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIGxvYy54LCBsb2MueSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYW5hZ2VzIHRoZSB0b29sdGlwIGFuZCB0aGUgYXR0YWNobWVudCBvZiB0aGUgYXNzb2NpYXRlZCBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNob3cgLSBUcnVlIHRvIGVuYWJsZSB0aGUgdG9vbHRpcCwgZmFsc2UgdG8gZGlzYWJsZS5cclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmVcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBNYW5hZ2VUb29sdGlwKHNob3c6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICBpZiAoc2hvdyAmJiB0aGlzLl9jYW52YXMpIHtcclxuICAgICAgICAgICAgLy8gYWRkIHRvb2x0aXAgc3Vic2NyaXB0aW9uc1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBTdWJzY3JpcHRpb25zLnB1c2godGhpcy5Qb2x5bGluZU1vdXNlTW92ZS5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2M6IElMYXRMb25nID0gdGhpcy5fY2FudmFzLkdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGUuQ2xpY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXAuU2V0KCdwb3NpdGlvbicsIGxvYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLlBvbHlsaW5lTW91c2VPdmVyLmFzT2JzZXJ2YWJsZSgpLnN1YnNjcmliZShlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlLlBvbHlsaW5lLlRpdGxlICYmIGUuUG9seWxpbmUuVGl0bGUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYzogSUxhdExvbmcgPSB0aGlzLl9jYW52YXMuR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZS5DbGljayk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ3RleHQnLCBlLlBvbHlsaW5lLlRpdGxlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgncG9zaXRpb24nLCBsb2MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcC5TZXQoJ2hpZGRlbicsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwU3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuUG9seWxpbmVNb3VzZU91dC5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcFZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRvb2x0aXAgc3Vic2NyaXB0aW9uc1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwU3Vic2NyaXB0aW9ucy5mb3JFYWNoKHMgPT4gcy51bnN1YnNjcmliZSgpKTtcclxuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcFN1YnNjcmlwdGlvbnMuc3BsaWNlKDApO1xyXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwLlNldCgnaGlkZGVuJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBvciB1cGRhdGVzIHRoZSBwb2x5bGluZXNzIGJhc2VkIG9uIHRoZSBwb2x5bGluZSBvcHRpb25zLiBUaGlzIHdpbGwgcGxhY2UgdGhlIHBvbHlsaW5lcyBvbiB0aGUgbWFwXHJcbiAgICAgKiBhbmQgcmVnaXN0ZXIgdGhlIGFzc29jaWF0ZWQgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgVXBkYXRlUG9seWxpbmVzKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXllclByb21pc2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xheWVyUHJvbWlzZS50aGVuKGwgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5bGluZXM6IEFycmF5PElQb2x5bGluZU9wdGlvbnM+ID0gdGhpcy5fc3RyZWFtaW5nID8gdGhpcy5fcG9seWxpbmVzTGFzdC5zcGxpY2UoMCkgOiB0aGlzLl9wb2x5bGluZXM7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3RyZWFtaW5nKSB7IHRoaXMuX2xhYmVscy5zcGxpY2UoMCk7IH1cclxuXHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSBwcm9taXNlIGZvciB0aGUgcG9seWxpbmVzXHJcbiAgICAgICAgICAgIGNvbnN0IGxwOiBQcm9taXNlPEFycmF5PFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+ID0gdGhpcy5fc2VydmljZS5DcmVhdGVQb2x5bGluZXMobC5HZXRPcHRpb25zKCkuaWQsIHBvbHlsaW5lcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBzZXQgcG9seWxpbmVzIG9uY2UgcHJvbWlzZXMgYXJlIGZ1bGxmaWxsZWQuXHJcbiAgICAgICAgICAgIGxwLnRoZW4ocCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5OiBBcnJheTxQb2x5bGluZT4gPSBuZXcgQXJyYXk8UG9seWxpbmU+KCk7XHJcbiAgICAgICAgICAgICAgICBwLmZvckVhY2gocG9seSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9seSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpdGxlOiBzdHJpbmcgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudHJvaWRzOiBBcnJheTxJTGF0TG9uZz4gPSBuZXcgQXJyYXk8SUxhdExvbmc+KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHkuZm9yRWFjaCh4ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkucHVzaCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkRXZlbnRMaXN0ZW5lcnMoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50cm9pZHMucHVzaCh4LkNlbnRyb2lkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4LlRpdGxlICE9IG51bGwgJiYgeC5UaXRsZS5sZW5ndGggPiAwICYmIHRpdGxlLmxlbmd0aCA9PT0gMCkgeyB0aXRsZSA9IHguVGl0bGU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVscy5wdXNoKHtsb2M6IFBvbHlsaW5lLkdldFBvbHlsaW5lQ2VudHJvaWQoY2VudHJvaWRzKSwgdGl0bGU6IHRpdGxlfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5LnB1c2gocG9seSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2x5LlRpdGxlICE9IG51bGwgJiYgcG9seS5UaXRsZS5sZW5ndGggPiAwKSB7IHRoaXMuX2xhYmVscy5wdXNoKHtsb2M6IHBvbHkuQ2VudHJvaWQsIHRpdGxlOiBwb2x5LlRpdGxlfSk7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRFdmVudExpc3RlbmVycyhwb2x5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0cmVhbWluZyA/IGwuQWRkRW50aXRpZXMoeSkgOiBsLlNldEVudGl0aWVzKHkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhbnZhcykgeyB0aGlzLl9jYW52YXMuUmVkcmF3KCF0aGlzLl9zdHJlYW1pbmcpOyB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgaW1wbGVtZW50YXRpb24uIFVTZWQgZm9yIGRlZmludGlvbiBvbmx5IGFuZCBhcyBhIGJhc2UgdG8gaW1wbGVtZW50IHlvdXJcclxuICogb3duIHByb3ZpZGVyLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTWFwQVBJTG9hZGVyIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIHRoZSBuZWNlc3NhcnkgcmVzb3VyY2VzIGZvciBhIGdpdmVuIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgZnVsbGZpbGxlZCB3aGVuIHRoZSByZXNvdXJjZXMgaGF2ZSBiZWVuIGxvYWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwQVBJTG9hZGVyXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IExvYWQoKTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEb2N1bWVudCBSZWZlcmVuY2Ugc2VydmljZSB0byBhc3Npc3Qgd2l0aCBhYnN0cmFjdGluZyB0aGUgYXZhaWxhYmlsaXR5IG9mIGRvY3VtZW50LiBOZWVkZWQgZm9yIEFPVCBhbmRcclxuICogU2VydmVyIFNpZGUgcmVuZGVyaW5nXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIERvY3VtZW50UmVmIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciBhIGRvY3VtZW50IGltcGxlbWVudGF0aW9uIGlzIGF2YWlsYWJsZS4gR2VuZXJhbGx5IHdpbGwgYmUgdHJ1ZSBpbiB0aGUgYnJvd3NlciBhbmQgZmFsc2Ugb3RoZXJ3aXNlLCB1bmxlc3MgdGhlcmVcclxuICAgICAqIHRoZXJlIGlzIGEgYnJvd3Nlci1sZXNzIGltcGxlbWVudGF0aW9uIGluIHRoZSBjdXJyZW50IG5vbi1icm93c2VyIGVudmlyb25tZW50LlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIERvY3VtZW50UmVmXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgSXNBdmFpbGFibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICEodHlwZW9mIChkb2N1bWVudCkgPT09ICd1bmRlZmluZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRvY3VtZW50IG9iamVjdCBvZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBkb2N1bWVudCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIERvY3VtZW50UmVmXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXROYXRpdmVEb2N1bWVudCgpOiBhbnkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGRvY3VtZW50KSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFdpbmRvdyBSZWZlcmVuY2Ugc2VydmljZSB0byBhc3Npc3Qgd2l0aCBhYnN0cmFjdGluZyB0aGUgYXZhaWxhYmlsaXR5IG9mIHdpbmRvdy4gTmVlZGVkIGZvciBBT1QgYW5kXHJcbiAqIFNlcnZlciBTaWRlIHJlbmRlcmluZ1xyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBXaW5kb3dSZWYge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIGEgd2luZG93IGltcGxlbWVudGF0aW9uIGlzIGF2YWlsYWJsZS4gR2VuZXJhbGx5IHdpbGwgYmUgdHJ1ZSBpbiB0aGUgYnJvd3NlciBhbmQgZmFsc2Ugb3RoZXJ3aXNlLCB1bmxlc3MgdGhlcmVcclxuICAgICAqIHRoZXJlIGlzIGEgYnJvd3Nlci1sZXNzIGltcGxlbWVudGF0aW9uIGluIHRoZSBjdXJyZW50IG5vbi1icm93c2VyIGVudmlyb25tZW50LlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIFdpbmRvd1JlZlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IElzQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAhKHR5cGVvZiAod2luZG93KSA9PT0gJ3VuZGVmaW5lZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgd2luZG93IG9iamVjdCBvZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSB3aW5kb3cgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBXaW5kb3dSZWZcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldE5hdGl2ZVdpbmRvdygpOiBhbnkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgKHdpbmRvdykgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBNYXBBUElMb2FkZXIsIFdpbmRvd1JlZiwgRG9jdW1lbnRSZWYgfSBmcm9tICcuLi9tYXBhcGlsb2FkZXInO1xyXG5cclxuLyoqXHJcbiAqIFByb3RvY29sIGVudW1lcmF0aW9uXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbmV4cG9ydCBlbnVtIFNjcmlwdFByb3RvY29sIHtcclxuICAgIEhUVFAsXHJcbiAgICBIVFRQUyxcclxuICAgIEFVVE9cclxufVxyXG5cclxuLyoqXHJcbiAqIEJpbmcgTWFwcyBWOCBzcGVjaWZpYyBsb2FkZXIgY29uZmlndXJhdGlvbiB0byBiZSB1c2VkIHdpdGggdGhlIHtAbGluayBCaW5nTWFwQVBJTG9hZGVyfVxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBCaW5nTWFwQVBJTG9hZGVyQ29uZmlnICB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQVBJIGtleSBmb3IgYmluZyBtYXBzXHJcbiAgICAvLy9cclxuICAgIGFwaUtleSA9ICcnO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEhvc3QgYW5kIFBhdGggdXNlZCBmb3IgdGhlIGA8c2NyaXB0PmAgdGFnLlxyXG4gICAgLy8vXHJcbiAgICBob3N0QW5kUGF0aCA9ICd3d3cuYmluZy5jb20vYXBpL21hcHMvbWFwY29udHJvbCc7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvdG9jb2wgdXNlZCBmb3IgdGhlIGA8c2NyaXB0PmAgdGFnLlxyXG4gICAgLy8vXHJcbiAgICBwcm90b2NvbDogU2NyaXB0UHJvdG9jb2wgPSBTY3JpcHRQcm90b2NvbC5IVFRQUztcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBUaGUgYnJhbmNoIHRvIGJlIHVzZWQuIExlYXZlIGVtcHR5IGZvciBwcm9kdWN0aW9uLiBVc2UgZXhwZXJpbWVudGFsXHJcbiAgICAvLy9cclxuICAgIGJyYW5jaCA9ICcnO1xyXG59XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBsb2FkZXIgY29uZmlndXJhdGlvbi5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfQ09ORklHVVJBVElPTiA9IG5ldyBCaW5nTWFwQVBJTG9hZGVyQ29uZmlnKCk7XHJcblxyXG4vKipcclxuICogQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uIGZvciB0aGUge0BsaW5rIE1hcEFQSUxvYWRlcn0gc2VydmljZS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQmluZ01hcEFQSUxvYWRlciBleHRlbmRzIE1hcEFQSUxvYWRlciB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVmaW50aXRpb25zLlxyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF9zY3JpcHRMb2FkaW5nUHJvbWlzZTogUHJvbWlzZTx2b2lkPjtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm9wZXJ0eSBkZWNsYXJhdGlvbnMuXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvYWRlciBjb25maWd1cmF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBBUElMb2FkZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBDb25maWcoKTogQmluZ01hcEFQSUxvYWRlckNvbmZpZyB7IHJldHVybiB0aGlzLl9jb25maWc7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmluZ01hcEFQSUxvYWRlci5cclxuICAgICAqIEBwYXJhbSBfY29uZmlnICAtIFRoZSBsb2FkZXIgY29uZmlndXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSBfd2luZG93UmVmIC0gQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFdpbmRvd1JlZn0uIE5lY2Vzc2FyeSBiZWNhdXNlIEJpbmcgTWFwIFY4IGludGVyYWN0cyB3aXRoIHRoZSB3aW5kb3cgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIF9kb2N1bWVudFJlZiAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBEb2N1bWVudFJlZn0uXHJcbiAgICAgKiBOZWNlc3NhcnkgYmVjYXVzZSBCaW5nIE1hcCBWOCBpbnRlcmFjdHMgd2l0aCB0aGUgZG9jdW1lbnQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwQVBJTG9hZGVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCBAT3B0aW9uYWwoKSBwcml2YXRlIF9jb25maWc6IEJpbmdNYXBBUElMb2FkZXJDb25maWcsIHByaXZhdGUgX3dpbmRvd1JlZjogV2luZG93UmVmLCBwcml2YXRlIF9kb2N1bWVudFJlZjogRG9jdW1lbnRSZWYpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcgPT09IG51bGwgfHwgdGhpcy5fY29uZmlnID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29uZmlnID0gREVGQVVMVF9DT05GSUdVUkFUSU9OO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kcyBhbmQgTWFwQVBJTG9hZGVyIGltcGxlbWVudGF0aW9uLlxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyB0aGUgbmVjZXNzYXJ5IHJlc291cmNlcyBmb3IgQmluZyBNYXBzIFY4LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwQVBJTG9hZGVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBMb2FkKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzY3JpcHQgPSB0aGlzLl9kb2N1bWVudFJlZi5HZXROYXRpdmVEb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xyXG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XHJcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcclxuICAgICAgICBzY3JpcHQuZGVmZXIgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTmFtZSA9IGBhbmd1bGFyMmJpbmdtYXBzJHtuZXcgRGF0ZSgpLmdldE1pbGxpc2Vjb25kcygpfWA7XHJcbiAgICAgICAgc2NyaXB0LnNyYyA9IHRoaXMuR2V0U2NyaXB0U3JjKGNhbGxiYWNrTmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmU6IEZ1bmN0aW9uLCByZWplY3Q6IEZ1bmN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICg8YW55PnRoaXMuX3dpbmRvd1JlZi5HZXROYXRpdmVXaW5kb3coKSlbY2FsbGJhY2tOYW1lXSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSAoZXJyb3I6IEV2ZW50KSA9PiB7IHJlamVjdChlcnJvcik7IH07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWYuR2V0TmF0aXZlRG9jdW1lbnQoKS5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByaXZhdGUgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBCaW5nIE1hcCBWOCBzY3JpcHRzIHVybCBmb3IgaW5qZWN0aW9ucyBpbnRvIHRoZSBoZWFkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrTmFtZSAtIE5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBCaW5nIE1hcHMgVjggc2NyaXB0cyBhcmUgbG9hZGVkLlxyXG4gICAgICogQHJldHVybnMgLSBUaGUgdXJsIHRvIGJlIHVzZWQgdG8gbG9hZCB0aGUgQmluZyBNYXAgc2NyaXB0cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcEFQSUxvYWRlclxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIEdldFNjcmlwdFNyYyhjYWxsYmFja05hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2xUeXBlOiBTY3JpcHRQcm90b2NvbCA9ICh0aGlzLl9jb25maWcgJiYgdGhpcy5fY29uZmlnLnByb3RvY29sKSB8fCBERUZBVUxUX0NPTkZJR1VSQVRJT04ucHJvdG9jb2w7XHJcbiAgICAgICAgbGV0IHByb3RvY29sOiBzdHJpbmc7XHJcblxyXG4gICAgICAgIHN3aXRjaCAocHJvdG9jb2xUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgU2NyaXB0UHJvdG9jb2wuQVVUTzpcclxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTY3JpcHRQcm90b2NvbC5IVFRQOlxyXG4gICAgICAgICAgICAgICAgcHJvdG9jb2wgPSAnaHR0cDonO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU2NyaXB0UHJvdG9jb2wuSFRUUFM6XHJcbiAgICAgICAgICAgICAgICBwcm90b2NvbCA9ICdodHRwczonO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBob3N0QW5kUGF0aDogc3RyaW5nID0gdGhpcy5fY29uZmlnLmhvc3RBbmRQYXRoIHx8IERFRkFVTFRfQ09ORklHVVJBVElPTi5ob3N0QW5kUGF0aDtcclxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrTmFtZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5icmFuY2ggIT09ICcnKSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zWydicmFuY2gnXSA9IHRoaXMuX2NvbmZpZy5icmFuY2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcmFtczogc3RyaW5nID0gT2JqZWN0LmtleXMocXVlcnlQYXJhbXMpXHJcbiAgICAgICAgICAgIC5tYXAoKGs6IHN0cmluZywgaTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW0gPSAoaSA9PT0gMCkgPyAnPycgOiAnJic7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0gKz0gYCR7a309JHtxdWVyeVBhcmFtc1trXX1gO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuam9pbignJyk7XHJcbiAgICAgICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0QW5kUGF0aH0ke3BhcmFtc31gO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgSUluZm9XaW5kb3dPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9paW5mby13aW5kb3ctb3B0aW9ucyc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IEluZm9Cb3hBY3Rpb25EaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2luZm9ib3gtYWN0aW9uJztcclxuaW1wb3J0IHsgSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuLi9pbmZvYm94LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJbmZvQm94Q29tcG9uZW50IH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9pbmZvYm94JztcclxuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuL2JpbmctbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCaW5nSW5mb1dpbmRvdyB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctaW5mby13aW5kb3cnO1xyXG5pbXBvcnQgeyBCaW5nTWFwRXZlbnRzTG9va3VwIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2JpbmcvYmluZy1ldmVudHMtbG9va3VwJztcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIEluZm9Cb3hTZXJ2aWNlfSBjb250cmFjdCBmb3IgdGhlIEJpbmcgTWFwcyBWOCBhcmNoaXRlY3R1cmUuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEJpbmdJbmZvQm94U2VydmljZSBpbXBsZW1lbnRzIEluZm9Cb3hTZXJ2aWNlIHtcclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF9ib3hlczogTWFwPEluZm9Cb3hDb21wb25lbnQsIFByb21pc2U8SW5mb1dpbmRvdz4+ID0gbmV3IE1hcDxJbmZvQm94Q29tcG9uZW50LCBQcm9taXNlPEluZm9XaW5kb3c+PigpO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmluZ0luZm9Cb3hTZXJ2aWNlLlxyXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0gQ29uY3JldGUge0BsaW5rIE1hcFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciBCaW5nIE1hcHMgVjguIEFuIGluc3RhbmNlIG9mIHtAbGluayBCaW5nTWFwU2VydmljZX0uXHJcbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBBbiBpbnN0YW5jZSBvZiBOZ1pvbmUgdG8gcHJvdmlkZSB6b25lIGF3YXJlIHByb21pc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gaW5mbyB3aW5kb3cgdG8gdGhlIG1hcCBvciBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5mbyAtIHtAbGluayBJbmZvQm94Q29tcG9uZW50fSBjb21wb25lbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5mb2JveC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0luZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRJbmZvV2luZG93KGluZm86IEluZm9Cb3hDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMgPSB7fTtcclxuICAgICAgICBpZiAodHlwZW9mIGluZm8uTGF0aXR1ZGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBpbmZvLkxvbmdpdHVkZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIGxhdGl0dWRlOiBpbmZvLkxhdGl0dWRlLFxyXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBpbmZvLkxvbmdpdHVkZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGluZm8uSW5mb1dpbmRvd0FjdGlvbnMgIT09ICd1bmRlZmluZWQnICYmIGluZm8uSW5mb1dpbmRvd0FjdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmFjdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgaW5mby5JbmZvV2luZG93QWN0aW9ucy5mb3JFYWNoKChhY3Rpb246IEluZm9Cb3hBY3Rpb25EaXJlY3RpdmUpID0+IHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogYWN0aW9uLkxhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlcjogKCkgPT4geyBhY3Rpb24uQWN0aW9uQ2xpY2tlZC5lbWl0KG51bGwpOyB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmZvLkh0bWxDb250ZW50ICE9PSAnJykge1xyXG4gICAgICAgICAgICBvcHRpb25zLmh0bWxDb250ZW50ID0gaW5mby5IdG1sQ29udGVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMudGl0bGUgPSBpbmZvLlRpdGxlO1xyXG4gICAgICAgICAgICBvcHRpb25zLmRlc2NyaXB0aW9uID0gaW5mby5EZXNjcmlwdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluZm8ueE9mZnNldCB8fCBpbmZvLnlPZmZzZXQpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGl4ZWxPZmZzZXQgPT0gbnVsbCkgeyBvcHRpb25zLnBpeGVsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07IH1cclxuICAgICAgICAgICAgaWYgKGluZm8ueE9mZnNldCkgeyBvcHRpb25zLnBpeGVsT2Zmc2V0LnggPSBpbmZvLnhPZmZzZXQ7IH1cclxuICAgICAgICAgICAgaWYgKGluZm8ueU9mZnNldCkgeyBvcHRpb25zLnBpeGVsT2Zmc2V0LnkgPSBpbmZvLnlPZmZzZXQ7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wdGlvbnMudmlzaWJsZSA9IGluZm8uVmlzaWJsZTtcclxuICAgICAgICBjb25zdCBpbmZvUHJvbWlzZSA9IHRoaXMuX21hcFNlcnZpY2UuQ3JlYXRlSW5mb1dpbmRvdyhvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9ib3hlcy5zZXQoaW5mbywgaW5mb1Byb21pc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIGFuIEluZm9Cb3hDb21wb25lbnQgdGhhdCBpcyBvcGVuLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGluZm8gLSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gY29tcG9uZW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluZm9ib3guXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBoYXMgYmVlbiBjbG9zZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDbG9zZShpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKCh3KSA9PiB3LkNsb3NlKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGRlbGVnYXRlIGZvciBhbiBpbmZvIHdpbmRvdy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlZ2lzdGVyIChlLmcuICdjbGljaycpXHJcbiAgICAgKiBAcGFyYW0gaW5mb0NvbXBvbmVudCAtIFRoZSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBldmVudC5cclxuICAgICAqIEByZXR1cm5zIC0gT2JzZXJ2YWJsZSBlbWl0aW5nIGFuIGluc3RhbmNlIG9mIFQgZWFjaCB0aW1lIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVFdmVudE9ic2VydmFibGU8VD4oZXZlbnROYW1lOiBzdHJpbmcsIGluZm9Db21wb25lbnQ6IEluZm9Cb3hDb21wb25lbnQpOiBPYnNlcnZhYmxlPFQ+IHtcclxuICAgICAgICBjb25zdCBldmVudE5hbWVUcmFuc2xhdGVkID0gQmluZ01hcEV2ZW50c0xvb2t1cFtldmVudE5hbWVdO1xyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JveGVzLmdldChpbmZvQ29tcG9uZW50KS50aGVuKChiOiBJbmZvV2luZG93KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBiLkFkZExpc3RlbmVyKGV2ZW50TmFtZVRyYW5zbGF0ZWQsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyBhbiBpbmZvYm94LlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGluZm8gLSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gY29tcG9uZW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluZm9ib3guXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBoYXMgYmVlbiBkZWxldGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlSW5mb1dpbmRvdyhpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgdyA9IHRoaXMuX2JveGVzLmdldChpbmZvKTtcclxuICAgICAgICBpZiAodyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHcudGhlbigoaTogSW5mb1dpbmRvdykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaS5DbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYm94ZXMuZGVsZXRlKGluZm8pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZW5zIGFuIGluZm9ib3ggdGhhdCBpcyBjbG9zZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gaW5mbyAtIHtAbGluayBJbmZvQm94Q29tcG9uZW50fSBjb21wb25lbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5mb2JveC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBpbmZvYm94IGhhcyBiZWVuIG9wZW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIE9wZW4oaW5mbzogSW5mb0JveENvbXBvbmVudCwgbG9jPzogSUxhdExvbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoaW5mby5DbG9zZUluZm9Cb3hlc09uT3BlbiB8fCBpbmZvLk1vZGFsKSB7XHJcbiAgICAgICAgICAgIC8vIGNsb3NlIGFsbCBvcGVuIGluZm8gYm94ZXMuXHJcbiAgICAgICAgICAgIHRoaXMuX2JveGVzLmZvckVhY2goKHY6IFByb21pc2U8SW5mb1dpbmRvdz4sIGk6IEluZm9Cb3hDb21wb25lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmZvLklkICE9PSBpLklkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdi50aGVuKHcgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAody5Jc09wZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcuQ2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkuQ2xvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKCh3KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnM6IElJbmZvV2luZG93T3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoaW5mby5IdG1sQ29udGVudCAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHRtbENvbnRlbnQgPSBpbmZvLkh0bWxDb250ZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50aXRsZSA9IGluZm8uVGl0bGU7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRlc2NyaXB0aW9uID0gaW5mby5EZXNjcmlwdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3LlNldE9wdGlvbnMob3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5mby5MYXRpdHVkZSAmJiBpbmZvLkxvbmdpdHVkZSkge1xyXG4gICAgICAgICAgICAgICAgdy5TZXRQb3NpdGlvbih7IGxhdGl0dWRlOiBpbmZvLkxhdGl0dWRlLCBsb25naXR1ZGU6IGluZm8uTG9uZ2l0dWRlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvYykge1xyXG4gICAgICAgICAgICAgICAgLy8vXHJcbiAgICAgICAgICAgICAgICAvLy8gdGhpcyBzaXR1YXRpb24gaXMgc3BlY2lmaWNhbGx5IHVzZWQgZm9yIGNsdXN0ZXIgbGF5ZXJzIHRoYXQgdXNlIHNwaWRlcmluZy5cclxuICAgICAgICAgICAgICAgIC8vL1xyXG4gICAgICAgICAgICAgICAgdy5TZXRQb3NpdGlvbihsb2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGluZm8uSG9zdE1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgdy5TZXRQb3NpdGlvbih7IGxhdGl0dWRlOiBpbmZvLkhvc3RNYXJrZXIuTGF0aXR1ZGUsIGxvbmdpdHVkZTogaW5mby5Ib3N0TWFya2VyLkxvbmdpdHVkZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3Lk9wZW4oKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluZm9ib3ggb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBpbmZvIC0ge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGNvbXBvbmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbmZvYm94LlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSUluZm9XaW5kb3dPcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucyB0byBzZXQuIE9wdGlvbnMgcHJvdmlkZWQgYXJlXHJcbiAgICAgKiBtZXJnZWQgd2l0aCB0aGUgZXhpc3Rpbmcgb3B0aW9ucyBvZiB0aGUgdW5kZXJseWluZyBpbmZvYm94LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGluZm9ib3ggb3B0aW9ucyBoYXZlIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMoaW5mbzogSW5mb0JveENvbXBvbmVudCwgb3B0aW9uczogSUluZm9XaW5kb3dPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKChpOiBJbmZvV2luZG93KSA9PiBpLlNldE9wdGlvbnMob3B0aW9ucykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgaW5mb2JveCBiYXNlZCBvbiB0aGUgcHJvcGVydGllcyBzZXQgb24gdGhlIEluZm9Cb3ggY29tcG9uZW50LlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGluZm8gLSB7QGxpbmsgSW5mb0JveENvbXBvbmVudH0gY29tcG9uZW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluZm9ib3guXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgaW5mb2JveCBwb3NpdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0UG9zaXRpb24oaW5mbzogSW5mb0JveENvbXBvbmVudCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3hlcy5nZXQoaW5mbykudGhlbigoaTogSW5mb1dpbmRvdykgPT4gaS5TZXRQb3NpdGlvbih7XHJcbiAgICAgICAgICAgIGxhdGl0dWRlOiBpbmZvLkxhdGl0dWRlLFxyXG4gICAgICAgICAgICBsb25naXR1ZGU6IGluZm8uTG9uZ2l0dWRlXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IE1hcE1hcmtlckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbWFwLW1hcmtlcic7XHJcbmltcG9ydCB7IE1hcmtlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9tYXJrZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2xheWVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBDbHVzdGVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NsdXN0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBCaW5nTWFwU2VydmljZSB9IGZyb20gJy4vYmluZy1tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4vYmluZy1jb252ZXJzaW9ucyc7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIE1hcmtlclNlcnZpY2UgYWJzdHJhY3QgY2xhc3MgZm9yIEJpbmcgTWFwcyBWOC5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQmluZ01hcmtlclNlcnZpY2UgaW1wbGVtZW50cyBNYXJrZXJTZXJ2aWNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfbWFya2VyczogTWFwPE1hcE1hcmtlckRpcmVjdGl2ZSwgUHJvbWlzZTxNYXJrZXI+PiA9IG5ldyBNYXA8TWFwTWFya2VyRGlyZWN0aXZlLCBQcm9taXNlPE1hcmtlcj4+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nTWFya2VyU2VydmljZS5cclxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbnN0YW5jZS4gVGhlIGNvbmNyZXRlIHtAbGluayBCaW5nTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyU2VydmljZSAtIHtAbGluayBMYXllclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gICAgICogVGhlIGNvbmNyZXRlIHtAbGluayBCaW5nTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBpcyBleHBlY3RlZC5cclxuICAgICAqIEBwYXJhbSBfY2x1c3RlclNlcnZpY2UgLSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gICAgICogVGhlIGNvbmNyZXRlIHtAbGluayBCaW5nQ2x1c3RlclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gTmdab25lIGluc3RhbmNlIHRvIHN1cHBvcnQgem9uZSBhd2FyZSBwcm9taXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSxcclxuICAgICAgICAgICAgICAgIHByaXZhdGUgX2xheWVyU2VydmljZTogTGF5ZXJTZXJ2aWNlLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBfY2x1c3RlclNlcnZpY2U6IENsdXN0ZXJTZXJ2aWNlLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1lbWJlcnMgYW5kIE1hcmtlclNlcnZpY2UgaW1wbGVtZW50YXRpb25cclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG1hcmtlci4gRGVwZW5kaW5nIG9uIHRoZSBtYXJrZXIgY29udGV4dCwgdGhlIG1hcmtlciB3aWxsIGVpdGhlciBieSBhZGRlZCB0byB0aGUgbWFwIG9yIGEgY29ycmVjc3BvbmRpbmcgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcmtlciAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSB0byBiZSBhZGRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZE1hcmtlcihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IElNYXJrZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogeyBsYXRpdHVkZTogbWFya2VyLkxhdGl0dWRlLCBsb25naXR1ZGU6IG1hcmtlci5Mb25naXR1ZGUgfSxcclxuICAgICAgICAgICAgdGl0bGU6IG1hcmtlci5UaXRsZSxcclxuICAgICAgICAgICAgbGFiZWw6IG1hcmtlci5MYWJlbCxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBtYXJrZXIuRHJhZ2dhYmxlLFxyXG4gICAgICAgICAgICBpY29uOiBtYXJrZXIuSWNvblVybCxcclxuICAgICAgICAgICAgaWNvbkluZm86IG1hcmtlci5JY29uSW5mbyxcclxuICAgICAgICAgICAgaXNGaXJzdDogbWFya2VyLklzRmlyc3RJblNldCxcclxuICAgICAgICAgICAgaXNMYXN0OiBtYXJrZXIuSXNMYXN0SW5TZXRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChtYXJrZXIuV2lkdGgpIHsgby53aWR0aCA9IG1hcmtlci5XaWR0aDsgfVxyXG4gICAgICAgIGlmIChtYXJrZXIuSGVpZ2h0KSB7IG8uaGVpZ2h0ID0gbWFya2VyLkhlaWdodDsgfVxyXG4gICAgICAgIGlmIChtYXJrZXIuQW5jaG9yKSB7IG8uYW5jaG9yID0gbWFya2VyLkFuY2hvcjsgfVxyXG4gICAgICAgIGlmIChtYXJrZXIuTWV0YWRhdGEpIHsgby5tZXRhZGF0YSA9IG1hcmtlci5NZXRhZGF0YTsgfVxyXG5cclxuICAgICAgICAvLyBjcmVhdGUgbWFya2VyIHZpYSBwcm9taXNlLlxyXG4gICAgICAgIGxldCBtYXJrZXJQcm9taXNlOiBQcm9taXNlPE1hcmtlcj4gPSBudWxsO1xyXG4gICAgICAgIGlmIChtYXJrZXIuSW5DbHVzdGVyTGF5ZXIpIHtcclxuICAgICAgICAgICAgbWFya2VyUHJvbWlzZSA9IHRoaXMuX2NsdXN0ZXJTZXJ2aWNlLkNyZWF0ZU1hcmtlcihtYXJrZXIuTGF5ZXJJZCwgbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1hcmtlci5JbkN1c3RvbUxheWVyKSB7XHJcbiAgICAgICAgICAgIG1hcmtlclByb21pc2UgPSB0aGlzLl9sYXllclNlcnZpY2UuQ3JlYXRlTWFya2VyKG1hcmtlci5MYXllcklkLCBvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1hcmtlclByb21pc2UgPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZU1hcmtlcihvKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX21hcmtlcnMuc2V0KG1hcmtlciwgbWFya2VyUHJvbWlzZSk7XHJcbiAgICAgICAgaWYgKG1hcmtlci5JY29uSW5mbykge1xyXG4gICAgICAgICAgICBtYXJrZXJQcm9taXNlLnRoZW4oKG06IE1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGljb25JbmZvIHRvIHByb3ZpZGUgaG9vayB0byBkbyBwb3N0IGljb24gY3JlYXRpb24gYWN0aXZpdGllcyBhbmRcclxuICAgICAgICAgICAgICAgIC8vIGFsc28gcmUtYW5jaG9yIHRoZSBtYXJrZXJcclxuICAgICAgICAgICAgICAgIG1hcmtlci5EeW5hbWljTWFya2VyQ3JlYXRlZC5lbWl0KG8uaWNvbkluZm8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDogSVBvaW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IChvLmljb25JbmZvLnNpemUgJiYgby5pY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpbykgPyAoby5pY29uSW5mby5zaXplLndpZHRoICogby5pY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpby54KSA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogKG8uaWNvbkluZm8uc2l6ZSAmJiBvLmljb25JbmZvLm1hcmtlck9mZnNldFJhdGlvKSA/IChvLmljb25JbmZvLnNpemUuaGVpZ2h0ICogby5pY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpby55KSA6IDAsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbS5TZXRBbmNob3IocCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciAoZS5nLiAnY2xpY2snKVxyXG4gICAgICogQHBhcmFtIG1hcmtlciAtIFRoZSB7QGxpbmsgTWFwTWFya2VyfSBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGV2ZW50LlxyXG4gICAgICogQHJldHVybnMgLSBPYnNlcnZhYmxlIGVtaXRpbmcgYW4gaW5zdGFuY2Ugb2YgVCBlYWNoIHRpbWUgdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZUV2ZW50T2JzZXJ2YWJsZTxUPihldmVudE5hbWU6IHN0cmluZywgbWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBPYnNlcnZhYmxlPFQ+IHtcclxuICAgICAgICBjb25zdCBiOiBTdWJqZWN0PFQ+ID0gbmV3IFN1YmplY3Q8VD4oKTtcclxuICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnbW91c2Vtb3ZlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gYi5hc09ic2VydmFibGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3JpZ2h0Y2xpY2snKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiLmFzT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gbW91c2Vtb3ZlIGFuZCByaWdodGNsaWNrIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGJpbmcgcG9seWdvbnMuXHJcbiAgICAgICAgLy8vXHJcblxyXG5cclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbS5BZGRMaXN0ZW5lcihldmVudE5hbWUsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZSkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGEgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSB7QGxpbmsgTWFwTWFya2VyfSB0byBiZSBkZWxldGVkLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBtYXJrZXIgaGFzIGJlZW4gZGVsZXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZU1hcmtlcihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpO1xyXG4gICAgICAgIGxldCBwOiBQcm9taXNlPHZvaWQ+ID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgaWYgKG0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwID0gbS50aGVuKChtYTogTWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyLkluQ2x1c3RlckxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2x1c3RlclNlcnZpY2UuR2V0TmF0aXZlTGF5ZXIobWFya2VyLkxheWVySWQpLnRoZW4obCA9PiB7IGwuUmVtb3ZlRW50aXR5KG1hKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyLkluQ3VzdG9tTGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXllclNlcnZpY2UuR2V0TmF0aXZlTGF5ZXIobWFya2VyLkxheWVySWQpLnRoZW4obCA9PiB7IGwuUmVtb3ZlRW50aXR5KG1hKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hLkRlbGV0ZU1hcmtlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMuZGVsZXRlKG1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXJrZXIgb24gdGhlIGNsaWNrIGxvY2F0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1vdXNlRXZlbnQgfCBhbnkpOiBJTGF0TG9uZyB7XHJcbiAgICAgICAgaWYgKCFlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWUucHJpbWl0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShlLnByaW1pdGl2ZSBpbnN0YW5jZW9mIE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwOiBNaWNyb3NvZnQuTWFwcy5QdXNocGluID0gZS5wcmltaXRpdmU7XHJcbiAgICAgICAgY29uc3QgbG9jOiBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbiA9IHAuZ2V0TG9jYXRpb24oKTtcclxuICAgICAgICByZXR1cm4geyBsYXRpdHVkZTogbG9jLmxhdGl0dWRlLCBsb25naXR1ZGU6IGxvYy5sb25naXR1ZGUgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIG1hcmtlciBtb2RlbCBmb3IgdGhlIG1hcmtlciBhbGxvd2luZyBhY2Nlc3MgdG8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uYXRpbGl5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSBUaGUge0BsaW5rIE1hcE1hcmtlcn0gZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgbWFya2VyIG1vZGVsLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBNYXJrZXJ9IGltcGxlbWVudGF0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIHBsYXRmb3JtLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TmF0aXZlTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTxNYXJrZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIG1hcmtlciBwaXhlbCBsb2NhdGlvbiBmb3IgdGhlIG1hcmtlciBvbiB0aGUgY2xpY2sgbG9jYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIElMYXRMb25nfSBjb250YWluaW5nIHRoZSBwaXhlbHMgb2YgdGhlIG1hcmtlciBvbiB0aGUgbWFwIGNhbnZhcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFBpeGVsc0Zyb21DbGljayhlOiBNb3VzZUV2ZW50IHwgYW55KTogSVBvaW50IHtcclxuICAgICAgICBjb25zdCBsb2M6IElMYXRMb25nID0gdGhpcy5HZXRDb29yZGluYXRlc0Zyb21DbGljayhlKTtcclxuICAgICAgICBpZiAobG9jID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGw6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKGxvYyk7XHJcbiAgICAgICAgY29uc3QgcDogTWljcm9zb2Z0Lk1hcHMuUG9pbnQgPSA8TWljcm9zb2Z0Lk1hcHMuUG9pbnQ+KDxCaW5nTWFwU2VydmljZT5cclxuICAgICAgICAgICAgdGhpcy5fbWFwU2VydmljZSkuTWFwSW5zdGFuY2UudHJ5TG9jYXRpb25Ub1BpeGVsKGwsIE1pY3Jvc29mdC5NYXBzLlBpeGVsUmVmZXJlbmNlLmNvbnRyb2wpO1xyXG4gICAgICAgIGlmIChwID09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICByZXR1cm4geyB4OiBwLngsIHk6IHAueSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSBnZW8gbG9jYXRpb24gdG8gYSBwaXhlbCBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgbWFwIGNhbnZhcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gRWl0aGVyIGEge0BsaW5rIE1hcE1hcmtlcn0gb3IgYSB7QGxpbmsgSUxhdExvbmd9IGZvciB0aGUgYmFzaXMgb2YgdHJhbnNsYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyBhIHtAbGluayBJUG9pbnR9XHJcbiAgICAgKiB3aXRoIHRoZSBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgTWFwTWFya2VyIG9yIElMYXRMb25nIHJlbGF0aXZlIHRvIHRoZSBtYXAgY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgTG9jYXRpb25Ub1BvaW50KHRhcmdldDogTWFwTWFya2VyRGlyZWN0aXZlIHwgSUxhdExvbmcpOiBQcm9taXNlPElQb2ludD4ge1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwTWFya2VyRGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldCh0YXJnZXQpLnRoZW4oKG06IE1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbDogSUxhdExvbmcgPSBtLkxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDogUHJvbWlzZTxJUG9pbnQ+ID0gdGhpcy5fbWFwU2VydmljZS5Mb2NhdGlvblRvUG9pbnQobCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXBTZXJ2aWNlLkxvY2F0aW9uVG9Qb2ludCh0YXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgYW5jaG9yIHBvc2l0aW9uIGZvciB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBhbmNob3IuXHJcbiAgICAgKiBBbmNob3IgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgYW5jaG9yIHBvc2l0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVBbmNob3IobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKChtOiBNYXJrZXIpID0+IHtcclxuICAgICAgICAgICAgbS5TZXRBbmNob3IobWFya2VyLkFuY2hvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHdoZXRoZXIgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJ9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgZHJhZ2FiaWxpdHkuXHJcbiAgICAgKiBEcmFnYWJpbGl0eSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBtYXJrZXIgaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFVwZGF0ZURyYWdnYWJsZShtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4gbS5TZXREcmFnZ2FibGUobWFya2VyLkRyYWdnYWJsZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgSWNvbiBvbiB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBpY29uLlxyXG4gICAgICogSWNvbiBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBpY29uIGluZm9ybWF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVJY29uKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IChtOiBNYXJrZXIsIGljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mbykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaWNvbiAmJiBpY29uICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgbS5TZXRJY29uKGljb24pO1xyXG4gICAgICAgICAgICAgICAgbWFya2VyLkR5bmFtaWNNYXJrZXJDcmVhdGVkLmVtaXQoaWNvbkluZm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKChtOiBNYXJrZXIpID0+IHtcclxuICAgICAgICAgICAgaWYgKG1hcmtlci5JY29uSW5mbykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IE1hcmtlci5DcmVhdGVNYXJrZXIobWFya2VyLkljb25JbmZvKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocykgPT09ICdzdHJpbmcnKSB7IHJldHVybihwYXlsb2FkKG0sIHMsIG1hcmtlci5JY29uSW5mbykpOyB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy50aGVuKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ocGF5bG9hZChtLCB4Lmljb24sIHguaWNvbkluZm8pKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybihtLlNldEljb24obWFya2VyLkljb25VcmwpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgbGFiZWwgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgbGFiZWwuXHJcbiAgICAgKiBMYWJlbCBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBsYWJlbCBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVXBkYXRlTGFiZWwobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKChtOiBNYXJrZXIpID0+IHsgbS5TZXRMYWJlbChtYXJrZXIuTGFiZWwpOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBDb29yZGluYXRlIGluZm9ybWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIHBvc2l0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVNYXJrZXJQb3NpdGlvbihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oXHJcbiAgICAgICAgICAgIChtOiBNYXJrZXIpID0+IG0uU2V0UG9zaXRpb24oe1xyXG4gICAgICAgICAgICAgICAgbGF0aXR1ZGU6IG1hcmtlci5MYXRpdHVkZSxcclxuICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogbWFya2VyLkxvbmdpdHVkZVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB0aXRsZSBvbiB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSB0aXRsZS5cclxuICAgICAqIFRpdGxlIGluZm9ybWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIHRpdGxlIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVUaXRsZShtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4gbS5TZXRUaXRsZShtYXJrZXIuVGl0bGUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZpc2liaWxpdHkgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgdmlzaWJsaXR5LlxyXG4gICAgICogVmlzaWJpbGl0eSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSB2aXNpYmlsaXR5IGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVWaXNpYmxlKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiBtLlNldFZpc2libGUobWFya2VyLlZpc2libGUpKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2ZXIsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcEFQSUxvYWRlciB9IGZyb20gJy4uL21hcGFwaWxvYWRlcic7XHJcbmltcG9ydCB7IEJpbmdNYXBBUElMb2FkZXIsIEJpbmdNYXBBUElMb2FkZXJDb25maWcgfSBmcm9tICcuL2JpbmctbWFwLmFwaS1sb2FkZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdDb252ZXJzaW9ucyB9IGZyb20gJy4vYmluZy1jb252ZXJzaW9ucyc7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlnb24nO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5bGluZSc7XHJcbmltcG9ydCB7IE1hcmtlclR5cGVJZCB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXItdHlwZS1pZCc7XHJcbmltcG9ydCB7IEluZm9XaW5kb3cgfSBmcm9tICcuLi8uLi9tb2RlbHMvaW5mby13aW5kb3cnO1xyXG5pbXBvcnQgeyBCaW5nTWFya2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2JpbmcvYmluZy1tYXJrZXInO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IEJpbmdMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctbGF5ZXInO1xyXG5pbXBvcnQgeyBCaW5nQ2x1c3RlckxheWVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2JpbmcvYmluZy1jbHVzdGVyLWxheWVyJztcclxuaW1wb3J0IHsgQmluZ0luZm9XaW5kb3cgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWluZm8td2luZG93JztcclxuaW1wb3J0IHsgQmluZ1BvbHlnb24gfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLXBvbHlnb24nO1xyXG5pbXBvcnQgeyBCaW5nUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLXBvbHlsaW5lJztcclxuaW1wb3J0IHsgTWl4aW5NYXBMYWJlbFdpdGhPdmVybGF5VmlldyB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctbGFiZWwnO1xyXG5pbXBvcnQgeyBNaXhpbkNhbnZhc092ZXJsYXkgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWNhbnZhcy1vdmVybGF5JztcclxuaW1wb3J0IHsgQmluZ0NhbnZhc092ZXJsYXkgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWNhbnZhcy1vdmVybGF5JztcclxuaW1wb3J0IHsgQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uLy4uL21vZGVscy9jYW52YXMtb3ZlcmxheSc7XHJcbmltcG9ydCB7IElMYXllck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXllci1vcHRpb25zJztcclxuaW1wb3J0IHsgSUNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pY2x1c3Rlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSU1hcE9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXAtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvaW50JztcclxuaW1wb3J0IHsgSVNpemUgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lzaXplJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJQm94IH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pYm94JztcclxuXHJcbmltcG9ydCB7IEJpbmdNYXBFdmVudHNMb29rdXAgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWV2ZW50cy1sb29rdXAnO1xyXG5cclxuLyoqXHJcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBNYXBTZXJ2aWNlIGFic3RyYWN0IGltcGxlbWVudGluZyBhIEJpbiBNYXAgVjggcHJvdmlkZXJcclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQmluZ01hcFNlcnZpY2UgaW1wbGVtZW50cyBNYXBTZXJ2aWNlIHtcclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIERlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcblxyXG4gICAgcHJpdmF0ZSBfbWFwOiBQcm9taXNlPE1pY3Jvc29mdC5NYXBzLk1hcD47XHJcbiAgICBwcml2YXRlIF9tYXBJbnN0YW5jZTogTWljcm9zb2Z0Lk1hcHMuTWFwO1xyXG4gICAgcHJpdmF0ZSBfbWFwUmVzb2x2ZXI6ICh2YWx1ZT86IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4gdm9pZDtcclxuICAgIHByaXZhdGUgX2NvbmZpZzogQmluZ01hcEFQSUxvYWRlckNvbmZpZztcclxuICAgIHByaXZhdGUgX21vZHVsZXM6IE1hcDxzdHJpbmcsIE9iamVjdD4gPSBuZXcgTWFwPHN0cmluZywgT2JqZWN0PigpO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IERlZmluaXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYW4gYXJyYXkgb2YgbG9hZGVkIEJvbmcgbW9kdWxlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IExvYWRlZE1vZHVsZXMoKTogTWFwPHN0cmluZywgT2JqZWN0PiB7IHJldHVybiB0aGlzLl9tb2R1bGVzOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBCaW5nIE1hcCBjb250cm9sIGluc3RhbmNlIHVuZGVybHlpbmcgdGhlIGltcGxlbWVudGF0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBNYXBJbnN0YW5jZSgpOiBNaWNyb3NvZnQuTWFwcy5NYXAgeyByZXR1cm4gdGhpcy5fbWFwSW5zdGFuY2U7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBQcm9taXNlIGZvciBhIEJpbmcgTWFwIGNvbnRyb2wgaW5zdGFuY2UgdW5kZXJseWluZyB0aGUgaW1wbGVtZW50YXRpb24uIFVzZSB0aGlzIGluc3RlYWQgb2Yge0BsaW5rIE1hcEluc3RhbmNlfSBpZiB5b3VcclxuICAgICAqIGFyZSBub3Qgc3VyZSBpZiBhbmQgd2hlbiB0aGUgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkLlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBNYXBQcm9taXNlKCk6IFByb21pc2U8TWljcm9zb2Z0Lk1hcHMuTWFwPiB7IHJldHVybiB0aGlzLl9tYXA7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG1hcHMgcGh5c2ljYWwgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTWFwU2l6ZSgpOiBJU2l6ZSB7XHJcbiAgICAgICAgaWYgKHRoaXMuTWFwSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgY29uc3QgczogSVNpemUgPSB7IHdpZHRoOiB0aGlzLk1hcEluc3RhbmNlLmdldFdpZHRoKCksIGhlaWdodDogdGhpcy5NYXBJbnN0YW5jZS5nZXRIZWlnaHQoKSB9O1xyXG4gICAgICAgICAgICByZXR1cm4gcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nTWFwU2VydmljZS5cclxuICAgICAqIEBwYXJhbSBfbG9hZGVyIE1hcEFQSUxvYWRlciBpbnN0YW5jZSBpbXBsZW1lbnRlZCBmb3IgQmluZyBNYXBzLiBUaGlzIGluc3RhbmNlIHdpbGwgZ2VuZXJhbGx5IGJlIGluamVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIE5nWm9uZSBvYmplY3QgdG8gZW5hYmxlIHpvbmUgYXdhcmUgcHJvbWlzZXMuIFRoaXMgd2lsbCBnZW5lcmFsbHkgYmUgaW5qZWN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2xvYWRlcjogTWFwQVBJTG9hZGVyLCBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcclxuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgUHJvbWlzZTxNaWNyb3NvZnQuTWFwcy5NYXA+KChyZXNvbHZlOiAoKSA9PiB2b2lkKSA9PiB7IHRoaXMuX21hcFJlc29sdmVyID0gcmVzb2x2ZTsgfSk7XHJcbiAgICAgICAgdGhpcy5fY29uZmlnID0gKDxCaW5nTWFwQVBJTG9hZGVyPnRoaXMuX2xvYWRlcikuQ29uZmlnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzIGFuZCBNYXBTZXJ2aWNlIGludGVyZmFjZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY2FudmFzIG92ZXJsYXkgbGF5ZXIgdG8gcGVyZm9ybSBjdXN0b20gZHJhd2luZyBvdmVyIHRoZSBtYXAgd2l0aCBvdXRcclxuICAgICAqIHNvbWUgb2YgdGhlIG92ZXJoZWFkIGFzc29jaWF0ZWQgd2l0aCBnb2luZyB0aHJvdWdoIHRoZSBNYXAgb2JqZWN0cy5cclxuICAgICAqIEBwYXJhbSBkcmF3Q2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBjYW52YXMgaXMgcmVhZHkgdG8gYmVcclxuICAgICAqIHJlbmRlcmVkIGZvciB0aGUgY3VycmVudCBtYXAgdmlldy5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBDYW52YXNPdmVybGF5fSBvYmplY3QuXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZUNhbnZhc092ZXJsYXkoZHJhd0NhbGxiYWNrOiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4gdm9pZCk6IFByb21pc2U8Q2FudmFzT3ZlcmxheT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheTogQmluZ0NhbnZhc092ZXJsYXkgPSBuZXcgQmluZ0NhbnZhc092ZXJsYXkoZHJhd0NhbGxiYWNrKTtcclxuICAgICAgICAgICAgbWFwLmxheWVycy5pbnNlcnQob3ZlcmxheSk7XHJcbiAgICAgICAgICAgIHJldHVybiBvdmVybGF5O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIEJpbmcgbWFwIGNsdXN0ZXIgbGF5ZXIgd2l0aGluIHRoZSBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLiBTZWUge0BsaW5rIElDbHVzdGVyT3B0aW9uc30uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgTGF5ZXJ9IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJMYXllciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVDbHVzdGVyTGF5ZXIob3B0aW9uczogSUNsdXN0ZXJPcHRpb25zKTogUHJvbWlzZTxMYXllcj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSBuZXcgUHJvbWlzZTxMYXllcj4ocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkxvYWRNb2R1bGUoJ01pY3Jvc29mdC5NYXBzLkNsdXN0ZXJpbmcnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSUNsdXN0ZXJMYXllck9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlQ2x1c3Rlck9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF5ZXI6IE1pY3Jvc29mdC5NYXBzLkNsdXN0ZXJMYXllciA9IG5ldyBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyTGF5ZXIobmV3IEFycmF5PE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4+KCksIG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBibDogQmluZ0NsdXN0ZXJMYXllcjtcclxuICAgICAgICAgICAgICAgICAgICBtYXAubGF5ZXJzLmluc2VydChsYXllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYmwgPSBuZXcgQmluZ0NsdXN0ZXJMYXllcihsYXllciwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmwuU2V0T3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGJsKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluZm9ybWF0aW9uIHdpbmRvdyBmb3IgYSBtYXAgcG9zaXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIC0gSW5mb3dpbmRvdyBvcHRpb25zLiBTZWUge0BsaW5rIElJbmZvV2luZG93T3B0aW9uc31cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBJbmZvV2luZG93fSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBNaWNyb3NvZnQuTWFwcy5JbmZvYm94IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZUluZm9XaW5kb3cob3B0aW9ucz86IElJbmZvV2luZG93T3B0aW9ucyk6IFByb21pc2U8SW5mb1dpbmRvdz4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IHtcclxuICAgICAgICAgICAgbGV0IGxvYzogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb247XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxvYyA9IG1hcC5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxvYyA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbihvcHRpb25zLnBvc2l0aW9uLmxhdGl0dWRlLCBvcHRpb25zLnBvc2l0aW9uLmxvbmdpdHVkZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaW5mb0JveDogTWljcm9zb2Z0Lk1hcHMuSW5mb2JveCA9IG5ldyBNaWNyb3NvZnQuTWFwcy5JbmZvYm94KGxvYywgQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUluZm9Cb3hPcHRpb25zKG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgaW5mb0JveC5zZXRNYXAobWFwKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5nSW5mb1dpbmRvdyhpbmZvQm94KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtYXAgbGF5ZXIgd2l0aGluIHRoZSBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLiBTZWUge0BsaW5rIElMYXllck9wdGlvbnN9XHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgTGF5ZXJ9IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIE1pY3Jvc29mdC5NYXBzLkxheWVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZUxheWVyKG9wdGlvbnM6IElMYXllck9wdGlvbnMpOiBQcm9taXNlPExheWVyPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsYXllcjogTWljcm9zb2Z0Lk1hcHMuTGF5ZXIgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuTGF5ZXIob3B0aW9ucy5pZC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgbWFwLmxheWVycy5pbnNlcnQobGF5ZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmdMYXllcihsYXllciwgdGhpcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVsIC0gSFRNTCBlbGVtZW50IHRvIGhvc3QgdGhlIG1hcC5cclxuICAgICAqIEBwYXJhbSBtYXBPcHRpb25zIC0gTWFwIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIG1hcCBoYXMgYmVlbiBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlTWFwKGVsOiBIVE1MRWxlbWVudCwgbWFwT3B0aW9uczogSU1hcE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVyLkxvYWQoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gYXBwbHkgbWl4aW5zXHJcbiAgICAgICAgICAgIE1peGluTWFwTGFiZWxXaXRoT3ZlcmxheVZpZXcoKTtcclxuICAgICAgICAgICAgTWl4aW5DYW52YXNPdmVybGF5KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBtYXAgc3RhcnR1cC4uLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWFwSW5zdGFuY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5EaXNwb3NlTWFwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSU1hcExvYWRPcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvYWRPcHRpb25zKG1hcE9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoIW8uY3JlZGVudGlhbHMpIHtcclxuICAgICAgICAgICAgICAgIG8uY3JlZGVudGlhbHMgPSB0aGlzLl9jb25maWcuYXBpS2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IG5ldyBNaWNyb3NvZnQuTWFwcy5NYXAoZWwsIG8pO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG1hcDtcclxuICAgICAgICAgICAgdGhpcy5fbWFwUmVzb2x2ZXIobWFwKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBCaW5nIG1hcCBtYXJrZXIgd2l0aGluIHRoZSBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBbb3B0aW9ucz08SU1hcmtlck9wdGlvbnM+e31dIC0gT3B0aW9ucyBmb3IgdGhlIG1hcmtlci4gU2VlIHtAbGluayBJTWFya2VyT3B0aW9uc30uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgTWFya2VyfSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBNaWNyb3NvZnQuTWFwcy5QdXNoUGluIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZU1hcmtlcihvcHRpb25zOiBJTWFya2VyT3B0aW9ucyA9IDxJTWFya2VyT3B0aW9ucz57fSk6IFByb21pc2U8TWFya2VyPiB7XHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IChpY29uOiBzdHJpbmcsIG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKTogQmluZ01hcmtlciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYzogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24ob3B0aW9ucy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVNYXJrZXJPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoaWNvbiAmJiBpY29uICE9PSAnJykgeyBvLmljb24gPSBpY29uOyB9XHJcbiAgICAgICAgICAgIGNvbnN0IHB1c2hwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbihsb2MsIG8pO1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXI6IEJpbmdNYXJrZXIgPSBuZXcgQmluZ01hcmtlcihwdXNocGluLCBtYXAsIG51bGwpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IG1hcmtlci5NZXRhZGF0YS5zZXQoaywgdikpOyB9XHJcbiAgICAgICAgICAgIG1hcC5lbnRpdGllcy5wdXNoKHB1c2hwaW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gbWFya2VyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pY29uSW5mbyAmJiBvcHRpb25zLmljb25JbmZvLm1hcmtlclR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBNYXJrZXIuQ3JlYXRlTWFya2VyKG9wdGlvbnMuaWNvbkluZm8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocykgPT09ICdzdHJpbmcnKSB7IHJldHVybiAocGF5bG9hZChzLCBtYXApKTsgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMudGhlbih4ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwYXlsb2FkKHguaWNvbiwgbWFwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBheWxvYWQobnVsbCwgbWFwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBwb2x5Z29uIHdpdGhpbiB0aGUgQmluZyBNYXBzIFY4IG1hcCBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBwb2x5Z29uLiBTZWUge0BsaW5rIElQb2x5Z29uT3B0aW9uc30uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgUG9seWdvbn0gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgbmF0aXZlIHBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb24ob3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5Z29uPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsb2NzOiBBcnJheTxBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4+ID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBhdGhzKG9wdGlvbnMucGF0aHMpO1xyXG4gICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUG9seWdvbk9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWdvbk9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvbHk6IE1pY3Jvc29mdC5NYXBzLlBvbHlnb24gPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9seWdvbihsb2NzLCBvKTtcclxuICAgICAgICAgICAgbWFwLmVudGl0aWVzLnB1c2gocG9seSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwID0gbmV3IEJpbmdQb2x5Z29uKHBvbHksIHRoaXMsIG51bGwpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHAuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAmJiBvcHRpb25zLnRpdGxlICE9PSAnJykgeyBwLlRpdGxlID0gb3B0aW9ucy50aXRsZTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93TGFiZWwgIT0gbnVsbCkgeyBwLlNob3dMYWJlbCA9IG9wdGlvbnMuc2hvd0xhYmVsOyB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dUb29sdGlwICE9IG51bGwpIHsgcC5TaG93VG9vbHRpcCA9IG9wdGlvbnMuc2hvd1Rvb2x0aXA7IH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGFiZWxNYXhab29tICE9IG51bGwpIHsgcC5MYWJlbE1heFpvb20gPSBvcHRpb25zLmxhYmVsTWF4Wm9vbTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sYWJlbE1pblpvb20gIT0gbnVsbCkgeyBwLkxhYmVsTWluWm9vbSA9IG9wdGlvbnMubGFiZWxNaW5ab29tOyB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVkaXRhYmxlKSB7IHAuU2V0RWRpdGFibGUob3B0aW9ucy5lZGl0YWJsZSk7IH1cclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcG9seWxpbmUgd2l0aGluIHRoZSBCaW5nIE1hcHMgVjggbWFwIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIHBvbHlsaW5lLiBTZWUge0BsaW5rIElQb2x5bGluZU9wdGlvbnN9LlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIFBvbHlsaW5lfSBvYmplY3QgKG9yIGFuIGFycmF5IHRoZXJlb2YgZm9yIGNvbXBsZXggcGF0aHMpLFxyXG4gICAgICogd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBwb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVQb2x5bGluZShvcHRpb25zOiBJUG9seWxpbmVPcHRpb25zKTogUHJvbWlzZTxQb2x5bGluZSB8IEFycmF5PFBvbHlsaW5lPj4ge1xyXG4gICAgICAgIGxldCBwb2x5bGluZTogTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUG9seWxpbmVPcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBvbHlsaW5lT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgbG9jczogQXJyYXk8QXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+PiA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQYXRocyhvcHRpb25zLnBhdGgpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXRoICYmIG9wdGlvbnMucGF0aC5sZW5ndGggPiAwICYmICFBcnJheS5pc0FycmF5KG9wdGlvbnMucGF0aFswXSkpIHtcclxuICAgICAgICAgICAgICAgIHBvbHlsaW5lID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lKGxvY3NbMF0sIG8pO1xyXG4gICAgICAgICAgICAgICAgbWFwLmVudGl0aWVzLnB1c2gocG9seWxpbmUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsID0gbmV3IEJpbmdQb2x5bGluZShwb2x5bGluZSwgbWFwLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7IG9wdGlvbnMubWV0YWRhdGEuZm9yRWFjaCgodiwgaykgPT4gcGwuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgJiYgb3B0aW9ucy50aXRsZSAhPT0gJycpIHsgcGwuVGl0bGUgPSBvcHRpb25zLnRpdGxlOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93VG9vbHRpcCAhPSBudWxsKSB7IHBsLlNob3dUb29sdGlwID0gb3B0aW9ucy5zaG93VG9vbHRpcDsgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZXM6IEFycmF5PFBvbHlsaW5lPiA9IG5ldyBBcnJheTxQb2x5bGluZT4oKTtcclxuICAgICAgICAgICAgICAgIGxvY3MuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5bGluZSA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZShwLCBvKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXAuZW50aXRpZXMucHVzaChwb2x5bGluZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsID0gbmV3IEJpbmdQb2x5bGluZShwb2x5bGluZSwgbWFwLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHBsLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAmJiBvcHRpb25zLnRpdGxlICE9PSAnJykgeyBwbC5UaXRsZSA9IG9wdGlvbnMudGl0bGU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93VG9vbHRpcCAhPSBudWxsKSB7IHBsLlNob3dUb29sdGlwID0gb3B0aW9ucy5zaG93VG9vbHRpcDsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gocGwpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgYSBsYXllciBmcm9tIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gTGF5ZXIgdG8gZGVsZXRlLiBTZWUge0BsaW5rIExheWVyfS4gVGhpcyBtZXRob2QgZXhwZWN0cyB0aGUgQmluZyBzcGVjaWZpYyBMYXllciBtb2RlbCBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBmdWxsZmlsbGVkIHdoZW4gdGhlIGxheWVyIGhhcyBiZWVuIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGVMYXllcihsYXllcjogTGF5ZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XHJcbiAgICAgICAgICAgIG1hcC5sYXllcnMucmVtb3ZlKGxheWVyLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc3Bhb3NlIHRoZSBtYXAgYW5kIGFzc29jaWF0ZWQgcmVzb3VyZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEaXNwb3NlTWFwKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9tYXAgPT0gbnVsbCAmJiB0aGlzLl9tYXBJbnN0YW5jZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX21hcEluc3RhbmNlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFwSW5zdGFuY2UuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcCA9IG5ldyBQcm9taXNlPE1pY3Jvc29mdC5NYXBzLk1hcD4oKHJlc29sdmU6ICgpID0+IHZvaWQpID0+IHsgdGhpcy5fbWFwUmVzb2x2ZXIgPSByZXNvbHZlOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIG1hcCBjZW50ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgZ29lIGxvY2F0aW9uIG9mIHRoZSBjZW50ZXIuIFNlZSB7QGxpbmsgSUxhdExvbmd9LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0Q2VudGVyKCk6IFByb21pc2U8SUxhdExvbmc+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIDxJTGF0TG9uZz57XHJcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogY2VudGVyLmxhdGl0dWRlLFxyXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBjZW50ZXIubG9uZ2l0dWRlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIG1hcCBib3VuZGluZyBib3hcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgZ29lIGxvY2F0aW9uIG9mIHRoZSBib3VuZGluZyBib3guIFNlZSB7QGxpbmsgSUJveH0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRCb3VuZHMoKTogUHJvbWlzZTxJQm94PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBib3ggPSBtYXAuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiA8SUJveD57XHJcbiAgICAgICAgICAgICAgICBtYXhMYXRpdHVkZTogYm94LmdldE5vcnRoKCksXHJcbiAgICAgICAgICAgICAgICBtYXhMb25naXR1ZGU6IGJveC5jcm9zc2VzSW50ZXJuYXRpb25hbERhdGVMaW5lKCkgPyBib3guZ2V0V2VzdCgpIDogYm94LmdldEVhc3QoKSxcclxuICAgICAgICAgICAgICAgIG1pbkxhdGl0dWRlOiBib3guZ2V0U291dGgoKSxcclxuICAgICAgICAgICAgICAgIG1pbkxvbmdpdHVkZTogYm94LmNyb3NzZXNJbnRlcm5hdGlvbmFsRGF0ZUxpbmUoKSA/IGJveC5nZXRFYXN0KCkgOiBib3guZ2V0V2VzdCgpLFxyXG4gICAgICAgICAgICAgICAgY2VudGVyOiB7IGxhdGl0dWRlOiBib3guY2VudGVyLmxhdGl0dWRlLCBsb25naXR1ZGU6IGJveC5jZW50ZXIubG9uZ2l0dWRlIH0sXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgc2hhcmVkIG9yIHByaXZhdGUgaW5zdGFuY2Ugb2YgdGhlIG1hcCBkcmF3aW5nIHRvb2xzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBbdXNlU2hhcmVkSW5zdGFuY2U9dHJ1ZV0gLSBTZXQgdG8gZmFsc2UgdG8gY3JlYXRlIGEgcHJpdmF0ZSBpbnN0YW5jZS5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSB0aGF0IHdoZW4gcmVzb2x2ZWQgY29udGFpbnN0IGFuIGluc3RhbmNlIG9mIHRoZSBkcmF3aW5nIHRvb2xzLlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXREcmF3aW5nVG9vbHMgKHVzZVNoYXJlZEluc3RhbmNlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8TWljcm9zb2Z0Lk1hcHMuRHJhd2luZ1Rvb2xzPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPE1pY3Jvc29mdC5NYXBzLkRyYXdpbmdUb29scz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLkxvYWRNb2R1bGVJbnN0YW5jZSgnTWljcm9zb2Z0Lk1hcHMuRHJhd2luZ1Rvb2xzJywgdXNlU2hhcmVkSW5zdGFuY2UpLnRoZW4oKG86IE1pY3Jvc29mdC5NYXBzLkRyYXdpbmdUb29scykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShvKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgb2YgdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgem9vbSBsZXZlbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFpvb20oKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiBtYXAuZ2V0Wm9vbSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgbW9kdWxlIGludG8gdGhlIE1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbW9kdWxlTmFtZSAtIFRoZSBtb2R1bGUgdG8gbG9hZC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIGNhbGwgb25jZSBsb2FkaW5nIGlzIGNvbXBsZXRlLlxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBMb2FkTW9kdWxlKG1vZHVsZU5hbWU6IHN0cmluZywgY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcclxuICAgICAgICBpZiAodGhpcy5fbW9kdWxlcy5oYXMobW9kdWxlTmFtZSkpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLmxvYWRNb2R1bGUobW9kdWxlTmFtZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kdWxlcy5zZXQobW9kdWxlTmFtZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIG1vZHVsZSBpbnRvIHRoZSBNYXAgYW5kIGRlbGl2ZXJzIGFuZCBpbnN0YW5jZSBvZiB0aGUgbW9kdWxlIHBheWxvYWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1vZHVsZU5hbWUgLSBUaGUgbW9kdWxlIHRvIGxvYWQuXHJcbiAgICAgKiBAcGFyYW0gdXNlU2hhcmVkSW5zdGFuY2UtIFVzZSBhIHNoYXJlZCBpbnN0YW5jZSBpZiB0cnVlLCBjcmVhdGUgYSBuZXcgaW5zdGFuY2UgaWYgZmFsc2UuXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIExvYWRNb2R1bGVJbnN0YW5jZShtb2R1bGVOYW1lOiBzdHJpbmcsIHVzZVNoYXJlZEluc3RhbmNlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8T2JqZWN0PiB7XHJcbiAgICAgICAgY29uc3Qgczogc3RyaW5nID0gbW9kdWxlTmFtZS5zdWJzdHIobW9kdWxlTmFtZS5sYXN0SW5kZXhPZignLicpICsgMSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX21vZHVsZXMuaGFzKG1vZHVsZU5hbWUpKSB7XHJcbiAgICAgICAgICAgIGxldCBvOiBhbnkgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIXVzZVNoYXJlZEluc3RhbmNlKSAge1xyXG4gICAgICAgICAgICAgICAgbyA9IG5ldyAoPGFueT5NaWNyb3NvZnQuTWFwcylbc10odGhpcy5fbWFwSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX21vZHVsZXMuZ2V0KG1vZHVsZU5hbWUpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG8gPSB0aGlzLl9tb2R1bGVzLmdldChtb2R1bGVOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG8gPSBuZXcgKDxhbnk+TWljcm9zb2Z0Lk1hcHMpW3NdKHRoaXMuX21hcEluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vZHVsZXMuc2V0KG1vZHVsZU5hbWUsIG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8T2JqZWN0PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMubG9hZE1vZHVsZShtb2R1bGVOYW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbyA9IG5ldyAoPGFueT5NaWNyb3NvZnQuTWFwcylbc10odGhpcy5fbWFwSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VTaGFyZWRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb2R1bGVzLnNldChtb2R1bGVOYW1lLCBvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21vZHVsZXMuc2V0KG1vZHVsZU5hbWUsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG8pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCdDb3VsZCBub3QgbG9hZCBtb2R1bGUgb3IgY3JlYXRlIGluc3RhbmNlLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm92aWRlcyBhIGNvbnZlcnNpb24gb2YgZ2VvIGNvb3JkaW5hdGVzIHRvIHBpeGVscyBvbiB0aGUgbWFwIGNvbnRyb2wuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvYyAtIFRoZSBnZW8gY29vcmRpbmF0ZXMgdG8gdHJhbnNsYXRlLlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGFuIHtAbGluayBJUG9pbnR9IGludGVyZmFjZSByZXByZXNlbnRpbmcgdGhlIHBpeGVscy4gVGhpcyBwcm9taXNlIHJlc29sdmVzIHRvIG51bGxcclxuICAgICAqIGlmIHRoZSBnb2UgY29vcmRpbmF0ZXMgYXJlIG5vdCBpbiB0aGUgdmlldyBwb3J0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgTG9jYXRpb25Ub1BvaW50KGxvYzogSUxhdExvbmcpOiBQcm9taXNlPElQb2ludD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobTogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGw6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKGxvYyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHA6IE1pY3Jvc29mdC5NYXBzLlBvaW50ID0gPE1pY3Jvc29mdC5NYXBzLlBvaW50Pm0udHJ5TG9jYXRpb25Ub1BpeGVsKGwsIE1pY3Jvc29mdC5NYXBzLlBpeGVsUmVmZXJlbmNlLmNvbnRyb2wpO1xyXG4gICAgICAgICAgICBpZiAocCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBwLngsIHk6IHAueSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgYSBjb252ZXJzaW9uIG9mIGdlbyBjb29yZGluYXRlcyB0byBwaXhlbHMgb24gdGhlIG1hcCBjb250cm9sLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2MgLSBUaGUgZ2VvIGNvb3JkaW5hdGVzIHRvIHRyYW5zbGF0ZS5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhbiB7QGxpbmsgSVBvaW50fSBpbnRlcmZhY2UgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBMb2NhdGlvbnNUb1BvaW50cyhsb2NzOiBBcnJheTxJTGF0TG9uZz4pOiBQcm9taXNlPEFycmF5PElQb2ludD4+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG06IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsID0gbG9jcy5tYXAobG9jID0+IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVMb2NhdGlvbihsb2MpKTtcclxuICAgICAgICAgICAgY29uc3QgcDogQXJyYXk8TWljcm9zb2Z0Lk1hcHMuUG9pbnQ+ID0gPEFycmF5PE1pY3Jvc29mdC5NYXBzLlBvaW50Pj5tLnRyeUxvY2F0aW9uVG9QaXhlbChsLFxyXG4gICAgICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuUGl4ZWxSZWZlcmVuY2UuY29udHJvbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwID8gcCA6IG5ldyBBcnJheTxJUG9pbnQ+KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDZW50ZXJzIHRoZSBtYXAgb24gYSBnZW8gbG9jYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxhdExuZyAtIEdlb0Nvb3JkaW5hdGVzIGFyb3VuZCB3aGljaCB0byBjZW50ZXIgdGhlIG1hcC4gU2VlIHtAbGluayBJTGF0TG9uZ31cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgY2VudGVyIG9wZXJhdGlvbnMgaGFzIGJlZW4gY29tcGxldGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0Q2VudGVyKGxhdExuZzogSUxhdExvbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiBtYXAuc2V0Vmlldyh7XHJcbiAgICAgICAgICAgIGNlbnRlcjogQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKGxhdExuZylcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBnZW5lcmljIG1hcCBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRNYXBPcHRpb25zKG9wdGlvbnM6IElNYXBPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwLnRoZW4oKG06IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JTWFwT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBtLnNldE9wdGlvbnMobyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB2aWV3IG9wdGlvbnMgb2YgdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0Vmlld09wdGlvbnMob3B0aW9uczogSU1hcE9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9tYXAudGhlbigobTogTWljcm9zb2Z0Lk1hcHMuTWFwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklWaWV3T3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVWaWV3T3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgbS5zZXRWaWV3KG8pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB6b29tIC0gWm9vbSBsZXZlbCB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgUHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgb25jZSB0aGUgem9vbSBvcGVyYXRpb24gaXMgY29tcGxldGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRab29tKHpvb206IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IG1hcC5zZXRWaWV3KHtcclxuICAgICAgICAgICAgem9vbTogem9vbVxyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZXZlbnQgc3Vic2NyaXB0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCAoZS5nLiAnY2xpY2snKVxyXG4gICAgICogQHJldHVybnMgLSBBbiBvYnNlcnZhYmxlIG9mIHRweWUgRSB0aGF0IGZpcmVzIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFN1YnNjcmliZVRvTWFwRXZlbnQ8RT4oZXZlbnROYW1lOiBzdHJpbmcpOiBPYnNlcnZhYmxlPEU+IHtcclxuICAgICAgICBjb25zdCBldmVudE5hbWVUcmFuc2xhdGVkID0gQmluZ01hcEV2ZW50c0xvb2t1cFtldmVudE5hbWVdO1xyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPEU+KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcC50aGVuKChtOiBNaWNyb3NvZnQuTWFwcy5NYXApID0+IHtcclxuICAgICAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKG0sIGV2ZW50TmFtZVRyYW5zbGF0ZWQsIChlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJzIHRoZSBnaXZlbiBldmVudCBuYW1lIG9uIHRoZSBtYXAgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIEV2ZW50IHRvIHRyaWdnZXIuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgb25jZSB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVHJpZ2dlck1hcEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtKSA9PiBNaWNyb3NvZnQuTWFwcy5FdmVudHMuaW52b2tlKG0sIGV2ZW50TmFtZSwgbnVsbCkpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcclxuaW1wb3J0IHsgQmluZ01hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctbWFya2VyJztcclxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbGF5ZXInO1xyXG5pbXBvcnQgeyBNYXJrZXJUeXBlSWQgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyLXR5cGUtaWQnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbWFwLWxheWVyJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLW1hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0NvbnZlcnNpb25zIH0gZnJvbSAnLi9iaW5nLWNvbnZlcnNpb25zJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGFic3RyYWN0IHBhcnRpYWxseSBpbXBsZW1lbnRzIHRoZSBjb250cmFjdCBmb3IgdGhlIHtAbGluayBMYXllclNlcnZpY2V9XHJcbiAqIGFuZCB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9IGZvciB0aGUgQmluZyBNYXBzIFY4IGFyY2h0aWVjdHVyZS4gSXQgc2VydmVzXHJcbiAqIGFzIHRoZSBiYXNlIGNsYXNzIGZvciBiYXNpYyBsYXllciAoe0BsaW5rIEJpbmdMYXllclNlcnZpY2V9KSBhbmQgY2x1c3RlciBsYXllciAoe0BsaW5rIEJpbmdDbHVzdGVyTGF5ZXJ9KS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCaW5nTGF5ZXJCYXNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIHByb3RlY3RlZCBfbGF5ZXJzOiBNYXA8bnVtYmVyLCBQcm9taXNlPExheWVyPj4gPSBuZXcgTWFwPG51bWJlciwgUHJvbWlzZTxMYXllcj4+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nTGF5ZXJCYXNlLlxyXG4gICAgICogQHBhcmFtIF9tYXBTZXJ2aWNlIC0gQ29uY3JldGUge0BsaW5rIE1hcFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciBCaW5nIE1hcHMgVjguIEFuIGluc3RhbmNlIG9mIHtAbGluayBCaW5nTWFwU2VydmljZX0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllckJhc2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBwcm90ZWN0ZWQgX3pvbmU6IE5nWm9uZSkgeyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGxheWVyIHRvIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAgICogR2VuZXJhbGx5LCBNYXBMYXllckRpcmVjdGl2ZSB3aWxsIGJlIGluamVjdGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAgKiBMYXllclNlcnZpY2UgYW5kIHRoZW4gc2VsZiByZWdpc3RlciBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyQmFzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgQWRkTGF5ZXIobGF5ZXI6IE1hcExheWVyRGlyZWN0aXZlKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtYXJrZXIgaW4gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBJZCBvZiB0aGUgbGF5ZXIgaW4gd2hpY2ggdG8gY3JlYXRlIHRoZSBtYXJrZXIuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJTWFya2VyT3B0aW9uc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcmtlciBwcm9wZXJ0aWVzLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBNYXJrZXJ9IG1vZGVsIGZvciB0aGUgY3JlYXRlZCBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllckJhc2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZU1hcmtlcihsYXllcjogbnVtYmVyLCBvcHRpb25zOiBJTWFya2VyT3B0aW9ucyk6IFByb21pc2U8TWFya2VyPiB7XHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IChpY29uOiBzdHJpbmcsIGw6IExheWVyKTogQmluZ01hcmtlciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYzogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb24ob3B0aW9ucy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVNYXJrZXJPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoaWNvbiAmJiBpY29uICE9PSAnJykgeyBvLmljb24gPSBpY29uOyB9XHJcbiAgICAgICAgICAgIGNvbnN0IHB1c2hwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbihsb2MsIG8pO1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXI6IEJpbmdNYXJrZXIgPSBuZXcgQmluZ01hcmtlcihwdXNocGluLCBudWxsLCBsLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICAgICAgbWFya2VyLklzRmlyc3QgPSBvcHRpb25zLmlzRmlyc3Q7XHJcbiAgICAgICAgICAgIG1hcmtlci5Jc0xhc3QgPSBvcHRpb25zLmlzTGFzdDtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHsgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKCh2LCBrKSA9PiBtYXJrZXIuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxyXG4gICAgICAgICAgICBsLkFkZEVudGl0eShtYXJrZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWFya2VyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLkdldExheWVyQnlJZChsYXllcik7XHJcbiAgICAgICAgaWYgKHAgPT0gbnVsbCkgeyB0aHJvdyAobmV3IEVycm9yKGBMYXllciB3aXRoIGlkICR7bGF5ZXJ9IG5vdCBmb3VuZCBpbiBMYXllciBNYXBgKSk7IH1cclxuICAgICAgICByZXR1cm4gcC50aGVuKChsOiBMYXllcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pY29uSW5mbyAmJiBvcHRpb25zLmljb25JbmZvLm1hcmtlclR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBNYXJrZXIuQ3JlYXRlTWFya2VyKG9wdGlvbnMuaWNvbkluZm8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihzKSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuKHBheWxvYWQocywgbCkpOyB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy50aGVuKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ocGF5bG9hZCh4Lmljb24sIGwpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAocGF5bG9hZChudWxsLCBsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBtYXJrZXJzLiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGFycmF5cyBvZiBtYXJrZXJzIHRvIGJlIHVzZWQgaW4gYnVsa1xyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE1hcmtlciBvcHRpb25zIGRlZmluaW5nIHRoZSBtYXJrZXJzLlxyXG4gICAgICogQHBhcmFtIG1hcmtlckljb24gLSBPcHRpb25hbCBpbmZvcm1hdGlvbiB0byBnZW5lcmF0ZSBjdXN0b20gbWFya2Vycy4gVGhpcyB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIG1hcmtlcnMuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gYXJyYXlzIG9mIHRoZSBNYXJrZXIgbW9kZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJCYXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVNYXJrZXJzKG9wdGlvbnM6IEFycmF5PElNYXJrZXJPcHRpb25zPiwgbWFya2VySWNvbj86IElNYXJrZXJJY29uSW5mbyk6IFByb21pc2U8QXJyYXk8TWFya2VyPj4ge1xyXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSAoaWNvbjogc3RyaW5nLCBvcDogQXJyYXk8SU1hcmtlck9wdGlvbnM+KTogQXJyYXk8QmluZ01hcmtlcj4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXJzOiBBcnJheTxCaW5nTWFya2VyPiA9IG9wLm1hcChtbyA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgczogc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZU1hcmtlck9wdGlvbnMobW8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGljb24gJiYgaWNvbiAhPT0gJycgKSB7IHMgPSBpY29uOyB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvLmljb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gby5pY29uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG8uaWNvbikgeyBkZWxldGUgby5pY29uOyB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2M6IE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uKG1vLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHB1c2hwaW46IE1pY3Jvc29mdC5NYXBzLlB1c2hwaW4gPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUHVzaHBpbihsb2MsIG8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW1nID0gTWFya2VyLkdldEltYWdlRm9yTWFya2VyKHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGltZyAhPSBudWxsKSB7ICg8YW55PnB1c2hwaW4pLmltYWdlID0gaW1nOyB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWFya2VyOiBCaW5nTWFya2VyID0gbmV3IEJpbmdNYXJrZXIocHVzaHBpbiwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuSXNGaXJzdCA9IG1vLmlzRmlyc3Q7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuSXNMYXN0ID0gbW8uaXNMYXN0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vLm1ldGFkYXRhKSB7IG1vLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IG1hcmtlci5NZXRhZGF0YS5zZXQoaywgdikpOyB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hcmtlcnM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBwOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+ID0gbmV3IFByb21pc2U8QXJyYXk8TWFya2VyPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWFya2VySWNvbiAmJiBtYXJrZXJJY29uLm1hcmtlclR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBNYXJrZXIuQ3JlYXRlTWFya2VyKG1hcmtlckljb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihzKSA9PT0gJ3N0cmluZycpIHsgcmVzb2x2ZShwYXlsb2FkKHMsIG9wdGlvbnMpKTsgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMudGhlbih4ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwYXlsb2FkKHguaWNvbiwgb3B0aW9ucykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShwYXlsb2FkKG51bGwsIG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgbGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgbGF5ZXIgaGFzIGJlZW4gcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyQmFzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlTGF5ZXIobGF5ZXI6IE1hcExheWVyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuX2xheWVycy5nZXQobGF5ZXIuSWQpO1xyXG4gICAgICAgIGlmIChsID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbC50aGVuKChsMTogTGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGwxLkRlbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLmRlbGV0ZShsYXllci5JZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgTGF5ZXIgbW9kZWwgcmVwcmVzZW50ZWQgYnkgdGhpcyBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IG9yIExheWVyIElkIGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIgbW9kZWwuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gcmVzb2x2ZWQgY29udGFpbnMgdGhlIExheWVyIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJCYXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXROYXRpdmVMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmV8bnVtYmVyKTogUHJvbWlzZTxMYXllcj4ge1xyXG4gICAgICAgIGxldCBwOiBQcm9taXNlPExheWVyPiA9IG51bGw7XHJcbiAgICAgICAgaWYgKHR5cGVvZihsYXllcikgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHAgPSB0aGlzLl9sYXllcnMuZ2V0KGxheWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHAgPSB0aGlzLl9sYXllcnMuZ2V0KCg8TWFwTGF5ZXJEaXJlY3RpdmU+bGF5ZXIpLklkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvdGVjdGVkIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbGF5ZXIgYmFzZWQgb24gaXRzIGlkLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSBpZCAtIExheWVyIElkLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHtAbGluayBMYXllcn0gbW9kZWwgZm9yIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyQmFzZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgR2V0TGF5ZXJCeUlkKGlkOiBudW1iZXIpOiBQcm9taXNlPExheWVyPiB7XHJcbiAgICAgICAgbGV0IHA6IFByb21pc2U8TGF5ZXI+O1xyXG4gICAgICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKChsOiBQcm9taXNlPExheWVyPiwgazogbnVtYmVyKSA9PiB7IGlmIChrID09PSBpZCkgeyBwID0gbDsgfSB9KTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBCaW5nTWFya2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2JpbmcvYmluZy1tYXJrZXInO1xyXG5pbXBvcnQgeyBCaW5nUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctcG9seWdvbic7XHJcbmltcG9ydCB7IEJpbmdQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9iaW5nL2JpbmctcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IE1hcmtlclR5cGVJZCB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXItdHlwZS1pZCc7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcExheWVyRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9tYXAtbGF5ZXInO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuL2JpbmctbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCaW5nTGF5ZXJCYXNlIH0gZnJvbSAnLi9iaW5nLWxheWVyLWJhc2UnO1xyXG5pbXBvcnQgeyBCaW5nQ29udmVyc2lvbnMgfSBmcm9tICcuL2JpbmctY29udmVyc2lvbnMnO1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBMYXllclNlcnZpY2V9IGNvbnRyYWN0IGZvciBhICBCaW5nIE1hcHMgVjggc3BlY2lmaWMgaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEJpbmdMYXllclNlcnZpY2UgZXh0ZW5kcyBCaW5nTGF5ZXJCYXNlIGltcGxlbWVudHMgTGF5ZXJTZXJ2aWNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmdMYXllclNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSBJbnN0YW5jZSBvZiB0aGUgQmluZyBNYXBzIFNlcnZpY2UuIFdpbGwgZ2VuZXJhbGx5IGJlIGluamVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gTmdab25lIGluc3RhbmNlIHRvIHByb3ZpZGUgem9uZSBhd2FyZSBwcm9taXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihfbWFwU2VydmljZTogTWFwU2VydmljZSwgX3pvbmU6IE5nWm9uZSkge1xyXG4gICAgICAgIHN1cGVyKF9tYXBTZXJ2aWNlLCBfem9uZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbGF5ZXIgdG8gdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYXllciAtIE1hcExheWVyRGlyZWN0aXZlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICAgKiBHZW5lcmFsbHksIE1hcExheWVyRGlyZWN0aXZlIHdpbGwgYmUgaW5qZWN0ZWQgd2l0aCBhbiBpbnN0YW5jZSBvZiB0aGVcclxuICAgICAqIExheWVyU2VydmljZSBhbmQgdGhlbiBzZWxmIHJlZ2lzdGVyIG9uIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTGF5ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmUpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBsYXllclByb21pc2UgPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZUxheWVyKHsgaWQ6IGxheWVyLklkIH0pO1xyXG4gICAgICAgIHRoaXMuX2xheWVycy5zZXQobGF5ZXIuSWQsIGxheWVyUHJvbWlzZSk7XHJcbiAgICAgICAgbGF5ZXJQcm9taXNlLnRoZW4obCA9PiBsLlNldFZpc2libGUobGF5ZXIuVmlzaWJsZSkpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBwb2x5Z29uIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5Z29uLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5Z29uIG9wdGlvbnMgZGVmaW5pbmcgdGhlIHBvbHlnb24uXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIFBvbHlnb24gbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb24obGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5Z29uPiB7XHJcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLkdldExheWVyQnlJZChsYXllcik7XHJcbiAgICAgICAgaWYgKHAgPT0gbnVsbCkgeyB0aHJvdyAobmV3IEVycm9yKGBMYXllciB3aXRoIGlkICR7bGF5ZXJ9IG5vdCBmb3VuZCBpbiBMYXllciBNYXBgKSk7IH1cclxuICAgICAgICByZXR1cm4gcC50aGVuKChsOiBMYXllcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBsb2NzOiBBcnJheTxBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4+ID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBhdGhzKG9wdGlvbnMucGF0aHMpO1xyXG4gICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUG9seWxpbmVPcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBvbHlnb25PcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5OiBNaWNyb3NvZnQuTWFwcy5Qb2x5Z29uID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvbHlnb24obG9jcywgbyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvbHlnb246IFBvbHlnb24gPSBuZXcgQmluZ1BvbHlnb24ocG9seSwgPEJpbmdNYXBTZXJ2aWNlPnRoaXMuX21hcFNlcnZpY2UsIGwuTmF0aXZlUHJpbWl0dmUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHsgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKCh2LCBrKSA9PiBwb2x5Z29uLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgJiYgb3B0aW9ucy50aXRsZSAhPT0gJycpIHtwb2x5Z29uLlRpdGxlID0gb3B0aW9ucy50aXRsZTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93TGFiZWwgIT0gbnVsbCkgeyBwb2x5Z29uLlNob3dMYWJlbCA9IG9wdGlvbnMuc2hvd0xhYmVsOyB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dUb29sdGlwICE9IG51bGwpIHsgcG9seWdvbi5TaG93VG9vbHRpcCA9IG9wdGlvbnMuc2hvd1Rvb2x0aXA7IH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGFiZWxNYXhab29tICE9IG51bGwpIHsgcG9seWdvbi5MYWJlbE1heFpvb20gPSBvcHRpb25zLmxhYmVsTWF4Wm9vbTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sYWJlbE1pblpvb20gIT0gbnVsbCkgeyBwb2x5Z29uLkxhYmVsTWluWm9vbSA9IG9wdGlvbnMubGFiZWxNaW5ab29tOyB9XHJcbiAgICAgICAgICAgIGwuQWRkRW50aXR5KHBvbHlnb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gcG9seWdvbjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBwb2x5Z29ucy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWdvbnMgdG8gYmUgdXNlZCBpbiBidWxrXHJcbiAgICAgKiBvcGVyYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5Z29uLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5Z29uIG9wdGlvbnMgZGVmaW5pbmcgdGhlIHBvbHlnb25zLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGFycmF5cyBvZiB0aGUgUG9seWdvbiBtb2RlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb25zKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlnb24+PiB7XHJcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLkdldExheWVyQnlJZChsYXllcik7XHJcbiAgICAgICAgaWYgKHAgPT0gbnVsbCkgeyB0aHJvdyAobmV3IEVycm9yKGBMYXllciB3aXRoIGlkICR7bGF5ZXJ9IG5vdCBmb3VuZCBpbiBMYXllciBNYXBgKSk7IH1cclxuICAgICAgICByZXR1cm4gcC50aGVuKChsOiBMYXllcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5Z29uczogUHJvbWlzZTxBcnJheTxQb2x5Z29uPj4gPSBuZXcgUHJvbWlzZTxBcnJheTxQb2x5Z29uPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9seXM6IEFycmF5PEJpbmdQb2x5Z29uPiA9IG9wdGlvbnMubWFwKG8gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY3M6IEFycmF5PEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPj4gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUGF0aHMoby5wYXRocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3A6IE1pY3Jvc29mdC5NYXBzLklQb2x5bGluZU9wdGlvbnMgPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWdvbk9wdGlvbnMobyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9seTogTWljcm9zb2Z0Lk1hcHMuUG9seWdvbiA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2x5Z29uKGxvY3MsIG9wKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5Z29uOiBCaW5nUG9seWdvbiA9IG5ldyBCaW5nUG9seWdvbihwb2x5LCA8QmluZ01hcFNlcnZpY2U+dGhpcy5fbWFwU2VydmljZSwgbC5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8udGl0bGUgJiYgby50aXRsZSAhPT0gJycpIHsgcG9seWdvbi5UaXRsZSA9IG8udGl0bGU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoby5tZXRhZGF0YSkgeyBvLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHBvbHlnb24uTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5Z29uO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHBvbHlzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29ucztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBwb2x5bGluZSB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgbGluZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgbGluZS5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgUG9seWxpbmUgKG9yIGFuIGFycmF5XHJcbiAgICAgKiBvZiBwb2x5Z29ucyBmb3IgY29tcGxleCBwYXRocykgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4ge1xyXG4gICAgICAgIGNvbnN0IHA6IFByb21pc2U8TGF5ZXI+ID0gdGhpcy5HZXRMYXllckJ5SWQobGF5ZXIpO1xyXG4gICAgICAgIGxldCBwb2x5bGluZTogTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmU7XHJcbiAgICAgICAgbGV0IGxpbmU6IFBvbHlsaW5lO1xyXG4gICAgICAgIGlmIChwID09IG51bGwpIHsgdGhyb3cgKG5ldyBFcnJvcihgTGF5ZXIgd2l0aCBpZCAke2xheWVyfSBub3QgZm91bmQgaW4gTGF5ZXIgTWFwYCkpOyB9XHJcbiAgICAgICAgcmV0dXJuIHAudGhlbigobDogTGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbG9jczogQXJyYXk8QXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+PiA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQYXRocyhvcHRpb25zLnBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBvOiBNaWNyb3NvZnQuTWFwcy5JUG9seWxpbmVPcHRpb25zID0gQmluZ0NvbnZlcnNpb25zLlRyYW5zbGF0ZVBvbHlsaW5lT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGF0aCAmJiBvcHRpb25zLnBhdGgubGVuZ3RoID4gMCAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGhbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICBwb2x5bGluZSA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZShsb2NzWzBdLCBvKTtcclxuICAgICAgICAgICAgICAgIGxpbmUgPSBuZXcgQmluZ1BvbHlsaW5lKHBvbHlsaW5lLCB0aGlzLl9tYXBTZXJ2aWNlLk1hcEluc3RhbmNlLCBsLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICAgICAgICAgIGwuQWRkRW50aXR5KGxpbmUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7IG9wdGlvbnMubWV0YWRhdGEuZm9yRWFjaCgodiwgaykgPT4gbGluZS5NZXRhZGF0YS5zZXQoaywgdikpOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAmJiBvcHRpb25zLnRpdGxlICE9PSAnJykge2xpbmUuVGl0bGUgPSBvcHRpb25zLnRpdGxlOyB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93VG9vbHRpcCAhPSBudWxsKSB7IGxpbmUuU2hvd1Rvb2x0aXAgPSBvcHRpb25zLnNob3dUb29sdGlwOyB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzOiBBcnJheTxQb2x5bGluZT4gPSBuZXcgQXJyYXk8UG9seWxpbmU+KCk7XHJcbiAgICAgICAgICAgICAgICBsb2NzLmZvckVhY2goeCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWxpbmUgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9seWxpbmUoeCwgbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IG5ldyBCaW5nUG9seWxpbmUocG9seWxpbmUsIHRoaXMuX21hcFNlcnZpY2UuTWFwSW5zdGFuY2UsIGwuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGwuQWRkRW50aXR5KGxpbmUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IGxpbmUuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpdGxlICYmIG9wdGlvbnMudGl0bGUgIT09ICcnKSB7bGluZS5UaXRsZSA9IG9wdGlvbnMudGl0bGU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93VG9vbHRpcCAhPSBudWxsKSB7IGxpbmUuU2hvd1Rvb2x0aXAgPSBvcHRpb25zLnNob3dUb29sdGlwOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChsaW5lKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuYm91bmQgcG9seWxpbmVzLiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGFycmF5cyBvZiBwb2x5bGluZXMgdG8gYmUgdXNlZCBpbiBidWxrXHJcbiAgICAgKiBvcGVyYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5bGluZXMuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlsaW5lIG9wdGlvbnMgZGVmaW5pbmcgdGhlIHBvbHlsaW5lcy5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBhcnJheXMgb2YgdGhlIFBvbHlsaW5lIG1vZGVscy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0xheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWxpbmVzKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5bGluZU9wdGlvbnM+KTogUHJvbWlzZTxBcnJheTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+PiB7XHJcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLkdldExheWVyQnlJZChsYXllcik7XHJcbiAgICAgICAgaWYgKHAgPT0gbnVsbCkgeyB0aHJvdyAobmV3IEVycm9yKGBMYXllciB3aXRoIGlkICR7bGF5ZXJ9IG5vdCBmb3VuZCBpbiBMYXllciBNYXBgKSk7IH1cclxuICAgICAgICByZXR1cm4gcC50aGVuKChsOiBMYXllcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5bGluZXM6IFByb21pc2U8QXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4gPSBuZXcgUHJvbWlzZTxBcnJheTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2x5czogQXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+PiA9IG9wdGlvbnMubWFwKG8gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY3M6IEFycmF5PEFycmF5PE1pY3Jvc29mdC5NYXBzLkxvY2F0aW9uPj4gPSBCaW5nQ29udmVyc2lvbnMuVHJhbnNsYXRlUGF0aHMoby5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcDogTWljcm9zb2Z0Lk1hcHMuSVBvbHlsaW5lT3B0aW9ucyA9IEJpbmdDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5bGluZU9wdGlvbnMobyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY3MgJiYgbG9jcy5sZW5ndGggPiAwICYmICFBcnJheS5pc0FycmF5KGxvY3NbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvbHk6IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lID0gbmV3IE1pY3Jvc29mdC5NYXBzLlBvbHlsaW5lKGxvY3NbMF0sIG9wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9seWxpbmU6IEJpbmdQb2x5bGluZSA9IG5ldyBCaW5nUG9seWxpbmUocG9seSwgdGhpcy5fbWFwU2VydmljZS5NYXBJbnN0YW5jZSwgbC5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnRpdGxlICYmIG8udGl0bGUgIT09ICcnKSB7IHBvbHlsaW5lLlRpdGxlID0gby50aXRsZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5tZXRhZGF0YSkgeyBvLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHBvbHlsaW5lLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZXM6IEFycmF5PFBvbHlsaW5lPiA9IG5ldyBBcnJheTxQb2x5bGluZT4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jcy5mb3JFYWNoKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9seSA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2x5bGluZSh4LCBvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5bGluZTogQmluZ1BvbHlsaW5lID0gbmV3IEJpbmdQb2x5bGluZShwb2x5LCB0aGlzLl9tYXBTZXJ2aWNlLk1hcEluc3RhbmNlLCBsLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLm1ldGFkYXRhKSB7IG8ubWV0YWRhdGEuZm9yRWFjaCgodiwgaykgPT4gcG9seWxpbmUuTWV0YWRhdGEuc2V0KGssIHYpKTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8udGl0bGUgJiYgby50aXRsZSAhPT0gJycpIHtwb2x5bGluZS5UaXRsZSA9IG8udGl0bGU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gocG9seWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShwb2x5cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcG9seWxpbmVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcclxuaW1wb3J0IHsgSUNsdXN0ZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pY2x1c3Rlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSU1hcmtlckljb25JbmZvIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLWljb24taW5mbyc7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlnb24nO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5bGluZSc7XHJcbmltcG9ydCB7IEJpbmdNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLW1hcmtlcic7XHJcbmltcG9ydCB7IEJpbmdDbHVzdGVyTGF5ZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmluZy9iaW5nLWNsdXN0ZXItbGF5ZXInO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IE1hcmtlclR5cGVJZCB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXItdHlwZS1pZCc7XHJcbmltcG9ydCB7IENsdXN0ZXJDbGlja0FjdGlvbiB9IGZyb20gJy4uLy4uL21vZGVscy9jbHVzdGVyLWNsaWNrLWFjdGlvbic7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IENsdXN0ZXJMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvY2x1c3Rlci1sYXllcic7XHJcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0xheWVyQmFzZSB9IGZyb20gJy4vYmluZy1sYXllci1iYXNlJztcclxuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2UgfSBmcm9tICcuL2JpbmctbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCaW5nQ29udmVyc2lvbnMgfSBmcm9tICcuL2JpbmctY29udmVyc2lvbnMnO1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBDbHVzdGVyU2VydmljZX0gY29udHJhY3QgZm9yIGEgIEJpbmcgTWFwcyBWOCBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbi5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQmluZ0NsdXN0ZXJTZXJ2aWNlIGV4dGVuZHMgQmluZ0xheWVyQmFzZSBpbXBsZW1lbnRzIENsdXN0ZXJTZXJ2aWNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmdDbHVzdGVyU2VydmljZS5cclxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIENvbmNyZXRlIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgQmluZyBNYXBzIFY4LiBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgQmluZ01hcFNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gTmdab25lIGluc3RhbmNlIHRvIHByb3ZpZGUgem9uZSBhd2FyZSBwcm9taXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBfem9uZTogTmdab25lKSB7XHJcbiAgICAgICAgc3VwZXIoX21hcFNlcnZpY2UsIF96b25lKTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbGF5ZXIgdG8gdGhlIG1hcC5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYXllciAtIENsdXN0ZXJMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAgICogR2VuZXJhbGx5LCBNYXBMYXllciB3aWxsIGJlIGluamVjdGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAgKiBMYXllclNlcnZpY2UgYW5kIHRoZW4gc2VsZiByZWdpc3RlciBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMYXllcihsYXllcjogQ2x1c3RlckxheWVyRGlyZWN0aXZlKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uczogSUNsdXN0ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogbGF5ZXIuSWQsXHJcbiAgICAgICAgICAgIHZpc2libGU6IGxheWVyLlZpc2libGUsXHJcbiAgICAgICAgICAgIGNsdXN0ZXJpbmdFbmFibGVkOiBsYXllci5DbHVzdGVyaW5nRW5hYmxlZCxcclxuICAgICAgICAgICAgcGxhY2VtZW50TW9kZTogbGF5ZXIuQ2x1c3RlclBsYWNlbWVudE1vZGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChsYXllci5HcmlkU2l6ZSkgeyBvcHRpb25zLmdyaWRTaXplID0gbGF5ZXIuR3JpZFNpemU7IH1cclxuICAgICAgICBpZiAobGF5ZXIuTGF5ZXJPZmZzZXQpIHsgb3B0aW9ucy5sYXllck9mZnNldCA9IGxheWVyLkxheWVyT2Zmc2V0OyB9XHJcbiAgICAgICAgaWYgKGxheWVyLlpJbmRleCkgeyBvcHRpb25zLnpJbmRleCA9IGxheWVyLlpJbmRleDsgfVxyXG4gICAgICAgIGlmIChsYXllci5JY29uSW5mbykge1xyXG4gICAgICAgICAgICBvcHRpb25zLmNsdXN0ZXJlZFBpbkNhbGxiYWNrID0gKHBpbjogTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclB1c2hwaW4pID0+IHsgdGhpcy5DcmVhdGVDbHVzdGVyUHVzaFBpbihwaW4sIGxheWVyKTsgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxheWVyLkN1c3RvbU1hcmtlckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY2x1c3RlcmVkUGluQ2FsbGJhY2sgPSAocGluOiBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbikgPT4geyB0aGlzLkNyZWF0ZUN1c3RvbUNsdXN0ZXJQdXNoUGluKHBpbiwgbGF5ZXIpOyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGF5ZXIuU3BpZGVyQ2x1c3Rlck9wdGlvbnMpIHsgb3B0aW9ucy5zcGlkZXJDbHVzdGVyT3B0aW9ucyA9IGxheWVyLlNwaWRlckNsdXN0ZXJPcHRpb25zOyB9XHJcblxyXG4gICAgICAgIGNvbnN0IGxheWVyUHJvbWlzZTogUHJvbWlzZTxMYXllcj4gPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZUNsdXN0ZXJMYXllcihvcHRpb25zKTtcclxuICAgICAgICAoPEJpbmdNYXBTZXJ2aWNlPnRoaXMuX21hcFNlcnZpY2UpLk1hcFByb21pc2UudGhlbihtID0+IHtcclxuICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIobSwgJ3ZpZXdjaGFuZ2VlbmQnLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLkNsdXN0ZXJpbmdFbmFibGVkICYmIG0uZ2V0Wm9vbSgpID09PSAxOSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyUHJvbWlzZS50aGVuKChsOiBCaW5nQ2x1c3RlckxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGwuU2V0T3B0aW9ucyh7IGlkOiBsYXllci5JZCwgY2x1c3RlcmluZ0VuYWJsZWQ6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLkNsdXN0ZXJpbmdFbmFibGVkICYmIG0uZ2V0Wm9vbSgpIDwgMTkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXllclByb21pc2UudGhlbigobDogQmluZ0NsdXN0ZXJMYXllcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWwuR2V0T3B0aW9ucygpLmNsdXN0ZXJpbmdFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsLlNldE9wdGlvbnMoeyBpZDogbGF5ZXIuSWQsIGNsdXN0ZXJpbmdFbmFibGVkOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2xheWVycy5zZXQobGF5ZXIuSWQsIGxheWVyUHJvbWlzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWdvbiB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWdvbi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWdvbiBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5Z29uLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGluc3RhbmNlIG9mIHRoZSBQb2x5Z29uIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb24obGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5Z29uPiB7XHJcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignUG9seWdvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY2x1c3RlcmluZyBsYXllcnMuIFlvdSBjYW4gb25seSB1c2UgbWFya2Vycy4nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuYm91bmQgcG9seWdvbnMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIHBvbHlnb25zIHRvIGJlIHVzZWQgaW4gYnVsa1xyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWdvbi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWdvbiBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5Z29ucy5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBhcnJheXMgb2YgdGhlIFBvbHlnb24gbW9kZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb25zKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlnb24+PiB7XHJcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignUG9seWdvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY2x1c3RlcmluZyBsYXllcnMuIFlvdSBjYW4gb25seSB1c2UgbWFya2Vycy4nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWxpbmUgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIGxpbmUuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlsaW5lIG9wdGlvbnMgZGVmaW5pbmcgdGhlIGxpbmUuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIFBvbHlsaW5lIChvciBhbiBhcnJheVxyXG4gICAgICogb2YgcG9seWdvbnMgZm9yIGNvbXBsZXggcGF0aHMpIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4ge1xyXG4gICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1BvbHlsaW5lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBjbHVzdGVyaW5nIGxheWVycy4gWW91IGNhbiBvbmx5IHVzZSBtYXJrZXJzLicpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBwb2x5bGluZXMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIHBvbHlsaW5lcyB0byBiZSB1c2VkIGluIGJ1bGtcclxuICAgICAqIG9wZXJhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIHBvbHlsaW5lcy5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWxpbmVzLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGFycmF5cyBvZiB0aGUgUG9seWxpbmUgbW9kZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lcyhsYXllcjogbnVtYmVyLCBvcHRpb25zOiBBcnJheTxJUG9seWxpbmVPcHRpb25zPik6IFByb21pc2U8QXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4ge1xyXG4gICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1BvbHlsaW5lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBjbHVzdGVyaW5nIGxheWVycy4gWW91IGNhbiBvbmx5IHVzZSBtYXJrZXJzLicpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGUgaW5pdGlhbCBzZXQgb2YgZW50aXRpZXNcclxuICAgICAqIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgY2x1c3Rlci4gVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBhcyBhZGRpbmcgYW4gZW50aXRpeSB3aWxsIHJlY2FsY3VsYXRlIGFsbCBjbHVzdGVycy5cclxuICAgICAqIEFzIHN1Y2gsIFN0b3BDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGFkZGluZyBtYW55IGVudGl0aWVzIGFuZCBTdGFydENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBvbmNlIGFkZGluZyBpc1xyXG4gICAgICogY29tcGxldGUgdG8gcmVjYWxjdWxhdGUgdGhlIGNsdXN0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIENsdXN0ZXJMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdDbHVzdGVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU3RhcnRDbHVzdGVyaW5nKGxheWVyOiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBsID0gdGhpcy5fbGF5ZXJzLmdldChsYXllci5JZCk7XHJcbiAgICAgICAgaWYgKGwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsLnRoZW4oKGwxOiBCaW5nQ2x1c3RlckxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsMS5TdGFydENsdXN0ZXJpbmcoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHRvIGFjdHVhbGx5IGNsdXN0ZXIgdGhlIGVudGl0aWVzIGluIGEgY2x1c3RlciBsYXllci5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgYXMgYWRkaW5nIGFuIGVudGl0aXkgd2lsbCByZWNhbGN1bGF0ZSBhbGwgY2x1c3RlcnMuXHJcbiAgICAgKiBBcyBzdWNoLCBTdG9wQ2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhZGRpbmcgbWFueSBlbnRpdGllcyBhbmQgU3RhcnRDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgb25jZSBhZGRpbmcgaXNcclxuICAgICAqIGNvbXBsZXRlIHRvIHJlY2FsY3VsYXRlIHRoZSBjbHVzdGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUgY29tcG9uZW50IG9iamVjdCBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFN0b3BDbHVzdGVyaW5nKGxheWVyOiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBsID0gdGhpcy5fbGF5ZXJzLmdldChsYXllci5JZCk7XHJcbiAgICAgICAgaWYgKGwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsLnRoZW4oKGwxOiBCaW5nQ2x1c3RlckxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsMS5TdG9wQ2x1c3RlcmluZygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcml2YXRlIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgZGVmYXVsdCBjbHVzdGVyIHB1c2hwaW4gYXMgYSBjYWxsYmFjayBmcm9tIEJpbmdNYXBzIHdoZW4gY2x1c3RlcmluZyBvY2N1cnMuIFRoZSB7QGxpbmsgQ2x1c3RlckxheWVyRGlyZWN0aXZlfSBtb2RlbFxyXG4gICAgICogY2FuIHByb3ZpZGUgYW4gSWNvbkluZm8gcHJvcGVydHkgdGhhdCB3b3VsZCBnb3Zlcm4gdGhlIGFwcGFyZW5hY2Ugb2YgdGhlIHBpbi4gVGhpcyBtZXRob2Qgd2lsbCBhc3NpZ24gdGhlIHNhbWUgcGluIHRvIGFsbFxyXG4gICAgICogY2x1c3RlcnMgaW4gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjbHVzdGVyIC0gVGhlIGNsdXN0ZXIgZm9yIHdoaWNoIHRvIGNyZWF0ZSB0aGUgcHVzaHBpbi5cclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSB7QGxpbmsgQ2x1c3RlckxheWVyRGlyZWN0aXZlfSBjb21wb25lbnQgcmVwcmVzZW50aW5nIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgQ3JlYXRlQ2x1c3RlclB1c2hQaW4oY2x1c3RlcjogTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclB1c2hwaW4sIGxheWVyOiBDbHVzdGVyTGF5ZXJEaXJlY3RpdmUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9sYXllcnMuZ2V0KGxheWVyLklkKS50aGVuKChsOiBCaW5nQ2x1c3RlckxheWVyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChsYXllci5JY29uSW5mbykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbzogTWljcm9zb2Z0Lk1hcHMuSVB1c2hwaW5PcHRpb25zID0ge307XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkOiAoaWNvOiBzdHJpbmcsIGluZm86IElNYXJrZXJJY29uSW5mbykgPT4gdm9pZCA9IChpY28sIGluZm8pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5pY29uID0gaWNvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvLmFuY2hvciA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2ludChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbmZvLnNpemUgJiYgaW5mby5tYXJrZXJPZmZzZXRSYXRpbykgPyAoaW5mby5zaXplLndpZHRoICogaW5mby5tYXJrZXJPZmZzZXRSYXRpby54KSA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5mby5zaXplICYmIGluZm8ubWFya2VyT2Zmc2V0UmF0aW8pID8gKGluZm8uc2l6ZS5oZWlnaHQgKiBpbmZvLm1hcmtlck9mZnNldFJhdGlvLnkpIDogMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLnNldE9wdGlvbnMobyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbjogc3RyaW5nfFByb21pc2U8e2ljb246IHN0cmluZywgaWNvbkluZm86IElNYXJrZXJJY29uSW5mb30+ID0gTWFya2VyLkNyZWF0ZU1hcmtlcihsYXllci5JY29uSW5mbyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGljb24pID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQoaWNvbiwgbGF5ZXIuSWNvbkluZm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWNvbi50aGVuKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkKHguaWNvbiwgeC5pY29uSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxheWVyLkNsdXN0ZXJDbGlja0FjdGlvbiA9PT0gQ2x1c3RlckNsaWNrQWN0aW9uLlpvb21JbnRvQ2x1c3Rlcikge1xyXG4gICAgICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIoY2x1c3RlciwgJ2NsaWNrJywgKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncykgPT4gdGhpcy5ab29tSW50b0NsdXN0ZXIoZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYXllci5DbHVzdGVyQ2xpY2tBY3Rpb24gPT09IENsdXN0ZXJDbGlja0FjdGlvbi5TcGlkZXIpIHtcclxuICAgICAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKGNsdXN0ZXIsICdkYmxjbGljaycsIChlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpID0+IHRoaXMuWm9vbUludG9DbHVzdGVyKGUpKTtcclxuICAgICAgICAgICAgICAgIGwuSW5pdGlhbGl6ZVNwaWRlckNsdXN0ZXJTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVzIGEgaG9vayBmb3IgY29uc3VtZXJzIHRvIHByb3ZpZGUgYSBjdXN0b20gZnVuY3Rpb24gdG8gY3JlYXRlIGNsdXN0ZXIgYmlucyBmb3IgYSBjbHVzdGVyLiBUaGlzIGlzIHBhcnRpY3VhcmlseSB1c2VmdWxcclxuICAgICAqIGluIHNpdHVhdGlvbiB3aGVyZSB0aGUgcGluIHNob3VsZCBkaWZmZXIgdG8gcmVwcmVzZW50IGluZm9ybWF0aW9uIGFib3V0IHRoZSBwaW5zIGluIHRoZSBjbHVzdGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjbHVzdGVyIC0gVGhlIGNsdXN0ZXIgZm9yIHdoaWNoIHRvIGNyZWF0ZSB0aGUgcHVzaHBpbi5cclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSB7QGxpbmsgQ2x1c3RlckxheWVyRGlyZWN0aXZlfSBjb21wb25lbnRcclxuICAgICAqIHJlcHJlc2VudGluZyB0aGUgbGF5ZXIuIFNldCB0aGUge0BsaW5rIENsdXN0ZXJMYXllckRpcmVjdGl2ZS5DdXN0b21NYXJrZXJDYWxsYmFja31cclxuICAgICAqIHByb3BlcnR5IHRvIGRlZmluZSB0aGUgY2FsbGJhY2sgZ2VuZXJhdGluZyB0aGUgcGluLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBDcmVhdGVDdXN0b21DbHVzdGVyUHVzaFBpbihjbHVzdGVyOiBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyUHVzaHBpbiwgbGF5ZXI6IENsdXN0ZXJMYXllckRpcmVjdGl2ZSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2xheWVycy5nZXQobGF5ZXIuSWQpLnRoZW4oKGw6IEJpbmdDbHVzdGVyTGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgLy8gYXNzZW1ibGUgbWFya2VycyBmb3IgY2FsbGJhY2tcclxuICAgICAgICAgICAgY29uc3QgbTogQXJyYXk8TWFya2VyPiA9IG5ldyBBcnJheTxNYXJrZXI+KCk7XHJcbiAgICAgICAgICAgIGNsdXN0ZXIuY29udGFpbmVkUHVzaHBpbnMuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcjogTWFya2VyID0gbC5HZXRNYXJrZXJGcm9tQmluZ01hcmtlcihwKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIpIHsgbS5wdXNoKG1hcmtlcik7IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGljb25JbmZvOiBJTWFya2VySWNvbkluZm8gPSB7IG1hcmtlclR5cGU6IE1hcmtlclR5cGVJZC5Ob25lIH07XHJcbiAgICAgICAgICAgIGNvbnN0IG86IE1pY3Jvc29mdC5NYXBzLklQdXNocGluT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBvLmljb24gPSBsYXllci5DdXN0b21NYXJrZXJDYWxsYmFjayhtLCBpY29uSW5mbyk7XHJcbiAgICAgICAgICAgIGlmIChvLmljb24gIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBvLmFuY2hvciA9IG5ldyBNaWNyb3NvZnQuTWFwcy5Qb2ludChcclxuICAgICAgICAgICAgICAgICAgICAoaWNvbkluZm8uc2l6ZSAmJiBpY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpbykgPyAoaWNvbkluZm8uc2l6ZS53aWR0aCAqIGljb25JbmZvLm1hcmtlck9mZnNldFJhdGlvLngpIDogMCxcclxuICAgICAgICAgICAgICAgICAgICAoaWNvbkluZm8uc2l6ZSAmJiBpY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpbykgPyAoaWNvbkluZm8uc2l6ZS5oZWlnaHQgKiBpY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpby55KSA6IDBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWNvbkluZm8udGV4dE9mZnNldCkgeyBvLnRleHRPZmZzZXQgPSBuZXcgTWljcm9zb2Z0Lk1hcHMuUG9pbnQoaWNvbkluZm8udGV4dE9mZnNldC54LCBpY29uSW5mby50ZXh0T2Zmc2V0LnkpOyB9XHJcbiAgICAgICAgICAgICAgICBjbHVzdGVyLnNldE9wdGlvbnMobyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxheWVyLkNsdXN0ZXJDbGlja0FjdGlvbiA9PT0gQ2x1c3RlckNsaWNrQWN0aW9uLlpvb21JbnRvQ2x1c3Rlcikge1xyXG4gICAgICAgICAgICAgICAgTWljcm9zb2Z0Lk1hcHMuRXZlbnRzLmFkZEhhbmRsZXIoY2x1c3RlciwgJ2NsaWNrJywgKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncykgPT4gdGhpcy5ab29tSW50b0NsdXN0ZXIoZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYXllci5DbHVzdGVyQ2xpY2tBY3Rpb24gPT09IENsdXN0ZXJDbGlja0FjdGlvbi5TcGlkZXIpIHtcclxuICAgICAgICAgICAgICAgIE1pY3Jvc29mdC5NYXBzLkV2ZW50cy5hZGRIYW5kbGVyKGNsdXN0ZXIsICdkYmxjbGljaycsIChlOiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MpID0+IHRoaXMuWm9vbUludG9DbHVzdGVyKGUpKTtcclxuICAgICAgICAgICAgICAgIGwuSW5pdGlhbGl6ZVNwaWRlckNsdXN0ZXJTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFpvb21zIGludG8gdGhlIGNsdXN0ZXIgb24gY2xpY2sgc28gdGhhdCB0aGUgbWVtYmVycyBvZiB0aGUgY2x1c3RlciBjb21mb3J0YWJsZSBmaXQgaW50byB0aGUgem9tbWVkIGFyZWEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGUgLSBNb3VzZSBFdmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ0NsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgWm9vbUludG9DbHVzdGVyKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHBpbjogTWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclB1c2hwaW4gPSA8TWljcm9zb2Z0Lk1hcHMuQ2x1c3RlclB1c2hwaW4+ZS50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHBpbiAmJiBwaW4uY29udGFpbmVkUHVzaHBpbnMpIHtcclxuICAgICAgICAgICAgbGV0IGJvdW5kczogTWljcm9zb2Z0Lk1hcHMuTG9jYXRpb25SZWN0O1xyXG4gICAgICAgICAgICBjb25zdCBsb2NzOiBBcnJheTxNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvbj4gPSBuZXcgQXJyYXk8TWljcm9zb2Z0Lk1hcHMuTG9jYXRpb24+KCk7XHJcbiAgICAgICAgICAgIHBpbi5jb250YWluZWRQdXNocGlucy5mb3JFYWNoKHAgPT4gbG9jcy5wdXNoKHAuZ2V0TG9jYXRpb24oKSkpO1xyXG4gICAgICAgICAgICBib3VuZHMgPSBNaWNyb3NvZnQuTWFwcy5Mb2NhdGlvblJlY3QuZnJvbUxvY2F0aW9ucyhsb2NzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFpvb20gaW50byB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBjbHVzdGVyLlxyXG4gICAgICAgICAgICAvLyBBZGQgYSBwYWRkaW5nIHRvIGNvbXBlbnNhdGUgZm9yIHRoZSBwaXhlbCBhcmVhIG9mIHRoZSBwdXNocGlucy5cclxuICAgICAgICAgICAgKDxCaW5nTWFwU2VydmljZT50aGlzLl9tYXBTZXJ2aWNlKS5NYXBQcm9taXNlLnRoZW4oKG06IE1pY3Jvc29mdC5NYXBzLk1hcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbS5zZXRWaWV3KHsgYm91bmRzOiBib3VuZHMsIHBhZGRpbmc6IDc1IH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZlciwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlnb24nO1xyXG5pbXBvcnQgeyBNYXBQb2x5Z29uRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9tYXAtcG9seWdvbic7XHJcbmltcG9ydCB7IFBvbHlnb25TZXJ2aWNlIH0gZnJvbSAnLi4vcG9seWdvbi5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIFBvbHlnb24gU2VydmljZSBhYnN0cmFjdCBjbGFzcyBmb3IgQmluZyBNYXBzIFY4LlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBCaW5nUG9seWdvblNlcnZpY2UgaW1wbGVtZW50cyBQb2x5Z29uU2VydmljZSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX3BvbHlnb25zOiBNYXA8TWFwUG9seWdvbkRpcmVjdGl2ZSwgUHJvbWlzZTxQb2x5Z29uPj4gPSBuZXcgTWFwPE1hcFBvbHlnb25EaXJlY3RpdmUsIFByb21pc2U8UG9seWdvbj4+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCaW5nUG9seWdvblNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuIFRoZSBjb25jcmV0ZSB7QGxpbmsgQmluZ01hcFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF9sYXllclNlcnZpY2UgLSB7QGxpbmsgQmluZ0xheWVyU2VydmljZX0gaW5zdGFuY2UuXHJcbiAgICAgKiBUaGUgY29uY3JldGUge0BsaW5rIEJpbmdMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gTmdab25lIGluc3RhbmNlIHRvIHN1cHBvcnQgem9uZSBhd2FyZSBwcm9taXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25TZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfbGF5ZXJTZXJ2aWNlOiBMYXllclNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWdvbiB0byBhIG1hcC4gRGVwZW5kaW5nIG9uIHRoZSBwb2x5Z29uIGNvbnRleHQsIHRoZSBwb2x5Z29uIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYVxyXG4gICAgICogY29ycmVjc3BvbmRpbmcgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIGFkZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZFBvbHlnb24ocG9seWdvbjogTWFwUG9seWdvbkRpcmVjdGl2ZSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IElQb2x5Z29uT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgaWQ6IHBvbHlnb24uSWQsXHJcbiAgICAgICAgICAgIGNsaWNrYWJsZTogcG9seWdvbi5DbGlja2FibGUsXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogcG9seWdvbi5EcmFnZ2FibGUsXHJcbiAgICAgICAgICAgIGVkaXRhYmxlOiBwb2x5Z29uLkVkaXRhYmxlLFxyXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHBvbHlnb24uRmlsbENvbG9yLFxyXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogcG9seWdvbi5GaWxsT3BhY2l0eSxcclxuICAgICAgICAgICAgZ2VvZGVzaWM6IHBvbHlnb24uR2VvZGVzaWMsXHJcbiAgICAgICAgICAgIGxhYmVsTWF4Wm9vbTogcG9seWdvbi5MYWJlbE1heFpvb20sXHJcbiAgICAgICAgICAgIGxhYmVsTWluWm9vbTogcG9seWdvbi5MYWJlbE1pblpvb20sXHJcbiAgICAgICAgICAgIHBhdGhzOiBwb2x5Z29uLlBhdGhzLFxyXG4gICAgICAgICAgICBzaG93TGFiZWw6IHBvbHlnb24uU2hvd0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93VG9vbHRpcDogcG9seWdvbi5TaG93VG9vbHRpcCxcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHBvbHlnb24uU3Ryb2tlQ29sb3IsXHJcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHBvbHlnb24uU3Ryb2tlT3BhY2l0eSxcclxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiBwb2x5Z29uLlN0cm9rZVdlaWdodCxcclxuICAgICAgICAgICAgdGl0bGU6IHBvbHlnb24uVGl0bGUsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHBvbHlnb24uVmlzaWJsZSxcclxuICAgICAgICAgICAgekluZGV4OiBwb2x5Z29uLnpJbmRleCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBwb2x5Z29uUHJvbWlzZTogUHJvbWlzZTxQb2x5Z29uPjtcclxuICAgICAgICBpZiAocG9seWdvbi5JbkN1c3RvbUxheWVyKSB7XHJcbiAgICAgICAgICAgIHBvbHlnb25Qcm9taXNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlLkNyZWF0ZVBvbHlnb24ocG9seWdvbi5MYXllcklkLCBvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBvbHlnb25Qcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVQb2x5Z29uKG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wb2x5Z29ucy5zZXQocG9seWdvbiwgcG9seWdvblByb21pc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYSBwb2x5Z29uLlxyXG4gICAgICAqXHJcbiAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciAoZS5nLiAnY2xpY2snKVxyXG4gICAgICAqIEBwYXJhbSBwb2x5Z29uIC0gVGhlIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGV2ZW50LlxyXG4gICAgICAqIEByZXR1cm5zIC0gT2JzZXJ2YWJsZSBlbWl0aW5nIGFuIGluc3RhbmNlIG9mIFQgZWFjaCB0aW1lIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgICpcclxuICAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25TZXJ2aWNlXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgICAgICAgY29uc3QgYjogU3ViamVjdDxUPiA9IG5ldyBTdWJqZWN0PFQ+KCk7XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ21vdXNlbW92ZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIuYXNPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdyaWdodGNsaWNrJykge1xyXG4gICAgICAgICAgICByZXR1cm4gYi5hc09ic2VydmFibGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgLy8vIG1vdXNlbW92ZSBhbmQgcmlnaHRjbGljayBhcmUgbm90IHN1cHBvcnRlZCBieSBiaW5nIHBvbHlnb25zLlxyXG4gICAgICAgIC8vL1xyXG5cclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2x5Z29ucy5nZXQocG9seWdvbikudGhlbigocDogUG9seWdvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcC5BZGRMaXN0ZW5lcihldmVudE5hbWUsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIERlbGV0ZXMgYSBwb2x5Z29uLlxyXG4gICAgICAqXHJcbiAgICAgICogQHBhcmFtIHBvbHlnb24gLSB7QGxpbmsgTWFwUG9seWdvbkRpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cclxuICAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlnb24gaGFzIGJlZW4gZGVsZXRlZC5cclxuICAgICAgKlxyXG4gICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblNlcnZpY2VcclxuICAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGVQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pO1xyXG4gICAgICAgIGlmIChtID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbS50aGVuKChsOiBQb2x5Z29uKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsLkRlbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9seWdvbnMuZGVsZXRlKHBvbHlnb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIHBvbHlnb24gb24gdGhlIGNsaWNrIGxvY2F0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC4gRXhwZWN0ZWQgdG8gaW1wbGVtZW50IHtAbGluayBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3N9LlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2xpY2tlZCBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZTogTW91c2VFdmVudCB8IGFueSk6IElMYXRMb25nIHtcclxuICAgICAgICBjb25zdCB4OiBNaWNyb3NvZnQuTWFwcy5JTW91c2VFdmVudEFyZ3MgPSA8TWljcm9zb2Z0Lk1hcHMuSU1vdXNlRXZlbnRBcmdzPmU7XHJcbiAgICAgICAgcmV0dXJuIHsgbGF0aXR1ZGU6IHgubG9jYXRpb24ubGF0aXR1ZGUsIGxvbmdpdHVkZTogeC5sb2NhdGlvbi5sb25naXR1ZGUgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIHBvbHlnb24gbW9kZWwgZm9yIHRoZSBwb2x5Z29uIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IGZvciB3aGljaCB0byBvYnRhaW4gdGhlIHBvbHlnb24gbW9kZWwuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIFBvbHlnb259IGltcGxlbWVudGF0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIHBsYXRmb3JtLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWdvblNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldE5hdGl2ZVBvbHlnb24ocG9seWdvbjogTWFwUG9seWdvbkRpcmVjdGl2ZSk6IFByb21pc2U8UG9seWdvbj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5Z29ucy5nZXQocG9seWdvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHBvbHlnb24gb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9seWdvbiAtIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSVBvbHlnb25PcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucy4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxyXG4gICAgICogb3B0aW9ucyBhbHJlYWR5IG9uIHRoZSB1bmRlcmx5aW5nIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWdvbiBvcHRpb25zIGhhdmUgYmVlbiBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5Z29uU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlLCBvcHRpb25zOiBJUG9seWdvbk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pLnRoZW4oKGw6IFBvbHlnb24pID0+IHsgbC5TZXRPcHRpb25zKG9wdGlvbnMpOyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIFBvbHlnb24gcGF0aFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2x5Z29uIC0ge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlnb24gaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlnb25TZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pO1xyXG4gICAgICAgIGlmIChtID09IG51bGwgfHwgcG9seWdvbi5QYXRocyA9PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHBvbHlnb24uUGF0aHMpIHx8IHBvbHlnb24uUGF0aHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG0udGhlbigobDogUG9seWdvbikgPT4gIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9seWdvbi5QYXRoc1swXSkpIHtcclxuICAgICAgICAgICAgICAgIGwuU2V0UGF0aHMocG9seWdvbi5QYXRocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsLlNldFBhdGgoPEFycmF5PElMYXRMb25nPj5wb2x5Z29uLlBhdGhzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5bGluZSc7XHJcbmltcG9ydCB7IE1hcFBvbHlsaW5lRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9tYXAtcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuLi9wb2x5bGluZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XHJcblxyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIFBvbHlsaW5lIFNlcnZpY2UgYWJzdHJhY3QgY2xhc3MgZm9yIEJpbmcgTWFwcyBWOC5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgQmluZ1BvbHlsaW5lU2VydmljZSBpbXBsZW1lbnRzIFBvbHlsaW5lU2VydmljZSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX3BvbHlsaW5lczogTWFwPE1hcFBvbHlsaW5lRGlyZWN0aXZlLCBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+ID1cclxuICAgIG5ldyBNYXA8TWFwUG9seWxpbmVEaXJlY3RpdmUsIFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4oKTtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmdQb2x5bGluZVNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuIFRoZSBjb25jcmV0ZSB7QGxpbmsgQmluZ01hcFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF9sYXllclNlcnZpY2UgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbnN0YW5jZS5cclxuICAgICAqIFRoZSBjb25jcmV0ZSB7QGxpbmsgQmluZ0xheWVyU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgaW5zdGFuY2UgdG8gc3VwcG9ydCB6b25lIGF3YXJlIHByb21pc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfbGF5ZXJTZXJ2aWNlOiBMYXllclNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1lbWJlcnMgYW5kIE1hcmtlclNlcnZpY2UgaW1wbGVtZW50YXRpb25cclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHBvbHlsaW5lIHRvIGEgbWFwLiBEZXBlbmRpbmcgb24gdGhlIHBvbHlsaW5lIGNvbnRleHQsIHRoZSBwb2x5bGluZSB3aWxsIGVpdGhlciBieSBhZGRlZCB0byB0aGUgbWFwIG9yIGFcclxuICAgICAqIGNvcnJlc3BvbmRpbmcgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZFBvbHlsaW5lKHBvbHlsaW5lOiBNYXBQb2x5bGluZURpcmVjdGl2ZSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IElQb2x5bGluZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGlkOiBwb2x5bGluZS5JZCxcclxuICAgICAgICAgICAgY2xpY2thYmxlOiBwb2x5bGluZS5DbGlja2FibGUsXHJcbiAgICAgICAgICAgIGRyYWdnYWJsZTogcG9seWxpbmUuRHJhZ2dhYmxlLFxyXG4gICAgICAgICAgICBlZGl0YWJsZTogcG9seWxpbmUuRWRpdGFibGUsXHJcbiAgICAgICAgICAgIGdlb2Rlc2ljOiBwb2x5bGluZS5HZW9kZXNpYyxcclxuICAgICAgICAgICAgcGF0aDogcG9seWxpbmUuUGF0aCxcclxuICAgICAgICAgICAgc2hvd1Rvb2x0aXA6IHBvbHlsaW5lLlNob3dUb29sdGlwLFxyXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogcG9seWxpbmUuU3Ryb2tlQ29sb3IsXHJcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHBvbHlsaW5lLlN0cm9rZU9wYWNpdHksXHJcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogcG9seWxpbmUuU3Ryb2tlV2VpZ2h0LFxyXG4gICAgICAgICAgICB0aXRsZTogcG9seWxpbmUuVGl0bGUsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHBvbHlsaW5lLlZpc2libGUsXHJcbiAgICAgICAgICAgIHpJbmRleDogcG9seWxpbmUuekluZGV4LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHBvbHlsaW5lUHJvbWlzZTogUHJvbWlzZTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+O1xyXG4gICAgICAgIGlmIChwb2x5bGluZS5JbkN1c3RvbUxheWVyKSB7XHJcbiAgICAgICAgICAgIHBvbHlsaW5lUHJvbWlzZSA9IHRoaXMuX2xheWVyU2VydmljZS5DcmVhdGVQb2x5bGluZShwb2x5bGluZS5MYXllcklkLCBvKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwb2x5bGluZVByb21pc2UgPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZVBvbHlsaW5lKG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wb2x5bGluZXMuc2V0KHBvbHlsaW5lLCBwb2x5bGluZVByb21pc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYSBsaW5lLlxyXG4gICAgICAqXHJcbiAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciAoZS5nLiAnY2xpY2snKVxyXG4gICAgICAqIEBwYXJhbSBwb2x5bGluZSAtIFRoZSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgZXZlbnQuXHJcbiAgICAgICogQHJldHVybnMgLSBPYnNlcnZhYmxlIGVtaXRpbmcgYW4gaW5zdGFuY2Ugb2YgVCBlYWNoIHRpbWUgdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAgKlxyXG4gICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBPYnNlcnZhYmxlPFQ+IHtcclxuICAgICAgICBjb25zdCBiOiBTdWJqZWN0PFQ+ID0gbmV3IFN1YmplY3Q8VD4oKTtcclxuICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnbW91c2Vtb3ZlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gYi5hc09ic2VydmFibGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3JpZ2h0Y2xpY2snKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiLmFzT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gbW91c2Vtb3ZlIGFuZCByaWdodGNsaWNrIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGJpbmcgcG9seWdvbnMuXHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSkudGhlbihwID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHg6IEFycmF5PFBvbHlsaW5lPiA9IEFycmF5LmlzQXJyYXkocCkgPyBwIDogW3BdO1xyXG4gICAgICAgICAgICAgICAgeC5mb3JFYWNoKGxpbmUgPT4gbGluZS5BZGRMaXN0ZW5lcihldmVudE5hbWUsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBEZWxldGVzIGEgcG9seWxpbmUuXHJcbiAgICAgICpcclxuICAgICAgKiBAcGFyYW0gcG9seWxpbmUgLSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5bGluZSBoYXMgYmVlbiBkZWxldGVkLlxyXG4gICAgICAqXHJcbiAgICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVNlcnZpY2VcclxuICAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGVQb2x5bGluZShwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSk7XHJcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtLnRoZW4oKGw6IFBvbHlsaW5lKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4OiBBcnJheTxQb2x5bGluZT4gPSBBcnJheS5pc0FycmF5KGwpID8gbCA6IFtsXTtcclxuICAgICAgICAgICAgICAgIHguZm9yRWFjaChsaW5lID0+ICBsaW5lLkRlbGV0ZSgpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvbHlsaW5lcy5kZWxldGUocG9seWxpbmUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIG1hcmtlciBvbiB0aGUgY2xpY2sgbG9jYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBlIC0gVGhlIG1vdXNlIGV2ZW50LlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2xpY2tlZCBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdQb2x5bGluZVNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldENvb3JkaW5hdGVzRnJvbUNsaWNrKGU6IE1pY3Jvc29mdC5NYXBzLklNb3VzZUV2ZW50QXJncyk6IElMYXRMb25nIHtcclxuICAgICAgICBpZiAoIWUpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICBpZiAoIWUubG9jYXRpb24pIHsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICByZXR1cm4geyBsYXRpdHVkZTogZS5sb2NhdGlvbi5sYXRpdHVkZSwgbG9uZ2l0dWRlOiBlLmxvY2F0aW9uLmxvbmdpdHVkZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyB0aGUgbWFya2VyIG1vZGVsIGZvciB0aGUgbWFya2VyIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgcG9seWxpbmUgbW9kZWwuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIFBvbHlsaW5lfVxyXG4gICAgICogaW1wbGVtZW50YXRpb24gb2YgdGhlIHVuZGVybHlpbmcgcGxhdGZvcm0uIEZvciBjb21wbGV4IHBhdGhzLCByZXR1cm5zIGFuIGFycmF5IG9mIHBvbHlsaW5lcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TmF0aXZlUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogUHJvbWlzZTxQb2x5bGluZXxBcnJheTxQb2x5bGluZT4+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHBvbHlsaW5lIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0ge0BsaW5rIE1hcFBvbHlsaW5lRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB7QGxpbmsgSVBvbHlsaW5lT3B0aW9uc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMuIE9wdGlvbnMgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcclxuICAgICAqIG9wdGlvbnMgYWxyZWFkeSBvbiB0aGUgdW5kZXJseWluZyBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlsaW5lIG9wdGlvbnMgaGF2ZSBiZWVuIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ1BvbHlsaW5lU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0T3B0aW9ucyhwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUsIG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSkudGhlbihsID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeDogQXJyYXk8UG9seWxpbmU+ID0gQXJyYXkuaXNBcnJheShsKSA/IGwgOiBbbF07XHJcbiAgICAgICAgICAgIHguZm9yRWFjaChsaW5lID0+IGxpbmUuU2V0T3B0aW9ucyhvcHRpb25zKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBQb2x5bGluZSBwYXRoXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0ge0BsaW5rIE1hcFBvbHlsaW5lRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5bGluZSBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVQb2x5bGluZShwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSk7XHJcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtLnRoZW4obCA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHg6IEFycmF5PFBvbHlsaW5lPiA9IEFycmF5LmlzQXJyYXkobCkgPyBsIDogW2xdO1xyXG4gICAgICAgICAgICBjb25zdCBwOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+ID1cclxuICAgICAgICAgICAgICAgIHBvbHlsaW5lLlBhdGgubGVuZ3RoID4gMCAmJiBBcnJheS5pc0FycmF5KHBvbHlsaW5lLlBhdGhbMF0pID8gPEFycmF5PEFycmF5PElMYXRMb25nPj4+cG9seWxpbmUuUGF0aCA6XHJcbiAgICAgICAgICAgICAgICA8QXJyYXk8QXJyYXk8SUxhdExvbmc+Pj5bcG9seWxpbmUuUGF0aF07XHJcbiAgICAgICAgICAgICB4LmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHAubGVuZ3RoID4gaW5kZXgpIHsgbGluZS5TZXRQYXRoKHBbaW5kZXhdKTsgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobCkgJiYgbC5sZW5ndGggPiBwLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbC5zcGxpY2UocC5sZW5ndGggLSAxKS5mb3JFYWNoKGxpbmUgPT4gbGluZS5EZWxldGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2VGYWN0b3J5IH0gZnJvbSAnLi4vbWFwc2VydmljZWZhY3RvcnknO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBBUElMb2FkZXIsIFdpbmRvd1JlZiwgRG9jdW1lbnRSZWYgfSBmcm9tICcuLi9tYXBhcGlsb2FkZXInO1xyXG5pbXBvcnQgeyBNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbWFya2VyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJbmZvQm94U2VydmljZSB9IGZyb20gJy4uL2luZm9ib3guc2VydmljZSc7XHJcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uL2xheWVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBDbHVzdGVyU2VydmljZSB9IGZyb20gJy4uL2NsdXN0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IFBvbHlnb25TZXJ2aWNlIH0gZnJvbSAnLi4vcG9seWdvbi5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUG9seWxpbmVTZXJ2aWNlIH0gZnJvbSAnLi4vcG9seWxpbmUuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdNYXBBUElMb2FkZXIsIEJpbmdNYXBBUElMb2FkZXJDb25maWcgfSBmcm9tICcuL2JpbmctbWFwLmFwaS1sb2FkZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdJbmZvQm94U2VydmljZSB9IGZyb20gJy4vYmluZy1pbmZvYm94LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCaW5nTWFya2VyU2VydmljZSB9IGZyb20gJy4vYmluZy1tYXJrZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLW1hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0xheWVyU2VydmljZSB9IGZyb20gJy4vYmluZy1sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0NsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLWNsdXN0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdQb2x5Z29uU2VydmljZSB9IGZyb20gJy4vYmluZy1wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCaW5nUG9seWxpbmVTZXJ2aWNlIH0gZnJvbSAnLi9iaW5nLXBvbHlsaW5lLnNlcnZpY2UnO1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgYSBmYWN0b3J5IHRvIGNyZWF0ZSB0aHJlIG5lY2Vzc2FyeSBCaW5nIE1hcHMgVjggc3BlY2lmaWMgc2VydmljZSBpbnN0YW5jZXMuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeSBpbXBsZW1lbnRzIE1hcFNlcnZpY2VGYWN0b3J5IHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeS5cclxuICAgICAqIEBwYXJhbSBfbG9hZGVyIC0ge0BsaW5rIE1hcEFQSUxvYWRlcn0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBCaW5nIE1hcCBWOCBwcm92aWRlci5cclxuICAgICAqIEBwYXJhbSBfem9uZSAtIE5nWm9uZSBvYmplY3QgdG8gaW1wbGVtZW50IHpvbmUgYXdhcmUgcHJvbWlzZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sb2FkZXI6IE1hcEFQSUxvYWRlciwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kcyBhbmQgTWFwU2VydmljZUZhY3RvcnkgaW1wbGVtZW50YXRpb24uXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIG1hcCBzZXJ2aWNlIGZvciB0aGUgQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIE1hcFNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEJpbmdNYXBTZXJ2aWNlfS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGUoKTogTWFwU2VydmljZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5nTWFwU2VydmljZSh0aGlzLl9sb2FkZXIsIHRoaXMuX3pvbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgY2x1c3RlciBzZXJ2aWNlIGZvciB0aGUgQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ01hcFNlcnZpY2V9LlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEJpbmdDbHVzdGVyU2VydmljZX0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlQ2x1c3RlclNlcnZpY2UoX21hcFNlcnZpY2U6IEJpbmdNYXBTZXJ2aWNlKTogQ2x1c3RlclNlcnZpY2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZ0NsdXN0ZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlLCB0aGlzLl96b25lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhoIGluZm8gYm94IHNlcnZpY2UgZm9yIHRoZSBCaW5nIE1hcHMgVjggaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBCaW5nTWFwU2VydmljZX0uXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJbmZvQm94U2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ0luZm9Cb3hTZXJ2aWNlfS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVJbmZvQm94U2VydmljZShfbWFwU2VydmljZTogQmluZ01hcFNlcnZpY2UpOiBJbmZvQm94U2VydmljZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5nSW5mb0JveFNlcnZpY2UoX21hcFNlcnZpY2UsIHRoaXMuX3pvbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgbGF5ZXIgc2VydmljZSBmb3IgdGhlIEJpbmcgTWFwcyBWOCBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFwIC0ge0BsaW5rIE1hcFNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEJpbmdNYXBTZXJ2aWNlfS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIExheWVyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ0xheWVyU2VydmljZX0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlTGF5ZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlOiBCaW5nTWFwU2VydmljZSk6IExheWVyU2VydmljZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5nTGF5ZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlLCB0aGlzLl96b25lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIG1hcmtlciBzZXJ2aWNlIGZvciB0aGUgQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ01hcFNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIGxheWVycyAtIHtAbGluayBMYXllclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEJpbmdMYXllclNlcnZpY2V9LlxyXG4gICAgICogQHBhcmFtIGNsdXN0ZXJzICAtIHtAbGluayBDbHVzdGVyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgQmluZ0NsdXN0ZXJTZXJ2aWNlfS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIE1hcmtlclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEJpbmdNYXJrZXJTZXJ2aWNlfS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZ01hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVNYXJrZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlOiBCaW5nTWFwU2VydmljZSxcclxuICAgICAgICBfbGF5ZXJTZXJ2aWNlOiBCaW5nTGF5ZXJTZXJ2aWNlLCBfY2x1c3RlclNlcnZpY2U6IEJpbmdDbHVzdGVyU2VydmljZSk6IE1hcmtlclNlcnZpY2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmluZ01hcmtlclNlcnZpY2UoX21hcFNlcnZpY2UsIF9sYXllclNlcnZpY2UsIF9jbHVzdGVyU2VydmljZSwgdGhpcy5fem9uZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBwb2x5Z29uIHNlcnZpY2UgZm9yIHRoZSBCaW5nIE1hcHMgVjggaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhoIHVuZGVybHlpbmcgbWFwIGFyY2h0aWN0dXJlLlxyXG4gICAgICogQHBhcmFtIGxheWVycyAtIHtAbGluayBMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgUG9seWdvblNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWdvblNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlLCBsYXllcnM6IExheWVyU2VydmljZSk6IFBvbHlnb25TZXJ2aWNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmdQb2x5Z29uU2VydmljZShtYXAsIGxheWVycywgdGhpcy5fem9uZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBwb2x5bGluZSBzZXJ2aWNlIGZvciB0aGUgQmluZyBNYXBzIFY4IGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoaCB1bmRlcmx5aW5nIG1hcCBhcmNodGljdHVyZS5cclxuICAgICAqIEBwYXJhbSBsYXllcnMgLSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHVuZGVybHlpbmcgbWFwIGFyY2hpdGVjdHVyZS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIFBvbHlsaW5lU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVQb2x5bGluZVNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlLCBsYXllcnM6IExheWVyU2VydmljZSk6IFBvbHlsaW5lU2VydmljZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5nUG9seWxpbmVTZXJ2aWNlKG1hcCwgbGF5ZXJzLCB0aGlzLl96b25lKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgcGxhZm9ybSBzcGVjaWZpYyBNYXBTZXJ2aWNlRmFjdG9yeS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0gYXBpTG9hZGVyIC0gQW4ge0BsaW5rIE1hcEFQSUxvYWRlcn0gaW5zdGFuY2UuIFRoaXMgaXMgZXhwZWN0ZWQgdG8gdGhlIGEge0BsaW5rIEJpbmdNYXBBUElMb2FkZXJ9LlxyXG4gKiBAcGFyYW0gem9uZSAtIEFuIE5nWm9uZSBpbnN0YW5jZSB0byBwcm92aWRlIHpvbmUgYXdhcmUgcHJvbWlzZXMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIC0gIEEge0BsaW5rIE1hcFNlcnZpY2VGYWN0b3J5fSBpbnN0YW5jZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBCaW5nTWFwU2VydmljZUZhY3RvcnlGYWN0b3J5KGFwaUxvYWRlcjogTWFwQVBJTG9hZGVyLCB6b25lOiBOZ1pvbmUpOiBNYXBTZXJ2aWNlRmFjdG9yeSB7XHJcbiAgICByZXR1cm4gbmV3IEJpbmdNYXBTZXJ2aWNlRmFjdG9yeShhcGlMb2FkZXIsIHpvbmUpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHBsYWZvcm0gc3BlY2lmaWMgTWFwTG9hZGVyRmFjdG9yeS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcmV0dXJucyAtIEEge0BsaW5rIE1hcEFQSUxvYWRlcn0gaW5zdGFuY2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gQmluZ01hcExvYWRlckZhY3RvcnkoKTogTWFwQVBJTG9hZGVyIHtcclxuICAgIHJldHVybiBuZXcgQmluZ01hcEFQSUxvYWRlcihuZXcgQmluZ01hcEFQSUxvYWRlckNvbmZpZygpLCBuZXcgV2luZG93UmVmKCksIG5ldyBEb2N1bWVudFJlZigpKTtcclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcclxuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbGF5ZXInO1xyXG5pbXBvcnQgeyBNYXJrZXJUeXBlSWQgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyLXR5cGUtaWQnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbWFwLWxheWVyJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZU1hcFNlcnZpY2UgfSBmcm9tICcuL2dvb2dsZS1tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZUNvbnZlcnNpb25zIH0gZnJvbSAnLi9nb29nbGUtY29udmVyc2lvbnMnO1xyXG5pbXBvcnQgeyBHb29nbGVNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1tYXJrZXInO1xyXG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5cclxuZGVjbGFyZSB2YXIgZ29vZ2xlOiBhbnk7XHJcblxyXG4vKipcclxuICogVGhpcyBhYnN0cmFjdCBwYXJ0aWFsbHkgaW1wbGVtZW50cyB0aGUgY29udHJhY3QgZm9yIHRoZSB7QGxpbmsgTGF5ZXJTZXJ2aWNlfVxyXG4gKiBhbmQge0BsaW5rIENsdXN0ZXJTZXJ2aWNlfSBmb3IgdGhlIEdvb2dsZSBNYXBzIGFyY2h0aWVjdHVyZS4gSXQgc2VydmVzXHJcbiAqIGFzIHRoZSBiYXNlIGNsYXNzIGZvciBiYXNpYyBsYXllciAoe0BsaW5rIEdvb2dsZUxheWVyU2VydmljZX0pIGFuZCBjbHVzdGVyIGxheWVyICh7QGxpbmsgR29vZ2xlQ2x1c3RlckxheWVyfSkuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgR29vZ2xlTGF5ZXJCYXNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IF9sYXllcnM6IE1hcDxudW1iZXIsIFByb21pc2U8TGF5ZXI+PjtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZUxheWVyQmFzZS5cclxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIENvbmNyZXRlIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgR29vZ2xlIE1hcHMuXHJcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0uXHJcbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgaW5zdGFuY2UgdG8gcHJvdmlkZSB6b25lIGF3YXJlIHByb21pc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllckJhc2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBwcm90ZWN0ZWQgX3pvbmU6IE5nWm9uZSkgeyB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGxheWVyIHRvIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAgICogR2VuZXJhbGx5LCBNYXBMYXllckRpcmVjdGl2ZSB3aWxsIGJlIGluamVjdGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAgKiBMYXllclNlcnZpY2UgYW5kIHRoZW4gc2VsZiByZWdpc3RlciBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJCYXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBBZGRMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmUpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgbGF5ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0IGZvciB3aGljaCB0byByZXRyaWV2ZSB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgbGF5ZXIgaGFzIGJlZW4gcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJCYXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGVMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBsID0gdGhpcy5fbGF5ZXJzLmdldChsYXllci5JZCk7XHJcbiAgICAgICAgaWYgKGwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsLnRoZW4oKGwxOiBMYXllcikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbDEuRGVsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnMuZGVsZXRlKGxheWVyLklkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBMYXllciBtb2RlbCByZXByZXNlbnRlZCBieSB0aGlzIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIE1hcExheWVyRGlyZWN0aXZlIGNvbXBvbmVudCBvYmplY3Qgb3IgbGF5ZXIgaWQgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHRoZSBsYXllciBtb2RlbC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiByZXNvbHZlZCBjb250YWlucyB0aGUgTGF5ZXIgbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyQmFzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TmF0aXZlTGF5ZXIobGF5ZXI6IE1hcExheWVyRGlyZWN0aXZlfG51bWJlcik6IFByb21pc2U8TGF5ZXI+IHtcclxuICAgICAgICBsZXQgcDogUHJvbWlzZTxMYXllcj4gPSBudWxsO1xyXG4gICAgICAgIGlmICh0eXBlb2YobGF5ZXIpID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBwID0gdGhpcy5fbGF5ZXJzLmdldChsYXllcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwID0gdGhpcy5fbGF5ZXJzLmdldCgoPE1hcExheWVyRGlyZWN0aXZlPmxheWVyKS5JZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG1hcmtlciBpbiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIElkIG9mIHRoZSBsYXllciBpbiB3aGljaCB0byBjcmVhdGUgdGhlIG1hcmtlci5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0ge0BsaW5rIElNYXJrZXJPcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgbWFya2VyIHByb3BlcnRpZXMuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIE1hcmtlcn0gbW9kZWwgZm9yIHRoZSBjcmVhdGVkIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJCYXNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVNYXJrZXIobGF5ZXI6IG51bWJlciwgb3B0aW9uczogSU1hcmtlck9wdGlvbnMpOiBQcm9taXNlPE1hcmtlcj4ge1xyXG4gICAgICAgIGNvbnN0IG1wOiBQcm9taXNlPEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcD4gPSB0aGlzLl9tYXBTZXJ2aWNlLk1hcFByb21pc2U7XHJcbiAgICAgICAgY29uc3QgbHA6IFByb21pc2U8TGF5ZXI+ID0gdGhpcy5fbGF5ZXJzLmdldChsYXllcik7XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbXAsIGxwXSkudGhlbigoW21hcCwgbF0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9ICh4OiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zKTogR29vZ2xlTWFya2VyID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoeCk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHZhbDogYW55LCBrZXk6IHN0cmluZykgPT4gbWFya2VyLk1ldGFkYXRhLnNldChrZXksIHZhbCkpOyB9XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuc2V0TWFwKG1hcCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gbmV3IEdvb2dsZU1hcmtlcihtYXJrZXIpO1xyXG4gICAgICAgICAgICAgICAgbS5Jc0ZpcnN0ID0gb3B0aW9ucy5pc0ZpcnN0O1xyXG4gICAgICAgICAgICAgICAgbS5Jc0xhc3QgPSBvcHRpb25zLmlzTGFzdDtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7IG9wdGlvbnMubWV0YWRhdGEuZm9yRWFjaCgodmFsOiBhbnksIGtleTogc3RyaW5nKSA9PiBtLk1ldGFkYXRhLnNldChrZXksIHZhbCkpOyB9XHJcbiAgICAgICAgICAgICAgICBsLkFkZEVudGl0eShtKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTWFya2VyT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaWNvbkluZm8gJiYgb3B0aW9ucy5pY29uSW5mby5tYXJrZXJUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gTWFya2VyLkNyZWF0ZU1hcmtlcihvcHRpb25zLmljb25JbmZvKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocykgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5pY29uID0gcztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZChvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnRoZW4oeCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uaWNvbiA9IHguaWNvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQobyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZChvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmJvdW5kIG1hcmtlcnMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIG1hcmtlcnMgdG8gYmUgdXNlZCBpbiBidWxrXHJcbiAgICAgKiBvcGVyYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTWFya2VyIG9wdGlvbnMgZGVmaW5pbmcgdGhlIG1hcmtlcnMuXHJcbiAgICAgKiBAcGFyYW0gbWFya2VySWNvbiAtIE9wdGlvbmFsIGluZm9ybWF0aW9uIHRvIGdlbmVyYXRlIGN1c3RvbSBtYXJrZXJzLiBUaGlzIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgbWFya2Vycy5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIHRoZSBhbiBhcnJheXMgb2YgdGhlIE1hcmtlciBtb2RlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyQmFzZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlTWFya2VycyhvcHRpb25zOiBBcnJheTxJTWFya2VyT3B0aW9ucz4sIG1hcmtlckljb24/OiBJTWFya2VySWNvbkluZm8pOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+IHtcclxuICAgICAgICBjb25zdCBwYXlsb2FkID0gKGljb246IHN0cmluZyk6IEFycmF5PEdvb2dsZU1hcmtlcj4gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXJzOiBBcnJheTxHb29nbGVNYXJrZXI+ID0gb3B0aW9ucy5tYXAobW8gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFya2VyT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU1hcmtlck9wdGlvbnMobW8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGljb24gJiYgaWNvbiAhPT0gJycpIHsgby5pY29uID0gaWNvbjsgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHVzaHBpbiA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIobyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXI6IEdvb2dsZU1hcmtlciA9IG5ldyBHb29nbGVNYXJrZXIocHVzaHBpbik7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuSXNGaXJzdCA9IG1vLmlzRmlyc3Q7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuSXNMYXN0ID0gbW8uaXNMYXN0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vLm1ldGFkYXRhKSB7IG1vLm1ldGFkYXRhLmZvckVhY2goKHZhbDogYW55LCBrZXk6IHN0cmluZykgPT4gbWFya2VyLk1ldGFkYXRhLnNldChrZXksIHZhbCkpOyB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hcmtlcnM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBwOiBQcm9taXNlPEFycmF5PE1hcmtlcj4+ID0gbmV3IFByb21pc2U8QXJyYXk8TWFya2VyPj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWFya2VySWNvbiAmJiBtYXJrZXJJY29uLm1hcmtlclR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBNYXJrZXIuQ3JlYXRlTWFya2VyKG1hcmtlckljb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihzKSA9PT0gJ3N0cmluZycpIHsgcmVzb2x2ZShwYXlsb2FkKHMpKTsgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMudGhlbih4ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwYXlsb2FkKHguaWNvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSAocGF5bG9hZChudWxsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQcm90ZWN0ZWQgbWV0aG9kc1xyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsYXllciBiYXNlZCBvbiBpdHMgaWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIGlkIC0gTGF5ZXIgSWQuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIExheWVyfSBtb2RlbCBmb3IgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllckJhc2VcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIEdldExheWVyQnlJZChpZDogbnVtYmVyKTogUHJvbWlzZTxMYXllcj4ge1xyXG4gICAgICAgIGxldCBwOiBQcm9taXNlPExheWVyPjtcclxuICAgICAgICB0aGlzLl9sYXllcnMuZm9yRWFjaCgobDogUHJvbWlzZTxMYXllcj4sIGs6IG51bWJlcikgPT4geyBpZiAoayA9PT0gaWQpIHsgcCA9IGw7IH0gfSk7XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsIsOvwrvCv2ltcG9ydCB7IElDbHVzdGVySWNvbkluZm8gfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ljbHVzdGVyLWljb24taW5mbyc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbWFya2VyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ljbHVzdGVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSU1hcmtlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ltYXJrZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IE1hcmtlclR5cGVJZCB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXItdHlwZS1pZCc7XHJcbmltcG9ydCB7IENsdXN0ZXJDbGlja0FjdGlvbiB9IGZyb20gJy4uLy4uL21vZGVscy9jbHVzdGVyLWNsaWNrLWFjdGlvbic7XHJcbmltcG9ydCB7IENsdXN0ZXJMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvY2x1c3Rlci1sYXllcic7XHJcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR29vZ2xlTGF5ZXJCYXNlIH0gZnJvbSAnLi9nb29nbGUtbGF5ZXItYmFzZSc7XHJcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWxpbmUnO1xyXG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgR29vZ2xlQ2x1c3RlclNlcnZpY2UgZXh0ZW5kcyBHb29nbGVMYXllckJhc2UgaW1wbGVtZW50cyBDbHVzdGVyU2VydmljZSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByb3RlY3RlZCBfbGF5ZXJzOiBNYXA8bnVtYmVyLCBQcm9taXNlPExheWVyPj4gPSBuZXcgTWFwPG51bWJlciwgUHJvbWlzZTxMYXllcj4+KCk7XHJcbiAgICBwcm90ZWN0ZWQgX2xheWVyU3R5bGVzOiBNYXA8bnVtYmVyLCBBcnJheTxHb29nbGVNYXBUeXBlcy5DbHVzdGVyU3R5bGU+PiA9IG5ldyBNYXA8bnVtYmVyLCBBcnJheTxHb29nbGVNYXBUeXBlcy5DbHVzdGVyU3R5bGU+PigpO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFN0YXRpYyBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIGNsdXN0ZXIgaWNvbiBmcm9tIHRoZSBzdHlsZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3R5bGVzXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2UgdGhhdCB3aGVuIHJlc29sdmVkIGNvbnRhaW5zIGFuIEFycmF5IG9mIElDbHVzdGVySWNvbkluZm8gb2JqZWN0c1xyXG4gICAgICogY29udGFpbmluZyB0aGUgaHlkcmF0ZWQgY2x1c3RlciBpY29ucy5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDbHVzdGVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIENyZWF0ZUNsdXN0ZXJJY29ucyhzdHlsZXM6IEFycmF5PElDbHVzdGVySWNvbkluZm8+KTogUHJvbWlzZTxBcnJheTxJQ2x1c3Rlckljb25JbmZvPj4ge1xyXG4gICAgICAgIGNvbnN0IGk6IFByb21pc2U8QXJyYXk8SUNsdXN0ZXJJY29uSW5mbz4+ID0gbmV3IFByb21pc2U8QXJyYXk8SUNsdXN0ZXJJY29uSW5mbz4+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGEgPSBuZXcgQXJyYXk8UHJvbWlzZTx7aWNvbjogc3RyaW5nLCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvfT4+KCk7XHJcbiAgICAgICAgICAgIHN0eWxlcy5mb3JFYWNoKChzdHlsZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5pY29uSW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHM6IHN0cmluZ3xQcm9taXNlPHtpY29uOiBzdHJpbmcsIGljb25JbmZvOiBJTWFya2VySWNvbkluZm99PiA9IE1hcmtlci5DcmVhdGVNYXJrZXIoc3R5bGUuaWNvbkluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YocykgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnVybCA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS53aWR0aCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHN0eWxlLmljb25JbmZvLnNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBzdHlsZS5pY29uSW5mby5zaXplLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8gJiYgc3R5bGUuaWNvbkluZm8uc2l6ZSAmJiBzdHlsZS5hbmNob3IgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbzogSU1hcmtlckljb25JbmZvID0gc3R5bGUuaWNvbkluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5hbmNob3IgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5zaXplLndpZHRoICogby5tYXJrZXJPZmZzZXRSYXRpby54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uc2l6ZS5oZWlnaHQgKiBvLm1hcmtlck9mZnNldFJhdGlvLnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlLmljb25JbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcy50aGVuKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUudXJsID0geC5pY29uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLndpZHRoID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS53aWR0aCA9IHguaWNvbkluZm8uc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSB4Lmljb25JbmZvLnNpemUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHguaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8gJiYgeC5pY29uSW5mby5zaXplICYmIHN0eWxlLmFuY2hvciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbzogSU1hcmtlckljb25JbmZvID0geC5pY29uSW5mbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5hbmNob3IgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8uc2l6ZS53aWR0aCAqIG8ubWFya2VyT2Zmc2V0UmF0aW8ueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby5zaXplLmhlaWdodCAqIG8ubWFya2VyT2Zmc2V0UmF0aW8ueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3R5bGUuaWNvbkluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYS5wdXNoKHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChwYS5sZW5ndGggPT09IDApIHsgcmVzb2x2ZShzdHlsZXMpOyB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocGEpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3R5bGVzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlQ2x1c3RlclNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2VcclxuICAgICAqIEBwYXJhbSBfem9uZVxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9tYXBTZXJ2aWNlOiBNYXBTZXJ2aWNlLCBfem9uZTogTmdab25lKSB7XHJcbiAgICAgICAgc3VwZXIoX21hcFNlcnZpY2UsIF96b25lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGNsdXN0ZXIgbGF5ZXIgdG8gdGhlIG1hcFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllclxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMYXllcihsYXllcjogQ2x1c3RlckxheWVyRGlyZWN0aXZlKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uczogSUNsdXN0ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogbGF5ZXIuSWQsXHJcbiAgICAgICAgICAgIHZpc2libGU6IGxheWVyLlZpc2libGUsXHJcbiAgICAgICAgICAgIGNsdXN0ZXJpbmdFbmFibGVkOiBsYXllci5DbHVzdGVyaW5nRW5hYmxlZCxcclxuICAgICAgICAgICAgem9vbU9uQ2xpY2s6IGxheWVyLkNsdXN0ZXJDbGlja0FjdGlvbiA9PT0gQ2x1c3RlckNsaWNrQWN0aW9uLlpvb21JbnRvQ2x1c3RlclxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGxheWVyLkdyaWRTaXplKSB7IG9wdGlvbnMuZ3JpZFNpemUgPSBsYXllci5HcmlkU2l6ZTsgfVxyXG4gICAgICAgIGlmIChsYXllci5NaW5pbXVtQ2x1c3RlclNpemUpIHsgb3B0aW9ucy5taW5pbXVtQ2x1c3RlclNpemUgPSBsYXllci5NaW5pbXVtQ2x1c3RlclNpemU7IH1cclxuICAgICAgICBpZiAobGF5ZXIuU3R5bGVzKSB7IG9wdGlvbnMuc3R5bGVzID0gbGF5ZXIuU3R5bGVzOyB9XHJcbiAgICAgICAgaWYgKGxheWVyLlVzZUR5bmFtaWNTaXplTWFya2Vycykge1xyXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIGRvIG5vdCB0byBhdHRlbXB0IHRvIHNldHVwIHN0eWxlcyBoZXJlIGFzIHRoZSBkeW5hbWljIGNhbGwgYmFjayB3aWxsIGdlbmVyYXRlIHRoZW0uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlcyA9IFt7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDMwLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDM1LFxyXG4gICAgICAgICAgICAgICAgdGV4dENvbG9yOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICAgICAgdGV4dFNpemU6IDExLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgICAgIGljb25JbmZvOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyVHlwZTogTWFya2VyVHlwZUlkLkZvbnRNYXJrZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9udE5hbWU6ICdGb250QXdlc29tZScsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDMwLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnZ3JlZW4nLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICdcXHVGMTExJ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZHluYW1pY0NsdXN0ZXJDYWxsYmFjayA9IChtYXJrZXJzOiBBcnJheTxHb29nbGVNYXBUeXBlcy5NYXJrZXI+LCBudW1TdHlsZXM6IG51bWJlcixcclxuICAgICAgICAgICAgY2x1c3RlcmVyOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJDbHVzdGVyZXIpID0+IHtcclxuICAgICAgICAgICAgLy8gZHluYW1pY2FsbHkgZW5zdXJlIHRoYXQgdGhlIG5lY2Vzc2FyeSBzdHlsZSBmb3IgdGhpcyBjbHVzdGVyIGljb24gZXhpc3RzIGFuZFxyXG4gICAgICAgICAgICAvLyB0aGUgY2x1c3RlcmVyIGlzIGFscmVhZHkgaG9va2VkIHVwIHRvIHRoZSBzdHlsZXMgYXJyYXkgdmlhIHBvaW50ZXIsIHNvIHdlIG9ubHlcclxuICAgICAgICAgICAgLy8gbmVlZCB0byB1cGRhdGUgdGhlIHN0eWxlLiBTaW5jZSB0aGUgY2x1c3RlcmVyIHJlLXJlbmRlcnMgYSBjbHVzdGVyIGljb24gaXMgdGhlXHJcbiAgICAgICAgICAgIC8vIHRoZSBtYXJrZXIgY291bnQgY2hhbmdlcywgd2Ugd2lsbCBvbmx5IG5lZWQgdG8gcmV0YWluIHRoZSBjdXJyZW50IGljb24gYXMgb3Bwb3NlZFxyXG4gICAgICAgICAgICAvLyB0byBhbGwgY2x1c3RlciBpY29uLlxyXG4gICAgICAgICAgICBjb25zdCBzdHlsZXM6IEFycmF5PEdvb2dsZU1hcFR5cGVzLkNsdXN0ZXJTdHlsZT4gPSB0aGlzLl9sYXllclN0eWxlcy5nZXQobGF5ZXIuSWQpO1xyXG4gICAgICAgICAgICBjb25zdCBpY29uSW5mbzogSU1hcmtlckljb25JbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgbWFya2VyVHlwZTogTWFya2VyVHlwZUlkLk5vbmVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgaWNvbjogc3RyaW5nID0gbGF5ZXIuQ3VzdG9tTWFya2VyQ2FsbGJhY2soPGFueT5tYXJrZXJzLCBpY29uSW5mbyk7XHJcbiAgICAgICAgICAgIHN0eWxlc1swXSA9IHtcclxuICAgICAgICAgICAgICAgIHVybDogYFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCwke2ljb259XFxcImAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGljb25JbmZvLnNpemUuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGljb25JbmZvLnNpemUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0U2l6ZTogMTEsXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246ICdjZW50ZXInLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogbWFya2Vycy5sZW5ndGgudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgIGluZGV4OiAxXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZXNldFN0eWxlcyA9IChjbHVzdGVyZXI6IEdvb2dsZU1hcFR5cGVzLk1hcmtlckNsdXN0ZXJlcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJTdHlsZXMuaGFzKGxheWVyLklkKSkgeyB0aGlzLl9sYXllclN0eWxlcy5nZXQobGF5ZXIuSWQpLnNwbGljZSgwKTsgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlczogQXJyYXk8R29vZ2xlTWFwVHlwZXMuQ2x1c3RlclN0eWxlPiA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5DbHVzdGVyU3R5bGU+KCk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZXMucHVzaCh7fSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllclN0eWxlcy5zZXQobGF5ZXIuSWQsIHN0eWxlcyk7XHJcbiAgICAgICAgICAgICAgICBjbHVzdGVyZXIuc2V0U3R5bGVzKHN0eWxlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgc3R5bGVzIGFzIHRoZSBwb2ludGVyIHRvIHRoaXMgYXJyYXkgZ2V0cyBwYXNzZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcm91bmQga2V5IG9iamVjdHMgaW4gdGhlIGNsdXN0ZXJlci4gVGhlcmVmb3JlLCBpdCBtdXN0IGJlIGluaXRpYWxpemVkIGhlcmUgaW4gb3JkZXIgZm9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0byB0aGUgc3R5bGVzIHRvIGJlIHZpc2libGUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxzbywgd2UgbmVlZCB0byBhZGQgYXQgbGVhc3Qgb25lIHN0eWxlIHRvIHByZXZlbnQgdGhlIGRlZmF1bHQgc3R5bGVzIGZyb20gYmVpbmcgcGlja2VkIHVwLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgbGF5ZXJQcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVDbHVzdGVyTGF5ZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJzLnNldChsYXllci5JZCwgbGF5ZXJQcm9taXNlKTtcclxuICAgICAgICBsYXllclByb21pc2UudGhlbihsID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2x1c3RlcmVyOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJDbHVzdGVyZXIgPSA8R29vZ2xlTWFwVHlwZXMuTWFya2VyQ2x1c3RlcmVyPmwuTmF0aXZlUHJpbWl0dmU7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0eWxlcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyAgPSBHb29nbGVDbHVzdGVyU2VydmljZS5DcmVhdGVDbHVzdGVySWNvbnMob3B0aW9ucy5zdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgcy50aGVuKHggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJlci5zZXRTdHlsZXMoPEFycmF5PEdvb2dsZU1hcFR5cGVzLkNsdXN0ZXJTdHlsZT4+eCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc2V0U3R5bGVzKGNsdXN0ZXJlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBTZXJ2aWNlLk1hcFByb21pc2UudGhlbigobTogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbS5hZGRMaXN0ZW5lcignem9vbV9jaGFuZ2VkJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFN0eWxlcyhjbHVzdGVyZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjbHVzdGVyZXIuc2V0Q2FsY3VsYXRvcigobSwgbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkeW5hbWljQ2x1c3RlckNhbGxiYWNrKG0sIG4sIGNsdXN0ZXJlcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbWFya2VyIGluIHRoZSBjbHVzdGVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVNYXJrZXIobGF5ZXI6IG51bWJlciwgb3B0aW9uczogSU1hcmtlck9wdGlvbnMpOiBQcm9taXNlPE1hcmtlcj4ge1xyXG4gICAgICAgIGNvbnN0IHA6IFByb21pc2U8TGF5ZXI+ID0gdGhpcy5HZXRMYXllckJ5SWQobGF5ZXIpO1xyXG4gICAgICAgIGlmIChwID09IG51bGwpIHsgdGhyb3cgKG5ldyBFcnJvcihgTGF5ZXIgd2l0aCBpZCAke2xheWVyfSBub3QgZm91bmQgaW4gTGF5ZXIgTWFwYCkpOyB9XHJcblxyXG4gICAgICAgIHJldHVybiBwLnRoZW4oKGw6IExheWVyKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZU1hcmtlcihvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKG1hcmtlcjogTWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLklzRmlyc3QgPSBvcHRpb25zLmlzRmlyc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLklzTGFzdCA9IG9wdGlvbnMuaXNMYXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGwuQWRkRW50aXR5KG1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlcjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHRoZSBjbHVzdGVyaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFN0YXJ0Q2x1c3RlcmluZyhsYXllcjogQ2x1c3RlckxheWVyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhlIGNsdXN0ZXJpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXJcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDbHVzdGVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU3RvcENsdXN0ZXJpbmcobGF5ZXI6IENsdXN0ZXJMYXllckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBwb2x5Z29uIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5Z29uLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5Z29uIG9wdGlvbnMgZGVmaW5pbmcgdGhlIHBvbHlnb24uXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIFBvbHlnb24gbW9kZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVQb2x5Z29uKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IFByb21pc2U8UG9seWdvbj4ge1xyXG4gICAgICAgIHRocm93IChuZXcgRXJyb3IoJ1BvbHlnb25zIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNsdXN0ZXJpbmcgbGF5ZXJzLiBZb3UgY2FuIG9ubHkgdXNlIG1hcmtlcnMuJykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmJvdW5kIHBvbHlnb25zLiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIGFycmF5cyBvZiBwb2x5Z29ucyB0byBiZSB1c2VkIGluIGJ1bGtcclxuICAgICAqIG9wZXJhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIHBvbHlnb24uXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlnb24gb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWdvbnMuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gYXJyYXlzIG9mIHRoZSBQb2x5Z29uIG1vZGVscy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlQ2x1c3RlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb25zKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IEFycmF5PElQb2x5Z29uT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlnb24+PiB7XHJcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignUG9seWdvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY2x1c3RlcmluZyBsYXllcnMuIFlvdSBjYW4gb25seSB1c2UgbWFya2Vycy4nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWxpbmUgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIGxpbmUuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBvbHlsaW5lIG9wdGlvbnMgZGVmaW5pbmcgdGhlIGxpbmUuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIFBvbHlsaW5lIChvciBhblxyXG4gICAgICogYXJyYXkgb2YgcG9seWdvbnMgZm9yIGNvbXBsZXggcGF0aHMpIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVDbHVzdGVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWxpbmUobGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyk6IFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+PiB7XHJcbiAgICAgICAgdGhyb3cgKG5ldyBFcnJvcignUG9seWxpbmVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNsdXN0ZXJpbmcgbGF5ZXJzLiBZb3UgY2FuIG9ubHkgdXNlIG1hcmtlcnMuJykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmJvdW5kIHBvbHlsaW5lcy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWxpbmVzIHRvIGJlIHVzZWQgaW4gYnVsa1xyXG4gICAgICogb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWxpbmVzLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5bGluZSBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5bGluZXMuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gYXJyYXlzIG9mIHRoZSBQb2x5bGluZSBtb2RlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVQb2x5bGluZXMobGF5ZXI6IG51bWJlciwgb3B0aW9uczogQXJyYXk8SVBvbHlsaW5lT3B0aW9ucz4pOiBQcm9taXNlPEFycmF5PFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+IHtcclxuICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdQb2x5bGluZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY2x1c3RlcmluZyBsYXllcnMuIFlvdSBjYW4gb25seSB1c2UgbWFya2Vycy4nKSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IEluZm9Cb3hDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2luZm9ib3gnO1xyXG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuLi9pbmZvYm94LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbWFya2VyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgR29vZ2xlSW5mb1dpbmRvdyB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLWluZm8td2luZG93JztcclxuaW1wb3J0IHsgR29vZ2xlTWFya2VyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtbWFya2VyJztcclxuaW1wb3J0IHsgR29vZ2xlTWFwRXZlbnRzTG9va3VwIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtZXZlbnRzLWxvb2t1cCc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVJbmZvQm94U2VydmljZSBleHRlbmRzIEluZm9Cb3hTZXJ2aWNlIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBkZWNsYXJhdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIHByaXZhdGUgX2JveGVzOiBNYXA8SW5mb0JveENvbXBvbmVudCwgUHJvbWlzZTxJbmZvV2luZG93Pj4gPSBuZXcgTWFwPEluZm9Cb3hDb21wb25lbnQsIFByb21pc2U8R29vZ2xlSW5mb1dpbmRvdz4+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlSW5mb0JveFNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2VcclxuICAgICAqIEBwYXJhbSBfbWFya2VyU2VydmljZVxyXG4gICAgICogQHBhcmFtIF96b25lXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfbWFya2VyU2VydmljZTogTWFya2VyU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBpbmZvIHdpbmRvd1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmZvXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUluZm9Cb3hTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRJbmZvV2luZG93KGluZm86IEluZm9Cb3hDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMgPSB7fTtcclxuICAgICAgICBpZiAoaW5mby5IdG1sQ29udGVudCAhPT0gJycpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5odG1sQ29udGVudCA9IGluZm8uSHRtbENvbnRlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zLnRpdGxlID0gaW5mby5UaXRsZTtcclxuICAgICAgICAgICAgb3B0aW9ucy5kZXNjcmlwdGlvbiA9IGluZm8uRGVzY3JpcHRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmZvLnhPZmZzZXQgfHwgaW5mby55T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBpeGVsT2Zmc2V0ID09IG51bGwpIHsgb3B0aW9ucy5waXhlbE9mZnNldCA9IHsgeDogMCwgeTogMCB9OyB9XHJcbiAgICAgICAgICAgIGlmIChpbmZvLnhPZmZzZXQpIHsgb3B0aW9ucy5waXhlbE9mZnNldC54ID0gaW5mby54T2Zmc2V0OyB9XHJcbiAgICAgICAgICAgIGlmIChpbmZvLnlPZmZzZXQpIHsgb3B0aW9ucy5waXhlbE9mZnNldC55ID0gaW5mby55T2Zmc2V0OyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdGlvbnMuZGlzYWJsZUF1dG9QYW4gPSBpbmZvLkRpc2FibGVBdXRvUGFuO1xyXG4gICAgICAgIG9wdGlvbnMudmlzaWJsZSA9IGluZm8uVmlzaWJsZTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbmZvLkxhdGl0dWRlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgaW5mby5Mb25naXR1ZGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24gPSB7IGxhdGl0dWRlOiBpbmZvLkxhdGl0dWRlLCBsb25naXR1ZGU6IGluZm8uTG9uZ2l0dWRlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluZm9XaW5kb3dQcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVJbmZvV2luZG93KG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2JveGVzLnNldChpbmZvLCBpbmZvV2luZG93UHJvbWlzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhlIGluZm8gd2luZG93XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZm9cclxuICAgICAqIEByZXR1cm5zIC0gIEEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIGluZm8gYm94IGlzIGNsb3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENsb3NlKGluZm86IEluZm9Cb3hDb21wb25lbnQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYm94ZXMuZ2V0KGluZm8pLnRoZW4odyA9PiB7XHJcbiAgICAgICAgICAgIHcuQ2xvc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhbiBldmVudCBkZWxlZ2F0ZSBmb3IgYW4gaW5mbyB3aW5kb3cuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciAoZS5nLiAnY2xpY2snKVxyXG4gICAgICogQHBhcmFtIGluZm9Db21wb25lbnQgLSBUaGUge0BsaW5rIEluZm9Cb3hDb21wb25lbnR9IGZvciB3aGljaCB0byByZWdpc3RlciB0aGUgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyAtIE9ic2VydmFibGUgZW1pdGluZyBhbiBpbnN0YW5jZSBvZiBUIGVhY2ggdGltZSB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBpbmZvQ29tcG9uZW50OiBJbmZvQm94Q29tcG9uZW50KTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgICAgICAgY29uc3QgZ29vZ2xlRXZlbnROYW1lOiBzdHJpbmcgPSBHb29nbGVNYXBFdmVudHNMb29rdXBbZXZlbnROYW1lXTtcclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9ib3hlcy5nZXQoaW5mb0NvbXBvbmVudCkudGhlbigoYjogSW5mb1dpbmRvdykgPT4ge1xyXG4gICAgICAgICAgICAgICAgYi5BZGRMaXN0ZW5lcihnb29nbGVFdmVudE5hbWUsIChlOiBUKSA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiBvYnNlcnZlci5uZXh0KGUpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgaW5mbyB3aW5kb3dcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5mb1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlSW5mb1dpbmRvdyhpbmZvOiBJbmZvQm94Q29tcG9uZW50KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgdGhlIGluZm8gd2luZG93LiBXaW5kb3cgb3BlbnMgb24gYSBtYXJrZXIsIGlmIHN1cHBsaWVkLCBvciBhIHNwZWNpZmljIGxvY2F0aW9uIGlmIGdpdmVuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZm9cclxuICAgICAqIEBwYXJhbSBbbG9jXVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVJbmZvQm94U2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgT3BlbihpbmZvOiBJbmZvQm94Q29tcG9uZW50LCBsb2M/OiBJTGF0TG9uZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmIChpbmZvLkNsb3NlSW5mb0JveGVzT25PcGVuIHx8IGluZm8uTW9kYWwpIHtcclxuICAgICAgICAgICAgLy8gY2xvc2UgYWxsIG9wZW4gaW5mbyBib3hlc1xyXG4gICAgICAgICAgICB0aGlzLl9ib3hlcy5mb3JFYWNoKChib3g6IFByb21pc2U8SW5mb1dpbmRvdz4sIGk6IEluZm9Cb3hDb21wb25lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmZvLklkICE9PSBpLklkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm94LnRoZW4oKHcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcuSXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3LkNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLkNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3hlcy5nZXQoaW5mbykudGhlbigodzogR29vZ2xlSW5mb1dpbmRvdykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zOiBJSW5mb1dpbmRvd09wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgaWYgKGluZm8uSHRtbENvbnRlbnQgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmh0bWxDb250ZW50ID0gaW5mby5IdG1sQ29udGVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMudGl0bGUgPSBpbmZvLlRpdGxlO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kZXNjcmlwdGlvbiA9IGluZm8uRGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdy5TZXRPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoaW5mby5Ib3N0TWFya2VyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJTZXJ2aWNlLkdldE5hdGl2ZU1hcmtlcihpbmZvLkhvc3RNYXJrZXIpLnRoZW4oKG1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXBTZXJ2aWNlLk1hcFByb21pc2UudGhlbigobWFwKSA9PiAoPEdvb2dsZUluZm9XaW5kb3c+dykuT3BlbigoPEdvb2dsZU1hcmtlcj5tYXJrZXIpLk5hdGl2ZVByaW1pdHZlKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwU2VydmljZS5NYXBQcm9taXNlLnRoZW4oKG1hcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvYykgeyB3LlNldFBvc2l0aW9uKGxvYyk7IH1cclxuICAgICAgICAgICAgICAgIHcuT3BlbigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IG9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5mb1xyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMoaW5mbzogSW5mb0JveENvbXBvbmVudCwgb3B0aW9uczogSUluZm9XaW5kb3dPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JveGVzLmdldChpbmZvKS50aGVuKCh3OiBHb29nbGVJbmZvV2luZG93KSA9PiB7XHJcbiAgICAgICAgICAgIHcuU2V0T3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGluZm8gd2luZG93IHBvc2l0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZm9cclxuICAgICAqIEBwYXJhbSBsYXRsbmdcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlSW5mb0JveFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFBvc2l0aW9uKGluZm86IEluZm9Cb3hDb21wb25lbnQsIGxhdGxuZzogSUxhdExvbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0aGlzLl9ib3hlcy5nZXQoaW5mbykudGhlbigodykgPT4ge1xyXG4gICAgICAgICAgICB3LlNldFBvc2l0aW9uKGxhdGxuZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBlYWNoU2VyaWVzLCBuZXh0VGljayB9IGZyb20gJ2FzeW5jJztcclxuaW1wb3J0IHsgR29vZ2xlTWFya2VyIH0gZnJvbSAnLi9nb29nbGUtbWFya2VyJztcclxuaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2xheWVyJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbWFya2VyJztcclxuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uL3BvbHlnb24nO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uL3BvbHlsaW5lJztcclxuaW1wb3J0IHsgQ2x1c3RlclBsYWNlbWVudE1vZGUgfSBmcm9tICcuLi9jbHVzdGVyLXBsYWNlbWVudC1tb2RlJztcclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIGEgbGF5ZXIgZm9yIHRoZSBHb29nbGUgTWFwIFByb3ZpZGVyLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR29vZ2xlTGF5ZXIgaW1wbGVtZW50cyBMYXllciB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2VudGl0aWVzOiBBcnJheTxNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lPiA9IG5ldyBBcnJheTxNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lPigpO1xyXG4gICAgcHJpdmF0ZSBfdmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgZGVmaW5pdGlvbnNcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBuYXRpdmUgcHJpbWl0aXZlIHVuZGVybmVhdGggdGhlIGFic3RyYWN0aW9uIGxheWVyLiBHb29nbGUgZG9lcyBub3QgaGF2ZSB0aGUgY29uY2VwdCBvZiBhIGN1c3RvbSBsYXllcixcclxuICAgICAqIHNvIHdlIGFyZSByZXR1cm5pbmcgdGhlIE1hcCBhcyB0aGUgbmF0aXZlIG9iamVjdCBiZWNhdXNlIGl0IGhvc3RzIGFsbCB0aGUgbWFya2Vycy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXAuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTmF0aXZlUHJpbWl0dmUoKTogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgR29vZ2xlTWFya2VyQ2x1c3RlcmVyIGNsYXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBfbGF5ZXIgR29vZ2xlTWFwVHlwZXMuTWFya2VyQ2x1c3RlcmVyLiBOYXRpdmUgR29vZ2xlIE1hcHMgTWFya2VyIENsdXN0ZXJlciBzdXBwb3J0aW5nIHRoZSBjbHVzdGVyIGxheWVyLlxyXG4gICAgICogQHBhcmFtIF9tYXBzIE1hcFNlcnZpY2UuIE1hcFNlcnZpY2UgaW1wbGVtZW50YXRpb24gdG8gbGV2ZXJhZ2UgZm9yIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbGF5ZXI6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCwgcHJpdmF0ZSBfbWFwczogTWFwU2VydmljZSwgcHJpdmF0ZSBfaWQ6IG51bWJlcikgeyB9XHJcblxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzLCBMYXllciBpbnRlcmZhY2UgaW1wbGVtZW50YXRpb25cclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgc3RyaW5nLiBUeXBlIG9mIGV2ZW50IHRvIGFkZCAoY2xpY2ssIG1vdXNlb3ZlciwgZXRjKS4gWW91IGNhbiB1c2UgYW55IGV2ZW50IHRoYXQgdGhlIHVuZGVybHlpbmcgbmF0aXZlXHJcbiAgICAgKiBsYXllciBzdXBwb3J0cy5cclxuICAgICAqIEBwYXJhbSBmbiBmdW5jdGlvbi4gSGFuZGxlciB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IG9jY3Vycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdFdmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gR29vZ2xlIExheWVycy4gWW91IGNhbiBzdGlsbCBhZGQgZXZlbnRzIHRvIGluZGl2aWR1YWwgbWFya2Vycy4nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGVudGl0eSB0byB0aGUgbGF5ZXIuIFVzZSB0aGlzIG1ldGhvZCB3aXRoIGNhdXRpb24gYXMgaXQgd2lsbFxyXG4gICAgICogdHJpZ2dlciBhIHJlY2FsdWF0aW9uIG9mIHRoZSBjbHVzdGVycyAoYW5kIGFzc29jaWF0ZWQgbWFya2VycyBpZiBhcHByb3ByaXRlKSBmb3JcclxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gSWYgeW91IHVzZSB0aGlzIG1ldGhvZCB0byBhZGQgbWFueSBtYXJrZXJzIHRvIHRoZSBjbHVzdGVyLCB1c2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5IE1hcmtlcnxJbmZvV2luZG93fFBvbHlnb258UG9seWxpbmUuIEVudGl0eSB0byBhZGQgdG8gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMQXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkRW50aXR5KGVudGl0eTogTWFya2VyIHwgSW5mb1dpbmRvdyB8IFBvbHlnb24gfCBQb2x5bGluZSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChlbnRpdHkuTmF0aXZlUHJpbWl0dmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW50aXRpZXMucHVzaChlbnRpdHkpO1xyXG4gICAgICAgICAgICBlbnRpdHkuTmF0aXZlUHJpbWl0dmUuc2V0VmlzaWJsZSh0aGlzLl92aXNpYmxlKTtcclxuICAgICAgICAgICAgZW50aXR5Lk5hdGl2ZVByaW1pdHZlLnNldE1hcCh0aGlzLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbnVtYmVyIG9mIGVudGl0aWVzIHRvIHRoZSBsYXllci4gRW50aXRpZXMgaW4gdGhpcyBjb250ZXh0IHNob3VsZCBiZSBtb2RlbCBhYnN0cmFjdGlvbnMgb2YgY29uY2VyZWQgbWFwIGZ1bmN0aW9uYWxpdHkgKHN1Y2hcclxuICAgICAqIGFzIG1hcmtlciwgaW5mb3dpbmRvdywgcG9seWxpbmUsIHBvbHlnb24sIGV0Yy4uKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdGllcyBBcnJheTxNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lPi4gRW50aXRpZXMgdG8gYWRkIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTEF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZEVudGl0aWVzKGVudGl0aWVzOiBBcnJheTxNYXJrZXJ8SW5mb1dpbmRvd3xQb2x5Z29ufFBvbHlsaW5lPik6IHZvaWQge1xyXG4gICAgICAgIGlmIChlbnRpdGllcyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkoZW50aXRpZXMpICYmIGVudGl0aWVzLmxlbmd0aCAhPT0gMCApIHtcclxuICAgICAgICAgICAgdGhpcy5fZW50aXRpZXMucHVzaCguLi5lbnRpdGllcyk7XHJcbiAgICAgICAgICAgIGVhY2hTZXJpZXMoWy4uLmVudGl0aWVzXSwgKGUsIG5leHQpID0+IHtcclxuICAgICAgICAgICAgICAgIGUuTmF0aXZlUHJpbWl0dmUuc2V0VmlzaWJsZSh0aGlzLl92aXNpYmxlKTtcclxuICAgICAgICAgICAgICAgIGUuTmF0aXZlUHJpbWl0dmUuc2V0TWFwKHRoaXMuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgICAgICAgICAgbmV4dFRpY2soKCkgPT4gbmV4dCgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgbGF5ZXIgYW5iZCB0aGUgbWFya2VycyBpbiBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcclxuICAgICAgICBlYWNoU2VyaWVzKHRoaXMuX2VudGl0aWVzLnNwbGljZSgwKSwgKGUsIG5leHQpID0+IHtcclxuICAgICAgICAgICAgZS5OYXRpdmVQcmltaXR2ZS5zZXRNYXAobnVsbCk7XHJcbiAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IG5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIGdvdmVybmluZyB0aGUgYmVoYXZpb3Igb2YgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIElMYXllck9wdGlvbnMuIFRoZSBsYXllciBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0T3B0aW9ucygpOiBJTGF5ZXJPcHRpb25zIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zOiBJTGF5ZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogdGhpcy5faWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQm9vbGVhbi4gVHJ1ZSBpcyB0aGUgbGF5ZXIgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0VmlzaWJsZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gZW50aXR5IGZyb20gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyfEluZm9XaW5kb3d8UG9seWdvbnxQb2x5bGluZSBFbnRpdHkgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFJlbW92ZUVudGl0eShlbnRpdHk6IE1hcmtlciB8IEluZm9XaW5kb3cgfCBQb2x5Z29uIHwgUG9seWxpbmUpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZW50aXR5Lk5hdGl2ZVByaW1pdHZlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGo6IG51bWJlciA9IHRoaXMuX2VudGl0aWVzLmluZGV4T2YoZW50aXR5KTtcclxuICAgICAgICAgICAgaWYgKGogPiAtMSkgeyB0aGlzLl9lbnRpdGllcy5zcGxpY2UoaiwgMSk7IH1cclxuICAgICAgICAgICAgZW50aXR5Lk5hdGl2ZVByaW1pdHZlLnNldE1hcChudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBlbnRpdGllcyBmb3IgdGhlIGNsdXN0ZXIgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVudGl0aWVzIEFycmF5PE1hcmtlcj58QXJyYXk8SW5mb1dpbmRvdz58QXJyYXk8UG9seWdvbj58QXJyYXk8UG9seWxpbmU+IGNvbnRhaW5pbmdcclxuICAgICAqIHRoZSBlbnRpdGllcyB0byBhZGQgdG8gdGhlIGNsdXN0ZXIuIFRoaXMgcmVwbGFjZXMgYW55IGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0RW50aXRpZXMoZW50aXRpZXM6IEFycmF5PE1hcmtlcj4gfCBBcnJheTxJbmZvV2luZG93PiB8IEFycmF5PFBvbHlnb24+IHwgQXJyYXk8UG9seWxpbmU+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5EZWxldGUoKTtcclxuICAgICAgICB0aGlzLkFkZEVudGl0aWVzKGVudGl0aWVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG9wdGlvbnMgZm9yIHRoZSBjbHVzdGVyIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIElMYXllck9wdGlvbnMgY29udGFpbmluZyB0aGUgb3B0aW9ucyBlbnVtZXJhdGlvbiBjb250cm9sbGluZyB0aGUgbGF5ZXIgYmVoYXZpb3IuIFRoZSBzdXBwbGllZCBvcHRpb25zXHJcbiAgICAgKiBhcmUgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQvZXhpc3Rpbmcgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMob3B0aW9uczogSUxheWVyT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2lkID0gb3B0aW9ucy5pZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRvZ2dsZXMgdGhlIGNsdXN0ZXIgbGF5ZXIgdmlzaWJpbGl0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmlzaWJsZSBCb29sZWFuIHRydWUgdG8gbWFrZSB0aGUgbGF5ZXIgdmlzaWJsZSwgZmFsc2UgdG8gaGlkZSB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlckNsdXN0ZXJlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgZWFjaFNlcmllcyhbLi4udGhpcy5fZW50aXRpZXNdLCAoZSwgbmV4dCkgPT4ge1xyXG4gICAgICAgICAgICBlLk5hdGl2ZVByaW1pdHZlLnNldFZpc2libGUodmlzaWJsZSk7XHJcbiAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IG5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgSVBvbHlsaW5lT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9sYXllcic7XHJcbmltcG9ydCB7IEdvb2dsZUxheWVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtbGF5ZXInO1xyXG5pbXBvcnQgeyBHb29nbGVQb2x5Z29uIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtcG9seWdvbic7XHJcbmltcG9ydCB7IEdvb2dsZVBvbHlsaW5lIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dvb2dsZS9nb29nbGUtcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBNYXBMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbWFwLWxheWVyJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZUxheWVyQmFzZSB9IGZyb20gJy4vZ29vZ2xlLWxheWVyLWJhc2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHb29nbGVDb252ZXJzaW9ucyB9IGZyb20gJy4vZ29vZ2xlLWNvbnZlcnNpb25zJztcclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi9nb29nbGUtbWFwLXR5cGVzJztcclxuXHJcbmRlY2xhcmUgdmFyIGdvb2dsZTogYW55O1xyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBMYXllclNlcnZpY2V9IGNvbnRyYWN0IGZvciBhIEdvb2dsZSBNYXBzIHNwZWNpZmljIGltcGxlbWVudGF0aW9uLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVMYXllclNlcnZpY2UgZXh0ZW5kcyBHb29nbGVMYXllckJhc2UgaW1wbGVtZW50cyBMYXllclNlcnZpY2UgIHtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBGaWVsZCBEZWNsYXJhdGlvbnMuXHJcbiAgICAvLy9cclxuICAgIHByb3RlY3RlZCBfbGF5ZXJzOiBNYXA8bnVtYmVyLCBQcm9taXNlPExheWVyPj4gPSBuZXcgTWFwPG51bWJlciwgUHJvbWlzZTxMYXllcj4+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHb29nbGVMYXllclNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSBJbnN0YW5jZSBvZiB0aGUgR29vZ2xlIE1hcHMgU2VydmljZS4gV2lsbCBnZW5lcmFsbHkgYmUgaW5qZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgaW5zdGFuY2UgdG8gcHJvdmlkZSB6b25lIGF3YXJlIHByb21pc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsIF96b25lOiBOZ1pvbmUpIHtcclxuICAgICAgICBzdXBlcihfbWFwU2VydmljZSwgX3pvbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGxheWVyIHRvIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBNYXBMYXllckRpcmVjdGl2ZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAgICogR2VuZXJhbGx5LCBNYXBMYXllckRpcmVjdGl2ZSB3aWxsIGJlIGluamVjdGVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAgKiBMYXllclNlcnZpY2UgYW5kIHRoZW4gc2VsZiByZWdpc3RlciBvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTGF5ZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRMYXllcihsYXllcjogTWFwTGF5ZXJEaXJlY3RpdmUpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBwOiBQcm9taXNlPExheWVyPiA9IG5ldyBQcm9taXNlPExheWVyPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcFNlcnZpY2UuTWFwUHJvbWlzZS50aGVuKG0gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbDogR29vZ2xlTGF5ZXIgPSBuZXcgR29vZ2xlTGF5ZXIobSwgdGhpcy5fbWFwU2VydmljZSwgbGF5ZXIuSWQpO1xyXG4gICAgICAgICAgICAgICAgbC5TZXRWaXNpYmxlKGxheWVyLlZpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJzLnNldChsYXllci5JZCwgcCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWdvbiB0byB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgLSBUaGUgaWQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRvIGFkZCB0aGUgcG9seWdvbi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWdvbiBvcHRpb25zIGRlZmluaW5nIHRoZSBwb2x5Z29uLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGluc3RhbmNlIG9mIHRoZSBQb2x5Z29uIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlnb24obGF5ZXI6IG51bWJlciwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTxQb2x5Z29uPiB7XHJcbiAgICAgICAgY29uc3QgcDogUHJvbWlzZTxQb2x5Z29uPiA9IHRoaXMuX21hcFNlcnZpY2UuQ3JlYXRlUG9seWdvbihvcHRpb25zKTtcclxuICAgICAgICBjb25zdCBsOiBQcm9taXNlPExheWVyPiA9IHRoaXMuX2xheWVycy5nZXQobGF5ZXIpO1xyXG4gICAgICAgIFByb21pc2UuYWxsKFtwLCBsXSkudGhlbih4ID0+IHhbMV0uQWRkRW50aXR5KHhbMF0pKTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBwb2x5Z29ucy4gVXNlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSBhcnJheXMgb2YgcG9seWdvbnMgdG8gYmUgdXNlZCBpbiBidWxrXHJcbiAgICAgKiBvcGVyYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5Z29uLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQb2x5Z29uIG9wdGlvbnMgZGVmaW5pbmcgdGhlIHBvbHlnb25zLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGFycmF5cyBvZiB0aGUgUG9seWdvbiBtb2RlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZUxheWVyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWdvbnMobGF5ZXI6IG51bWJlciwgb3B0aW9uczogQXJyYXk8SVBvbHlnb25PcHRpb25zPik6IFByb21pc2U8QXJyYXk8UG9seWdvbj4+IHtcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIE5vdGU6IHdlIGF0dGVtcHRlZCB1c2luZyBkYXRhLlBvbHlnb25zIGluIGFuIGF0dGVtcHQgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgYnV0IGVpdGhlciBkYXRhLlBvbHlnb25cclxuICAgICAgICAvLyBvciBkYXRhLk11bHRpUG9seWdvbiBhY3R1YWxseSBvcGVyYXRlIHNpZ25pZmljYW50bHkgc2xvd2VyIHRoYW4gZ2VuZXJhdGluZyB0aGUgcG9seWdvbnMgdGhpcyB3YXkuXHJcbiAgICAgICAgLy8gdGhlIHNsb3duZXNzIGluIGdvb2dsZSBhcyBvcHBvc2VkIHRvIGJpbmcgcHJvYmFibHkgY29tZXMgZnJvbSB0aGUgcG9pbnQgcmVkdWN0aW9uIGFsZ29yaXRobSB1c2VzLlxyXG4gICAgICAgIC8vIFNpZ25pZ2ljYW50IHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cyBtaWdodCBiZSBwb3NzaWJsZSBpbiBnb29nbGUgd2hlbiB1c2luZyBhIHBpeGVsIGJhc2VkIHJlZHVjdGlvbiBhbGdvcml0aG1cclxuICAgICAgICAvLyBwcmlvciB0byBzZXR0aW5nIHRoZSBwb2x5Z29uIHBhdGguIFRoaXMgd2lsbCBsb3dlciB0byBwcm9jZXNzaW5nIG92ZXJoZWFkIG9mIHRoZSBnb29nbGUgYWxnb3JpdGhtICh3aXRoIGlzIERvdWdsYXMtUGV1Y2tlclxyXG4gICAgICAgIC8vIGFuZCByYXRoZXIgY29tcHV0ZSBpbnRlbnNpdmUpXHJcbiAgICAgICAgLy9cclxuICAgICAgICBjb25zdCBwOiBQcm9taXNlPExheWVyPiA9IHRoaXMuR2V0TGF5ZXJCeUlkKGxheWVyKTtcclxuICAgICAgICBpZiAocCA9PSBudWxsKSB7IHRocm93IChuZXcgRXJyb3IoYExheWVyIHdpdGggaWQgJHtsYXllcn0gbm90IGZvdW5kIGluIExheWVyIE1hcGApKTsgfVxyXG4gICAgICAgIHJldHVybiBwLnRoZW4oKGw6IExheWVyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvbHlnb25zOiBQcm9taXNlPEFycmF5PFBvbHlnb24+PiA9IG5ldyBQcm9taXNlPEFycmF5PFBvbHlnb24+PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2x5czogQXJyYXk8R29vZ2xlUG9seWdvbj4gPSBvcHRpb25zLm1hcChvID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcDogR29vZ2xlTWFwVHlwZXMuUG9seWdvbk9wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5Z29uT3B0aW9ucyhvKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5OiBHb29nbGVNYXBUeXBlcy5Qb2x5Z29uID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlnb24ob3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvbHlnb246IEdvb2dsZVBvbHlnb24gPSBuZXcgR29vZ2xlUG9seWdvbihwb2x5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoby50aXRsZSAmJiBvLnRpdGxlICE9PSAnJykgeyBwb2x5Z29uLlRpdGxlID0gby50aXRsZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvLm1ldGFkYXRhKSB7IG8ubWV0YWRhdGEuZm9yRWFjaCgodmFsOiBhbnksIGtleTogc3RyaW5nKSA9PiBwb2x5Z29uLk1ldGFkYXRhLnNldChrZXksIHZhbCkpOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlnb247XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocG9seXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25zO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHBvbHlsaW5lIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBwYXJhbSBsYXllciAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gd2hpY2ggdG8gYWRkIHRoZSBwb2x5bGluZS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWxpbmUuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIFBvbHlsaW5lIChvciBhbiBhcnJheVxyXG4gICAgICogb2YgcG9seWdvbnMgZm9yIGNvbXBsZXggcGF0aHMpIG1vZGVsLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lKGxheWVyOiBudW1iZXIsIG9wdGlvbnM6IElQb2x5bGluZU9wdGlvbnMpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4ge1xyXG4gICAgICAgIGNvbnN0IHA6IFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+PiA9IHRoaXMuX21hcFNlcnZpY2UuQ3JlYXRlUG9seWxpbmUob3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgbDogUHJvbWlzZTxMYXllcj4gPSB0aGlzLl9sYXllcnMuZ2V0KGxheWVyKTtcclxuICAgICAgICBQcm9taXNlLmFsbChbcCwgbF0pLnRoZW4oeCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHAxOiBBcnJheTxQb2x5bGluZT4gPSAgQXJyYXkuaXNBcnJheSh4WzBdKSA/IDxBcnJheTxQb2x5bGluZT4+eFswXSA6IFs8UG9seWxpbmU+eFswXV07XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcDIgb2YgcDEpIHt4WzFdLkFkZEVudGl0eShwMik7IH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5ib3VuZCBwb2x5bGluZXMuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgYXJyYXlzIG9mIHBvbHlsaW5lcyB0byBiZSB1c2VkIGluIGJ1bGtcclxuICAgICAqIG9wZXJhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxheWVyIC0gVGhlIGlkIG9mIHRoZSBsYXllciB0byB3aGljaCB0byBhZGQgdGhlIHBvbHlsaW5lcy5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUG9seWxpbmUgb3B0aW9ucyBkZWZpbmluZyB0aGUgcG9seWxpbmVzLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIGFuIGFycmF5cyBvZiB0aGUgUG9seWxpbmUgbW9kZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVMYXllclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZVBvbHlsaW5lcyhsYXllcjogbnVtYmVyLCBvcHRpb25zOiBBcnJheTxJUG9seWxpbmVPcHRpb25zPik6IFByb21pc2U8QXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4ge1xyXG4gICAgICAgIGNvbnN0IHA6IFByb21pc2U8TGF5ZXI+ID0gdGhpcy5HZXRMYXllckJ5SWQobGF5ZXIpO1xyXG4gICAgICAgIGlmIChwID09IG51bGwpIHsgdGhyb3cgKG5ldyBFcnJvcihgTGF5ZXIgd2l0aCBpZCAke2xheWVyfSBub3QgZm91bmQgaW4gTGF5ZXIgTWFwYCkpOyB9XHJcbiAgICAgICAgcmV0dXJuIHAudGhlbigobDogTGF5ZXIpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9seWxpbmVzOiBQcm9taXNlPEFycmF5PFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+ID0gbmV3IFByb21pc2U8QXJyYXk8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+Pj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9seXM6IEFycmF5PFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4gPSBvcHRpb25zLm1hcChvID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcDogR29vZ2xlTWFwVHlwZXMuUG9seWxpbmVPcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlUG9seWxpbmVPcHRpb25zKG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvLnBhdGggJiYgby5wYXRoLmxlbmd0aCA+IDAgJiYgIUFycmF5LmlzQXJyYXkoby5wYXRoWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5wYXRoID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlUGF0aHMoby5wYXRoKVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9seTogR29vZ2xlTWFwVHlwZXMuUG9seWxpbmUgPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWxpbmUob3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5bGluZTogR29vZ2xlUG9seWxpbmUgPSBuZXcgR29vZ2xlUG9seWxpbmUocG9seSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnRpdGxlICYmIG8udGl0bGUgIT09ICcnKSB7IHBvbHlsaW5lLlRpdGxlID0gby50aXRsZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5tZXRhZGF0YSkgeyBvLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHBvbHlsaW5lLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aHM6IEFycmF5PEFycmF5PEdvb2dsZU1hcFR5cGVzLkxhdExuZz4+ID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlUGF0aHMoby5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZXM6IEFycmF5PFBvbHlsaW5lPiA9IG5ldyBBcnJheTxQb2x5bGluZT4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHMuZm9yRWFjaCh4ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wLnBhdGggPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9seSA9IG5ldyBnb29nbGUubWFwcy5Qb2x5bGluZShvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2x5bGluZTogR29vZ2xlUG9seWxpbmUgPSBuZXcgR29vZ2xlUG9seWxpbmUocG9seSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoby5tZXRhZGF0YSkgeyBvLm1ldGFkYXRhLmZvckVhY2goKHYsIGspID0+IHBvbHlsaW5lLk1ldGFkYXRhLnNldChrLCB2KSk7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLnRpdGxlICYmIG8udGl0bGUgIT09ICcnKSB7cG9seWxpbmUuVGl0bGUgPSBvLnRpdGxlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHBvbHlsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocG9seXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lcztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTWFwQVBJTG9hZGVyLCBXaW5kb3dSZWYsIERvY3VtZW50UmVmIH0gZnJvbSAnLi4vbWFwYXBpbG9hZGVyJztcclxuXHJcbi8qKlxyXG4gKiBQcm90b2NvbCBlbnVtZXJhdGlvblxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBlbnVtIHtudW1iZXJ9XHJcbiAqL1xyXG5leHBvcnQgZW51bSBTY3JpcHRQcm90b2NvbCB7XHJcbiAgICBIVFRQLFxyXG4gICAgSFRUUFMsXHJcbiAgICBBVVRPXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCaW5nIE1hcHMgVjggc3BlY2lmaWMgbG9hZGVyIGNvbmZpZ3VyYXRpb24gdG8gYmUgdXNlZCB3aXRoIHRoZSB7QGxpbmsgR29vZ2xlTWFwQVBJTG9hZGVyfVxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXBBUElMb2FkZXJDb25maWcge1xyXG4gICAgLyoqXHJcbiAgICAgICAqIFRoZSBHb29nbGUgTWFwcyBBUEkgS2V5IChzZWU6XHJcbiAgICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L2dldC1hcGkta2V5KVxyXG4gICAgICAgKi9cclxuICAgIGFwaUtleT86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBHb29nbGUgTWFwcyBjbGllbnQgSUQgKGZvciBwcmVtaXVtIHBsYW5zKS5cclxuICAgICAqIFdoZW4geW91IGhhdmUgYSBHb29nbGUgTWFwcyBBUElzIFByZW1pdW0gUGxhbiBsaWNlbnNlLCB5b3UgbXVzdCBhdXRoZW50aWNhdGVcclxuICAgICAqIHlvdXIgYXBwbGljYXRpb24gd2l0aCBlaXRoZXIgYW4gQVBJIGtleSBvciBhIGNsaWVudCBJRC5cclxuICAgICAqIFRoZSBHb29nbGUgTWFwcyBBUEkgd2lsbCBmYWlsIHRvIGxvYWQgaWYgYm90aCBhIGNsaWVudCBJRCBhbmQgYW4gQVBJIGtleSBhcmUgaW5jbHVkZWQuXHJcbiAgICAgKi9cclxuICAgIGNsaWVudElkPzogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIEdvb2dsZSBNYXBzIGNoYW5uZWwgbmFtZSAoZm9yIHByZW1pdW0gcGxhbnMpLlxyXG4gICAgICogQSBjaGFubmVsIHBhcmFtZXRlciBpcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBhbGxvd3MgeW91IHRvIHRyYWNrIHVzYWdlIHVuZGVyIHlvdXIgY2xpZW50XHJcbiAgICAgKiBJRCBieSBhc3NpZ25pbmcgYSBkaXN0aW5jdCBjaGFubmVsIHRvIGVhY2ggb2YgeW91ciBhcHBsaWNhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGNoYW5uZWw/OiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHb29nbGUgTWFwcyBBUEkgdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgYXBpVmVyc2lvbj86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvc3QgYW5kIFBhdGggdXNlZCBmb3IgdGhlIGA8c2NyaXB0PmAgdGFnLlxyXG4gICAgICovXHJcbiAgICBob3N0QW5kUGF0aD86IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3RvY29sIHVzZWQgZm9yIHRoZSBgPHNjcmlwdD5gIHRhZy5cclxuICAgICAqL1xyXG4gICAgcHJvdG9jb2w/OiBTY3JpcHRQcm90b2NvbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgd2hpY2ggR29vZ2xlIE1hcHMgbGlicmFyaWVzIHNob3VsZCBnZXQgbG9hZGVkLlxyXG4gICAgICovXHJcbiAgICBsaWJyYXJpZXM/OiBzdHJpbmdbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IGJpYXMgZm9yIHRoZSBtYXAgYmVoYXZpb3IgaXMgVVMuXHJcbiAgICAgKiBJZiB5b3Ugd2lzaCB0byBhbHRlciB5b3VyIGFwcGxpY2F0aW9uIHRvIHNlcnZlIGRpZmZlcmVudCBtYXAgdGlsZXMgb3IgYmlhcyB0aGVcclxuICAgICAqIGFwcGxpY2F0aW9uLCB5b3UgY2FuIG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBiZWhhdmlvciAoVVMpIGJ5IGRlZmluaW5nIGEgYHJlZ2lvbmAuXHJcbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvYmFzaWNzI1JlZ2lvblxyXG4gICAgICovXHJcbiAgICByZWdpb24/OiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgR29vZ2xlIE1hcHMgQVBJIHVzZXMgdGhlIGJyb3dzZXIncyBwcmVmZXJyZWQgbGFuZ3VhZ2Ugd2hlbiBkaXNwbGF5aW5nXHJcbiAgICAgKiB0ZXh0dWFsIGluZm9ybWF0aW9uLiBJZiB5b3Ugd2lzaCB0byBvdmVyd3JpdGUgdGhpcyBiZWhhdmlvciBhbmQgZm9yY2UgdGhlIEFQSVxyXG4gICAgICogdG8gdXNlIGEgZ2l2ZW4gbGFuZ3VhZ2UsIHlvdSBjYW4gdXNlIHRoaXMgc2V0dGluZy5cclxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9iYXNpY3MjTGFuZ3VhZ2VcclxuICAgICAqL1xyXG4gICAgbGFuZ3VhZ2U/OiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgR29vZ2xlIE1hcHMgQVBJIHJlcXVpcmVzIGEgc2VwYXJhdGUgbGlicmFyeSBmb3IgY2x1c3RlcmluZy4gU2V0IHRoZSBwcm9wZXJ0eVxyXG4gICAgICogdG8gdHJ1ZSBpbiBvcmRlciB0byBsb2FkIHRoaXMgbGlicmFyeS5cclxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9tYXJrZXItY2x1c3RlcmluZ1xyXG4gICAgICovXHJcbiAgICBlbmFibGVDbHVzdGVyaW5nPzogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvc3QgYW5kIFBhdGggdXNlZCBmb3IgdGhlIGNsdXN0ZXIgbGlicmFyeSBgPHNjcmlwdD5gIHRhZy5cclxuICAgICAqL1xyXG4gICAgY2x1c3Rlckhvc3RBbmRQYXRoPzogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBsb2FkZXIgY29uZmlndXJhdGlvbi5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfQ09ORklHVVJBVElPTiA9IG5ldyBHb29nbGVNYXBBUElMb2FkZXJDb25maWcoKTtcclxuXHJcbi8qKlxyXG4gKiBCaW5nIE1hcHMgVjggaW1wbGVtZW50YXRpb24gZm9yIHRoZSB7QGxpbmsgTWFwQVBJTG9hZGVyfSBzZXJ2aWNlLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXBBUElMb2FkZXIgZXh0ZW5kcyBNYXBBUElMb2FkZXIge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlZmludGl0aW9ucy5cclxuICAgIC8vL1xyXG4gICAgcHJpdmF0ZSBfc2NyaXB0TG9hZGluZ1Byb21pc2U6IFByb21pc2U8dm9pZD47XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgZGVjbGFyYXRpb25zLlxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsb2FkZXIgY29uZmlndXJhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBBUElMb2FkZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBDb25maWcoKTogR29vZ2xlTWFwQVBJTG9hZGVyQ29uZmlnIHsgcmV0dXJuIHRoaXMuX2NvbmZpZzsgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHb29nbGVNYXBBUElMb2FkZXIuXHJcbiAgICAgKiBAcGFyYW0gX2NvbmZpZyAtIFRoZSBsb2FkZXIgY29uZmlndXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSBfd2luZG93UmVmIC0gQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFdpbmRvd1JlZn0uIE5lY2Vzc2FyeSBiZWNhdXNlIEJpbmcgTWFwIFY4IGludGVyYWN0cyB3aXRoIHRoZSB3aW5kb3cgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIF9kb2N1bWVudFJlZiAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBEb2N1bWVudFJlZn0uXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZWNlc3NhcnkgYmVjYXVzZSBCaW5nIE1hcCBWOCBpbnRlcmFjdHMgd2l0aCB0aGUgZG9jdW1lbnQgb2JqZWN0LlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcEFQSUxvYWRlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvciggQE9wdGlvbmFsKCkgcHJpdmF0ZSBfY29uZmlnOiBHb29nbGVNYXBBUElMb2FkZXJDb25maWcsIHByaXZhdGUgX3dpbmRvd1JlZjogV2luZG93UmVmLCBwcml2YXRlIF9kb2N1bWVudFJlZjogRG9jdW1lbnRSZWYpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcgPT09IG51bGwgfHwgdGhpcy5fY29uZmlnID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29uZmlnID0gREVGQVVMVF9DT05GSUdVUkFUSU9OO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kcyBhbmQgTWFwQVBJTG9hZGVyIGltcGxlbWVudGF0aW9uLlxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyB0aGUgbmVjZXNzYXJ5IHJlc291cmNlcyBmb3IgQmluZyBNYXBzIFY4LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBBUElMb2FkZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIExvYWQoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNjcmlwdCA9IHRoaXMuX2RvY3VtZW50UmVmLkdldE5hdGl2ZURvY3VtZW50KCkuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcclxuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xyXG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2tOYW1lID0gYENyZWF0ZWA7XHJcbiAgICAgICAgc2NyaXB0LnNyYyA9IHRoaXMuR2V0TWFwc1NjcmlwdFNyYyhjYWxsYmFja05hbWUpO1xyXG5cclxuICAgICAgICB0aGlzLl9zY3JpcHRMb2FkaW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlOiBGdW5jdGlvbiwgcmVqZWN0OiBGdW5jdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAoPGFueT50aGlzLl93aW5kb3dSZWYuR2V0TmF0aXZlV2luZG93KCkpW2NhbGxiYWNrTmFtZV0gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29uZmlnLmVuYWJsZUNsdXN0ZXJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQgdGhlbiBkZWxheSB0aGUgbG9hZGluZyB1bnRpbCBhZnRlciB0aGUgY2x1c3RlciBsaWJyYXJ5IGlzIGxvYWRlZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXJTY3JpcHQgPSB0aGlzLl9kb2N1bWVudFJlZi5HZXROYXRpdmVEb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJTY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJTY3JpcHQuc3JjID0gdGhpcy5HZXRDbHVzdGVyU2NyaXB0U3JjKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2x1c3RlclNjcmlwdC5vbmxvYWQgPSBjbHVzdGVyU2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWYuR2V0TmF0aXZlRG9jdW1lbnQoKS5oZWFkLmFwcGVuZENoaWxkKGNsdXN0ZXJTY3JpcHQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gKGVycm9yOiBFdmVudCkgPT4geyByZWplY3QoZXJyb3IpOyB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX2RvY3VtZW50UmVmLkdldE5hdGl2ZURvY3VtZW50KCkuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJpdmF0ZSBtZXRob2RzXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIEdvb2dsZSBNYXBzIHNjcmlwdHMgdXJsIGZvciBpbmplY3Rpb25zIGludG8gdGhlIGhlYWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tOYW1lIC0gTmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIEdvb2dsZSBNYXBzIHNjcmlwdHMgYXJlIGxvYWRlZC5cclxuICAgICAqIEByZXR1cm5zIC0gVGhlIHVybCB0byBiZSB1c2VkIHRvIGxvYWQgdGhlIEdvb2dsZSBNYXAgc2NyaXB0cy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwQVBJTG9hZGVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgR2V0TWFwc1NjcmlwdFNyYyhjYWxsYmFja05hbWU6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IGhvc3RBbmRQYXRoOiBzdHJpbmcgPSB0aGlzLl9jb25maWcuaG9zdEFuZFBhdGggfHwgJ21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanMnO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfSA9IHtcclxuICAgICAgICAgICAgdjogdGhpcy5fY29uZmlnLmFwaVZlcnNpb24sXHJcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja05hbWUsXHJcbiAgICAgICAgICAgIGtleTogdGhpcy5fY29uZmlnLmFwaUtleSxcclxuICAgICAgICAgICAgY2xpZW50OiB0aGlzLl9jb25maWcuY2xpZW50SWQsXHJcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMuX2NvbmZpZy5jaGFubmVsLFxyXG4gICAgICAgICAgICBsaWJyYXJpZXM6IHRoaXMuX2NvbmZpZy5saWJyYXJpZXMsXHJcbiAgICAgICAgICAgIHJlZ2lvbjogdGhpcy5fY29uZmlnLnJlZ2lvbixcclxuICAgICAgICAgICAgbGFuZ3VhZ2U6IHRoaXMuX2NvbmZpZy5sYW5ndWFnZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuR2V0U2NyaXB0U3JjKGhvc3RBbmRQYXRoLCBxdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBHb29nbGUgTWFwcyBDbHVzdGVyIGxpYnJhcnkgdXJsIGZvciBpbmplY3Rpb25zIGludG8gdGhlIGhlYWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSB1cmwgdG8gYmUgdXNlZCB0byBsb2FkIHRoZSBHb29nbGUgTWFwIENsdXN0ZXIgbGlicmFyeS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwQVBJTG9hZGVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgR2V0Q2x1c3RlclNjcmlwdFNyYygpIHtcclxuICAgICAgICBjb25zdCBob3N0QW5kUGF0aDogc3RyaW5nID0gdGhpcy5fY29uZmlnLmNsdXN0ZXJIb3N0QW5kUGF0aCB8fFxyXG4gICAgICAgICAgICAnZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L2V4YW1wbGVzL21hcmtlcmNsdXN0ZXJlci9tYXJrZXJjbHVzdGVyZXIuanMnO1xyXG4gICAgICAgIHJldHVybiB0aGlzLkdldFNjcmlwdFNyYyhob3N0QW5kUGF0aCwge30pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIHNjcmlwdHMgdXJsIGZvciBpbmplY3Rpb25zIGludG8gdGhlIGhlYWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaG9zdEFuZFBhdGggLSBIb3N0IGFuZCBwYXRoIG5hbWUgb2YgdGhlIHNjcmlwdCB0byBsb2FkLlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5UGFyYW1zIC0gVXJsIHF1ZXJ5IHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcmV0dXJucyAtIFRoZSB1cmwgd2l0aCBjb3JyZWN0IHByb3RvY29sLCBwYXRoLCBhbmQgcXVlcnkgcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwQVBJTG9hZGVyXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgR2V0U2NyaXB0U3JjKGhvc3RBbmRQYXRoOiBzdHJpbmcsIHF1ZXJ5UGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfSk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2xUeXBlOiBTY3JpcHRQcm90b2NvbCA9XHJcbiAgICAgICAgICAgIDxTY3JpcHRQcm90b2NvbD4oKHRoaXMuX2NvbmZpZyAmJiB0aGlzLl9jb25maWcucHJvdG9jb2wpIHx8IFNjcmlwdFByb3RvY29sLkhUVFBTKTtcclxuICAgICAgICBsZXQgcHJvdG9jb2w6IHN0cmluZztcclxuXHJcbiAgICAgICAgc3dpdGNoIChwcm90b2NvbFR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBTY3JpcHRQcm90b2NvbC5BVVRPOlxyXG4gICAgICAgICAgICAgICAgcHJvdG9jb2wgPSAnJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFNjcmlwdFByb3RvY29sLkhUVFA6XHJcbiAgICAgICAgICAgICAgICBwcm90b2NvbCA9ICdodHRwOic7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTY3JpcHRQcm90b2NvbC5IVFRQUzpcclxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJ2h0dHBzOic7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHBhcmFtczogc3RyaW5nID1cclxuICAgICAgICAgICAgT2JqZWN0LmtleXMocXVlcnlQYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChrOiBzdHJpbmcpID0+IHF1ZXJ5UGFyYW1zW2tdICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChrOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHF1ZXJ5UGFyYW1zW2tdKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShxdWVyeVBhcmFtc1trXSkgJiYgcXVlcnlQYXJhbXNba10ubGVuZ3RoID4gMCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoazogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gam9pbiBhcnJheXMgYXMgY29tbWEgc2VwZXJhdGVkIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpID0gcXVlcnlQYXJhbXNba107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrLCB2YWx1ZTogaS5qb2luKCcsJykgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrLCB2YWx1ZTogcXVlcnlQYXJhbXNba10gfTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAubWFwKChlbnRyeTogeyBrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyB9KSA9PiB7IHJldHVybiBgJHtlbnRyeS5rZXl9PSR7ZW50cnkudmFsdWV9YDsgfSlcclxuICAgICAgICAgICAgICAgIC5qb2luKCcmJyk7XHJcbiAgICAgICAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0QW5kUGF0aH0/JHtwYXJhbXN9YDtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJUG9pbnQgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2ludCc7XHJcbmltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IElNYXJrZXJPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvbWFya2VyJztcclxuaW1wb3J0IHsgTWFwTWFya2VyRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9tYXAtbWFya2VyJztcclxuaW1wb3J0IHsgTWFya2VyU2VydmljZSB9IGZyb20gJy4uL21hcmtlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi4vY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5pbXBvcnQgeyBHb29nbGVDb252ZXJzaW9ucyB9IGZyb20gJy4vZ29vZ2xlLWNvbnZlcnNpb25zJztcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgTWFya2VyU2VydmljZSBhYnN0cmFjdCBjbGFzcyBmb3IgR29vZ2xlLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXJrZXJTZXJ2aWNlIGltcGxlbWVudHMgTWFya2VyU2VydmljZSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX21hcmtlcnM6IE1hcDxNYXBNYXJrZXJEaXJlY3RpdmUsIFByb21pc2U8TWFya2VyPj4gPSBuZXcgTWFwPE1hcE1hcmtlckRpcmVjdGl2ZSwgUHJvbWlzZTxNYXJrZXI+PigpO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlTWFya2VyU2VydmljZS5cclxuICAgICAqIEBwYXJhbSBfbWFwU2VydmljZSAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbnN0YW5jZS5cclxuICAgICAqIFRoZSBjb25jcmV0ZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyU2VydmljZSAtIHtAbGluayBMYXllclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gICAgICogVGhlIGNvbmNyZXRlIHtAbGluayBHb29nbGVMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF9jbHVzdGVyU2VydmljZSAtIHtAbGluayBDbHVzdGVyU2VydmljZX0gaW5zdGFuY2UuXHJcbiAgICAgKiBUaGUgY29uY3JldGUge0BsaW5rIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBpcyBleHBlY3RlZC5cclxuICAgICAqIEBwYXJhbSBfem9uZSAtIE5nWm9uZSBpbnN0YW5jZSB0byBzdXBwb3J0IHpvbmUgYXdhcmUgcHJvbWlzZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF9sYXllclNlcnZpY2U6IExheWVyU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF9jbHVzdGVyU2VydmljZTogQ2x1c3RlclNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbWFya2VyLiBEZXBlbmRpbmcgb24gdGhlIG1hcmtlciBjb250ZXh0LCB0aGUgbWFya2VyIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYSBjb3JyZWNzcG9uZGluZyBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFya2VyIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IHRvIGJlIGFkZGVkLlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZE1hcmtlcihtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG86IElNYXJrZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBhbmNob3I6IG1hcmtlci5BbmNob3IsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IGxhdGl0dWRlOiBtYXJrZXIuTGF0aXR1ZGUsIGxvbmdpdHVkZTogbWFya2VyLkxvbmdpdHVkZSB9LFxyXG4gICAgICAgICAgICB0aXRsZTogbWFya2VyLlRpdGxlLFxyXG4gICAgICAgICAgICBsYWJlbDogbWFya2VyLkxhYmVsLFxyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IG1hcmtlci5EcmFnZ2FibGUsXHJcbiAgICAgICAgICAgIGljb246IG1hcmtlci5JY29uVXJsLFxyXG4gICAgICAgICAgICBpY29uSW5mbzogbWFya2VyLkljb25JbmZvLFxyXG4gICAgICAgICAgICB3aWR0aDogbWFya2VyLldpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IG1hcmtlci5IZWlnaHQsXHJcbiAgICAgICAgICAgIGlzRmlyc3Q6IG1hcmtlci5Jc0ZpcnN0SW5TZXQsXHJcbiAgICAgICAgICAgIGlzTGFzdDogbWFya2VyLklzTGFzdEluU2V0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gY3JlYXRlIG1hcmtlciB2aWEgcHJvbWlzZS5cclxuICAgICAgICBsZXQgbWFya2VyUHJvbWlzZTogUHJvbWlzZTxNYXJrZXI+ID0gbnVsbDtcclxuICAgICAgICBpZiAobWFya2VyLkluQ2x1c3RlckxheWVyKSB7XHJcbiAgICAgICAgICAgIG1hcmtlclByb21pc2UgPSB0aGlzLl9jbHVzdGVyU2VydmljZS5DcmVhdGVNYXJrZXIobWFya2VyLkxheWVySWQsIG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXJrZXIuSW5DdXN0b21MYXllcikge1xyXG4gICAgICAgICAgICBtYXJrZXJQcm9taXNlID0gdGhpcy5fbGF5ZXJTZXJ2aWNlLkNyZWF0ZU1hcmtlcihtYXJrZXIuTGF5ZXJJZCwgbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtYXJrZXJQcm9taXNlID0gdGhpcy5fbWFwU2VydmljZS5DcmVhdGVNYXJrZXIobyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9tYXJrZXJzLnNldChtYXJrZXIsIG1hcmtlclByb21pc2UpO1xyXG4gICAgICAgIGlmIChtYXJrZXIuSWNvbkluZm8pIHtcclxuICAgICAgICAgICAgbWFya2VyUHJvbWlzZS50aGVuKChtOiBNYXJrZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBpY29uSW5mbyB0byBwcm92aWRlIGhvb2sgdG8gZG8gcG9zdCBpY29uIGNyZWF0aW9uIGFjdGl2aXRpZXMgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBhbHNvIHJlLWFuY2hvciB0aGUgbWFya2VyXHJcbiAgICAgICAgICAgICAgICBtYXJrZXIuRHluYW1pY01hcmtlckNyZWF0ZWQuZW1pdChvLmljb25JbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHA6IElQb2ludCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiAoby5pY29uSW5mby5zaXplICYmIG8uaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8pID8gKG8uaWNvbkluZm8uc2l6ZS53aWR0aCAqIG8uaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8ueCkgOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IChvLmljb25JbmZvLnNpemUgJiYgby5pY29uSW5mby5tYXJrZXJPZmZzZXRSYXRpbykgPyAoby5pY29uSW5mby5zaXplLmhlaWdodCAqIG8uaWNvbkluZm8ubWFya2VyT2Zmc2V0UmF0aW8ueSkgOiAwLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIG0uU2V0QW5jaG9yKHApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgZGVsZWdhdGUgZm9yIGEgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgKGUuZy4gJ2NsaWNrJylcclxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBldmVudC5cclxuICAgICAqIEByZXR1cm5zIC0gT2JzZXJ2YWJsZSBlbWl0aW5nIGFuIGluc3RhbmNlIG9mIFQgZWFjaCB0aW1lIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IE9ic2VydmFibGU8VD4ge1xyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBtLkFkZExpc3RlbmVyKGV2ZW50TmFtZSwgKGU6IFQpID0+IHRoaXMuX3pvbmUucnVuKCgpID0+IG9ic2VydmVyLm5leHQoZSkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGEgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXJrZXIgLSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSB0byBiZSBkZWxldGVkLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBtYXJrZXIgaGFzIGJlZW4gZGVsZXRlZC5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGVNYXJrZXIobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKTtcclxuICAgICAgICBpZiAobSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG0udGhlbigobWE6IE1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWFya2VyLkluQ2x1c3RlckxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jbHVzdGVyU2VydmljZS5HZXROYXRpdmVMYXllcihtYXJrZXIuTGF5ZXJJZCkudGhlbihsID0+IHsgbC5SZW1vdmVFbnRpdHkobWEpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWFya2VyLkluQ3VzdG9tTGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyU2VydmljZS5HZXROYXRpdmVMYXllcihtYXJrZXIuTGF5ZXJJZCkudGhlbihsID0+IHsgbC5SZW1vdmVFbnRpdHkobWEpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbWEuRGVsZXRlTWFya2VyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXJzLmRlbGV0ZShtYXJrZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgZ2VvIGNvb3JkaW5hdGVzIGZvciB0aGUgbWFya2VyIG9uIHRoZSBjbGljayBsb2NhdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlIC0gVGhlIG1vdXNlIGV2ZW50LlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgSUxhdExvbmd9IGNvbnRhaW5pbmcgdGhlIGdlbyBjb29yZGluYXRlcyBvZiB0aGUgY2xpY2tlZCBtYXJrZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZTogTW91c2VFdmVudCB8IGFueSk6IElMYXRMb25nIHtcclxuICAgICAgICBpZiAoIWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZS5sYXRMbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZS5sYXRMbmcubGF0IHx8ICFlLmxhdExuZy5sbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGxhdGl0dWRlOiBlLmxhdExuZy5sYXQoKSwgbG9uZ2l0dWRlOiBlLmxhdExuZy5sbmcoKSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyB0aGUgbWFya2VyIG1vZGVsIGZvciB0aGUgbWFya2VyIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcmtlciAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gb2J0YWluIHRoZSBtYXJrZXIgbW9kZWwuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIE1hcmtlcn0gaW1wbGVtZW50YXRpb24gb2YgdGhlIHVuZGVybHlpbmcgcGxhdGZvcm0uXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TmF0aXZlTWFya2VyKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTxNYXJrZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIG1hcmtlciBwaXhlbCBsb2NhdGlvbiBmb3IgdGhlIG1hcmtlciBvbiB0aGUgY2xpY2sgbG9jYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIElMYXRMb25nfSBjb250YWluaW5nIHRoZSBwaXhlbHMgb2YgdGhlIG1hcmtlciBvbiB0aGUgbWFwIGNhbnZhcy5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRQaXhlbHNGcm9tQ2xpY2soZTogTW91c2VFdmVudCB8IGFueSk6IElQb2ludCB7XHJcbiAgICAgICAgaWYgKCFlIHx8ICFlLmxhdExuZyB8fCAhZS5sYXRMbmcubGF0IHx8ICFlLmxhdExuZy5sbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9tYXBTZXJ2aWNlLk1hcEluc3RhbmNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY3Jvc3Nlc0RhdGVMaW5lOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX21hcFNlcnZpY2UuTWFwSW5zdGFuY2U7XHJcbiAgICAgICAgY29uc3QgcCA9IG0uZ2V0UHJvamVjdGlvbigpO1xyXG4gICAgICAgIGNvbnN0IHM6IG51bWJlciA9IE1hdGgucG93KDIsIG0uZ2V0Wm9vbSgpKTtcclxuICAgICAgICBjb25zdCBiOiBHb29nbGVNYXBUeXBlcy5MYXRMbmdCb3VuZHMgPSBtLmdldEJvdW5kcygpO1xyXG4gICAgICAgIGlmIChiLmdldENlbnRlcigpLmxuZygpIDwgYi5nZXRTb3V0aFdlc3QoKS5sbmcoKSAgfHxcclxuICAgICAgICAgICAgYi5nZXRDZW50ZXIoKS5sbmcoKSA+IGIuZ2V0Tm9ydGhFYXN0KCkubG5nKCkpIHsgY3Jvc3Nlc0RhdGVMaW5lID0gdHJ1ZTsgfVxyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXRZOiBudW1iZXIgPSBwLmZyb21MYXRMbmdUb1BvaW50KGIuZ2V0Tm9ydGhFYXN0KCkpLnk7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0WDogbnVtYmVyID0gcC5mcm9tTGF0TG5nVG9Qb2ludChiLmdldFNvdXRoV2VzdCgpKS54O1xyXG4gICAgICAgIGNvbnN0IHBvaW50OiBHb29nbGVNYXBUeXBlcy5Qb2ludCA9IHAuZnJvbUxhdExuZ1RvUG9pbnQoZS5sYXRMbmcpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3IoKHBvaW50LnggLSBvZmZzZXRYICsgKChjcm9zc2VzRGF0ZUxpbmUgJiYgcG9pbnQueCA8IG9mZnNldFgpID8gMjU2IDogMCkpICogcyksXHJcbiAgICAgICAgICAgIHk6IE1hdGguZmxvb3IoKHBvaW50LnkgLSBvZmZzZXRZKSAqIHMpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgZ2VvIGxvY2F0aW9uIHRvIGEgcGl4ZWwgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIG1hcCBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhcmdldCAtIEVpdGhlciBhIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9XHJcbiAgICAgKiBvciBhIHtAbGluayBJTGF0TG9uZ30gZm9yIHRoZSBiYXNpcyBvZiB0cmFuc2xhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgd2hlbiBmdWxsZmlsbGVkIGNvbnRhaW5zIGEge0BsaW5rIElQb2ludH1cclxuICAgICAqIHdpdGggdGhlIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSBNYXBNYXJrZXIgb3IgSUxhdExvbmcgcmVsYXRpdmUgdG8gdGhlIG1hcCBjYW52YXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgTG9jYXRpb25Ub1BvaW50KHRhcmdldDogTWFwTWFya2VyRGlyZWN0aXZlIHwgSUxhdExvbmcpOiBQcm9taXNlPElQb2ludD4ge1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwTWFya2VyRGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldCh0YXJnZXQpLnRoZW4oKG06IE1hcmtlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbDogSUxhdExvbmcgPSBtLkxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcDogUHJvbWlzZTxJUG9pbnQ+ID0gdGhpcy5fbWFwU2VydmljZS5Mb2NhdGlvblRvUG9pbnQobCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXBTZXJ2aWNlLkxvY2F0aW9uVG9Qb2ludCh0YXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgYW5jaG9yIHBvc2l0aW9uIGZvciB0aGUgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIHRoZSBhbmNob3IuXHJcbiAgICAgKiBBbmNob3IgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgYW5jaG9yIHBvc2l0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVXBkYXRlQW5jaG9yKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgIG0uU2V0QW5jaG9yKG1hcmtlci5BbmNob3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB3aGV0aGVyIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAtIFRoZSB7QGxpbmsgTWFwTWFya2VyRGlyZWN0aXZlfSBvYmplY3QgZm9yIHdoaWNoIHRvIHVwYXRlIGRyYWdhYmlsaXR5LlxyXG4gICAgICogRHJhZ2FiaWxpdHkgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgbWFya2VyIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVXBkYXRlRHJhZ2dhYmxlKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiBtLlNldERyYWdnYWJsZShtYXJrZXIuRHJhZ2dhYmxlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBJY29uIG9uIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgdGhlIGljb24uIEljb24gaW5mb3JtYXRpb24gaXMgcHJlc2VudFxyXG4gICAgICogaW4gdGhlIHVuZGVybHlpbmcge0BsaW5rIE1hcmtlcn0gbW9kZWwgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIHdoZW4gdGhlIGljb24gaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVJY29uKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtYXJrZXIuSWNvbkluZm8pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHg6IElNYXJrZXJPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IGxhdGl0dWRlOiBtYXJrZXIuTGF0aXR1ZGUsIGxvbmdpdHVkZTogbWFya2VyLkxvbmdpdHVkZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGljb25JbmZvOiBtYXJrZXIuSWNvbkluZm9cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTWFya2VyT3B0aW9ucyh4KTtcclxuICAgICAgICAgICAgICAgIG0uU2V0SWNvbihvLmljb24pO1xyXG4gICAgICAgICAgICAgICAgbWFya2VyLkR5bmFtaWNNYXJrZXJDcmVhdGVkLmVtaXQoeC5pY29uSW5mbyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtLlNldEljb24obWFya2VyLkljb25VcmwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgbGFiZWwgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgbGFiZWwuXHJcbiAgICAgKiBMYWJlbCBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBsYWJlbCBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFVwZGF0ZUxhYmVsKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbigobTogTWFya2VyKSA9PiB7IG0uU2V0TGFiZWwobWFya2VyLkxhYmVsKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgdGhlIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQ29vcmRpbmF0ZSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBwb3NpdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFVwZGF0ZU1hcmtlclBvc2l0aW9uKG1hcmtlcjogTWFwTWFya2VyRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihcclxuICAgICAgICAgICAgKG06IE1hcmtlcikgPT4gbS5TZXRQb3NpdGlvbih7XHJcbiAgICAgICAgICAgICAgICBsYXRpdHVkZTogbWFya2VyLkxhdGl0dWRlLFxyXG4gICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiBtYXJrZXIuTG9uZ2l0dWRlXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHRpdGxlIG9uIHRoZSBtYXJrZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIC0gVGhlIHtAbGluayBNYXBNYXJrZXJEaXJlY3RpdmV9IG9iamVjdCBmb3Igd2hpY2ggdG8gdXBhdGUgdGhlIHRpdGxlLlxyXG4gICAgICogVGl0bGUgaW5mb3JtYXRpb24gaXMgcHJlc2VudCBpbiB0aGUgdW5kZXJseWluZyB7QGxpbmsgTWFya2VyfSBtb2RlbCBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGxmaWxsZWQgd2hlbiB0aGUgdGl0bGUgaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVUaXRsZShtYXJrZXI6IE1hcE1hcmtlckRpcmVjdGl2ZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oKG06IE1hcmtlcikgPT4gbS5TZXRUaXRsZShtYXJrZXIuVGl0bGUpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZpc2liaWxpdHkgb24gdGhlIG1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gLSBUaGUge0BsaW5rIE1hcE1hcmtlckRpcmVjdGl2ZX0gb2JqZWN0IGZvciB3aGljaCB0byB1cGF0ZSB0aGUgdGl0bGUuXHJcbiAgICAgKiBUaXRsZSBpbmZvcm1hdGlvbiBpcyBwcmVzZW50IGluIHRoZSB1bmRlcmx5aW5nIHtAbGluayBNYXJrZXJ9IG1vZGVsIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSB0aXRsZSBoYXMgYmVlbiB1cGRhdGVkLlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlclNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFVwZGF0ZVZpc2libGUobWFya2VyOiBNYXBNYXJrZXJEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKChtOiBNYXJrZXIpID0+IG0uU2V0VmlzaWJsZShtYXJrZXIuVmlzaWJsZSkpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBHb29nbGVNYXJrZXIgfSBmcm9tICcuL2dvb2dsZS1tYXJrZXInO1xyXG5pbXBvcnQgeyBJQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ljbHVzdGVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllciB9IGZyb20gJy4uL2xheWVyJztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi4vbWFya2VyJztcclxuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgQ2x1c3RlclBsYWNlbWVudE1vZGUgfSBmcm9tICcuLi9jbHVzdGVyLXBsYWNlbWVudC1tb2RlJztcclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi4vLi4vc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5pbXBvcnQgeyB0aW1lciB9IGZyb20gJ3J4anMnO1xyXG5cclxuLyoqXHJcbiAqIENvbmNyZXRlIGltcGxlbWVudGF0aW9uIG9mIGEgY2x1c3RlcmluZyBsYXllciBmb3IgdGhlIEdvb2dsZSBNYXAgUHJvdmlkZXIuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXJrZXJDbHVzdGVyZXIgaW1wbGVtZW50cyBMYXllciB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX2lzQ2x1c3RlcmluZyA9IHRydWU7XHJcbiAgICBwcml2YXRlIF9tYXJrZXJMb29rdXA6IE1hcDxHb29nbGVNYXBUeXBlcy5NYXJrZXIsIE1hcmtlcj4gPSBuZXcgTWFwPEdvb2dsZU1hcFR5cGVzLk1hcmtlciwgTWFya2VyPigpO1xyXG4gICAgcHJpdmF0ZSBfbWFya2VyczogQXJyYXk8TWFya2VyPiA9IG5ldyBBcnJheTxNYXJrZXI+KCk7XHJcbiAgICBwcml2YXRlIF9wZW5kaW5nTWFya2VyczogQXJyYXk8TWFya2VyPiA9IG5ldyBBcnJheTxNYXJrZXI+KCk7XHJcbiAgICBwcml2YXRlIF9tYXBjbGlja3M6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIF9jdXJyZW50Wm9vbTogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgX3Zpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFByb3BlcnR5IGRlZmluaXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbmF0aXZlIHByaW1pdGl2ZSB1bmRlcm5lYXRoIHRoZSBhYnN0cmFjdGlvbiBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBHb29nbGVNYXBUeXBlcy5NYXJrZXJDbHVzdGVyZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlckNsdXN0ZXJlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE5hdGl2ZVByaW1pdHZlKCk6IEdvb2dsZU1hcFR5cGVzLk1hcmtlckNsdXN0ZXJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEdvb2dsZU1hcmtlckNsdXN0ZXJlciBjbGFzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyIEdvb2dsZU1hcFR5cGVzLk1hcmtlckNsdXN0ZXJlci4gTmF0aXZlIEdvb2dsZSBNYXBzIE1hcmtlciBDbHVzdGVyZXIgc3VwcG9ydGluZyB0aGUgY2x1c3RlciBsYXllci5cclxuICAgICAqIEBwYXJhbSBfbWFwcyBNYXBTZXJ2aWNlLiBNYXBTZXJ2aWNlIGltcGxlbWVudGF0aW9uIHRvIGxldmVyYWdlIGZvciB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlckNsdXN0ZXJlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sYXllcjogR29vZ2xlTWFwVHlwZXMuTWFya2VyQ2x1c3RlcmVyKSB7IH1cclxuXHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHVibGljIG1ldGhvZHMsIExheWVyIGludGVyZmFjZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSBzdHJpbmcuIFR5cGUgb2YgZXZlbnQgdG8gYWRkIChjbGljaywgbW91c2VvdmVyLCBldGMpLiBZb3UgY2FuIHVzZSBhbnkgZXZlbnQgdGhhdCB0aGUgdW5kZXJseWluZyBuYXRpdmVcclxuICAgICAqIGxheWVyIHN1cHBvcnRzLlxyXG4gICAgICogQHBhcmFtIGZuIGZ1bmN0aW9uLiBIYW5kbGVyIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEFkZExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBmbjogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aHJvdyAobmV3IEVycm9yKCdFdmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gR29vZ2xlIENsdXN0ZXIgTGF5ZXJzLiBZb3UgY2FuIHN0aWxsIGFkZCBldmVudHMgdG8gaW5kaXZpZHVhbCBtYXJrZXJzLicpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZW50aXR5IHRvIHRoZSBsYXllci4gVXNlIHRoaXMgbWV0aG9kIHdpdGggY2F1dGlvbiBhcyBpdCB3aWxsXHJcbiAgICAgKiB0cmlnZ2VyIGEgcmVjYWx1YXRpb24gb2YgdGhlIGNsdXN0ZXJzIChhbmQgYXNzb2NpYXRlZCBtYXJrZXJzIGlmIGFwcHJvcHJpdGUpIGZvclxyXG4gICAgICogZWFjaCBpbnZvY2F0aW9uLiBJZiB5b3UgdXNlIHRoaXMgbWV0aG9kIHRvIGFkZCBtYW55IG1hcmtlcnMgdG8gdGhlIGNsdXN0ZXIsIHVzZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyLiBFbnRpdHkgdG8gYWRkIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRFbnRpdHkoZW50aXR5OiBNYXJrZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaXNNYXJrZXI6IGJvb2xlYW4gPSBlbnRpdHkgaW5zdGFuY2VvZiBNYXJrZXI7XHJcbiAgICAgICAgaXNNYXJrZXIgPSBlbnRpdHkgaW5zdGFuY2VvZiBHb29nbGVNYXJrZXIgfHwgaXNNYXJrZXI7XHJcbiAgICAgICAgaWYgKGlzTWFya2VyKSB7XHJcbiAgICAgICAgICAgIGVudGl0eS5OYXRpdmVQcmltaXR2ZS5zZXRNYXAobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBtYXAgYXMgdGhlIGNsdXN0ZXJlciB3aWxsIGNvbnRyb2wgbWFya2VyIHZpc2liaWxpdHkuXHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkuSXNGaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5TdG9wQ2x1c3RlcmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbnRpdHkuTmF0aXZlUHJpbWl0dmUgJiYgZW50aXR5LkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NsdXN0ZXJpbmcgJiYgdGhpcy5fdmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIuYWRkTWFya2VyKGVudGl0eS5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrZXJzLnB1c2goZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdNYXJrZXJzLnB1c2goZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJMb29rdXAuc2V0KGVudGl0eS5OYXRpdmVQcmltaXR2ZSwgZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTWFya2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkuSXNMYXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXJ0Q2x1c3RlcmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG51bWJlciBvZiBtYXJrZXJzIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyPi4gRW50aXRpZXMgdG8gYWRkIHRvIHRoZSBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBBZGRFbnRpdGllcyhlbnRpdGllczogQXJyYXk8TWFya2VyPik6IHZvaWQge1xyXG4gICAgICAgIGlmIChlbnRpdGllcyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkoZW50aXRpZXMpICYmIGVudGl0aWVzLmxlbmd0aCAhPT0gMCApIHtcclxuICAgICAgICAgICAgY29uc3QgZTogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTWFya2VyPiA9IGVudGl0aWVzLm1hcChwID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlckxvb2t1cC5zZXQocC5OYXRpdmVQcmltaXR2ZSwgcCk7XHJcbiAgICAgICAgICAgICAgICBwLk5hdGl2ZVByaW1pdHZlLnNldE1hcChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBtYXAgYXMgdGhlIGNsdXN0ZXJlciB3aWxsIGNvbnRyb2wgbWFya2VyIHZpc2liaWxpdHkuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcC5OYXRpdmVQcmltaXR2ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NsdXN0ZXJpbmcgJiYgdGhpcy5fdmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIuYWRkTWFya2VycyhlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMucHVzaCguLi5lbnRpdGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBsYXllciBpcyBub3QgdmlzaWJsZSwgYWx3YXlzIGFkZCB0byBwZW5kaW5nTWFya2Vycy4gU2V0dGluZyB0aGUgbGF5ZXIgdG8gdmlzaWJsZSBsYXRlclxyXG4gICAgICAgICAgICAgICAgLy8gd2lsbCByZW5kZXIgdGhlIG1hcmtlcnMgYXBwcm9wcmlhdGVseVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMucHVzaCguLi5lbnRpdGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSBjbHVzdGVyaW5nIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9sYXllci5nZXRNYXJrZXJzKCkuZm9yRWFjaChtID0+IHtcclxuICAgICAgICAgICAgbS5zZXRNYXAobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBtYXAgYXMgdGhlIGNsdXN0ZXJlciB3aWxsIGNvbnRyb2wgbWFya2VyIHZpc2liaWxpdHkuXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXIuY2xlYXJNYXJrZXJzKCk7XHJcbiAgICAgICAgdGhpcy5fbWFya2Vycy5zcGxpY2UoMCk7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMuc3BsaWNlKDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYWJzdHJhY3QgbWFya2VyIHVzZWQgdG8gd3JhcCB0aGUgR29vZ2xlIE1hcmtlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBNYXJrZXIuIFRoZSBhYnN0cmFjdCBtYXJrZXIgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcHVzaHBpbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRNYXJrZXJGcm9tR29vZ2xlTWFya2VyKHBpbjogR29vZ2xlTWFwVHlwZXMuTWFya2VyKTogTWFya2VyIHtcclxuICAgICAgICBjb25zdCBtOiBNYXJrZXIgPSB0aGlzLl9tYXJrZXJMb29rdXAuZ2V0KHBpbik7XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIGdvdmVybmluZyB0aGUgYmVoYXZpb3Igb2YgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIElDbHVzdGVyT3B0aW9ucy4gVGhlIGxheWVyIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcmtlckNsdXN0ZXJlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0T3B0aW9ucygpOiBJQ2x1c3Rlck9wdGlvbnMge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IElDbHVzdGVyT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgaWQ6IDAsXHJcbiAgICAgICAgICAgIGdyaWRTaXplOiB0aGlzLl9sYXllci5nZXRHcmlkU2l6ZSgpLFxyXG4gICAgICAgICAgICBjbHVzdGVyaW5nRW5hYmxlZDogdGhpcy5fbGF5ZXIuZ2V0R3JpZFNpemUoKSA9PT0gMCxcclxuICAgICAgICAgICAgbWF4Wm9vbTogdGhpcy5fbGF5ZXIuZ2V0TWF4Wm9vbSgpLFxyXG4gICAgICAgICAgICBtaW5pbXVtQ2x1c3RlclNpemU6IHRoaXMuX2xheWVyLmdldE1pbkNsdXN0ZXJTaXplKCksXHJcbiAgICAgICAgICAgIHBsYWNlbWVudE1vZGU6IHRoaXMuX2xheWVyLmlzQXZlcmFnZUNlbnRlcigpID8gQ2x1c3RlclBsYWNlbWVudE1vZGUuTWVhblZhbHVlIDogQ2x1c3RlclBsYWNlbWVudE1vZGUuRmlyc3RQaW4sXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRoaXMuX3Zpc2libGUsXHJcbiAgICAgICAgICAgIHpvb21PbkNsaWNrOiB0aGlzLl9sYXllci5pc1pvb21PbkNsaWNrKCksXHJcbiAgICAgICAgICAgIHN0eWxlczogdGhpcy5fbGF5ZXIuZ2V0U3R5bGVzKClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQm9vbGVhbi4gVHJ1ZSBpcyB0aGUgbGF5ZXIgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFZpc2libGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIGVudGl0eSBmcm9tIHRoZSBjbHVzdGVyIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBlbnRpdHkgTWFya2VyIEVudGl0eSB0byBiZSByZW1vdmVkIGZyb20gdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFJlbW92ZUVudGl0eShlbnRpdHk6IE1hcmtlcik6IHZvaWQge1xyXG4gICAgICAgIGlmIChlbnRpdHkuTmF0aXZlUHJpbWl0dmUgJiYgZW50aXR5LkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGo6IG51bWJlciA9IHRoaXMuX21hcmtlcnMuaW5kZXhPZihlbnRpdHkpO1xyXG4gICAgICAgICAgICBjb25zdCBrOiBudW1iZXIgPSB0aGlzLl9wZW5kaW5nTWFya2Vycy5pbmRleE9mKGVudGl0eSk7XHJcbiAgICAgICAgICAgIGlmIChqID4gLTEpIHsgdGhpcy5fbWFya2Vycy5zcGxpY2UoaiwgMSk7IH1cclxuICAgICAgICAgICAgaWYgKGsgPiAtMSkgeyB0aGlzLl9wZW5kaW5nTWFya2Vycy5zcGxpY2UoaywgMSk7IH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ2x1c3RlcmluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIucmVtb3ZlTWFya2VyKGVudGl0eS5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbWFya2VyTG9va3VwLmRlbGV0ZShlbnRpdHkuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGVudGl0aWVzIGZvciB0aGUgY2x1c3RlciBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW50aXRpZXMgQXJyYXk8TWFya2VyPiBjb250YWluaW5nXHJcbiAgICAgKiB0aGUgZW50aXRpZXMgdG8gYWRkIHRvIHRoZSBjbHVzdGVyLiBUaGlzIHJlcGxhY2VzIGFueSBleGlzdGluZyBlbnRpdGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTZXRFbnRpdGllcyhlbnRpdGllczogQXJyYXk8TWFya2VyPik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2xheWVyLmdldE1hcmtlcnMoKS5mb3JFYWNoKG0gPT4ge1xyXG4gICAgICAgICAgICBtLnNldE1hcChudWxsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9sYXllci5jbGVhck1hcmtlcnMoKTtcclxuICAgICAgICB0aGlzLl9tYXJrZXJzLnNwbGljZSgwKTtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nTWFya2Vycy5zcGxpY2UoMCk7XHJcbiAgICAgICAgdGhpcy5fbWFya2VyTG9va3VwLmNsZWFyKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHA6IEFycmF5PEdvb2dsZU1hcFR5cGVzLk1hcmtlcj4gPSBuZXcgQXJyYXk8R29vZ2xlTWFwVHlwZXMuTWFya2VyPigpO1xyXG4gICAgICAgIGVudGl0aWVzLmZvckVhY2goKGU6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS5OYXRpdmVQcmltaXR2ZSAmJiBlLkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBlLk5hdGl2ZVByaW1pdHZlLnNldE1hcChudWxsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlckxvb2t1cC5zZXQoZS5OYXRpdmVQcmltaXR2ZSwgZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICBwLnB1c2goZS5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nTWFya2Vycy5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXIuYWRkTWFya2VycyhwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG9wdGlvbnMgZm9yIHRoZSBjbHVzdGVyIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIElDbHVzdGVyT3B0aW9ucyBjb250YWluaW5nIHRoZSBvcHRpb25zIGVudW1lcmF0aW9uIGNvbnRyb2xsaW5nIHRoZSBsYXllciBiZWhhdmlvci4gVGhlIHN1cHBsaWVkIG9wdGlvbnNcclxuICAgICAqIGFyZSBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdC9leGlzdGluZyBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMob3B0aW9uczogSUNsdXN0ZXJPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucGxhY2VtZW50TW9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcignR29vZ2xlTWFya2VyQ2x1c3RlcmVyOiBQbGFjZW1lbnRNb2RlIG9wdGlvbiBjYW5ub3QgYmUgc2V0IGFmdGVyIGluaXRpYWwgY3JlYXRpb24uJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy56b29tT25DbGljayAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcignR29vZ2xlTWFya2VyQ2x1c3RlcmVyOiBab29tT25DbGljayBvcHRpb24gY2Fubm90IGJlIHNldCBhZnRlciBpbml0aWFsIGNyZWF0aW9uLicpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2sgIT0gbnVsbCkge31cclxuICAgICAgICBpZiAob3B0aW9ucy5jbHVzdGVyaW5nRW5hYmxlZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLnNldE1pbkNsdXN0ZXJTaXplKG9wdGlvbnMuY2x1c3RlcmluZ0VuYWJsZWQgPyAxIDogMTAwMDAwMDApO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllci5yZXNldFZpZXdwb3J0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLnJlZHJhdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5ncmlkU2l6ZSAhPSBudWxsICYmIChvcHRpb25zLmNsdXN0ZXJpbmdFbmFibGVkID09IG51bGwgfHwgb3B0aW9ucy5jbHVzdGVyaW5nRW5hYmxlZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXIuc2V0R3JpZFNpemUob3B0aW9ucy5ncmlkU2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLnJlc2V0Vmlld3BvcnQoKTtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXIucmVkcmF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLm1heFpvb20gIT0gbnVsbCkgeyB0aGlzLl9sYXllci5zZXRNYXhab29tKG9wdGlvbnMubWF4Wm9vbSk7IH1cclxuICAgICAgICBpZiAob3B0aW9ucy5taW5pbXVtQ2x1c3RlclNpemUgIT0gbnVsbCkgeyB0aGlzLl9sYXllci5zZXRNaW5DbHVzdGVyU2l6ZShvcHRpb25zLm1pbmltdW1DbHVzdGVyU2l6ZSk7IH1cclxuICAgICAgICBpZiAob3B0aW9ucy5zdHlsZXMgIT0gbnVsbCkgeyB0aGlzLl9sYXllci5zZXRTdHlsZXMob3B0aW9ucy5zdHlsZXMpOyB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudmlzaWJsZSAhPSBudWxsKSB7IHRoaXMuU2V0VmlzaWJsZShvcHRpb25zLnZpc2libGUpOyB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUb2dnbGVzIHRoZSBjbHVzdGVyIGxheWVyIHZpc2liaWxpdHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZpc2libGUgQm9vbGVhbiB0cnVlIHRvIG1ha2UgdGhlIGxheWVyIHZpc2libGUsIGZhbHNlIHRvIGhpZGUgdGhlIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXJrZXJDbHVzdGVyZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFZpc2libGUodmlzaWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwID0gdmlzaWJsZSA/IHRoaXMuX2xheWVyLmdldE1hcCgpIDogbnVsbDtcclxuICAgICAgICBpZiAoIXZpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXIucmVzZXRWaWV3cG9ydCh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHA6IEFycmF5PEdvb2dsZU1hcFR5cGVzLk1hcmtlcj4gPSBuZXcgQXJyYXk8R29vZ2xlTWFwVHlwZXMuTWFya2VyPigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ01hcmtlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ01hcmtlcnMuZm9yRWFjaChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5OYXRpdmVQcmltaXR2ZSAmJiBlLkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAucHVzaCg8R29vZ2xlTWFwVHlwZXMuTWFya2VyPmUuTmF0aXZlUHJpbWl0dmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIuYWRkTWFya2VycyhwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcmtlcnMgPSB0aGlzLl9tYXJrZXJzLmNvbmNhdCh0aGlzLl9wZW5kaW5nTWFya2Vycy5zcGxpY2UoMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIucmVkcmF3KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCB0byBhY3R1YWxseSBjbHVzdGVyIHRoZSBlbnRpdGllcyBpbiBhIGNsdXN0ZXIgbGF5ZXIuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGluaXRpYWwgc2V0IG9mIGVudGl0aWVzXHJcbiAgICAgKiBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGNsdXN0ZXIuIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgYXMgYWRkaW5nIGFuIGVudGl0aXkgd2lsbCByZWNhbGN1bGF0ZSBhbGwgY2x1c3RlcnMuXHJcbiAgICAgKiBBcyBzdWNoLCBTdG9wQ2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhZGRpbmcgbWFueSBlbnRpdGllcyBhbmQgU3RhcnRDbHVzdGVyaW5nIHNob3VsZCBiZSBjYWxsZWQgb25jZSBhZGRpbmcgaXNcclxuICAgICAqIGNvbXBsZXRlIHRvIHJlY2FsY3VsYXRlIHRoZSBjbHVzdGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTdGFydENsdXN0ZXJpbmcoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzQ2x1c3RlcmluZykgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2libGUpIHtcclxuICAgICAgICAgICAgY29uc3QgcDogQXJyYXk8R29vZ2xlTWFwVHlwZXMuTWFya2VyPiA9IG5ldyBBcnJheTxHb29nbGVNYXBUeXBlcy5NYXJrZXI+KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcmtlcnMuZm9yRWFjaChlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlLk5hdGl2ZVByaW1pdHZlICYmIGUuTG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBwLnB1c2goPEdvb2dsZU1hcFR5cGVzLk1hcmtlcj5lLk5hdGl2ZVByaW1pdHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdNYXJrZXJzLmZvckVhY2goZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5OYXRpdmVQcmltaXR2ZSAmJiBlLkxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKDxHb29nbGVNYXBUeXBlcy5NYXJrZXI+ZS5OYXRpdmVQcmltaXR2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllci5hZGRNYXJrZXJzKHApO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJzID0gdGhpcy5fbWFya2Vycy5jb25jYXQodGhpcy5fcGVuZGluZ01hcmtlcnMuc3BsaWNlKDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fdmlzaWJsZSkge1xyXG4gICAgICAgICAgICAvLyBvbmx5IGFkZCB0aGUgbWFya2VycyBpZiB0aGUgbGF5ZXIgaXMgdmlzaWJsZS4gT3RoZXJ3aXNlLCBrZWVwIHRoZW0gcGVuZGluZy4gVGhleSB3b3VsZCBiZSBhZGRlZCBvbmNlIHRoZVxyXG4gICAgICAgICAgICAvLyBsYXllciBpcyBzZXQgdG8gdmlzaWJsZS5cclxuICAgICAgICAgICAgdGltZXIoMCkuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyLnJlc2V0Vmlld3BvcnQodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pc0NsdXN0ZXJpbmcgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcCB0byBhY3R1YWxseSBjbHVzdGVyIHRoZSBlbnRpdGllcyBpbiBhIGNsdXN0ZXIgbGF5ZXIuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIGFzIGFkZGluZyBhbiBlbnRpdGl5IHdpbGwgcmVjYWxjdWxhdGUgYWxsIGNsdXN0ZXJzLlxyXG4gICAgICogQXMgc3VjaCwgU3RvcENsdXN0ZXJpbmcgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgYWRkaW5nIG1hbnkgZW50aXRpZXMgYW5kIFN0YXJ0Q2x1c3RlcmluZyBzaG91bGQgYmUgY2FsbGVkIG9uY2UgYWRkaW5nIGlzXHJcbiAgICAgKiBjb21wbGV0ZSB0byByZWNhbGN1bGF0ZSB0aGUgY2x1c3RlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFya2VyQ2x1c3RlcmVyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBTdG9wQ2x1c3RlcmluZygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzQ2x1c3RlcmluZykgeyByZXR1cm47IH1cclxuICAgICAgICB0aGlzLl9pc0NsdXN0ZXJpbmcgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBHb29nbGVNYXJrZXJDbHVzdGVyZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1tYXJrZXItY2x1c3RlcmVyJztcclxuaW1wb3J0IHsgR29vZ2xlSW5mb1dpbmRvdyB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLWluZm8td2luZG93JztcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcEFQSUxvYWRlciB9IGZyb20gJy4uL21hcGFwaWxvYWRlcic7XHJcbmltcG9ydCB7IEdvb2dsZU1hcEFQSUxvYWRlciwgR29vZ2xlTWFwQVBJTG9hZGVyQ29uZmlnIH0gZnJvbSAnLi9nb29nbGUtbWFwLWFwaS1sb2FkZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZUNsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9nb29nbGUtY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSUxheWVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxheWVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJQ2x1c3Rlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ljbHVzdGVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTWFwT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcC1vcHRpb25zJztcclxuaW1wb3J0IHsgSUxhdExvbmcgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lsYXRsb25nJztcclxuaW1wb3J0IHsgSVBvaW50IH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9pbnQnO1xyXG5pbXBvcnQgeyBJU2l6ZSB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXNpemUnO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSU1hcmtlckljb25JbmZvIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbWFya2VyLWljb24taW5mbyc7XHJcbmltcG9ydCB7IElQb2x5Z29uT3B0aW9ucyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaXBvbHlnb24tb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2x5bGluZU9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2lwb2x5bGluZS1vcHRpb25zJztcclxuaW1wb3J0IHsgSUluZm9XaW5kb3dPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9paW5mby13aW5kb3ctb3B0aW9ucyc7XHJcbmltcG9ydCB7IE1hcFR5cGVJZCB9IGZyb20gJy4uLy4uL21vZGVscy9tYXAtdHlwZS1pZCc7XHJcbmltcG9ydCB7IE1hcmtlciB9IGZyb20gJy4uLy4uL21vZGVscy9tYXJrZXInO1xyXG5pbXBvcnQgeyBQb2x5Z29uIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlnb24nO1xyXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5bGluZSc7XHJcbmltcG9ydCB7IE1peGluTWFwTGFiZWxXaXRoT3ZlcmxheVZpZXcgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1sYWJlbCc7XHJcbmltcG9ydCB7IE1peGluQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLWNhbnZhcy1vdmVybGF5JztcclxuaW1wb3J0IHsgR29vZ2xlQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLWNhbnZhcy1vdmVybGF5JztcclxuaW1wb3J0IHsgQ2FudmFzT3ZlcmxheSB9IGZyb20gJy4uLy4uL21vZGVscy9jYW52YXMtb3ZlcmxheSc7XHJcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2xheWVyJztcclxuaW1wb3J0IHsgSW5mb1dpbmRvdyB9IGZyb20gJy4uLy4uL21vZGVscy9pbmZvLXdpbmRvdyc7XHJcbmltcG9ydCB7IEdvb2dsZVBvbHlnb24gfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1wb2x5Z29uJztcclxuaW1wb3J0IHsgR29vZ2xlUG9seWxpbmUgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1wb2x5bGluZSc7XHJcbmltcG9ydCB7IEdvb2dsZUNvbnZlcnNpb25zIH0gZnJvbSAnLi9nb29nbGUtY29udmVyc2lvbnMnO1xyXG5pbXBvcnQgeyBHb29nbGVNYXJrZXIgfSBmcm9tICcuLi8uLi9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1tYXJrZXInO1xyXG5pbXBvcnQgeyBHb29nbGVMYXllciB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLWxheWVyJztcclxuaW1wb3J0IHsgSUJveCB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWJveCc7XHJcbmltcG9ydCB7IEdvb2dsZU1hcEV2ZW50c0xvb2t1cCB9IGZyb20gJy4uLy4uL21vZGVscy9nb29nbGUvZ29vZ2xlLWV2ZW50cy1sb29rdXAnO1xyXG5pbXBvcnQgKiBhcyBHb29nbGVNYXBUeXBlcyBmcm9tICcuL2dvb2dsZS1tYXAtdHlwZXMnO1xyXG5cclxuZGVjbGFyZSBjb25zdCBnb29nbGU6IGFueTtcclxuZGVjbGFyZSBjb25zdCBNYXJrZXJDbHVzdGVyZXI6IGFueTtcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgTWFwU2VydmljZSBhYnN0cmFjdCBpbXBsZW1lbnRpbmcgYSBHb29nbGUgTWFwcyBwcm92aWRlclxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXBTZXJ2aWNlIGltcGxlbWVudHMgTWFwU2VydmljZSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgRGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuXHJcbiAgICBwcml2YXRlIF9tYXA6IFByb21pc2U8R29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwPjtcclxuICAgIHByaXZhdGUgX21hcEluc3RhbmNlOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXA7XHJcbiAgICBwcml2YXRlIF9tYXBSZXNvbHZlcjogKHZhbHVlPzogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB2b2lkO1xyXG4gICAgcHJpdmF0ZSBfY29uZmlnOiBHb29nbGVNYXBBUElMb2FkZXJDb25maWc7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gUHJvcGVydHkgRGVmaW5pdGlvbnNcclxuICAgIC8vL1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIEdvb2dsZSBNYXAgY29udHJvbCBpbnN0YW5jZSB1bmRlcmx5aW5nIHRoZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBNYXBJbnN0YW5jZSgpOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXAgeyByZXR1cm4gdGhpcy5fbWFwSW5zdGFuY2U7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBQcm9taXNlIGZvciBhIEdvb2dsZSBNYXAgY29udHJvbCBpbnN0YW5jZSB1bmRlcmx5aW5nIHRoZSBpbXBsZW1lbnRhdGlvbi4gVXNlIHRoaXMgaW5zdGVhZCBvZiB7QGxpbmsgTWFwSW5zdGFuY2V9IGlmIHlvdVxyXG4gICAgICogYXJlIG5vdCBzdXJlIGlmIGFuZCB3aGVuIHRoZSBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgTWFwUHJvbWlzZSgpOiBQcm9taXNlPEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcD4geyByZXR1cm4gdGhpcy5fbWFwOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXBzIHBoeXNpY2FsIHNpemUuXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAYWJzdHJhY3RcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0IE1hcFNpemUoKTogSVNpemUge1xyXG4gICAgICAgIGlmICh0aGlzLk1hcEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsOiBIVE1MRGl2RWxlbWVudCA9IHRoaXMuTWFwSW5zdGFuY2UuZ2V0RGl2KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHM6IElTaXplID0geyB3aWR0aDogZWwub2Zmc2V0V2lkdGgsIGhlaWdodDogZWwub2Zmc2V0SGVpZ2h0IH07XHJcbiAgICAgICAgICAgIHJldHVybiBzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZU1hcFNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX2xvYWRlciBNYXBBUElMb2FkZXIgaW5zdGFuY2UgaW1wbGVtZW50ZWQgZm9yIEdvb2dsZSBNYXBzLiBUaGlzIGluc3RhbmNlIHdpbGwgZ2VuZXJhbGx5IGJlIGluamVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIE5nWm9uZSBvYmplY3QgdG8gZW5hYmxlIHpvbmUgYXdhcmUgcHJvbWlzZXMuIFRoaXMgd2lsbCBnZW5lcmFsbHkgYmUgaW5qZWN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbG9hZGVyOiBNYXBBUElMb2FkZXIsIHByaXZhdGUgX3pvbmU6IE5nWm9uZSkge1xyXG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBQcm9taXNlPEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcD4oXHJcbiAgICAgICAgICAgIChyZXNvbHZlOiAobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHZvaWQpID0+IHsgdGhpcy5fbWFwUmVzb2x2ZXIgPSByZXNvbHZlOyB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLl9jb25maWcgPSAoPEdvb2dsZU1hcEFQSUxvYWRlcj50aGlzLl9sb2FkZXIpLkNvbmZpZztcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWV0aG9kcyBhbmQgTWFwU2VydmljZSBpbnRlcmZhY2UgaW1wbGVtZW50YXRpb25cclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNhbnZhcyBvdmVybGF5IGxheWVyIHRvIHBlcmZvcm0gY3VzdG9tIGRyYXdpbmcgb3ZlciB0aGUgbWFwIHdpdGggb3V0XHJcbiAgICAgKiBzb21lIG9mIHRoZSBvdmVyaGVhZCBhc3NvY2lhdGVkIHdpdGggZ29pbmcgdGhyb3VnaCB0aGUgTWFwIG9iamVjdHMuXHJcbiAgICAgKiBAcGFyYW0gZHJhd0NhbGxiYWNrIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgY2FudmFzIGlzIHJlYWR5IHRvIGJlXHJcbiAgICAgKiByZW5kZXJlZCBmb3IgdGhlIGN1cnJlbnQgbWFwIHZpZXcuXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgQ2FudmFzT3ZlcmxheX0gb2JqZWN0LlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZUNhbnZhc092ZXJsYXkoZHJhd0NhbGxiYWNrOiAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4gdm9pZCk6IFByb21pc2U8Q2FudmFzT3ZlcmxheT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheTogR29vZ2xlQ2FudmFzT3ZlcmxheSA9IG5ldyBHb29nbGVDYW52YXNPdmVybGF5KGRyYXdDYWxsYmFjayk7XHJcbiAgICAgICAgICAgIG92ZXJsYXkuU2V0TWFwKG1hcCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvdmVybGF5O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDcmVhdGVzIGEgR29vZ2xlIG1hcCBjbHVzdGVyIGxheWVyIHdpdGhpbiB0aGUgbWFwIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBsYXllci4gU2VlIHtAbGluayBJQ2x1c3Rlck9wdGlvbnN9LlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIExheWVyfSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBNaWNyb3NvZnQuTWFwcy5DbHVzdGVyTGF5ZXIgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVDbHVzdGVyTGF5ZXIob3B0aW9uczogSUNsdXN0ZXJPcHRpb25zKTogUHJvbWlzZTxMYXllcj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgbGV0IHVwZGF0ZU9wdGlvbnM6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgbWFya2VyQ2x1c3RlcmVyOiBHb29nbGVNYXBUeXBlcy5NYXJrZXJDbHVzdGVyZXIgPSBuZXcgTWFya2VyQ2x1c3RlcmVyKG1hcCwgW10sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCBjbHVzdGVyTGF5ZXIgPSBuZXcgR29vZ2xlTWFya2VyQ2x1c3RlcmVyKG1hcmtlckNsdXN0ZXJlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IG86IElDbHVzdGVyT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIGlkOiBvcHRpb25zLmlkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBvLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZU9wdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5jbHVzdGVyaW5nRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgby5jbHVzdGVyaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlT3B0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVwZGF0ZU9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNsdXN0ZXJMYXllci5TZXRPcHRpb25zKG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjbHVzdGVyTGF5ZXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluZm9ybWF0aW9uIHdpbmRvdyBmb3IgYSBtYXAgcG9zaXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIC0gSW5mb3dpbmRvdyBvcHRpb25zLiBTZWUge0BsaW5rIElJbmZvV2luZG93T3B0aW9uc31cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBvZiBhIHtAbGluayBJbmZvV2luZG93fSBvYmplY3QsIHdoaWNoIG1vZGVscyB0aGUgdW5kZXJseWluZyBNaWNyb3NvZnQuTWFwcy5JbmZvYm94IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlSW5mb1dpbmRvdyhvcHRpb25zPzogSUluZm9XaW5kb3dPcHRpb25zKTogUHJvbWlzZTxHb29nbGVJbmZvV2luZG93PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvOiBHb29nbGVNYXBUeXBlcy5JbmZvV2luZG93T3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUluZm9XaW5kb3dPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmZvV2luZG93OiBHb29nbGVNYXBUeXBlcy5JbmZvV2luZG93ID0gbmV3IGdvb2dsZS5tYXBzLkluZm9XaW5kb3cobyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgR29vZ2xlSW5mb1dpbmRvdyhpbmZvV2luZG93LCB0aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBtYXAgbGF5ZXIgd2l0aGluIHRoZSBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLiBTZWUge0BsaW5rIElMYXllck9wdGlvbnN9XHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgTGF5ZXJ9IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIE1pY3Jvc29mdC5NYXBzLkxheWVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlTGF5ZXIob3B0aW9uczogSUxheWVyT3B0aW9ucyk6IFByb21pc2U8TGF5ZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB7XHJcbiAgICAgICAgICAgICByZXR1cm4gbmV3IEdvb2dsZUxheWVyKG1hcCwgdGhpcywgb3B0aW9ucy5pZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVsIC0gSFRNTCBlbGVtZW50IHRvIGhvc3QgdGhlIG1hcC5cclxuICAgICAqIEBwYXJhbSBtYXBPcHRpb25zIC0gTWFwIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIG1hcCBoYXMgYmVlbiBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVNYXAoZWw6IEhUTUxFbGVtZW50LCBtYXBPcHRpb25zOiBJTWFwT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkZXIuTG9hZCgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBhcHBseSBtaXhpbnNcclxuICAgICAgICAgICAgTWl4aW5NYXBMYWJlbFdpdGhPdmVybGF5VmlldygpO1xyXG4gICAgICAgICAgICBNaXhpbkNhbnZhc092ZXJsYXkoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgbWFwIHN0YXJ0dXBcclxuICAgICAgICAgICAgaWYgKCFtYXBPcHRpb25zLm1hcFR5cGVJZCA9PSBudWxsKSB7IG1hcE9wdGlvbnMubWFwVHlwZUlkID0gTWFwVHlwZUlkLmh5YnJpZDsgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWFwSW5zdGFuY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5EaXNwb3NlTWFwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFwT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU9wdGlvbnMobWFwT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChlbCwgbyk7XHJcbiAgICAgICAgICAgIGlmIChtYXBPcHRpb25zLmJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgbWFwLmZpdEJvdW5kcyhHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVCb3VuZHMobWFwT3B0aW9ucy5ib3VuZHMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG1hcDtcclxuICAgICAgICAgICAgdGhpcy5fbWFwUmVzb2x2ZXIobWFwKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIEdvb2dsZSBtYXAgbWFya2VyIHdpdGhpbiB0aGUgbWFwIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gW29wdGlvbnM9PElNYXJrZXJPcHRpb25zPnt9XSAtIE9wdGlvbnMgZm9yIHRoZSBtYXJrZXIuIFNlZSB7QGxpbmsgSU1hcmtlck9wdGlvbnN9LlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIE1hcmtlcn0gb2JqZWN0LCB3aGljaCBtb2RlbHMgdGhlIHVuZGVybHlpbmcgTWljcm9zb2Z0Lk1hcHMuUHVzaFBpbiBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZU1hcmtlcihvcHRpb25zOiBJTWFya2VyT3B0aW9ucyA9IDxJTWFya2VyT3B0aW9ucz57fSk6IFByb21pc2U8TWFya2VyPiB7XHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9ICh4OiBHb29nbGVNYXBUeXBlcy5NYXJrZXJPcHRpb25zLCBtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCk6IEdvb2dsZU1hcmtlciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoeCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgR29vZ2xlTWFya2VyKG1hcmtlcik7XHJcbiAgICAgICAgICAgIG0uSXNGaXJzdCA9IG9wdGlvbnMuaXNGaXJzdDtcclxuICAgICAgICAgICAgbS5Jc0xhc3QgPSBvcHRpb25zLmlzTGFzdDtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHsgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKCh2YWw6IGFueSwga2V5OiBzdHJpbmcpID0+IG0uTWV0YWRhdGEuc2V0KGtleSwgdmFsKSk7IH1cclxuICAgICAgICAgICAgbWFya2VyLnNldE1hcChtYXApO1xyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFya2VyT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU1hcmtlck9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmljb25JbmZvICYmIG9wdGlvbnMuaWNvbkluZm8ubWFya2VyVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IE1hcmtlci5DcmVhdGVNYXJrZXIob3B0aW9ucy5pY29uSW5mbyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHMpID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uaWNvbiA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQobywgbWFwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnRoZW4oeCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8uaWNvbiA9IHguaWNvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQobywgbWFwKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkKG8sIG1hcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBwb2x5Z29uIHdpdGhpbiB0aGUgR29vZ2xlIE1hcCBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgcG9seWdvbi4gU2VlIHtAbGluayBJUG9seWdvbk9wdGlvbnN9LlxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIG9mIGEge0BsaW5rIFBvbHlnb259IG9iamVjdCwgd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBwb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVQb2x5Z29uKG9wdGlvbnM6IElQb2x5Z29uT3B0aW9ucyk6IFByb21pc2U8UG9seWdvbj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuUG9seWdvbk9wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVQb2x5Z29uT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgcG9seWdvbjogR29vZ2xlTWFwVHlwZXMuUG9seWdvbiA9IG5ldyBnb29nbGUubWFwcy5Qb2x5Z29uKG8pO1xyXG4gICAgICAgICAgICBwb2x5Z29uLnNldE1hcChtYXApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcDogR29vZ2xlUG9seWdvbiA9IG5ldyBHb29nbGVQb2x5Z29uKHBvbHlnb24pO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHZhbDogYW55LCBrZXk6IHN0cmluZykgPT4gcC5NZXRhZGF0YS5zZXQoa2V5LCB2YWwpKTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50aXRsZSAmJiBvcHRpb25zLnRpdGxlICE9PSAnJykgeyBwLlRpdGxlID0gb3B0aW9ucy50aXRsZTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG93TGFiZWwgIT0gbnVsbCkgeyBwLlNob3dMYWJlbCA9IG9wdGlvbnMuc2hvd0xhYmVsOyB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3dUb29sdGlwICE9IG51bGwpIHsgcC5TaG93VG9vbHRpcCA9IG9wdGlvbnMuc2hvd1Rvb2x0aXA7IH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGFiZWxNYXhab29tICE9IG51bGwpIHsgcC5MYWJlbE1heFpvb20gPSBvcHRpb25zLmxhYmVsTWF4Wm9vbTsgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sYWJlbE1pblpvb20gIT0gbnVsbCkgeyBwLkxhYmVsTWluWm9vbSA9IG9wdGlvbnMubGFiZWxNaW5ab29tOyB9XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHBvbHlsaW5lIHdpdGhpbiB0aGUgR29vZ2xlIE1hcCBtYXAgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgcG9seWxpbmUuIFNlZSB7QGxpbmsgSVBvbHlsaW5lT3B0aW9uc30uXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYSB7QGxpbmsgUG9seWxpbmV9IG9iamVjdCAob3IgYW4gYXJyYXkgdGhlcmVmb3JlIGZvciBjb21wbGV4IHBhdGhzKVxyXG4gICAgICogd2hpY2ggbW9kZWxzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBwb2x5bGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWxpbmUob3B0aW9uczogSVBvbHlsaW5lT3B0aW9ucyk6IFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+PiB7XHJcbiAgICAgICAgbGV0IHBvbHlsaW5lOiBHb29nbGVNYXBUeXBlcy5Qb2x5bGluZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLlBvbHlsaW5lT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZVBvbHlsaW5lT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGF0aCAmJiBvcHRpb25zLnBhdGgubGVuZ3RoID4gMCAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGhbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICBvLnBhdGggPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVQYXRocyhvcHRpb25zLnBhdGgpWzBdO1xyXG4gICAgICAgICAgICAgICAgcG9seWxpbmUgPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWxpbmUobyk7XHJcbiAgICAgICAgICAgICAgICBwb2x5bGluZS5zZXRNYXAobWFwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbCA9IG5ldyBHb29nbGVQb2x5bGluZShwb2x5bGluZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkgeyBvcHRpb25zLm1ldGFkYXRhLmZvckVhY2goKHZhbDogYW55LCBrZXk6IHN0cmluZykgPT4gcGwuTWV0YWRhdGEuc2V0KGtleSwgdmFsKSk7IH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpdGxlICYmIG9wdGlvbnMudGl0bGUgIT09ICcnKSB7IHBsLlRpdGxlID0gb3B0aW9ucy50aXRsZTsgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Rvb2x0aXAgIT0gbnVsbCkgeyBwbC5TaG93VG9vbHRpcCA9IG9wdGlvbnMuc2hvd1Rvb2x0aXA7IH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhzOiBBcnJheTxBcnJheTxHb29nbGVNYXBUeXBlcy5MYXRMbmc+PiA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZVBhdGhzKG9wdGlvbnMucGF0aCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lczogQXJyYXk8UG9seWxpbmU+ID0gbmV3IEFycmF5PFBvbHlsaW5lPigpO1xyXG4gICAgICAgICAgICAgICAgcGF0aHMuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvLnBhdGggPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlsaW5lKG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lLnNldE1hcChtYXApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbCA9IG5ldyBHb29nbGVQb2x5bGluZShwb2x5bGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHsgb3B0aW9ucy5tZXRhZGF0YS5mb3JFYWNoKCh2YWw6IGFueSwga2V5OiBzdHJpbmcpID0+IHBsLk1ldGFkYXRhLnNldChrZXksIHZhbCkpOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgJiYgb3B0aW9ucy50aXRsZSAhPT0gJycpIHsgcGwuVGl0bGUgPSBvcHRpb25zLnRpdGxlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Rvb2x0aXAgIT0gbnVsbCkgeyBwbC5TaG93VG9vbHRpcCA9IG9wdGlvbnMuc2hvd1Rvb2x0aXA7IH1cclxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHBsKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGEgbGF5ZXIgZnJvbSB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYXllciAtIExheWVyIHRvIGRlbGV0ZS4gU2VlIHtAbGluayBMYXllcn0uIFRoaXMgbWV0aG9kIGV4cGVjdHMgdGhlIEdvb2dsZSBzcGVjaWZpYyBMYXllciBtb2RlbCBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIC0gUHJvbWlzZSBmdWxsZmlsbGVkIHdoZW4gdGhlIGxheWVyIGhhcyBiZWVuIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIERlbGV0ZUxheWVyKGxheWVyOiBMYXllcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIC8vIHJldHVybiByZXNvbHZlZCBwcm9taXNlIGFzIHRoZXJlIGlzIG5vIGNvbmVwdCBvZiBhIGN1c3RvbSBsYXllciBpbiBHb29nbGUuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzcGFvc2UgdGhlIG1hcCBhbmQgYXNzb2NpYXRlZCByZXNvdXJlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgRGlzcG9zZU1hcCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fbWFwID09IG51bGwgJiYgdGhpcy5fbWFwSW5zdGFuY2UgPT0gbnVsbCkgeyByZXR1cm47IH1cclxuICAgICAgICBpZiAodGhpcy5fbWFwSW5zdGFuY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXBJbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcCA9IG5ldyBQcm9taXNlPEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcD4oKHJlc29sdmU6ICgpID0+IHZvaWQpID0+IHsgdGhpcy5fbWFwUmVzb2x2ZXIgPSByZXNvbHZlOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIG1hcCBjZW50ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgZ29lIGxvY2F0aW9uIG9mIHRoZSBjZW50ZXIuIFNlZSB7QGxpbmsgSUxhdExvbmd9LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXRDZW50ZXIoKTogUHJvbWlzZTxJTGF0TG9uZz4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbigobWFwOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VudGVyOiBHb29nbGVNYXBUeXBlcy5MYXRMbmcgPSBtYXAuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiA8SUxhdExvbmc+e1xyXG4gICAgICAgICAgICAgICAgbGF0aXR1ZGU6IGNlbnRlci5sYXQoKSxcclxuICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogY2VudGVyLmxuZygpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIG1hcCBib3VuZGluZyBib3hcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUgZ2VvIGxvY2F0aW9uIG9mIHRoZSBib3VuZGluZyBib3guIFNlZSB7QGxpbmsgSUJveH0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldEJvdW5kcygpOiBQcm9taXNlPElCb3g+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJveCA9IG1hcC5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIDxJQm94PntcclxuICAgICAgICAgICAgICAgIG1heExhdGl0dWRlOiBib3guZ2V0Tm9ydGhFYXN0KCkubGF0KCksXHJcbiAgICAgICAgICAgICAgICBtYXhMb25naXR1ZGU6IE1hdGgubWF4KGJveC5nZXROb3J0aEVhc3QoKS5sbmcoKSwgYm94LmdldFNvdXRoV2VzdCgpLmxuZygpKSxcclxuICAgICAgICAgICAgICAgIG1pbkxhdGl0dWRlOiBib3guZ2V0U291dGhXZXN0KCkubGF0KCksXHJcbiAgICAgICAgICAgICAgICBtaW5Mb25naXR1ZGU6IE1hdGgubWluKGJveC5nZXROb3J0aEVhc3QoKS5sbmcoKSwgYm94LmdldFNvdXRoV2VzdCgpLmxuZygpKSxcclxuICAgICAgICAgICAgICAgIGNlbnRlcjogeyBsYXRpdHVkZTogYm94LmdldENlbnRlcigpLmxhdCgpLCBsb25naXR1ZGU6IGJveC5nZXRDZW50ZXIoKS5sbmcoKSB9LFxyXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCB3aGVuIGZ1bGxmaWxsZWQgY29udGFpbnMgdGhlIHpvb20gbGV2ZWwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIEdldFpvb20oKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiBtYXAuZ2V0Wm9vbSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVzIGEgY29udmVyc2lvbiBvZiBnZW8gY29vcmRpbmF0ZXMgdG8gcGl4ZWxzIG9uIHRoZSBtYXAgY29udHJvbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbG9jIC0gVGhlIGdlbyBjb29yZGluYXRlcyB0byB0cmFuc2xhdGUuXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYW4ge0BsaW5rIElQb2ludH0gaW50ZXJmYWNlIHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzLiBUaGlzIHByb21pc2UgcmVzb2x2ZXMgdG8gbnVsbFxyXG4gICAgICogaWYgdGhlIGdvZSBjb29yZGluYXRlcyBhcmUgbm90IGluIHRoZSB2aWV3IHBvcnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIExvY2F0aW9uVG9Qb2ludChsb2M6IElMYXRMb25nKTogUHJvbWlzZTxJUG9pbnQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG06IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY3Jvc3Nlc0RhdGVMaW5lOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGw6IEdvb2dsZU1hcFR5cGVzLkxhdExuZyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0KGxvYyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBtLmdldFByb2plY3Rpb24oKTtcclxuICAgICAgICAgICAgY29uc3QgczogbnVtYmVyID0gTWF0aC5wb3coMiwgbS5nZXRab29tKCkpO1xyXG4gICAgICAgICAgICBjb25zdCBiOiBHb29nbGVNYXBUeXBlcy5MYXRMbmdCb3VuZHMgPSBtLmdldEJvdW5kcygpO1xyXG4gICAgICAgICAgICBpZiAoYi5nZXRDZW50ZXIoKS5sbmcoKSA8IGIuZ2V0U291dGhXZXN0KCkubG5nKCkgIHx8XHJcbiAgICAgICAgICAgICAgICBiLmdldENlbnRlcigpLmxuZygpID4gYi5nZXROb3J0aEVhc3QoKS5sbmcoKSkgeyBjcm9zc2VzRGF0ZUxpbmUgPSB0cnVlOyB9XHJcblxyXG5cclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WTogbnVtYmVyID0gcC5mcm9tTGF0TG5nVG9Qb2ludChiLmdldE5vcnRoRWFzdCgpKS55O1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRYOiBudW1iZXIgPSBwLmZyb21MYXRMbmdUb1BvaW50KGIuZ2V0U291dGhXZXN0KCkpLng7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50OiBHb29nbGVNYXBUeXBlcy5Qb2ludCA9IHAuZnJvbUxhdExuZ1RvUG9pbnQobCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBNYXRoLmZsb29yKChwb2ludC54IC0gb2Zmc2V0WCArICgoY3Jvc3Nlc0RhdGVMaW5lICYmIHBvaW50LnggPCBvZmZzZXRYKSA/IDI1NiA6IDApKSAqIHMpLFxyXG4gICAgICAgICAgICAgICAgeTogTWF0aC5mbG9vcigocG9pbnQueSAtIG9mZnNldFkpICogcylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVzIGEgY29udmVyc2lvbiBvZiBnZW8gY29vcmRpbmF0ZXMgdG8gcGl4ZWxzIG9uIHRoZSBtYXAgY29udHJvbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbG9jIC0gVGhlIGdlbyBjb29yZGluYXRlcyB0byB0cmFuc2xhdGUuXHJcbiAgICAgKiBAcmV0dXJucyAtIFByb21pc2Ugb2YgYW4ge0BsaW5rIElQb2ludH0gaW50ZXJmYWNlIGFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBCaW5nTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgTG9jYXRpb25zVG9Qb2ludHMobG9jczogQXJyYXk8SUxhdExvbmc+KTogUHJvbWlzZTxBcnJheTxJUG9pbnQ+PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgbGV0IGNyb3NzZXNEYXRlTGluZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBwID0gbS5nZXRQcm9qZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHM6IG51bWJlciA9IE1hdGgucG93KDIsIG0uZ2V0Wm9vbSgpKTtcclxuICAgICAgICAgICAgY29uc3QgYjogR29vZ2xlTWFwVHlwZXMuTGF0TG5nQm91bmRzID0gbS5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgaWYgKGIuZ2V0Q2VudGVyKCkubG5nKCkgPCBiLmdldFNvdXRoV2VzdCgpLmxuZygpICB8fFxyXG4gICAgICAgICAgICAgICAgYi5nZXRDZW50ZXIoKS5sbmcoKSA+IGIuZ2V0Tm9ydGhFYXN0KCkubG5nKCkpIHsgY3Jvc3Nlc0RhdGVMaW5lID0gdHJ1ZTsgfVxyXG5cclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WDogbnVtYmVyID0gcC5mcm9tTGF0TG5nVG9Qb2ludChiLmdldFNvdXRoV2VzdCgpKS54O1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRZOiBudW1iZXIgPSBwLmZyb21MYXRMbmdUb1BvaW50KGIuZ2V0Tm9ydGhFYXN0KCkpLnk7XHJcbiAgICAgICAgICAgIGNvbnN0IGwgPSBsb2NzLm1hcChsbCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsMTogR29vZ2xlTWFwVHlwZXMuTGF0TG5nID0gR29vZ2xlQ29udmVyc2lvbnMuVHJhbnNsYXRlTG9jYXRpb25PYmplY3QobGwpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQ6IEdvb2dsZU1hcFR5cGVzLlBvaW50ID0gcC5mcm9tTGF0TG5nVG9Qb2ludChsMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IE1hdGguZmxvb3IoKHBvaW50LnggLSBvZmZzZXRYICsgKChjcm9zc2VzRGF0ZUxpbmUgJiYgcG9pbnQueCA8IG9mZnNldFgpID8gMjU2IDogMCkpICogcyksXHJcbiAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5mbG9vcigocG9pbnQueSAtIG9mZnNldFkpICogcylcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENlbnRlcnMgdGhlIG1hcCBvbiBhIGdlbyBsb2NhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGF0TG5nIC0gR2VvQ29vcmRpbmF0ZXMgYXJvdW5kIHdoaWNoIHRvIGNlbnRlciB0aGUgbWFwLiBTZWUge0BsaW5rIElMYXRMb25nfVxyXG4gICAgICogQHJldHVybnMgLSBQcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCB3aGVuIHRoZSBjZW50ZXIgb3BlcmF0aW9ucyBoYXMgYmVlbiBjb21wbGV0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldENlbnRlcihsYXRMbmc6IElMYXRMb25nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtYXA6IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjZW50ZXI6IEdvb2dsZU1hcFR5cGVzLkxhdExuZyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUxvY2F0aW9uT2JqZWN0KGxhdExuZyk7XHJcbiAgICAgICAgICAgIG1hcC5zZXRDZW50ZXIoY2VudGVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGdlbmVyaWMgbWFwIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0TWFwT3B0aW9ucyhvcHRpb25zOiBJTWFwT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX21hcC50aGVuKChtOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbzogR29vZ2xlTWFwVHlwZXMuTWFwT3B0aW9ucyA9IEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZU9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIG0uc2V0T3B0aW9ucyhvKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZpZXcgb3B0aW9ucyBvZiB0aGUgbWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldFZpZXdPcHRpb25zKG9wdGlvbnM6IElNYXBPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwLnRoZW4oKG06IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ib3VuZHMpIHtcclxuICAgICAgICAgICAgICAgIG0uZml0Qm91bmRzKEdvb2dsZUNvbnZlcnNpb25zLlRyYW5zbGF0ZUJvdW5kcyhvcHRpb25zLmJvdW5kcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG86IEdvb2dsZU1hcFR5cGVzLk1hcE9wdGlvbnMgPSBHb29nbGVDb252ZXJzaW9ucy5UcmFuc2xhdGVPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBtLnNldE9wdGlvbnMobyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHpvb20gLSBab29tIGxldmVsIHRvIHNldC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBQcm9taXNlIHRoYXQgaXMgZnVsbGZpbGxlZCBvbmNlIHRoZSB6b29tIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgU2V0Wm9vbSh6b29tOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oKG1hcDogR29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwKSA9PiBtYXAuc2V0Wm9vbSh6b29tKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGV2ZW50IHN1YnNjcmlwdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKGUuZy4gJ2NsaWNrJylcclxuICAgICAqIEByZXR1cm5zIC0gQW4gb2JzZXJ2YWJsZSBvZiB0eXBlIEUgdGhhdCBmaXJlcyB3aGVuIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFN1YnNjcmliZVRvTWFwRXZlbnQ8RT4oZXZlbnROYW1lOiBzdHJpbmcpOiBPYnNlcnZhYmxlPEU+IHtcclxuICAgICAgICBjb25zdCBnb29nbGVFdmVudE5hbWU6IHN0cmluZyA9IEdvb2dsZU1hcEV2ZW50c0xvb2t1cFtldmVudE5hbWVdO1xyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPEU+KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hcC50aGVuKChtOiBHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXApID0+IHtcclxuICAgICAgICAgICAgICAgIG0uYWRkTGlzdGVuZXIoZ29vZ2xlRXZlbnROYW1lLCAoZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4gb2JzZXJ2ZXIubmV4dChlKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyB0aGUgZ2l2ZW4gZXZlbnQgbmFtZSBvbiB0aGUgbWFwIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBFdmVudCB0byB0cmlnZ2VyLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCBpcyBmdWxsZmlsbGVkIG9uY2UgdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgVHJpZ2dlck1hcEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKChtKSA9PiBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKG0sIGV2ZW50TmFtZSwgbnVsbCkpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgSVBvbHlnb25PcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWdvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4uLy4uL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgTWFwUG9seWdvbkRpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvbWFwLXBvbHlnb24nO1xyXG5pbXBvcnQgeyBQb2x5Z29uU2VydmljZSB9IGZyb20gJy4uL3BvbHlnb24uc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IExheWVyU2VydmljZSB9IGZyb20gJy4uL2xheWVyLnNlcnZpY2UnO1xyXG4vKipcclxuICogQ29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIFBvbHlnb24gU2VydmljZSBhYnN0cmFjdCBjbGFzcyBmb3IgR29vZ2xlIE1hcHMuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEdvb2dsZVBvbHlnb25TZXJ2aWNlIGltcGxlbWVudHMgUG9seWdvblNlcnZpY2Uge1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIEZpZWxkIGRlY2xhcmF0aW9uc1xyXG4gICAgLy8vXHJcbiAgICBwcml2YXRlIF9wb2x5Z29uczogTWFwPE1hcFBvbHlnb25EaXJlY3RpdmUsIFByb21pc2U8UG9seWdvbj4+ID0gbmV3IE1hcDxNYXBQb2x5Z29uRGlyZWN0aXZlLCBQcm9taXNlPFBvbHlnb24+PigpO1xyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIENvbnN0cnVjdG9yXHJcbiAgICAvLy9cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgR29vZ2xlUG9seWdvblNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuIFRoZSBjb25jcmV0ZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyU2VydmljZSAtIHtAbGluayBHb29nbGVMYXllclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gICAgICogVGhlIGNvbmNyZXRlIHtAbGluayBHb29nbGVMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gTmdab25lIGluc3RhbmNlIHRvIHN1cHBvcnQgem9uZSBhd2FyZSBwcm9taXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbWFwU2VydmljZTogTWFwU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF9sYXllclNlcnZpY2U6IExheWVyU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcclxuICAgIH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWVtYmVycyBhbmQgTWFya2VyU2VydmljZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWdvbiB0byBhIG1hcC4gRGVwZW5kaW5nIG9uIHRoZSBwb2x5Z29uIGNvbnRleHQsIHRoZSBwb2x5Z29uIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYVxyXG4gICAgICogY29ycmVjc3BvbmRpbmcgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIGFkZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogSVBvbHlnb25PcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpZDogcG9seWdvbi5JZCxcclxuICAgICAgICAgICAgY2xpY2thYmxlOiBwb2x5Z29uLkNsaWNrYWJsZSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBwb2x5Z29uLkRyYWdnYWJsZSxcclxuICAgICAgICAgICAgZWRpdGFibGU6IHBvbHlnb24uRWRpdGFibGUsXHJcbiAgICAgICAgICAgIGZpbGxDb2xvcjogcG9seWdvbi5GaWxsQ29sb3IsXHJcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBwb2x5Z29uLkZpbGxPcGFjaXR5LFxyXG4gICAgICAgICAgICBnZW9kZXNpYzogcG9seWdvbi5HZW9kZXNpYyxcclxuICAgICAgICAgICAgbGFiZWxNYXhab29tOiBwb2x5Z29uLkxhYmVsTWF4Wm9vbSxcclxuICAgICAgICAgICAgbGFiZWxNaW5ab29tOiBwb2x5Z29uLkxhYmVsTWluWm9vbSxcclxuICAgICAgICAgICAgcGF0aHM6IHBvbHlnb24uUGF0aHMsXHJcbiAgICAgICAgICAgIHNob3dMYWJlbDogcG9seWdvbi5TaG93TGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dUb29sdGlwOiBwb2x5Z29uLlNob3dUb29sdGlwLFxyXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogcG9seWdvbi5TdHJva2VDb2xvcixcclxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogcG9seWdvbi5TdHJva2VPcGFjaXR5LFxyXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IHBvbHlnb24uU3Ryb2tlV2VpZ2h0LFxyXG4gICAgICAgICAgICB0aXRsZTogcG9seWdvbi5UaXRsZSxcclxuICAgICAgICAgICAgdmlzaWJsZTogcG9seWdvbi5WaXNpYmxlLFxyXG4gICAgICAgICAgICB6SW5kZXg6IHBvbHlnb24uekluZGV4LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcG9seWdvblByb21pc2U6IFByb21pc2U8UG9seWdvbj4gPSB0aGlzLl9tYXBTZXJ2aWNlLkNyZWF0ZVBvbHlnb24obyk7XHJcbiAgICAgICAgdGhpcy5fcG9seWdvbnMuc2V0KHBvbHlnb24sIHBvbHlnb25Qcm9taXNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgZGVsZWdhdGUgZm9yIGEgcG9seWdvbi5cclxuICAgICAgKlxyXG4gICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgKGUuZy4gJ2NsaWNrJylcclxuICAgICAgKiBAcGFyYW0gcG9seWdvbiAtIFRoZSB7QGxpbmsgTWFwUG9seWdvbkRpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBldmVudC5cclxuICAgICAgKiBAcmV0dXJucyAtIE9ic2VydmFibGUgZW1pdGluZyBhbiBpbnN0YW5jZSBvZiBUIGVhY2ggdGltZSB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICAqXHJcbiAgICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25TZXJ2aWNlXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pLnRoZW4oKHA6IFBvbHlnb24pID0+IHtcclxuICAgICAgICAgICAgICAgIHAuQWRkTGlzdGVuZXIoZXZlbnROYW1lLCAoZTogVCkgPT4gdGhpcy5fem9uZS5ydW4oKCkgPT4gb2JzZXJ2ZXIubmV4dChlKSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBEZWxldGVzIGEgcG9seWdvbi5cclxuICAgICAgKlxyXG4gICAgICAqIEBwYXJhbSBwb2x5Z29uIC0ge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5Z29uIGhhcyBiZWVuIGRlbGV0ZWQuXHJcbiAgICAgICpcclxuICAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblNlcnZpY2VcclxuICAgICAgKi9cclxuICAgIHB1YmxpYyBEZWxldGVQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pO1xyXG4gICAgICAgIGlmIChtID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbS50aGVuKChsOiBQb2x5Z29uKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsLkRlbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9seWdvbnMuZGVsZXRlKHBvbHlnb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW5zIGdlbyBjb29yZGluYXRlcyBmb3IgdGhlIHBvbHlnb24gb24gdGhlIGNsaWNrIGxvY2F0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQGFic3RyYWN0XHJcbiAgICAgKiBAcGFyYW0gZSAtIFRoZSBtb3VzZSBldmVudC5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIElMYXRMb25nfSBjb250YWluaW5nIHRoZSBnZW8gY29vcmRpbmF0ZXMgb2YgdGhlIGNsaWNrZWQgbWFya2VyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZTogTW91c2VFdmVudCB8IGFueSk6IElMYXRMb25nIHtcclxuICAgICAgICByZXR1cm4geyBsYXRpdHVkZTogZS5sYXRMbmcubGF0KCksIGxvbmdpdHVkZTogZS5sYXRMbmcubG5nKCkgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIHBvbHlnb24gbW9kZWwgZm9yIHRoZSBwb2x5Z29uIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlnb24gLSBUaGUge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IGZvciB3aGljaCB0byBvYnRhaW4gdGhlIHBvbHlnb24gbW9kZWwuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIFBvbHlnb259IGltcGxlbWVudGF0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIHBsYXRmb3JtLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5Z29uU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0TmF0aXZlUG9seWdvbihwb2x5Z29uOiBNYXBQb2x5Z29uRGlyZWN0aXZlKTogUHJvbWlzZTxQb2x5Z29uPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb25zLmdldChwb2x5Z29uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcG9seWdvbiBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2x5Z29uIC0ge0BsaW5rIE1hcFBvbHlnb25EaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJUG9seWdvbk9wdGlvbnN9IG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zLiBPcHRpb25zIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlXHJcbiAgICAgKiBvcHRpb25zIGFscmVhZHkgb24gdGhlIHVuZGVybHlpbmcgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5Z29uIG9wdGlvbnMgaGF2ZSBiZWVuIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWdvblNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMocG9seWdvbjogTWFwUG9seWdvbkRpcmVjdGl2ZSwgb3B0aW9uczogSVBvbHlnb25PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb25zLmdldChwb2x5Z29uKS50aGVuKChsOiBQb2x5Z29uKSA9PiB7IGwuU2V0T3B0aW9ucyhvcHRpb25zKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBQb2x5Z29uIHBhdGhcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9seWdvbiAtIHtAbGluayBNYXBQb2x5Z29uRGlyZWN0aXZlfSB0byBiZSB1cGRhdGVkLlxyXG4gICAgICogQHJldHVybnMgLSBBIHByb21pc2UgZnVsbGZpbGxlZCBvbmNlIHRoZSBwb2x5Z29uIGhhcyBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlnb25TZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVQb2x5Z29uKHBvbHlnb246IE1hcFBvbHlnb25EaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pO1xyXG4gICAgICAgIGlmIChtID09IG51bGwgfHwgcG9seWdvbi5QYXRocyA9PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHBvbHlnb24uUGF0aHMpIHx8IHBvbHlnb24uUGF0aHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG0udGhlbigobDogUG9seWdvbikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2x5Z29uLlBhdGhzWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgbC5TZXRQYXRocyhwb2x5Z29uLlBhdGhzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGwuU2V0UGF0aCg8QXJyYXk8SUxhdExvbmc+PnBvbHlnb24uUGF0aHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IElMYXRMb25nIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pbGF0bG9uZyc7XHJcbmltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3BvbHlsaW5lJztcclxuaW1wb3J0IHsgTWFwUG9seWxpbmVEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL21hcC1wb2x5bGluZSc7XHJcbmltcG9ydCB7IFBvbHlsaW5lU2VydmljZSB9IGZyb20gJy4uL3BvbHlsaW5lLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi4vbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9sYXllci5zZXJ2aWNlJztcclxuXHJcbi8qKlxyXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUG9seWxpbmUgU2VydmljZSBhYnN0cmFjdCBjbGFzcyBmb3IgR29vZ2xlIE1hcHMuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIEdvb2dsZVBvbHlsaW5lU2VydmljZSBpbXBsZW1lbnRzIFBvbHlsaW5lU2VydmljZSB7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gRmllbGQgZGVjbGFyYXRpb25zXHJcbiAgICAvLy9cclxuICAgIHByaXZhdGUgX3BvbHlsaW5lczogTWFwPE1hcFBvbHlsaW5lRGlyZWN0aXZlLCBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+ID1cclxuICAgICAgICBuZXcgTWFwPE1hcFBvbHlsaW5lRGlyZWN0aXZlLCBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4+KCk7XHJcblxyXG4gICAgLy8vXHJcbiAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBHb29nbGVQb2x5bGluZVNlcnZpY2UuXHJcbiAgICAgKiBAcGFyYW0gX21hcFNlcnZpY2UgLSB7QGxpbmsgTWFwU2VydmljZX0gaW5zdGFuY2UuIFRoZSBjb25jcmV0ZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0gaW1wbGVtZW50YXRpb24gaXMgZXhwZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gX2xheWVyU2VydmljZSAtIHtAbGluayBMYXllclNlcnZpY2V9IGluc3RhbmNlLlxyXG4gICAgICogVGhlIGNvbmNyZXRlIHtAbGluayBHb29nbGVMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGlzIGV4cGVjdGVkLlxyXG4gICAgICogQHBhcmFtIF96b25lIC0gTmdab25lIGluc3RhbmNlIHRvIHN1cHBvcnQgem9uZSBhd2FyZSBwcm9taXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfbGF5ZXJTZXJ2aWNlOiBMYXllclNlcnZpY2UsXHJcbiAgICAgICAgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7IH1cclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBQdWJsaWMgbWVtYmVycyBhbmQgTWFya2VyU2VydmljZSBpbXBsZW1lbnRhdGlvblxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcG9seWxpbmUgdG8gYSBtYXAuIERlcGVuZGluZyBvbiB0aGUgcG9seWxpbmUgY29udGV4dCwgdGhlIHBvbHlsaW5lIHdpbGwgZWl0aGVyIGJ5IGFkZGVkIHRvIHRoZSBtYXAgb3IgYVxyXG4gICAgICogY29ycmVjc3BvbmRpbmcgbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlsaW5lU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQWRkUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbzogSVBvbHlsaW5lT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgaWQ6IHBvbHlsaW5lLklkLFxyXG4gICAgICAgICAgICBjbGlja2FibGU6IHBvbHlsaW5lLkNsaWNrYWJsZSxcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBwb2x5bGluZS5EcmFnZ2FibGUsXHJcbiAgICAgICAgICAgIGVkaXRhYmxlOiBwb2x5bGluZS5FZGl0YWJsZSxcclxuICAgICAgICAgICAgZ2VvZGVzaWM6IHBvbHlsaW5lLkdlb2Rlc2ljLFxyXG4gICAgICAgICAgICBwYXRoOiBwb2x5bGluZS5QYXRoLFxyXG4gICAgICAgICAgICBzaG93VG9vbHRpcDogcG9seWxpbmUuU2hvd1Rvb2x0aXAsXHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBwb2x5bGluZS5TdHJva2VDb2xvcixcclxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogcG9seWxpbmUuU3Ryb2tlT3BhY2l0eSxcclxuICAgICAgICAgICAgc3Ryb2tlV2VpZ2h0OiBwb2x5bGluZS5TdHJva2VXZWlnaHQsXHJcbiAgICAgICAgICAgIHRpdGxlOiBwb2x5bGluZS5UaXRsZSxcclxuICAgICAgICAgICAgdmlzaWJsZTogcG9seWxpbmUuVmlzaWJsZSxcclxuICAgICAgICAgICAgekluZGV4OiBwb2x5bGluZS56SW5kZXgsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBwb2x5bGluZVByb21pc2U6IFByb21pc2U8UG9seWxpbmV8QXJyYXk8UG9seWxpbmU+PiA9IHRoaXMuX21hcFNlcnZpY2UuQ3JlYXRlUG9seWxpbmUobyk7XHJcbiAgICAgICAgdGhpcy5fcG9seWxpbmVzLnNldChwb2x5bGluZSwgcG9seWxpbmVQcm9taXNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgZGVsZWdhdGUgZm9yIGEgbGluZS5cclxuICAgICAgKlxyXG4gICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgKGUuZy4gJ2NsaWNrJylcclxuICAgICAgKiBAcGFyYW0gcG9seWxpbmUgLSBUaGUge0BsaW5rIE1hcFBvbHlsaW5lRGlyZWN0aXZlfSBmb3Igd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGV2ZW50LlxyXG4gICAgICAqIEByZXR1cm5zIC0gT2JzZXJ2YWJsZSBlbWl0aW5nIGFuIGluc3RhbmNlIG9mIFQgZWFjaCB0aW1lIHRoZSBldmVudCBvY2N1cnMuXHJcbiAgICAgICpcclxuICAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlRXZlbnRPYnNlcnZhYmxlPFQ+KGV2ZW50TmFtZTogc3RyaW5nLCBwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBPYnNlcnZhYmxlPFQ+IHtcclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxUPikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9wb2x5bGluZXMuZ2V0KHBvbHlsaW5lKS50aGVuKHAgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeDogQXJyYXk8UG9seWxpbmU+ID0gQXJyYXkuaXNBcnJheShwKSA/IHAgOiBbcF07XHJcbiAgICAgICAgICAgICAgICB4LmZvckVhY2gobGluZSA9PiBsaW5lLkFkZExpc3RlbmVyKGV2ZW50TmFtZSwgKGU6IFQpID0+IHRoaXMuX3pvbmUucnVuKCgpID0+IG9ic2VydmVyLm5leHQoZSkpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIERlbGV0ZXMgYSBwb2x5bGluZS5cclxuICAgICAgKlxyXG4gICAgICAqIEBwYXJhbSBwb2x5bGluZSAtIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgZGVsZXRlZC5cclxuICAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSBmdWxsZmlsbGVkIG9uY2UgdGhlIHBvbHlsaW5lIGhhcyBiZWVuIGRlbGV0ZWQuXHJcbiAgICAgICpcclxuICAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgICovXHJcbiAgICBwdWJsaWMgRGVsZXRlUG9seWxpbmUocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX3BvbHlsaW5lcy5nZXQocG9seWxpbmUpO1xyXG4gICAgICAgIGlmIChtID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbS50aGVuKGwgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeDogQXJyYXk8UG9seWxpbmU+ID0gQXJyYXkuaXNBcnJheShsKSA/IGwgOiBbbF07XHJcbiAgICAgICAgICAgICAgICB4LmZvckVhY2gobGluZSA9PiAgbGluZS5EZWxldGUoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2x5bGluZXMuZGVsZXRlKHBvbHlsaW5lKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyBnZW8gY29vcmRpbmF0ZXMgZm9yIHRoZSBsaW5lIG9uIHRoZSBjbGljayBsb2NhdGlvblxyXG4gICAgICpcclxuICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICogQHBhcmFtIGUgLSBUaGUgbW91c2UgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJTGF0TG9uZ30gY29udGFpbmluZyB0aGUgZ2VvIGNvb3JkaW5hdGVzIG9mIHRoZSBjbGlja2VkIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZVBvbHlsaW5lU2VydmljZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgR2V0Q29vcmRpbmF0ZXNGcm9tQ2xpY2soZTogTW91c2VFdmVudCB8IGFueSk6IElMYXRMb25nIHtcclxuICAgICAgICBpZiAoIWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZS5sYXRMbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZS5sYXRMbmcubGF0IHx8ICFlLmxhdExuZy5sbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGxhdGl0dWRlOiBlLmxhdExuZy5sYXQoKSwgbG9uZ2l0dWRlOiBlLmxhdExuZy5sbmcoKSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyB0aGUgcG9seWxpbmUgbW9kZWwgZm9yIHRoZSBsaW5lIGFsbG93aW5nIGFjY2VzcyB0byBuYXRpdmUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb25hdGlsaXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIC0gVGhlIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gZm9yIHdoaWNoIHRvIG9idGFpbiB0aGUgcG9seWxpbmUgbW9kZWwuXHJcbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdoZW4gZnVsbGZpbGxlZCBjb250YWlucyB0aGUge0BsaW5rIFBvbHlsaW5lfVxyXG4gICAgICogaW1wbGVtZW50YXRpb24gb2YgdGhlIHVuZGVybHlpbmcgcGxhdGZvcm0uIEZvciBjb21wbGV4IHBhdGhzLCByZXR1cm5zIGFuIGFycmF5IG9mIHBvbHlsaW5lcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBHZXROYXRpdmVQb2x5bGluZShwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBQcm9taXNlPFBvbHlsaW5lfEFycmF5PFBvbHlsaW5lPj4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5bGluZXMuZ2V0KHBvbHlsaW5lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcG9seWxpbmUgb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9seWxpbmUgLSB7QGxpbmsgTWFwUG9seWxpbmVEaXJlY3RpdmV9IHRvIGJlIHVwZGF0ZWQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBJUG9seWxpbmVPcHRpb25zfSBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucy4gT3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZVxyXG4gICAgICogb3B0aW9ucyBhbHJlYWR5IG9uIHRoZSB1bmRlcmx5aW5nIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWxpbmUgb3B0aW9ucyBoYXZlIGJlZW4gc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVQb2x5bGluZVNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIFNldE9wdGlvbnMocG9seWxpbmU6IE1hcFBvbHlsaW5lRGlyZWN0aXZlLCBvcHRpb25zOiBJUG9seWxpbmVPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlsaW5lcy5nZXQocG9seWxpbmUpLnRoZW4obCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHg6IEFycmF5PFBvbHlsaW5lPiA9IEFycmF5LmlzQXJyYXkobCkgPyBsIDogW2xdO1xyXG4gICAgICAgICAgICB4LmZvckVhY2gobGluZSA9PiBsaW5lLlNldE9wdGlvbnMob3B0aW9ucykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgUG9seWxpbmUgcGF0aFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2x5bGluZSAtIHtAbGluayBNYXBQb2x5bGluZURpcmVjdGl2ZX0gdG8gYmUgdXBkYXRlZC5cclxuICAgICAqIEByZXR1cm5zIC0gQSBwcm9taXNlIGZ1bGxmaWxsZWQgb25jZSB0aGUgcG9seWxpbmUgaGFzIGJlZW4gdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlUG9seWxpbmVTZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBVcGRhdGVQb2x5bGluZShwb2x5bGluZTogTWFwUG9seWxpbmVEaXJlY3RpdmUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fcG9seWxpbmVzLmdldChwb2x5bGluZSk7XHJcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtLnRoZW4obCA9PiB0aGlzLl96b25lLnJ1bigoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHg6IEFycmF5PFBvbHlsaW5lPiA9IEFycmF5LmlzQXJyYXkobCkgPyBsIDogW2xdO1xyXG4gICAgICAgICAgICBjb25zdCBwOiBBcnJheTxBcnJheTxJTGF0TG9uZz4+ID1cclxuICAgICAgICAgICAgICAgIHBvbHlsaW5lLlBhdGgubGVuZ3RoID4gMCAmJiBBcnJheS5pc0FycmF5KHBvbHlsaW5lLlBhdGhbMF0pID8gPEFycmF5PEFycmF5PElMYXRMb25nPj4+cG9seWxpbmUuUGF0aCA6XHJcbiAgICAgICAgICAgICAgICA8QXJyYXk8QXJyYXk8SUxhdExvbmc+Pj5bcG9seWxpbmUuUGF0aF07XHJcbiAgICAgICAgICAgIHguZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChwLmxlbmd0aCA+IGluZGV4KSB7IGxpbmUuU2V0UGF0aChwW2luZGV4XSk7IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGwpICYmIGwubGVuZ3RoID4gcC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGwuc3BsaWNlKHAubGVuZ3RoIC0gMSkuZm9yRWFjaChsaW5lID0+IGxpbmUuRGVsZXRlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBNYXBTZXJ2aWNlRmFjdG9yeSB9IGZyb20gJy4uL21hcHNlcnZpY2VmYWN0b3J5JztcclxuaW1wb3J0IHsgTWFwU2VydmljZSB9IGZyb20gJy4uL21hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTWFwQVBJTG9hZGVyLCBXaW5kb3dSZWYsIERvY3VtZW50UmVmIH0gZnJvbSAnLi4vbWFwYXBpbG9hZGVyJztcclxuaW1wb3J0IHsgTWFya2VyU2VydmljZSB9IGZyb20gJy4uL21hcmtlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuLi9pbmZvYm94LnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYXllclNlcnZpY2UgfSBmcm9tICcuLi9sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQ2x1c3RlclNlcnZpY2UgfSBmcm9tICcuLi9jbHVzdGVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBQb2x5Z29uU2VydmljZSB9IGZyb20gJy4uL3BvbHlnb24uc2VydmljZSc7XHJcbmltcG9ydCB7IFBvbHlsaW5lU2VydmljZSB9IGZyb20gJy4uL3BvbHlsaW5lLnNlcnZpY2UnO1xyXG5cclxuaW1wb3J0ICogYXMgR29vZ2xlTWFwVHlwZXMgZnJvbSAnLi9nb29nbGUtbWFwLXR5cGVzJztcclxuXHJcbmltcG9ydCB7IEdvb2dsZU1hcEFQSUxvYWRlciwgR29vZ2xlTWFwQVBJTG9hZGVyQ29uZmlnIH0gZnJvbSAnLi9nb29nbGUtbWFwLWFwaS1sb2FkZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZUluZm9Cb3hTZXJ2aWNlIH0gZnJvbSAnLi9nb29nbGUtaW5mb2JveC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR29vZ2xlTWFya2VyU2VydmljZSB9IGZyb20gJy4vZ29vZ2xlLW1hcmtlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR29vZ2xlTWFwU2VydmljZSB9IGZyb20gJy4vZ29vZ2xlLW1hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR29vZ2xlTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi9nb29nbGUtbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZUNsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9nb29nbGUtY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR29vZ2xlUG9seWdvblNlcnZpY2UgfSBmcm9tICcuL2dvb2dsZS1wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHb29nbGVQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuL2dvb2dsZS1wb2x5bGluZS5zZXJ2aWNlJztcclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGEgZmFjdG9yeSB0byBjcmVhdGUgdGhyZWUgbmVjZXNzYXJ5IEdvb2dsZSBNYXBzIHNwZWNpZmljIHNlcnZpY2UgaW5zdGFuY2VzLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeSBpbXBsZW1lbnRzIE1hcFNlcnZpY2VGYWN0b3J5IHtcclxuICAgIHByaXZhdGUgX21hcDogUHJvbWlzZTxHb29nbGVNYXBUeXBlcy5Hb29nbGVNYXA+O1xyXG4gICAgcHJpdmF0ZSBfbWFwUmVzb2x2ZXI6ICh2YWx1ZT86IEdvb2dsZU1hcFR5cGVzLkdvb2dsZU1hcCkgPT4gdm9pZDtcclxuXHJcbiAgICAvLy9cclxuICAgIC8vLyBDb25zdHJ1Y3RvclxyXG4gICAgLy8vXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdvb2dsZU1hcFNlcnZpY2VGYWN0b3J5LlxyXG4gICAgICogQHBhcmFtIF9sb2FkZXIgLSB7QGxpbmsgTWFwQVBJTG9hZGVyfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIEdvb2dsZSBNYXAgcHJvdmlkZXIuXHJcbiAgICAgKiBAcGFyYW0gX3pvbmUgLSBOZ1pvbmUgb2JqZWN0IHRvIGltcGxlbWVudCB6b25lIGF3YXJlIHByb21pc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sb2FkZXI6IE1hcEFQSUxvYWRlciwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XHJcbiAgICAgICAgdGhpcy5fbWFwID1cclxuICAgICAgICAgICAgbmV3IFByb21pc2U8R29vZ2xlTWFwVHlwZXMuR29vZ2xlTWFwPigocmVzb2x2ZTogKCkgPT4gdm9pZCkgPT4geyB0aGlzLl9tYXBSZXNvbHZlciA9IHJlc29sdmU7IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vL1xyXG4gICAgLy8vIFB1YmxpYyBtZXRob2RzIGFuZCBNYXBTZXJ2aWNlRmFjdG9yeSBpbXBsZW1lbnRhdGlvbi5cclxuICAgIC8vL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgbWFwIHNlcnZpY2UgZm9yIHRoZSBHb29nbGUgTWFwcyBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBNYXBTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBHb29nbGVNYXBTZXJ2aWNlfS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgR29vZ2xlTWFwU2VydmljZUZhY3RvcnlcclxuICAgICAqL1xyXG4gICAgcHVibGljIENyZWF0ZSgpOiBNYXBTZXJ2aWNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdvb2dsZU1hcFNlcnZpY2UodGhpcy5fbG9hZGVyLCB0aGlzLl96b25lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIGNsdXN0ZXIgc2VydmljZSBmb3IgdGhlIEdvb2dsZSBNYXBzIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0uXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBDbHVzdGVyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlQ2x1c3RlclNlcnZpY2V9LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlQ2x1c3RlclNlcnZpY2UoX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UpOiBDbHVzdGVyU2VydmljZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVDbHVzdGVyU2VydmljZShfbWFwU2VydmljZSwgdGhpcy5fem9uZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoaCBpbmZvIGJveCBzZXJ2aWNlIGZvciB0aGUgR29vZ2xlIE1hcHMgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfS4gQSBjb25jcmV0ZWQgaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBHb29nbGVNYXBTZXJ2aWNlfS5cclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFya2VyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTWFya2VyU2VydmljZX0uXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBJbmZvQm94U2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlSW5mb0JveFNlcnZpY2V9LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlSW5mb0JveFNlcnZpY2UoX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UsIF9tYXJrZXJTZXJ2aWNlOiBNYXJrZXJTZXJ2aWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVJbmZvQm94U2VydmljZShfbWFwU2VydmljZSwgX21hcmtlclNlcnZpY2UsIHRoaXMuX3pvbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgbGF5ZXIgc2VydmljZSBmb3IgdGhlIEdvb2dsZSBNYXBzIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0uXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBMYXllclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEdvb2dsZUxheWVyU2VydmljZX0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEdvb2dsZU1hcFNlcnZpY2VGYWN0b3J5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBDcmVhdGVMYXllclNlcnZpY2UoX21hcFNlcnZpY2U6IE1hcFNlcnZpY2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdvb2dsZUxheWVyU2VydmljZShfbWFwU2VydmljZSwgdGhpcy5fem9uZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBtYXJrZXIgc2VydmljZSBmb3IgdGhlIEdvb2dsZSBNYXBzIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgLSB7QGxpbmsgTWFwU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTWFwU2VydmljZX0uXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXJzIC0ge0BsaW5rIExheWVyU2VydmljZX0uIEEgY29uY3JldGVkIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgR29vZ2xlTGF5ZXJTZXJ2aWNlfS5cclxuICAgICAqIEBwYXJhbSBjbHVzdGVycyAgLSB7QGxpbmsgQ2x1c3RlclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlfS5cclxuICAgICAqIEByZXR1cm5zIC0ge0BsaW5rIE1hcmtlclNlcnZpY2V9LiBBIGNvbmNyZXRlZCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEdvb2dsZU1hcmtlclNlcnZpY2V9LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlTWFya2VyU2VydmljZShfbWFwU2VydmljZTogTWFwU2VydmljZSwgX2xheWVyU2VydmljZTogR29vZ2xlTGF5ZXJTZXJ2aWNlLCBfY2x1c3RlclNlcnZpY2U6IEdvb2dsZUNsdXN0ZXJTZXJ2aWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVNYXJrZXJTZXJ2aWNlKF9tYXBTZXJ2aWNlLCBfbGF5ZXJTZXJ2aWNlLCBfY2x1c3RlclNlcnZpY2UsIHRoaXMuX3pvbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgcG9seWdvbiBzZXJ2aWNlIGZvciB0aGUgR29vZ2xlIE1hcHMgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCAtIHtAbGluayBNYXBTZXJ2aWNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhoIHVuZGVybHlpbmcgbWFwIGFyY2h0aWN0dXJlLlxyXG4gICAgICogQHBhcmFtIGxheWVycyAtIHtAbGluayBMYXllclNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICogQHJldHVybnMgLSB7QGxpbmsgUG9seWdvblNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWdvblNlcnZpY2UobWFwOiBNYXBTZXJ2aWNlLCBsYXllcnM6IExheWVyU2VydmljZSk6IFBvbHlnb25TZXJ2aWNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdvb2dsZVBvbHlnb25TZXJ2aWNlKG1hcCwgbGF5ZXJzLCB0aGlzLl96b25lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgdGhlIHBvbHlsaW5lIHNlcnZpY2UgZm9yIHRoZSBHb29nbGUgTWFwcyBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFwIC0ge0BsaW5rIE1hcFNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGggdW5kZXJseWluZyBtYXAgYXJjaHRpY3R1cmUuXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXJzIC0ge0BsaW5rIExheWVyU2VydmljZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1bmRlcmx5aW5nIG1hcCBhcmNoaXRlY3R1cmUuXHJcbiAgICAgKiBAcmV0dXJucyAtIHtAbGluayBQb2x5bGluZVNlcnZpY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgdW5kZXJseWluZyBtYXAgYXJjaGl0ZWN0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNYXBTZXJ2aWNlRmFjdG9yeVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgQ3JlYXRlUG9seWxpbmVTZXJ2aWNlKG1hcDogTWFwU2VydmljZSwgbGF5ZXJzOiBMYXllclNlcnZpY2UpOiBQb2x5bGluZVNlcnZpY2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgR29vZ2xlUG9seWxpbmVTZXJ2aWNlKG1hcCwgbGF5ZXJzLCB0aGlzLl96b25lKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHBsYWZvcm0gc3BlY2lmaWMgTWFwU2VydmljZUZhY3RvcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcGlMb2FkZXIgLSBBbiB7QGxpbmsgTWFwQVBJTG9hZGVyfSBpbnN0YW5jZS4gVGhpcyBpcyBleHBlY3RlZCB0byB0aGUgYSB7QGxpbmsgR29vZ2xlTWFwQVBJTG9hZGVyfS5cclxuICogQHBhcmFtIHpvbmUgLSBBbiBOZ1pvbmUgaW5zdGFuY2UgdG8gcHJvdmlkZSB6b25lIGF3YXJlIHByb21pc2VzLlxyXG4gKlxyXG4gKiBAcmV0dXJucyAtIEEge0BsaW5rIE1hcFNlcnZpY2VGYWN0b3J5fSBpbnN0YW5jZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeUZhY3RvcnkoYXBpTG9hZGVyOiBNYXBBUElMb2FkZXIsIHpvbmU6IE5nWm9uZSk6IE1hcFNlcnZpY2VGYWN0b3J5IHtcclxuICAgIHJldHVybiBuZXcgR29vZ2xlTWFwU2VydmljZUZhY3RvcnkoYXBpTG9hZGVyLCB6b25lKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBwbGFmb3JtIHNwZWNpZmljIE1hcExvYWRlckZhY3RvcnkuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHJldHVybnMgLSBBIHtAbGluayBNYXBBUElMb2FkZXJ9IGluc3RhbmNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEdvb2dsZU1hcExvYWRlckZhY3RvcnkoKTogTWFwQVBJTG9hZGVyIHtcclxuICAgIHJldHVybiBuZXcgR29vZ2xlTWFwQVBJTG9hZGVyKG5ldyBHb29nbGVNYXBBUElMb2FkZXJDb25maWcoKSwgbmV3IFdpbmRvd1JlZigpLCBuZXcgRG9jdW1lbnRSZWYoKSk7XHJcbn1cclxuIiwiaW1wb3J0IHsgTmdNb2R1bGUsIE1vZHVsZVdpdGhQcm92aWRlcnMsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgJ2JpbmdtYXBzJztcclxuXHJcbi8vL1xyXG4vLy8gaW1wb3J0IG1vZHVsZSBpbnRlcmZhY2VzXHJcbi8vL1xyXG5pbXBvcnQgeyBJTGF0TG9uZyB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaWxhdGxvbmcnO1xyXG5pbXBvcnQgeyBJSW5mb1dpbmRvd09wdGlvbnMgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1vcHRpb25zJztcclxuaW1wb3J0IHsgSUluZm9XaW5kb3dBY3Rpb24gfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lpbmZvLXdpbmRvdy1hY3Rpb24nO1xyXG5pbXBvcnQgeyBJTWFya2VyT3B0aW9ucyB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaW1hcmtlci1vcHRpb25zJztcclxuaW1wb3J0IHsgSU1hcE9wdGlvbnMgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2ltYXAtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElTaXplIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pc2l6ZSc7XHJcbmltcG9ydCB7IElQb2ludCB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaXBvaW50JztcclxuaW1wb3J0IHsgSUJveCB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaWJveCc7XHJcbmltcG9ydCB7IElNYXJrZXJFdmVudCB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaW1hcmtlci1ldmVudCc7XHJcbmltcG9ydCB7IElNYXJrZXJJY29uSW5mbyB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaW1hcmtlci1pY29uLWluZm8nO1xyXG5pbXBvcnQgeyBJTGF5ZXJPcHRpb25zIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pbGF5ZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElDbHVzdGVyT3B0aW9ucyB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaWNsdXN0ZXItb3B0aW9ucyc7XHJcbmltcG9ydCB7IElTcGlkZXJDbHVzdGVyT3B0aW9ucyB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaXNwaWRlci1jbHVzdGVyLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJTGluZU9wdGlvbnMgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lsaW5lLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9seWdvbk9wdGlvbnMgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lwb2x5Z29uLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBJUG9seWxpbmVPcHRpb25zIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pcG9seWxpbmUtb3B0aW9ucyc7XHJcbmltcG9ydCB7IElQb2x5Z29uRXZlbnQgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lwb2x5Z29uLWV2ZW50JztcclxuaW1wb3J0IHsgSVBvbHlsaW5lRXZlbnQgfSBmcm9tICcuL3NyYy9pbnRlcmZhY2VzL2lwb2x5bGluZS1ldmVudCc7XHJcbmltcG9ydCB7IElNYXBFdmVudExvb2t1cCB9IGZyb20gJy4vc3JjL2ludGVyZmFjZXMvaW1hcC1ldmVudC1sb29rdXAnO1xyXG5pbXBvcnQgeyBJTGFiZWxPcHRpb25zIH0gZnJvbSAnLi9zcmMvaW50ZXJmYWNlcy9pbGFiZWwtb3B0aW9ucyc7XHJcblxyXG4vLy9cclxuLy8vIGltcG9ydCBtb2R1bGUgbW9kZWxzXHJcbi8vL1xyXG5pbXBvcnQgeyBJbmZvV2luZG93IH0gZnJvbSAnLi9zcmMvbW9kZWxzL2luZm8td2luZG93JztcclxuaW1wb3J0IHsgTWFya2VyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL21hcmtlcic7XHJcbmltcG9ydCB7IE1hcmtlclR5cGVJZCB9IGZyb20gJy4vc3JjL21vZGVscy9tYXJrZXItdHlwZS1pZCc7XHJcbmltcG9ydCB7IE1hcFR5cGVJZCB9IGZyb20gJy4vc3JjL21vZGVscy9tYXAtdHlwZS1pZCc7XHJcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2xheWVyJztcclxuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4vc3JjL21vZGVscy9wb2x5Z29uJztcclxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuL3NyYy9tb2RlbHMvcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBTcGlkZXJDbHVzdGVyTWFya2VyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL3NwaWRlci1jbHVzdGVyLW1hcmtlcic7XHJcbmltcG9ydCB7IENsdXN0ZXJQbGFjZW1lbnRNb2RlIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2NsdXN0ZXItcGxhY2VtZW50LW1vZGUnO1xyXG5pbXBvcnQgeyBDbHVzdGVyQ2xpY2tBY3Rpb24gfSBmcm9tICcuL3NyYy9tb2RlbHMvY2x1c3Rlci1jbGljay1hY3Rpb24nO1xyXG5pbXBvcnQgeyBDYW52YXNPdmVybGF5fSBmcm9tICcuL3NyYy9tb2RlbHMvY2FudmFzLW92ZXJsYXknO1xyXG5pbXBvcnQgeyBCaW5nTGF5ZXIgfSBmcm9tICcuL3NyYy9tb2RlbHMvYmluZy9iaW5nLWxheWVyJztcclxuaW1wb3J0IHsgQmluZ0NsdXN0ZXJMYXllciB9IGZyb20gJy4vc3JjL21vZGVscy9iaW5nL2JpbmctY2x1c3Rlci1sYXllcic7XHJcbmltcG9ydCB7IEJpbmdTcGlkZXJDbHVzdGVyTWFya2VyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2JpbmcvYmluZy1zcGlkZXItY2x1c3Rlci1tYXJrZXInO1xyXG5pbXBvcnQgeyBCaW5nSW5mb1dpbmRvdyB9IGZyb20gJy4vc3JjL21vZGVscy9iaW5nL2JpbmctaW5mby13aW5kb3cnO1xyXG5pbXBvcnQgeyBCaW5nTWFya2VyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2JpbmcvYmluZy1tYXJrZXInO1xyXG5pbXBvcnQgeyBCaW5nUG9seWdvbiB9IGZyb20gJy4vc3JjL21vZGVscy9iaW5nL2JpbmctcG9seWdvbic7XHJcbmltcG9ydCB7IEJpbmdQb2x5bGluZSB9IGZyb20gJy4vc3JjL21vZGVscy9iaW5nL2JpbmctcG9seWxpbmUnO1xyXG5pbXBvcnQgeyBCaW5nTWFwRXZlbnRzTG9va3VwIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2JpbmcvYmluZy1ldmVudHMtbG9va3VwJztcclxuaW1wb3J0IHsgQmluZ0NhbnZhc092ZXJsYXkgfSBmcm9tICcuL3NyYy9tb2RlbHMvYmluZy9iaW5nLWNhbnZhcy1vdmVybGF5JztcclxuaW1wb3J0IHsgR29vZ2xlSW5mb1dpbmRvdyB9IGZyb20gJy4vc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLWluZm8td2luZG93JztcclxuaW1wb3J0IHsgR29vZ2xlTWFya2VyIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtbWFya2VyJztcclxuaW1wb3J0IHsgR29vZ2xlUG9seWdvbiB9IGZyb20gJy4vc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLXBvbHlnb24nO1xyXG5pbXBvcnQgeyBHb29nbGVQb2x5bGluZSB9IGZyb20gJy4vc3JjL21vZGVscy9nb29nbGUvZ29vZ2xlLXBvbHlsaW5lJztcclxuaW1wb3J0IHsgR29vZ2xlTWFwRXZlbnRzTG9va3VwIH0gZnJvbSAnLi9zcmMvbW9kZWxzL2dvb2dsZS9nb29nbGUtZXZlbnRzLWxvb2t1cCc7XHJcbmltcG9ydCB7IEdvb2dsZUNhbnZhc092ZXJsYXkgfSBmcm9tICcuL3NyYy9tb2RlbHMvZ29vZ2xlL2dvb2dsZS1jYW52YXMtb3ZlcmxheSc7XHJcblxyXG4vLy9cclxuLy8vIGltcG9ydCBtb2R1bGUgY29tcG9uZW50c1xyXG4vLy9cclxuaW1wb3J0IHsgTWFwQ29tcG9uZW50IH0gZnJvbSAnLi9zcmMvY29tcG9uZW50cy9tYXAnO1xyXG5pbXBvcnQgeyBNYXBNYXJrZXJEaXJlY3RpdmUgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL21hcC1tYXJrZXInO1xyXG5pbXBvcnQgeyBJbmZvQm94Q29tcG9uZW50IH0gZnJvbSAnLi9zcmMvY29tcG9uZW50cy9pbmZvYm94JztcclxuaW1wb3J0IHsgSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvaW5mb2JveC1hY3Rpb24nO1xyXG5pbXBvcnQgeyBNYXBMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvbWFwLWxheWVyJztcclxuaW1wb3J0IHsgQ2x1c3RlckxheWVyRGlyZWN0aXZlIH0gZnJvbSAnLi9zcmMvY29tcG9uZW50cy9jbHVzdGVyLWxheWVyJztcclxuaW1wb3J0IHsgTWFwUG9seWdvbkRpcmVjdGl2ZSB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvbWFwLXBvbHlnb24nO1xyXG5pbXBvcnQgeyBNYXBQb2x5bGluZURpcmVjdGl2ZSB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvbWFwLXBvbHlsaW5lJztcclxuaW1wb3J0IHsgTWFwTWFya2VyTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL21hcC1tYXJrZXItbGF5ZXInO1xyXG5pbXBvcnQgeyBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmUgfSBmcm9tICcuL3NyYy9jb21wb25lbnRzL21hcC1wb2x5Z29uLWxheWVyJztcclxuaW1wb3J0IHsgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZSB9IGZyb20gJy4vc3JjL2NvbXBvbmVudHMvbWFwLXBvbHlsaW5lLWxheWVyJztcclxuXHJcbi8vL1xyXG4vLy8gaW1wb3J0IG1vZHVsZSBzZXJ2aWNlc1xyXG4vLy9cclxuaW1wb3J0IHsgTWFwU2VydmljZUZhY3RvcnkgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9tYXBzZXJ2aWNlZmFjdG9yeSc7XHJcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9tYXAuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcEFQSUxvYWRlciwgV2luZG93UmVmLCBEb2N1bWVudFJlZiB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL21hcGFwaWxvYWRlcic7XHJcbmltcG9ydCB7IEluZm9Cb3hTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvaW5mb2JveC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IE1hcmtlclNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9tYXJrZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IENsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUG9seWdvblNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9wb2x5bGluZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ01hcFNlcnZpY2VGYWN0b3J5LFxyXG4gICAgQmluZ01hcFNlcnZpY2VGYWN0b3J5RmFjdG9yeSwgQmluZ01hcExvYWRlckZhY3RvcnkgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9iaW5nL2JpbmctbWFwLnNlcnZpY2UuZmFjdG9yeSc7XHJcbmltcG9ydCB7IEJpbmdNYXBTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvYmluZy9iaW5nLW1hcC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ01hcEFQSUxvYWRlciwgQmluZ01hcEFQSUxvYWRlckNvbmZpZyB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1tYXAuYXBpLWxvYWRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0luZm9Cb3hTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvYmluZy9iaW5nLWluZm9ib3guc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvYmluZy9iaW5nLW1hcmtlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0xheWVyU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1sYXllci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQmluZ0NsdXN0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvYmluZy9iaW5nLWNsdXN0ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEJpbmdQb2x5Z29uU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2JpbmcvYmluZy1wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBCaW5nUG9seWxpbmVTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvYmluZy9iaW5nLXBvbHlsaW5lLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHb29nbGVDbHVzdGVyU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtY2x1c3Rlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR29vZ2xlSW5mb0JveFNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLWluZm9ib3guc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZUxheWVyU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbGF5ZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZU1hcEFQSUxvYWRlciwgR29vZ2xlTWFwQVBJTG9hZGVyQ29uZmlnIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAtYXBpLWxvYWRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHtcclxuICAgIEdvb2dsZU1hcFNlcnZpY2VGYWN0b3J5LCBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeUZhY3RvcnksXHJcbiAgICBHb29nbGVNYXBMb2FkZXJGYWN0b3J5XHJcbn0gZnJvbSAnLi9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXAuc2VydmljZS5mYWN0b3J5JztcclxuaW1wb3J0IHsgR29vZ2xlTWFwU2VydmljZSB9IGZyb20gJy4vc3JjL3NlcnZpY2VzL2dvb2dsZS9nb29nbGUtbWFwLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHb29nbGVNYXJrZXJTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1tYXJrZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IEdvb2dsZVBvbHlnb25TZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZXMvZ29vZ2xlL2dvb2dsZS1wb2x5Z29uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBHb29nbGVQb2x5bGluZVNlcnZpY2UgfSBmcm9tICcuL3NyYy9zZXJ2aWNlcy9nb29nbGUvZ29vZ2xlLXBvbHlsaW5lLnNlcnZpY2UnO1xyXG5cclxuLy8vXHJcbi8vLyBleHBvcnQgcHVibGljcyBjb21wb25lbnRzLCBtb2RlbHMsIGludGVyZmFjZXMgZXRjIGZvciBleHRlcm5hbCByZXVzZS5cclxuLy8vXHJcbmV4cG9ydCB7XHJcbiAgICBJTGF0TG9uZywgSUluZm9XaW5kb3dPcHRpb25zLCBJSW5mb1dpbmRvd0FjdGlvbiwgSVNpemUsIElNYXJrZXJPcHRpb25zLCBJQm94LCBJTWFwT3B0aW9ucywgSVBvaW50LCBJTWFya2VyRXZlbnQsIElQb2x5Z29uRXZlbnQsXHJcbiAgICBJUG9seWxpbmVFdmVudCwgSU1hcEV2ZW50TG9va3VwLCBJTWFya2VySWNvbkluZm8sIElMYXllck9wdGlvbnMsIElDbHVzdGVyT3B0aW9ucywgSVNwaWRlckNsdXN0ZXJPcHRpb25zLCBJTGluZU9wdGlvbnMsXHJcbiAgICBJUG9seWdvbk9wdGlvbnMsIElQb2x5bGluZU9wdGlvbnMsIElMYWJlbE9wdGlvbnMsIE1hcENvbXBvbmVudCwgSW5mb0JveENvbXBvbmVudCwgTWFwTWFya2VyRGlyZWN0aXZlLCBNYXBQb2x5Z29uRGlyZWN0aXZlLFxyXG4gICAgTWFwUG9seWxpbmVEaXJlY3RpdmUsIEluZm9Cb3hBY3Rpb25EaXJlY3RpdmUsIE1hcE1hcmtlckxheWVyRGlyZWN0aXZlLCBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmUsIE1hcExheWVyRGlyZWN0aXZlLFxyXG4gICAgQ2x1c3RlckxheWVyRGlyZWN0aXZlLCBNYXBQb2x5bGluZUxheWVyRGlyZWN0aXZlLCBNYXBUeXBlSWQsIE1hcmtlciwgTWFya2VyVHlwZUlkLCBJbmZvV2luZG93LCBMYXllciwgQ2x1c3RlclBsYWNlbWVudE1vZGUsXHJcbiAgICBDbHVzdGVyQ2xpY2tBY3Rpb24sIFNwaWRlckNsdXN0ZXJNYXJrZXIsIFBvbHlnb24sIFBvbHlsaW5lLCBDYW52YXNPdmVybGF5LCBNYXBTZXJ2aWNlLCBNYXBTZXJ2aWNlRmFjdG9yeSwgTWFya2VyU2VydmljZSxcclxuICAgIEluZm9Cb3hTZXJ2aWNlLCBNYXBBUElMb2FkZXIsIFdpbmRvd1JlZiwgRG9jdW1lbnRSZWYsIExheWVyU2VydmljZSwgUG9seWdvblNlcnZpY2UsIFBvbHlsaW5lU2VydmljZSwgQ2x1c3RlclNlcnZpY2VcclxufTtcclxuZXhwb3J0IHtcclxuICAgIEJpbmdNYXBTZXJ2aWNlRmFjdG9yeSwgQmluZ01hcEFQSUxvYWRlckNvbmZpZywgQmluZ01hcFNlcnZpY2UsIEJpbmdJbmZvQm94U2VydmljZSxcclxuICAgIEJpbmdNYXJrZXJTZXJ2aWNlLCBCaW5nUG9seWdvblNlcnZpY2UsIEJpbmdQb2x5bGluZVNlcnZpY2UsIEJpbmdNYXBBUElMb2FkZXIsXHJcbiAgICBCaW5nTGF5ZXJTZXJ2aWNlLCBCaW5nQ2x1c3RlclNlcnZpY2UsIEJpbmdMYXllciwgQmluZ01hcmtlciwgQmluZ1BvbHlsaW5lLCBCaW5nTWFwRXZlbnRzTG9va3VwLCBCaW5nUG9seWdvbixcclxuICAgIEJpbmdJbmZvV2luZG93LCBCaW5nQ2x1c3RlckxheWVyLCBCaW5nU3BpZGVyQ2x1c3Rlck1hcmtlciwgQmluZ0NhbnZhc092ZXJsYXlcclxufTtcclxuZXhwb3J0IHtcclxuICAgIEdvb2dsZUNsdXN0ZXJTZXJ2aWNlLCBHb29nbGVJbmZvQm94U2VydmljZSwgR29vZ2xlTGF5ZXJTZXJ2aWNlLCBHb29nbGVNYXBBUElMb2FkZXIsIEdvb2dsZU1hcEFQSUxvYWRlckNvbmZpZyxcclxuICAgIEdvb2dsZU1hcFNlcnZpY2VGYWN0b3J5LCBHb29nbGVNYXBTZXJ2aWNlLCBHb29nbGVNYXJrZXJTZXJ2aWNlLCBHb29nbGVQb2x5Z29uU2VydmljZSwgR29vZ2xlUG9seWxpbmVTZXJ2aWNlLFxyXG4gICAgR29vZ2xlTWFya2VyLCBHb29nbGVJbmZvV2luZG93LCBHb29nbGVQb2x5Z29uLCBHb29nbGVQb2x5bGluZSwgR29vZ2xlTWFwRXZlbnRzTG9va3VwLCBHb29nbGVDYW52YXNPdmVybGF5XHJcbn07XHJcblxyXG4vLy9cclxuLy8vIGRlZmluZSBtb2R1bGVcclxuLy8vXHJcbkBOZ01vZHVsZSh7XHJcbiAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICBNYXBMYXllckRpcmVjdGl2ZSxcclxuICAgICAgICBNYXBDb21wb25lbnQsXHJcbiAgICAgICAgTWFwTWFya2VyRGlyZWN0aXZlLFxyXG4gICAgICAgIEluZm9Cb3hDb21wb25lbnQsXHJcbiAgICAgICAgSW5mb0JveEFjdGlvbkRpcmVjdGl2ZSxcclxuICAgICAgICBNYXBQb2x5Z29uRGlyZWN0aXZlLFxyXG4gICAgICAgIE1hcFBvbHlsaW5lRGlyZWN0aXZlLFxyXG4gICAgICAgIENsdXN0ZXJMYXllckRpcmVjdGl2ZSxcclxuICAgICAgICBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZSxcclxuICAgICAgICBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmUsXHJcbiAgICAgICAgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgXSxcclxuICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxyXG4gICAgZXhwb3J0czogW1xyXG4gICAgICAgIENvbW1vbk1vZHVsZSxcclxuICAgICAgICBNYXBDb21wb25lbnQsXHJcbiAgICAgICAgTWFwTWFya2VyRGlyZWN0aXZlLFxyXG4gICAgICAgIE1hcFBvbHlnb25EaXJlY3RpdmUsXHJcbiAgICAgICAgTWFwUG9seWxpbmVEaXJlY3RpdmUsXHJcbiAgICAgICAgSW5mb0JveENvbXBvbmVudCxcclxuICAgICAgICBJbmZvQm94QWN0aW9uRGlyZWN0aXZlLFxyXG4gICAgICAgIE1hcExheWVyRGlyZWN0aXZlLFxyXG4gICAgICAgIENsdXN0ZXJMYXllckRpcmVjdGl2ZSxcclxuICAgICAgICBNYXBNYXJrZXJMYXllckRpcmVjdGl2ZSxcclxuICAgICAgICBNYXBQb2x5Z29uTGF5ZXJEaXJlY3RpdmUsXHJcbiAgICAgICAgTWFwUG9seWxpbmVMYXllckRpcmVjdGl2ZVxyXG4gICAgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTWFwTW9kdWxlIHtcclxuXHJcbiAgICBzdGF0aWMgZm9yUm9vdChtYXBTZXJ2aWNlRmFjdG9yeT86IE1hcFNlcnZpY2VGYWN0b3J5LCBsb2FkZXI/OiBNYXBBUElMb2FkZXIpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZ01vZHVsZTogTWFwTW9kdWxlLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICAgICAgICAgIG1hcFNlcnZpY2VGYWN0b3J5ID8geyBwcm92aWRlOiBNYXBTZXJ2aWNlRmFjdG9yeSwgdXNlVmFsdWU6IG1hcFNlcnZpY2VGYWN0b3J5IH0gOlxyXG4gICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTWFwU2VydmljZUZhY3RvcnksIGRlcHM6IFtNYXBBUElMb2FkZXIsIE5nWm9uZV0sIHVzZUZhY3Rvcnk6IEJpbmdNYXBTZXJ2aWNlRmFjdG9yeUZhY3RvcnkgfSxcclxuICAgICAgICAgICAgICAgIGxvYWRlciA/IHsgcHJvdmlkZTogTWFwQVBJTG9hZGVyLCB1c2VWYWx1ZTogbG9hZGVyIH0gOiB7IHByb3ZpZGU6IE1hcEFQSUxvYWRlciwgdXNlRmFjdG9yeTogQmluZ01hcExvYWRlckZhY3RvcnkgfSxcclxuICAgICAgICAgICAgICAgIERvY3VtZW50UmVmLFxyXG4gICAgICAgICAgICAgICAgV2luZG93UmVmXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBmb3JSb290QmluZygpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZ01vZHVsZTogTWFwTW9kdWxlLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTWFwU2VydmljZUZhY3RvcnksIGRlcHM6IFtNYXBBUElMb2FkZXIsIE5nWm9uZV0sIHVzZUZhY3Rvcnk6IEJpbmdNYXBTZXJ2aWNlRmFjdG9yeUZhY3RvcnkgfSxcclxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTWFwQVBJTG9hZGVyLCB1c2VGYWN0b3J5OiBCaW5nTWFwTG9hZGVyRmFjdG9yeSB9LFxyXG4gICAgICAgICAgICAgICAgRG9jdW1lbnRSZWYsXHJcbiAgICAgICAgICAgICAgICBXaW5kb3dSZWZcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGZvclJvb3RHb29nbGUoKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmdNb2R1bGU6IE1hcE1vZHVsZSxcclxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE1hcFNlcnZpY2VGYWN0b3J5LCBkZXBzOiBbTWFwQVBJTG9hZGVyLCBOZ1pvbmVdLCB1c2VGYWN0b3J5OiBHb29nbGVNYXBTZXJ2aWNlRmFjdG9yeUZhY3RvcnkgfSxcclxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTWFwQVBJTG9hZGVyLCB1c2VGYWN0b3J5OiBHb29nbGVNYXBMb2FkZXJGYWN0b3J5IH0sXHJcbiAgICAgICAgICAgICAgICBEb2N1bWVudFJlZixcclxuICAgICAgICAgICAgICAgIFdpbmRvd1JlZlxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsidHNsaWJfMS5fX2V4dGVuZHMiLCJlYWNoU2VyaWVzIiwibmV4dFRpY2siLCJpZCIsIkdvb2dsZU1hcFR5cGVzLk1hcFR5cGVJZCIsIkluamVjdGFibGUiLCJFdmVudEVtaXR0ZXIiLCJEaXJlY3RpdmUiLCJJbnB1dCIsIk91dHB1dCIsIkNvbXBvbmVudCIsIlZpZXdFbmNhcHN1bGF0aW9uIiwiVmlld0NoaWxkIiwiQ29udGVudENoaWxkcmVuIiwidGltZXIiLCJWaWV3Q29udGFpbmVyUmVmIiwiQ29udGVudENoaWxkIiwiQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kiLCJOZ1pvbmUiLCJIb3N0QmluZGluZyIsImxheWVySWQiLCJPcHRpb25hbCIsIk9ic2VydmFibGUiLCJTdWJqZWN0IiwidHNsaWJfMS5fX3ZhbHVlcyIsIkRFRkFVTFRfQ09ORklHVVJBVElPTiIsIlNjcmlwdFByb3RvY29sIiwiTWl4aW5NYXBMYWJlbFdpdGhPdmVybGF5VmlldyIsIk1peGluQ2FudmFzT3ZlcmxheSIsIk5nTW9kdWxlIiwiQ29tbW9uTW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBR0E7O1FBQUE7Ozt5QkFIQTtRQWlGQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUVEOzs7Ozs7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SSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDdEcsQ0FBQyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDOzt3QkFHdkcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDOzt3QkFFekMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzs7d0JBRWpCLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxLQUFLLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDckYsUUFBUSxDQUFDLElBQUksR0FBRyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7d0JBRXJELHFCQUFNLENBQUMsR0FBVyxDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7d0JBQ2hDLElBQUksUUFBUSxDQUFDLEVBQUUsSUFBSSxJQUFJLEVBQUU7NEJBQUUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFH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QUFTLEVBQUUsQ0FBQyxFQUFDLENBQUM7Z0JBQzlDLHFCQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3BCLElBQUksR0FBRyxJQUFJLElBQUksRUFBRTtvQkFDYixxQkFBSSxTQUFTLEdBQVcsQ0FBQyxDQUFDO29CQUMxQixxQkFBSSxDQUFDLEdBQVcsQ0FBQyxDQUFDO29CQUNsQixxQkFBSSxDQUFDLEdBQVcsQ0FBQyxDQUFDO29CQUNsQixxQkFBSSxFQUFFLFNBQVUsbUJBQUUsRUFBRSxTQUFVLENBQUM7b0JBQy9CLHFCQUFJLENBQUMsU0FBUSxDQUFDO29CQUVkLEtBQUsscUJBQUksQ0FBQyxHQUFHLENBQUMsbUJBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRTt3QkFDM0QsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFDYixFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNiLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEdBQUcsR0FBRyxDQUFDLFFBQVEsS0FBSyxFQUFFLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUM7NEJBQzdELENBQUMsRUFBRSxDQUFDLFFBQVEsR0FBRyxHQUFHLENBQUMsUUFBUSxLQUFLLEVBQUUsQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO3dCQUNsRSxTQUFTLElBQUksQ0FBQyxDQUFDO3dCQUNmLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDLFFBQVEsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUM7d0JBQ3hELENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLFNBQVMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLFNB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