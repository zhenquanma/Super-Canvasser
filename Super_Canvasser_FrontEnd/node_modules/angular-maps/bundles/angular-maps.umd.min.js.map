{"version":3,"sources":["ng://angular-maps/src/models/info-window.ts","ng://angular-maps/src/models/marker.ts","ng://angular-maps/src/models/layer.ts","ng://angular-maps/src/models/polygon.ts","ng://angular-maps/src/models/polyline.ts","null","ng://angular-maps/src/models/spider-cluster-marker.ts","ng://angular-maps/src/models/canvas-overlay.ts","ng://angular-maps/src/models/bing/bing-layer.ts","ng://angular-maps/src/services/bing/bing-conversions.ts","ng://angular-maps/src/models/bing/bing-marker.ts","ng://angular-maps/src/models/bing/bing-spider-cluster-marker.ts","ng://angular-maps/src/models/bing/bing-cluster-layer.ts","ng://angular-maps/src/models/bing/bing-info-window.ts","ng://angular-maps/src/models/map-label.ts","ng://angular-maps/src/models/bing/bing-label.ts","ng://angular-maps/src/models/bing/bing-polygon.ts","ng://angular-maps/src/models/bing/bing-polyline.ts","ng://angular-maps/src/models/bing/bing-events-lookup.ts","ng://angular-maps/src/models/bing/bing-canvas-overlay.ts","ng://angular-maps/src/services/google/google-conversions.ts","ng://angular-maps/src/models/google/google-info-window.ts","ng://angular-maps/src/models/google/google-marker.ts","ng://angular-maps/src/models/google/google-label.ts","ng://angular-maps/src/models/google/google-polygon.ts","ng://angular-maps/src/models/google/google-polyline.ts","ng://angular-maps/src/models/google/google-events-lookup.ts","ng://angular-maps/src/models/google/google-canvas-overlay.ts","ng://angular-maps/src/services/mapservicefactory.ts","ng://angular-maps/src/services/map.service.ts","ng://angular-maps/src/services/marker.service.ts","ng://angular-maps/src/services/infobox.service.ts","ng://angular-maps/src/services/layer.service.ts","ng://angular-maps/src/services/polygon.service.ts","ng://angular-maps/src/services/polyline.service.ts","ng://angular-maps/src/services/cluster.service.ts","ng://angular-maps/src/components/infobox-action.ts","ng://angular-maps/src/components/infobox.ts","ng://angular-maps/src/components/map-marker.ts","ng://angular-maps/src/components/map.ts","ng://angular-maps/src/components/map-layer.ts","ng://angular-maps/src/components/cluster-layer.ts","ng://angular-maps/src/components/map-polygon.ts","ng://angular-maps/src/components/map-polyline.ts","ng://angular-maps/src/components/map-marker-layer.ts","ng://angular-maps/src/components/map-polygon-layer.ts","ng://angular-maps/src/components/map-polyline-layer.ts","ng://angular-maps/src/services/mapapiloader.ts","ng://angular-maps/src/services/bing/bing-map.api-loader.service.ts","ng://angular-maps/src/services/bing/bing-infobox.service.ts","ng://angular-maps/src/services/bing/bing-marker.service.ts","ng://angular-maps/src/services/bing/bing-map.service.ts","ng://angular-maps/src/services/bing/bing-layer-base.ts","ng://angular-maps/src/services/bing/bing-layer.service.ts","ng://angular-maps/src/services/bing/bing-cluster.service.ts","ng://angular-maps/src/services/bing/bing-polygon.service.ts","ng://angular-maps/src/services/bing/bing-polyline.service.ts","ng://angular-maps/src/services/bing/bing-map.service.factory.ts","ng://angular-maps/src/services/google/google-layer-base.ts","ng://angular-maps/src/services/google/google-cluster.service.ts","ng://angular-maps/src/services/google/google-infobox.service.ts","ng://angular-maps/src/models/google/google-layer.ts","ng://angular-maps/src/services/google/google-layer.service.ts","ng://angular-maps/src/services/google/google-map-api-loader.service.ts","ng://angular-maps/src/services/google/google-marker.service.ts","ng://angular-maps/src/models/google/google-marker-clusterer.ts","ng://angular-maps/src/services/google/google-map.service.ts","ng://angular-maps/src/services/google/google-polygon.service.ts","ng://angular-maps/src/services/google/google-polyline.service.ts","ng://angular-maps/src/services/google/google-map.service.factory.ts","ng://angular-maps/index.ts"],"names":["InfoWindow","Marker","CreateMarker","iconInfo","markerType","MarkerTypeId","CanvasMarker","CreateCanvasMarker","DynmaicCircleMarker","CreateDynmaicCircleMarker","FontMarker","CreateFontBasedMarker","RotatedImageMarker","CreateRotatedImageMarker","RoundedImageMarker","CreateRoundedImageMarker","ScaledImageMarker","CreateScaledImageMarker","Custom","Error","GetImageForMarker","icon","img","ImageElementCache","get","document","createElement","src","set","size","points","id","MarkerCache","has","mi","markerSize","markerIconString","c","ctx","getContext","width","height","rotation","translate","rotate","Math","PI","fillStyle","color","beginPath","drawingOffset","moveTo","x","y","forEach","p","lineTo","closePath","fill","stroke","s","toDataURL","strokeWidth","toString","join","fontName","fontSize","font","measureText","text","textBaseline","fillText","url","image","Image","Promise","resolve","reject","crossOrigin","onload","rads","ceil","abs","cos","sin","drawImage","radius","offset","arc","clip","scale","Map","Layer","Polygon","prototype","this","_center","GetBoundingCenter","_centroid","GetPolygonCentroid","latitude","longitude","x1","x2","y1","y2","path","GetPaths","inner","off","twicearea","p1","p2","f","k","length","i","j","Polyline","GetPolylineCentroid","GetPath","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","hasOwnProperty","__extends","__","constructor","create","__read","o","n","m","Symbol","iterator","r","e","call","ar","next","done","push","value","error","__spread","arguments","concat","SpiderClusterMarker","_super","tslib_1.__extends","CanvasOverlay","drawCallback","_this","_readyResolver","_drawCallback","_canvasReady","Delete","SetMap","OnAdd","_canvas","style","position","left","top","SetCanvasElement","OnRemove","RemoveEventHandlers","Redraw","clear","Resize","UpdatePosition","w","h","BingLayer","_layer","_maps","AddListener","eventType","fn","Microsoft","Maps","Events","addHandler","AddEntity","entity","NativePrimitve","GetVisible","add","_pendingEntities","AddEntities","entities","isArray","eachSeries","nextTick","DeleteLayer","GetOptions","Number","getId","getVisible","RemoveEntity","remove","SetEntities","setPrimitives","SetOptions","options","metadata","SetVisible","visible","setVisible","splice","BingConversions","TranslateAction","action","eventHandler","label","TranslateActions","actions","a","TranslateBounds","box","LocationRect","fromEdges","maxLatitude","minLongitude","minLatitude","maxLongitude","TranslateClusterOptions","keys","filter","_clusterOptionsAttributes","indexOf","layerOffset","TranslatePoint","placementMode","ClusterPlacementMode","FirstPin","ClusterPlacementType","FirstLocation","MeanAverage","TranslateInfoBoxOptions","_infoWindowOptionsAttributes","pixelOffset","location","TranslateLocation","TranslateLoadOptions","_mapOptionsAttributes","_viewOptionsAttributes","center","mapTypeId","MapTypeId","hybrid","aerial","labelOverlay","LabelOverlay","hidden","bounds","latlong","Location","TranslateMarkerOptions","_markerOptionsAttributes","anchor","TranslateOptions","TranslatePaths","paths","_p","point","Point","TranslatePolygonOptions","exec","z","substr","parseInt","_polygonOptionsAttributes","strokeThickness","strokeWeight","strokeOpacity","strokeColor","fillOpacity","fillColor","TranslatePolylineOptions","_polylineOptionsAttributes","TranslateViewOptions","centerOffset","BingMarker","_pushpin","_map","_isFirst","val","_isLast","l","getLocation","_metadata","DeleteMarker","GetLabel","getText","SetAnchor","setOptions","SetDraggable","draggable","SetIcon","SetLabel","SetPosition","latLng","setLocation","SetTitle","title","BingSpiderClusterMarker","BingClusterLayer","circleSpiralSwitchover","collapseClusterOnMapChange","collapseClusterOnNthClick","invokeClickOnHover","minCircleLength","minSpiralAngleSeperation","spiralDistanceFactor","stickStyle","stickHoverStyle","markerSelected","markerUnSelected","isMarker","IsFirst","StopClustering","_isClustering","getPushpins","setPushpins","_markers","_pendingMarkers","_markerLookup","IsLast","StartClustering","map","apply","_a","_b","InitializeSpiderClusterSupport","_useSpiderCluster","MapInstance","_spiderLayer","_currentZoom","getZoom","SetSpiderOptions","layers","insert","_events","OnMapClick","OnMapViewChangeStart","OnMapViewChangeEnd","OnLayerClick","OnSpiderMouseOver","OnSpiderMouseOut","MapPromise","then","removeHandler","_spiderMarkers","GetMarkerFromBingMarker","pin","getOptions","gridSize","clusteringEnabled","callback","clusteredPinCallback","zIndex","GetSpiderMarkerFromBingMarker","_spiderMarkerLookup","delete","spiderClusterOptions","GetBasicPushpinOptions","getAnchor","getColor","cursor","getCursor","getIcon","roundClickableArea","getRoundClickableArea","subTitle","getSubTitle","textOffset","getTextOffset","getTitle","HideSpiderCluster","_mapclicks","_currentCluster","_spiderOptions","primitive","ClusterPushpin","showNewCluster","ShowSpiderCluster","isClusterMarker","ParentMarker","ppin","hasHandler","invoke","hasZoomChanged","Pushpin","Stick","cluster","containedPushpins","pins","centerPoint","tryLocationToPixel","PixelReference","control","stick","angle","makeSpiral","legPixelLength","stepAngle","stepLength","len","loc","tryPixelToLocation","spiderMarker","BingInfoWindow","_infoBox","_isOpen","eventName","Close","GetPosition","Open","MapLabel","Set","SetValues","Changed","prop","shouldRunDrawCanvas","shouldRunDraw","DrawCanvas","Draw","minZoom","Get","maxZoom","undefined","GetMap","mapZoom","clearRect","strokeStyle","backgroundColor","textWidth","lineWidth","strokeText","fillRect","marginLeft","GetMarginLeft","marginTop","pointerEvents","parentNode","removeChild","BingMapLabel","_options","beneathLabels","fontFamily","fontColor","key","getMap","visibility","pos","lineJoin","setHtmlElement","OnLoad","BingPolygon","_polygon","_mapService","_originalPath","_maxZoom","ManageLabel","_minZoom","_showLabel","_showTooltip","ManageTooltip","_title","handlerId_1","_editingCompleteEmitter","_label","_tooltip","GetDraggable","GetEditable","_isEditable","getLocations","getRings","SetEditable","editable","isChanged","GetDrawingTools","t","edit","finish","editedPolygon","newPath","originalPath","SetPaths","Click","OriginalPath","NewPath","SetPath","setLocations","setRings","p_1","Centroid","align","_hasToolTipReceiver","_mouseOverListener","_tooltipVisible","_mouseMoveListener","_mouseOutListener","BingPolyline","_polyline","BingMapEventsLookup","click","dblclick","rightclick","resize","boundschanged","centerchanged","zoomchanged","mouseover","mouseout","mousemove","infowindowclose","BingCanvasOverlay","GetCoordinatesFromClick","GetToolTipOverlay","_zoomStart","_centerStart","getCenter","_viewChangeEvent","getMapTypeId","streetside","display","zoomCurrent","centerCurrent","pow","newWidth","getWidth","newHeight","getHeight","pixelPoints","centerOffsetX","centerOffsetY","_viewChangeEndEvent","UpdateCanvas","_mapResizeEvent","el","GoogleConversions","east","north","south","west","TranslateInfoWindowOptions","content","description","lat","lng","TranslateLatLng","latlng","TranslateLocationObject","google","maps","LatLng","TranslateLatLngObject","TranslateLocationObjectArray","latlongArray","TranslateMapTypeId","road","GoogleMapTypes.MapTypeId","roadmap","grayscale","terrain","ordnanceSurvey","satellite","gestureHandling","zoomControl","mapTypeControl","GoogleInfoWindow","_infoWindow","addListener","close","getPosition","open","setPosition","GoogleMarker","_marker","setMap","getLabel","setDraggable","setIcon","setLabel","setTitle","GoogleMapLabel","setValues","projection","getProjection","fromLatLngToDivPixel","panes","getPanes","overlayLayer","appendChild","GooglePolygon","getDraggable","getEditable","getPath","getPaths","previous","setEditable","setPath","setPaths","event","removeListener","GooglePolyline","GoogleMapEventsLookup","GoogleCanvasOverlay","OnDraw","getDiv","offsetWidth","offsetHeight","cc","Injectable","MapService","GetRandonLocations","count","_getRandomLocation","random","crossesDateLine","LayerService","EventEmitter","Directive","args","selector","Input","Output","infoBoxId","InfoBoxComponent","_infoBoxService","_content","nativeElement","innerText","trim","outerHTML","_id","InfoBoxClose","emit","ngAfterViewInit","AddInfoWindow","_infoBoxAddedToManager","HandleEvents","ngOnChanges","changes","Latitude","Longitude","currentValue","SetInfoWindowOptions","ngOnDestroy","DeleteInfoWindow","ToString","CreateEventObservable","subscribe","Title","Description","disableAutoPan","DisableAutoPan","Visible","xOffset","yOffset","Component","template","styles","encapsulation","ViewEncapsulation","None","InfoBoxService","ViewChild","ContentChildren","InfoBoxActionDirective","markerId","MapMarkerDirective","_markerService","_containerRef","_markerAddedToManger","_inClusterLayer","_inCustomLayer","_layerId","LocationToPixel","LocationToPoint","ngAfterContentInit","HostMarker","element","parentElement","parentName","tagName","toLowerCase","attributes","AddMarker","AddEventListeners","UpdateMarkerPosition","UpdateTitle","UpdateLabel","UpdateDraggable","UpdateIcon","UpdateAnchor","UpdateVisible","unsubscribe","_getEventArg","Pixels","GetPixelsFromClick","_clickTimeout","timer","MarkerClick","DblClick","name","handler","ev","Drag","DragEnd","DragStart","MouseDown","MouseMove","MouseOut","MouseOver","MouseUp","RightClick","obj","os","MarkerService","ViewContainerRef","ContentChild","MapComponent","_zone","defineProperty","_box","_longitude","_latitude","ConvertToDecimal","UpdateCenter","_zoom","SetZoom","ngOnInit","InitMapInstance","_container","_mapPromise","SetViewOptions","SetMapOptions","DisposeMap","TriggerResize","setTimeout","TriggerMapEvent","defaultValue","parseFloat","HandleMapClickEvents","SubscribeToMapEvent","MapClick","clearTimeout","MapDblClick","MapRightClick","MapMouseOver","MapMouseOut","MapMouseMove","HandleMapBoundsChange","GetBounds","BoundsChange","HandleMapCenterChange","GetCenter","CenterChange","HandleMapZoomChange","GetZoom","ZoomChange","runOutsideAngular","zoom","CreateMap","SetCenter","providers","provide","deps","MapServiceFactory","useFactory","MapServiceCreator","ClusterService","MarkerServiceFactory","InfoBoxServiceFactory","LayerServiceFactory","ClusterServiceFactory","PolygonService","PolygonServiceFactory","PolylineService","PolylineServiceFactory","changeDetection","ChangeDetectionStrategy","OnPush","NgZone","HostBinding","CreateClusterService","ma","CreateInfoBoxService","CreateLayerService","Create","CreateMarkerService","CreatePolygonService","CreatePolylineService","layerId","MapLayerDirective","_layerService","_visible","AddLayer","_addedToManager","GetNativeLayer","ClusterLayerDirective","MeanValue","ClusterClickAction","ZoomIntoCluster","MAX_SAFE_INTEGER","_clusterClickAction","_clusteringEnabled","_clusterPlacementMode","_iconCreationCallback","_useDynamicSizeMarker","_dynamicMarkerBaseSize","_dynamicMarkerRanges","_gridSize","_iconInfo","_layerOffset","_minimumClusterSize","_spiderClusterOptions","_styles","info","CreateDynamicSizeMarker","_zIndex","_zoomOnClick","baseMarkerSize","ranges","mr","outline","total","log","v","svg","markerOffsetRatio","polygonId","MapPolygonDirective","_polygonService","_addedToService","AddPolygon","GeneratePolygonChangeSet","isFirstChange","UpdatePolygon","DeletePolygon","PathChanged","hasOptions","clickable","Clickable","Draggable","Editable","FillColor","FillOpacity","geodesic","Geodesic","labelMaxZoom","LabelMaxZoom","labelMinZoom","LabelMinZoom","showTooltip","ShowTooltip","showLabel","ShowLabel","StrokeColor","StrokeOpacity","StrokeWeight","polylineId","MapPolylineDirective","_polylineService","AddPolyline","GeneratePolylineChangeSet","UpdatePolyline","DeletePolyline","MapMarkerLayerDirective","_clusterService","_streaming","_markersLast","slice","fakeLayerDirective","Id","EnableClustering","LayerOffset","ZIndex","ClusteringEnabled","GridSize","IconInfo","ClusterIconInfo","CustomMarkerCallback","UseDynamicSizeMarkers","_layerPromise","_service","MarkerOptions","UpdateMarkers","shouldSetOptions","firstChange","zoomOnClick","markers","CreateMarkers","marker","MapPolygonLayerDirective","_polygons","_polygonsLast","all","CreateCanvasOverlay","DrawLabels","values","ShowTooltips","PolygonOptions","UpdatePolygons","_tooltipSubscriptions","PolygonClick","PolygonDblClick","PolygonMouseMove","PolygonMouseOut","PolygonMouseOver","ShowLabels","ctx_1","labels_1","_labels","LocationsToPoints","locs","MapSize","DrawText","lo","LabelOptions","DefaultLabelStyle","_defaultOptions","textAlign","show","asObservable","polygons","CreatePolygons","poly","MapPolylineLayerDirective","_polylines","_polylinesLast","PolylineOptions","UpdatePolylines","PolylineClick","PolylineDblClick","PolylineMouseMove","PolylineMouseOut","PolylineMouseOver","polylines","CreatePolylines","title_1","centroids_1","DocumentRef","GetNativeDocument","WindowRef","GetNativeWindow","window","ScriptProtocol","HTTPS","DEFAULT_CONFIGURATION","BingMapAPILoaderConfig","BingMapAPILoader","_config","_windowRef","_documentRef","Load","_scriptLoadingPromise","script","type","async","defer","callbackName","Date","getMilliseconds","GetScriptSrc","onerror","head","protocol","AUTO","HTTP","hostAndPath","queryParams","branch","decorators","Optional","MapAPILoader","BingInfoBoxService","InfoWindowActions","Label","ActionClicked","HtmlContent","htmlContent","infoPromise","CreateInfoWindow","_boxes","infoComponent","eventNameTranslated","Observable","observer","run","CloseInfoBoxesOnOpen","Modal","IsOpen","BingMarkerService","IconUrl","isFirst","IsFirstInSet","isLast","IsLastInSet","Width","Height","Anchor","Metadata","markerPromise","InClusterLayer","LayerId","InCustomLayer","DynamicMarkerCreated","Subject","GetNativeMarker","target","payload","BingMapService","_loader","_mapResolver","Config","_modules","_mapInstance","overlay","CreateClusterLayer","LoadModule","bl","layer","ClusterLayer","infoBox","Infobox","CreateLayer","mapOptions","CustomOverlay","MixinMapLabelWithOverlayView","MixinCanvasOverlay","credentials","apiKey","pushpin","CreatePolygon","CreatePolyline","polyline","pl_1","lines_1","pl","dispose","getBounds","getNorth","crossesInternationalDateLine","getWest","getEast","getSouth","padding","useSharedInstance","LoadModuleInstance","moduleName","loadModule","lastIndexOf","setView","BingLayerBase","GetLayerById","markerIcon","op","mo","_layers","l1","BingLayerService","layerPromise","polygon","line","polyline_1","lines_2","BingClusterService","CreateClusterPushPin","CreateCustomClusterPushPin","SpiderClusterOptions","o_1","payload_1","ico","Spider","bounds_1","locs_1","fromLocations","BingPolygonService","polygonPromise","Paths","GetNativePolygon","BingPolylineService","polylinePromise","Path","GetNativePolyline","index","BingMapServiceFactory","BingMapServiceFactoryFactory","apiLoader","zone","BingMapLoaderFactory","GoogleLayerBase","mp","lp","GoogleClusterService","CreateClusterIcons","pa","MinimumClusterSize","minimumClusterSize","Styles","textColor","textSize","backgroundPosition","resetStyles","clusterer","_layerStyles","setStyles","setCalculator","GoogleInfoBoxService","infoWindowPromise","googleEventName","GoogleLayer","_entities","GoogleLayerService","p1_1","tslib_1.__values","p1_1_1","GoogleMapAPILoaderConfig","GoogleMapAPILoader","GetMapsScriptSrc","enableClustering","clusterScript","GetClusterScriptSrc","onreadystatechange","apiVersion","client","clientId","channel","libraries","region","language","clusterHostAndPath","entry","GoogleMarkerService","getSouthWest","getNorthEast","offsetY","fromLatLngToPoint","offsetX","floor","GoogleMarkerClusterer","addMarker","addMarkers","getMarkers","clearMarkers","GetMarkerFromGoogleMarker","getGridSize","getMaxZoom","getMinClusterSize","isAverageCenter","isZoomOnClick","getStyles","removeMarker","setMinClusterSize","resetViewport","redraw","setGridSize","setMaxZoom","p_2","GoogleMapService","updateOptions","markerClusterer","MarkerClusterer","clusterLayer","infoWindow","OverlayView","fitBounds","max","min","ll","setCenter","setZoom","trigger","GooglePolygonService","GooglePolylineService","GoogleMapServiceFactory","GoogleMapServiceFactoryFactory","GoogleMapLoaderFactory","MapModule","forRoot","mapServiceFactory","loader","ngModule","useValue","forRootBing","forRootGoogle","NgModule","declarations","imports","CommonModule","exports"],"mappings":"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","sourcesContent":["import { ILatLong } from '../interfaces/ilatlong';\r\nimport { IInfoWindowOptions } from '../interfaces/iinfo-window-options';\r\n\r\nexport abstract class InfoWindow {\r\n\r\n    /**\r\n     * Gets whether the info box is currently open.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract get IsOpen(): boolean;\r\n\r\n    /**\r\n     * Get the underlying native primitive of the implementation.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    /**\r\n     * Adds an event listener to the info window.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Closes the info window.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract Close(): void ;\r\n\r\n    /**\r\n     * Gets the position of the info window.\r\n     *\r\n     * @abstract\r\n     * @returns - Returns the geo coordinates of the info window.\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract GetPosition(): ILatLong;\r\n\r\n    /**\r\n     * Opens the info window.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract Open(): void;\r\n\r\n    /**\r\n     * Sets the info window options.\r\n     *\r\n     * @abstract\r\n     * @param options - Info window options to set. The options will be merged with any existing options.\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract SetOptions(options: IInfoWindowOptions): void;\r\n\r\n    /**\r\n     * Sets the info window position.\r\n     *\r\n     * @abstract\r\n     * @param position - Geo coordinates to move the anchor of the info window to.\r\n     *\r\n     * @memberof InfoWindow\r\n     */\r\n    public abstract SetPosition(position: ILatLong): void;\r\n}\r\n","import { ILatLong } from '../interfaces/ilatlong';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ISize } from '../interfaces/isize';\r\nimport { MarkerTypeId } from '../models/marker-type-id';\r\n\r\n/**\r\n * This interface defines the contract for an icon cache entry.\r\n */\r\ninterface IMarkerIconCacheEntry {\r\n    /**\r\n     * The icon string of the cache entry.\r\n     *\r\n     * @memberof IMarkerIconCacheEntry\r\n     */\r\n    markerIconString: string;\r\n\r\n    /**\r\n     * The Size of the icon.\r\n     *\r\n     * @memberof IMarkerIconCacheEntry\r\n    * */\r\n    markerSize: ISize;\r\n}\r\n\r\n/**\r\n * This class defines the contract for a marker.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class Marker {\r\n\r\n    ///\r\n    /// Field definitions\r\n    ///\r\n\r\n    /**\r\n     * Caches concrete img elements for marker icons to accelerate patining.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    private static ImageElementCache: Map<string, HTMLImageElement> = new Map<string, HTMLImageElement>();\r\n\r\n\r\n    /**\r\n     * Used to cache generated markers for performance and reusability.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    private static MarkerCache: Map<string, IMarkerIconCacheEntry> = new Map<string, IMarkerIconCacheEntry>();\r\n\r\n    /**\r\n     * Creates a marker based on the marker info. In turn calls a number of internal members to\r\n     * create the actual marker.\r\n     *\r\n     * @param iconInfo - icon information. Depending on the marker type, various properties\r\n     * need to be present. For performance, it is recommended to use an id for markers that are common to facilitate\r\n     * reuse.\r\n     * @param callback - a callback that is invoked on markers that require asyncronous\r\n     * processing during creation. For markers that do not require async processing, this parameter is ignored.\r\n     * @returns - a string or a promise for a string containing\r\n     * a data url with the marker image.\r\n     * @memberof Marker\r\n     */\r\n    public static CreateMarker(iconInfo: IMarkerIconInfo): string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> {\r\n        switch (iconInfo.markerType) {\r\n            case MarkerTypeId.CanvasMarker: return Marker.CreateCanvasMarker(iconInfo);\r\n            case MarkerTypeId.DynmaicCircleMarker: return Marker.CreateDynmaicCircleMarker(iconInfo);\r\n            case MarkerTypeId.FontMarker: return Marker.CreateFontBasedMarker(iconInfo);\r\n            case MarkerTypeId.RotatedImageMarker: return Marker.CreateRotatedImageMarker(iconInfo);\r\n            case MarkerTypeId.RoundedImageMarker: return Marker.CreateRoundedImageMarker(iconInfo);\r\n            case MarkerTypeId.ScaledImageMarker: return Marker.CreateScaledImageMarker(iconInfo);\r\n            case MarkerTypeId.Custom: throw Error('Custom Marker Creators are not currently supported.');\r\n        }\r\n        throw Error('Unsupported marker type: ' + iconInfo.markerType);\r\n    }\r\n\r\n    /**\r\n     * Obtains a shared img element for a marker icon to prevent unecessary creation of\r\n     * DOM items. This has sped up large scale makers on Bing Maps by about 70%\r\n     * @param icon - The icon string (url, data url, svg) for which to obtain the image.\r\n     * @returns - The obtained image element.\r\n     * @memberof Marker\r\n     */\r\n    public static GetImageForMarker(icon: string): HTMLImageElement {\r\n        if (icon == null || icon === '' ) { return  null; }\r\n\r\n        let img: HTMLImageElement = null;\r\n        img = Marker.ImageElementCache.get(icon);\r\n        if (img != null) { return img; }\r\n\r\n        if (typeof(document) !== 'undefined' && document != null) {\r\n            img = document.createElement('img');\r\n            img.src = icon;\r\n            Marker.ImageElementCache.set(icon, img);\r\n        }\r\n        return img;\r\n    }\r\n\r\n    /**\r\n     * Creates a canvased based marker using the point collection contained in the iconInfo parameter.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @returns - String with the data url for the marker image.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateCanvasMarker(iconInfo: IMarkerIconInfo): string {\r\n        if (document == null) { throw Error('Document context (window.document) is required for canvas markers.'); }\r\n        if (iconInfo == null || iconInfo.size == null || iconInfo.points == null) {\r\n            throw Error('IMarkerIconInfo.size, and IMarkerIConInfo.points are required for canvas markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const c: HTMLCanvasElement = document.createElement('canvas');\r\n        const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n        c.width = iconInfo.size.width;\r\n        c.height = iconInfo.size.height;\r\n        if (iconInfo.rotation) {\r\n            // Offset the canvas such that we will rotate around the center of our arrow\r\n            ctx.translate(c.width * 0.5, c.height * 0.5);\r\n            // Rotate the canvas by the desired heading\r\n            ctx.rotate(iconInfo.rotation * Math.PI / 180);\r\n            // Return the canvas offset back to it's original position\r\n            ctx.translate(-c.width * 0.5, -c.height * 0.5);\r\n        }\r\n\r\n        ctx.fillStyle = iconInfo.color || 'red';\r\n\r\n        // Draw a path in the shape of an arrow.\r\n        ctx.beginPath();\r\n        if (iconInfo.drawingOffset) { ctx.moveTo(iconInfo.drawingOffset.x, iconInfo.drawingOffset.y); }\r\n        iconInfo.points.forEach((p: IPoint) => { ctx.lineTo(p.x, p.y); });\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        ctx.stroke();\r\n\r\n        const s: string = c.toDataURL();\r\n        if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Creates a circle marker image using information contained in the iconInfo parameter.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @returns - String with the data url for the marker image.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateDynmaicCircleMarker(iconInfo: IMarkerIconInfo): string {\r\n        if (document == null) { throw Error('Document context (window.document) is required for dynamic circle markers.'); }\r\n        if (iconInfo == null || iconInfo.size == null) { throw Error('IMarkerIconInfo.size is required for dynamic circle markers.'); }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const strokeWidth: number = iconInfo.strokeWidth || 0;\r\n        // Create an SVG string of a circle with the specified radius and color.\r\n        const svg: Array<string> = [\r\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"',\r\n            iconInfo.size.width.toString(),\r\n            '\" height=\"',\r\n            iconInfo.size.width.toString(),\r\n            '\"><circle cx=\"',\r\n            (iconInfo.size.width / 2).toString(),\r\n            '\" cy=\"',\r\n            (iconInfo.size.width / 2).toString(),\r\n            '\" r=\"',\r\n            ((iconInfo.size.width / 2) - strokeWidth).toString(),\r\n            '\" stroke=\"',\r\n            iconInfo.color || 'red',\r\n            '\" stroke-width=\"',\r\n            strokeWidth.toString(),\r\n            '\" fill=\"',\r\n            iconInfo.color || 'red',\r\n            '\"/></svg>'\r\n        ];\r\n\r\n        const s: string = svg.join('');\r\n        if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Creates a font based marker image (such as Font-Awesome), by using information supplied in the parameters (such as Font-Awesome).\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @returns - String with the data url for the marker image.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateFontBasedMarker(iconInfo: IMarkerIconInfo): string {\r\n        if (document == null) { throw Error('Document context (window.document) is required for font based markers'); }\r\n        if (iconInfo == null || iconInfo.fontName == null || iconInfo.fontSize == null) {\r\n            throw Error('IMarkerIconInfo.fontName, IMarkerIconInfo.fontSize and IMarkerIConInfo.text are required for font based markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const c: HTMLCanvasElement = document.createElement('canvas');\r\n        const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n        const font: string = iconInfo.fontSize + 'px ' + iconInfo.fontName;\r\n        ctx.font = font;\r\n\r\n        // Resize canvas based on sie of text.\r\n        const size: TextMetrics = ctx.measureText(iconInfo.text);\r\n        c.width = size.width;\r\n        c.height = iconInfo.fontSize;\r\n\r\n        if (iconInfo.rotation) {\r\n            // Offset the canvas such that we will rotate around the center of our arrow\r\n            ctx.translate(c.width * 0.5, c.height * 0.5);\r\n            // Rotate the canvas by the desired heading\r\n            ctx.rotate(iconInfo.rotation * Math.PI / 180);\r\n            // Return the canvas offset back to it's original position\r\n            ctx.translate(-c.width * 0.5, -c.height * 0.5);\r\n        }\r\n\r\n        // Reset font as it will be cleared by the resize.\r\n        ctx.font = font;\r\n        ctx.textBaseline = 'top';\r\n        ctx.fillStyle = iconInfo.color || 'red';\r\n\r\n        ctx.fillText(iconInfo.text, 0, 0);\r\n        iconInfo.size = { width: c.width, height: c.height };\r\n        const s: string = c.toDataURL();\r\n        if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * Creates an image marker by applying a roation to a supplied image.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @returns - a string or a promise for a string containing\r\n     * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateRotatedImageMarker(iconInfo: IMarkerIconInfo): string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> {\r\n        if (document == null) { throw Error('Document context (window.document) is required for rotated image markers'); }\r\n        if (iconInfo == null || iconInfo.rotation == null || iconInfo.url == null) {\r\n            throw Error('IMarkerIconInfo.rotation, IMarkerIconInfo.url are required for rotated image markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const image: HTMLImageElement = new Image();\r\n        const promise: Promise<{icon: string, iconInfo: IMarkerIconInfo}> =\r\n            new Promise<{icon: string, iconInfo: IMarkerIconInfo}>((resolve, reject) => {\r\n            // Allow cross domain image editting.\r\n            image.crossOrigin = 'anonymous';\r\n            image.src = iconInfo.url;\r\n            if (iconInfo.size) {\r\n                image.width = iconInfo.size.width;\r\n                image.height = iconInfo.size.height;\r\n            }\r\n            image.onload = function () {\r\n                const c: HTMLCanvasElement = document.createElement('canvas');\r\n                const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n                const rads: number = iconInfo.rotation * Math.PI / 180;\r\n\r\n                // Calculate rotated image size.\r\n                c.width = Math.ceil(Math.abs(image.width * Math.cos(rads)) + Math.abs(image.height * Math.sin(rads)));\r\n                c.height = Math.ceil(Math.abs(image.width * Math.sin(rads)) + Math.abs(image.height * Math.cos(rads)));\r\n\r\n                // Move to the center of the canvas.\r\n                ctx.translate(c.width / 2, c.height / 2);\r\n                // Rotate the canvas to the specified angle in degrees.\r\n                ctx.rotate(rads);\r\n                // Draw the image, since the context is rotated, the image will be rotated also.\r\n                ctx.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);\r\n                iconInfo.size = { width: c.width, height: c.height };\r\n\r\n                const s: string = c.toDataURL();\r\n                if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n                resolve({icon: s, iconInfo: iconInfo});\r\n            };\r\n        });\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Creates a rounded image marker by applying a circle mask to a supplied image.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @param iconInfo - Callback invoked once marker generation is complete. The callback\r\n     * parameters are the data uri and the IMarkerIconInfo.\r\n     * @returns - a string or a promise for a string containing\r\n     * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateRoundedImageMarker(iconInfo: IMarkerIconInfo): string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> {\r\n        if (document == null) { throw Error('Document context (window.document) is required for rounded image markers'); }\r\n        if (iconInfo == null || iconInfo.size == null || iconInfo.url == null) {\r\n            throw Error('IMarkerIconInfo.size, IMarkerIconInfo.url are required for rounded image markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n\r\n        const promise: Promise<{icon: string, iconInfo: IMarkerIconInfo}> =\r\n            new Promise<{icon: string, iconInfo: IMarkerIconInfo}>((resolve, reject) => {\r\n            const radius: number = iconInfo.size.width / 2;\r\n            const image: HTMLImageElement = new Image();\r\n            const offset: IPoint = iconInfo.drawingOffset || { x: 0, y: 0 };\r\n\r\n            // Allow cross domain image editting.\r\n            image.crossOrigin = 'anonymous';\r\n            image.src = iconInfo.url;\r\n            image.onload = function () {\r\n                const c: HTMLCanvasElement = document.createElement('canvas');\r\n                const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n                c.width = iconInfo.size.width;\r\n                c.height = iconInfo.size.width;\r\n\r\n                // Draw a circle which can be used to clip the image, then draw the image.\r\n                ctx.beginPath();\r\n                ctx.arc(radius, radius, radius, 0, 2 * Math.PI, false);\r\n                ctx.fill();\r\n                ctx.clip();\r\n                ctx.drawImage(image, offset.x, offset.y, iconInfo.size.width, iconInfo.size.width);\r\n                iconInfo.size = { width: c.width, height: c.height };\r\n\r\n                const s: string = c.toDataURL();\r\n                if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n                resolve({icon: s, iconInfo: iconInfo});\r\n            };\r\n        });\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Creates a scaled image marker by scaling a supplied image by a factor using a canvas.\r\n     *\r\n     * @protected\r\n     * @param iconInfo - {@link IMarkerIconInfo} containing the information necessary to create the icon.\r\n     * @param iconInfo - Callback invoked once marker generation is complete. The callback\r\n     * parameters are the data uri and the IMarkerIconInfo.\r\n     * @returns - a string or a promise for a string containing\r\n     * a data url with the marker image. In case of a cached image, the image will be returned, otherwise the promise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    protected static CreateScaledImageMarker(iconInfo: IMarkerIconInfo): string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> {\r\n        if (document == null) { throw Error('Document context (window.document) is required for scaled image markers'); }\r\n        if (iconInfo == null || iconInfo.scale == null || iconInfo.url == null) {\r\n            throw Error('IMarkerIconInfo.scale, IMarkerIconInfo.url are required for scaled image markers.');\r\n        }\r\n        if (iconInfo.id != null && Marker.MarkerCache.has(iconInfo.id)) {\r\n            const mi: IMarkerIconCacheEntry = Marker.MarkerCache.get(iconInfo.id);\r\n            iconInfo.size = mi.markerSize;\r\n            return mi.markerIconString;\r\n        }\r\n        const promise: Promise<{icon: string, iconInfo: IMarkerIconInfo}> =\r\n            new Promise<{icon: string, iconInfo: IMarkerIconInfo}>((resolve, reject) => {\r\n            const image: HTMLImageElement = new Image();\r\n\r\n            // Allow cross domain image editting.\r\n            image.crossOrigin = 'anonymous';\r\n            image.src = iconInfo.url;\r\n            image.onload = function () {\r\n                const c: HTMLCanvasElement = document.createElement('canvas');\r\n                const ctx: CanvasRenderingContext2D = c.getContext('2d');\r\n                c.width = image.width * iconInfo.scale;\r\n                c.height = image.height * iconInfo.scale;\r\n\r\n                // Draw a circle which can be used to clip the image, then draw the image.\r\n                ctx.drawImage(image, 0, 0, c.width, c.height);\r\n                iconInfo.size = { width: c.width, height: c.height };\r\n\r\n                const s: string = c.toDataURL();\r\n                if (iconInfo.id != null) { Marker.MarkerCache.set(iconInfo.id, { markerIconString: s, markerSize: iconInfo.size }); }\r\n                resolve({icon: s, iconInfo: iconInfo});\r\n            };\r\n        });\r\n        return promise;\r\n    }\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Indicates that the marker is the first marker in a set.\r\n     *\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get IsFirst(): boolean;\r\n    public abstract set IsFirst(val: boolean);\r\n\r\n    /**\r\n     * Indicates that the marker is the last marker in the set.\r\n     *\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get IsLast(): boolean;\r\n    public abstract set IsLast(val: boolean);\r\n\r\n    /**\r\n     * Gets the Location of the marker\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get Location(): ILatLong;\r\n\r\n    /**\r\n     * Gets the marker metadata.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get Metadata(): Map<string, any>;\r\n\r\n    /**\r\n     * Gets the native primitve implementing the marker (e.g. Microsoft.Maps.Pushpin)\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Marker\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener to the marker.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Deletes the marker.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract DeleteMarker(): void;\r\n\r\n    /**\r\n     * Gets the marker label\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract GetLabel(): string;\r\n\r\n    /**\r\n     * Gets the marker visibility\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract GetVisible(): boolean;\r\n\r\n    /**\r\n     * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.\r\n     *\r\n     * @abstract\r\n     * @param anchor - Point coordinates for the marker anchor.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetAnchor(anchor: IPoint): void;\r\n\r\n    /**\r\n     * Sets the draggability of a marker.\r\n     *\r\n     * @abstract\r\n     * @param draggable - True to mark the marker as draggable, false otherwise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetDraggable(draggable: boolean): void;\r\n\r\n    /**\r\n     * Sets the icon for the marker.\r\n     *\r\n     * @abstract\r\n     * @param icon - String containing the icon in various forms (url, data url, etc.)\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetIcon(icon: string): void;\r\n\r\n    /**\r\n     * Sets the marker label.\r\n     *\r\n     * @abstract\r\n     * @param label - String containing the label to set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetLabel(label: string): void;\r\n\r\n    /**\r\n     * Sets the marker position.\r\n     *\r\n     * @abstract\r\n     * @param latLng - Geo coordinates to set the marker position to.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetPosition(latLng: ILatLong): void;\r\n\r\n    /**\r\n     * Sets the marker title.\r\n     *\r\n     * @abstract\r\n     * @param title - String containing the title to set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetTitle(title: string): void;\r\n\r\n    /**\r\n     * Sets the marker options.\r\n     *\r\n     * @abstract\r\n     * @param options - {@link IMarkerOptions} object containing the marker options to set. The supplied options are\r\n     * merged with the underlying marker options.\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetOptions(options: IMarkerOptions): void;\r\n\r\n    /**\r\n     * Sets the visiblilty of the marker.\r\n     *\r\n     * @abstract\r\n     * @param visible - Boolean which determines if the marker is visible or not.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public abstract SetVisible(visible: boolean): void;\r\n\r\n}\r\n","import { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { Marker } from './marker';\r\nimport { Polygon } from './polygon';\r\nimport { Polyline } from './polyline';\r\nimport { InfoWindow } from './info-window';\r\n\r\n/**\r\n * Defines the contract for a map layer implementation. Deriving providers should implements this abstract\r\n * to provide concrete layer functionality for the map.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class Layer {\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer.\r\n     *\r\n     * @returns - An object representing the native implementation of the layer in the underlying provider (such as\r\n     * Microsoft.Maps.Layer).\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Adds an entity to the layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..) Implementations of this method should not expect native implementation of\r\n     * these concepts, instead, the appropriate abstract model classes should be implemented for each provider\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract AddEntity(entity: Marker|InfoWindow|Polygon|Polyline): void;\r\n\r\n    /**\r\n     * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..) Implementations of this method should not expect native implementation of\r\n     * thise concepts, instead, the appropriate abstract model classes should be implemented for each provider\r\n     *\r\n     * @param entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract AddEntities(entity: Array<Marker|InfoWindow|Polygon|Polyline>): void;\r\n\r\n    /**\r\n     * Deletes the layer.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract Delete(): void;\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns - The layer options.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract GetOptions(): ILayerOptions;\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns - True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract GetVisible(): boolean;\r\n\r\n     /**\r\n     * Removes an entity from the cluster layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..) Implementations of this method should not expect native implementation of\r\n     * thise concepts, instead, the appropriate abstract model classes should be implemented for each provider\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline Entity to be removed from the layer.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract RemoveEntity(entity: Marker|InfoWindow|Polygon|Polyline): void;\r\n\r\n     /**\r\n     * Sets the entities for the cluster layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..) Implementations of this method should not expect native implementation of\r\n     * thise concepts, instead, the appropriate abstract model classes should be implemented for each provider\r\n     *\r\n     * @param entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing the entities to add to the cluster.\r\n     * This replaces any existing entities.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract SetEntities(entities: Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline>): void;\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof Layer\r\n     * @abstract\r\n     */\r\n    public abstract SetOptions(options: ILayerOptions): void;\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     * @abstract\r\n     */\r\n    public abstract SetVisible(visible: boolean): void;\r\n\r\n}\r\n","import { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\n\r\n/**\r\n * Abstract class defining the contract for a polygon in the architecture specific implementation.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class Polygon {\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _centroid: ILatLong;\r\n    protected _center: ILatLong;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Gets the polygon's center.\r\n     * @readonly\r\n     * @memberof Polygon\r\n     */\r\n    public get Center(): ILatLong {\r\n        if (this._center == null) {\r\n            this._center = this.GetBoundingCenter();\r\n        }\r\n        return this._center;\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon's centroid.\r\n     * @readonly\r\n     * @memberof Polygon\r\n     */\r\n    public get Centroid(): ILatLong {\r\n        if (this._centroid == null) {\r\n            this._centroid = this.GetPolygonCentroid();\r\n        }\r\n        return this._centroid;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get LabelMaxZoom(): number;\r\n    public abstract set LabelMaxZoom(val: number);\r\n\r\n    /**\r\n     * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get LabelMinZoom(): number;\r\n    public abstract set LabelMinZoom(val: number);\r\n\r\n    /**\r\n     * Gets the polygon metadata.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Polygon\r\n     */\r\n    public abstract get Metadata(): Map<string, any>;\r\n\r\n    /**\r\n     * Gets the native primitve implementing the polygon.\r\n     *\r\n     * @readonly\r\n     * @memberof Polygon\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    /**\r\n     * Gets or sets whether to show the label\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get ShowLabel(): boolean;\r\n    public abstract set ShowLabel(val: boolean);\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get ShowTooltip(): boolean;\r\n    public abstract set ShowTooltip(val: boolean);\r\n\r\n    /**\r\n     * Gets or sets the title off the polygon\r\n     *\r\n     * @abstract\r\n     * @memberof Polygon\r\n     * @property\r\n     */\r\n    public abstract get Title(): string;\r\n    public abstract set Title(val: string);\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n     * @memberof Polygon\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Deleted the polygon.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract Delete(): void;\r\n\r\n    /**\r\n     * Gets whether the polygon is draggable.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the polygon is dragable, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetDraggable(): boolean;\r\n\r\n    /**\r\n     * Gets whether the polygon path can be edited.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetEditable(): boolean;\r\n\r\n    /**\r\n     * Gets the polygon path.\r\n     *\r\n     * @abstract\r\n     * @returns - Array of ILatLong objects describing the polygon path.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetPath(): Array<ILatLong>;\r\n\r\n    /**\r\n     * Gets the polygon paths.\r\n     *\r\n     * @abstract\r\n     * @returns - Array of Array of ILatLong objects describing multiple polygon paths.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetPaths(): Array<Array<ILatLong>>;\r\n\r\n    /**\r\n     * Gets whether the polygon is visible.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the polygon is visible, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract GetVisible(): boolean;\r\n\r\n    /**\r\n     * Sets whether the polygon is dragable.\r\n     *\r\n     * @abstract\r\n     * @param draggable - True to make the polygon dragable, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetDraggable(draggable: boolean): void;\r\n\r\n    /**\r\n     * Sets wether the polygon path is editable.\r\n     *\r\n     * @abstract\r\n     * @param editable - True to make polygon path editable, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetEditable(editable: boolean): void;\r\n\r\n    /**\r\n     * Sets the polygon options\r\n     *\r\n     * @abstract\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetOptions(options: IPolygonOptions): void;\r\n\r\n    /**\r\n     * Sets the polygon path.\r\n     *\r\n     * @abstract\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polygons path.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetPath(path: Array<ILatLong> | Array<ILatLong>): void;\r\n\r\n    /**\r\n     * Set the polygon path or paths.\r\n     *\r\n     * @abstract\r\n     * @param paths An Array of {@link ILatLong}\r\n     * (or array of arrays) describing the polygons path(s).\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetPaths(paths: Array<Array<ILatLong>> | Array<ILatLong>): void;\r\n\r\n    /**\r\n     * Sets whether the polygon is visible.\r\n     *\r\n     * @abstract\r\n     * @param visible - True to set the polygon visible, false otherwise.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public abstract SetVisible(visible: boolean): void;\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the center of the polygons' bounding box.\r\n     *\r\n     * @returns - ILatLong object containing the center of the bounding box.\r\n     * @memberof Polygon\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected GetBoundingCenter(): ILatLong {\r\n        let c: ILatLong = {latitude: 0, longitude: 0};\r\n        let x1: number = 90, x2: number = -90, y1: number = 180, y2: number = -180;\r\n        const path: Array<Array<ILatLong>> = this.GetPaths();\r\n        if (path) {\r\n            path.forEach(inner => inner.forEach(p => {\r\n                if (p.latitude < x1) { x1 = p.latitude; }\r\n                if (p.latitude > x2) { x2 = p.latitude; }\r\n                if (p.longitude < y1) { y1 = p.longitude; }\r\n                if (p.longitude > y2) { y2 = p.longitude; }\r\n            }));\r\n            c.latitude = x1 + (x2 - x1) / 2;\r\n            c.longitude = y1 + (y2 - y1) / 2;\r\n        }\r\n        else {\r\n            c = null;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Get the centroid of the polygon based on the polygon path.\r\n     *\r\n     * @returns - The centroid coordinates of the polygon.\r\n     * @memberof Polygon\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected GetPolygonCentroid(): ILatLong {\r\n        let c: ILatLong = {latitude: 0, longitude: 0};\r\n        const path: Array<Array<ILatLong>> = this.GetPaths();\r\n        const off = path[0][0];\r\n        if (off != null) {\r\n            let twicearea: number = 0;\r\n            let x: number = 0;\r\n            let y: number = 0;\r\n            let p1: ILatLong, p2: ILatLong;\r\n            let f: number;\r\n            for (let k = 0; k < path.length; k++) {\r\n                for (let i = 0, j = path[k].length - 1; i < path[k].length; j = i++) {\r\n                    p1 = path[k][i];\r\n                    p2 = path[k][j];\r\n                    f = (p1.latitude - off.latitude) * (p2.longitude - off.longitude) -\r\n                        (p2.latitude - off.latitude) * (p1.longitude - off.longitude);\r\n                    twicearea += f;\r\n                    x += (p1.latitude + p2.latitude - 2 * off.latitude) * f;\r\n                    y += (p1.longitude + p2.longitude - 2 * off.longitude) * f;\r\n                }\r\n            }\r\n            if (twicearea !== 0) {\r\n                f = twicearea * 3;\r\n                c.latitude = x / f + off.latitude;\r\n                c.longitude = y / f + off.longitude;\r\n            }\r\n            else {\r\n                c.latitude = off.latitude;\r\n                c.longitude = off.longitude;\r\n            }\r\n        }\r\n        else {\r\n            c = null;\r\n        }\r\n        return c;\r\n    }\r\n}\r\n","import { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\n\r\n/**\r\n * Abstract class defining the contract for a polyline in the architecture specific implementation.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class Polyline {\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _centroid: ILatLong;\r\n    protected _center: ILatLong;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Gets the polyline's center.\r\n     * @readonly\r\n     * @memberof Polyline\r\n     */\r\n    public get Center(): ILatLong {\r\n        if (this._center == null) {\r\n            this._center = this.GetBoundingCenter();\r\n        }\r\n        return this._center;\r\n    }\r\n\r\n    /**\r\n     * Gets the polyline's centroid.\r\n     * @readonly\r\n     * @memberof Polyline\r\n     */\r\n    public get Centroid(): ILatLong {\r\n        if (this._centroid == null) {\r\n            this._centroid = this.GetPolylineCentroid();\r\n        }\r\n        return this._centroid;\r\n    }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the polyline.\r\n     *\r\n     * @readonly\r\n     * @memberof Polyline\r\n     */\r\n    public abstract get NativePrimitve(): any;\r\n\r\n    /**\r\n     * Gets the polyline metadata.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof Polylin\r\n     */\r\n    public abstract get Metadata(): Map<string, any>;\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof Polyline\r\n     * @property\r\n     */\r\n    public abstract get ShowTooltip(): boolean;\r\n    public abstract set ShowTooltip(val: boolean);\r\n\r\n    /**\r\n     * Gets or sets the title off the polyline\r\n     *\r\n     * @abstract\r\n     * @memberof Polyline\r\n     * @property\r\n     */\r\n    public abstract get Title(): string;\r\n    public abstract set Title(val: string);\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Get the centroid of the polyline based on the a path.\r\n     *\r\n     * @param path - the path for which to generate the centroid\r\n     * @returns - The centroid coordinates of the polyline.\r\n     * @memberof Polyline\r\n     * @method\r\n     */\r\n    public static GetPolylineCentroid(path: Array<ILatLong>): ILatLong {\r\n        let c: ILatLong = {latitude: 0, longitude: 0};\r\n        const off = path[0];\r\n        if (off != null) {\r\n            let twicearea: number = 0;\r\n            let x: number = 0;\r\n            let y: number = 0;\r\n            let p1: ILatLong, p2: ILatLong;\r\n            let f: number;\r\n\r\n            for (let i = 0, j = path.length - 1; i < path.length; j = i++) {\r\n                p1 = path[i];\r\n                p2 = path[j];\r\n                f = (p1.latitude - off.latitude) * (p2.longitude - off.longitude) -\r\n                    (p2.latitude - off.latitude) * (p1.longitude - off.longitude);\r\n                twicearea += f;\r\n                x += (p1.latitude + p2.latitude - 2 * off.latitude) * f;\r\n                y += (p1.longitude + p2.longitude - 2 * off.longitude) * f;\r\n            }\r\n            if (twicearea !== 0) {\r\n                f = twicearea * 3;\r\n                c.latitude = x / f + off.latitude;\r\n                c.longitude = y / f + off.longitude;\r\n            }\r\n            else {\r\n                c.latitude = off.latitude;\r\n                c.longitude = off.longitude;\r\n            }\r\n        }\r\n        else {\r\n            c = null;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract AddListener(eventType: string, fn: Function): void;\r\n\r\n    /**\r\n     * Deleted the polyline.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract Delete(): void;\r\n\r\n    /**\r\n     * Gets whether the polyline is draggable.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the polyline is dragable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract GetDraggable(): boolean;\r\n\r\n    /**\r\n     * Gets whether the polyline path can be edited.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract GetEditable(): boolean;\r\n\r\n    /**\r\n     * Gets the polyline path.\r\n     *\r\n     * @abstract\r\n     * @returns - Array of ILatLong objects describing the polyline path.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract GetPath(): Array<ILatLong>;\r\n\r\n    /**\r\n     * Gets whether the polyline is visible.\r\n     *\r\n     * @abstract\r\n     * @returns - True if the polyline is visible, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract GetVisible(): boolean;\r\n\r\n    /**\r\n     * Sets whether the polyline is dragable.\r\n     *\r\n     * @abstract\r\n     * @param draggable - True to make the polyline dragable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetDraggable(draggable: boolean): void;\r\n\r\n    /**\r\n     * Sets wether the polyline path is editable.\r\n     *\r\n     * @abstract\r\n     * @param editable - True to make polyline path editable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetEditable(editable: boolean): void;\r\n\r\n    /**\r\n     * Sets the polyline options\r\n     *\r\n     * @abstract\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetOptions(options: IPolylineOptions): void;\r\n\r\n    /**\r\n     * Sets the polyline path.\r\n     *\r\n     * @abstract\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polylines path.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetPath(path: Array<ILatLong> | Array<ILatLong>): void;\r\n\r\n    /**\r\n     * Sets whether the polyline is visible.\r\n     *\r\n     * @abstract\r\n     * @param visible - True to set the polyline visible, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public abstract SetVisible(visible: boolean): void;\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the center of the polyline' bounding box.\r\n     *\r\n     * @returns - {@link ILatLong} object containing the center of the bounding box.\r\n     * @memberof Polyline\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected GetBoundingCenter(): ILatLong {\r\n        let c: ILatLong = {latitude: 0, longitude: 0};\r\n        let x1: number = 90, x2: number = -90, y1: number = 180, y2: number = -180;\r\n        const path: Array<ILatLong> = this.GetPath();\r\n        if (path) {\r\n            path.forEach(p => {\r\n                if (p.latitude < x1) { x1 = p.latitude; }\r\n                if (p.latitude > x2) { x2 = p.latitude; }\r\n                if (p.longitude < y1) { y1 = p.longitude; }\r\n                if (p.longitude > y2) { y2 = p.longitude; }\r\n            });\r\n            c.latitude = x1 + (x2 - x1) / 2;\r\n            c.longitude = y1 + (y2 - y1) / 2;\r\n        }\r\n        else {\r\n            c = null;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Get the centroid of the polyline based on the polyline path.\r\n     *\r\n     * @returns - The centroid coordinates of the polyline.\r\n     * @memberof Polyline\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected GetPolylineCentroid(): ILatLong {\r\n        const path: Array<ILatLong> = this.GetPath();\r\n        const c: ILatLong  = Polyline.GetPolylineCentroid(path);\r\n        return c;\r\n    }\r\n\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Marker } from './marker';\r\n\r\nexport abstract class SpiderClusterMarker extends Marker {\r\n\r\n    /** The parent pushpin in which the spider pushpin is derived from. */\r\n    public ParentMarker: Marker;\r\n\r\n    /** The stick that connects the spider pushpin to the cluster. */\r\n    public Stick: any;\r\n\r\n}\r\n","import { ILatLong } from '../interfaces/ilatlong';\r\nimport { MapLabel } from './map-label';\r\n\r\nlet id: number = 0;\r\n\r\n/**\r\n * Abstract base implementing a canvas overlay to be placed on the map.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class CanvasOverlay {\r\n\r\n    ///\r\n    /// field declarations\r\n    ///\r\n    protected _readyResolver: (val: boolean) => void;\r\n    protected _canvas: HTMLCanvasElement;\r\n    protected _zoomStart: number;\r\n    protected _centerStart: ILatLong;\r\n    public _canvasReady: Promise<boolean> = new Promise<boolean>((resolve, reject) => { this._readyResolver = resolve; });\r\n\r\n    /**\r\n     * Returns a promise that gets resolved when the canvas overlay is ready for interaction.\r\n     */\r\n    public get CanvasReady(): Promise<boolean> { return this._canvasReady; }\r\n\r\n    /**\r\n    * A callback function that is triggered when the canvas is ready to be rendered for the current map view.\r\n    */\r\n    private _drawCallback: (canvas: HTMLCanvasElement) => void;\r\n\r\n\r\n    /**\r\n     * Creates a new instance of the CanvasOverlay class.\r\n     */\r\n    constructor(drawCallback: (canvas: HTMLCanvasElement) => void) {\r\n        this._drawCallback = drawCallback;\r\n        id++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Deletes the canvas overlay.\r\n     */\r\n    public Delete(): void {\r\n        this.SetMap(null);\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the click location\r\n     */\r\n    public abstract GetCoordinatesFromClick(e: any): ILatLong;\r\n\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     */\r\n    public abstract GetMap(): any;\r\n\r\n    /**\r\n     * Returns a MapLabel instance for the current platform that can be used as a tooltip.\r\n     * This method only generates the map label. Content and placement is the responsibility\r\n     * of the caller.\r\n     */\r\n    public abstract GetToolTipOverlay(): MapLabel;\r\n\r\n    /**\r\n     * CanvasOverlay added to map, load canvas.\r\n     */\r\n    public OnAdd(): void {\r\n        this._canvas = document.createElement('canvas');\r\n        this._canvas.style.position = 'absolute';\r\n        this._canvas.style.left = '0px';\r\n        this._canvas.style.top = '0px';\r\n        this._canvas.id = `xMapOverlay${id}`;\r\n\r\n        // Add the canvas to the overlay.\r\n        this.SetCanvasElement(this._canvas);\r\n    }\r\n\r\n    /**\r\n     * CanvasOverlay loaded, attach map events for updating canvas.\r\n     * @abstract\r\n     * @method\r\n     * @memberof CanvasOverlay\r\n     */\r\n    public abstract OnLoad(): void;\r\n\r\n    /**\r\n     * When the CanvasLayer is removed from the map, release resources.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    public OnRemove(): void {\r\n        this.SetCanvasElement(null);\r\n        this.RemoveEventHandlers();\r\n        this._canvas = null;\r\n    }\r\n\r\n    /**\r\n     * Redraws the canvas for the current map view.\r\n     * @param clear - True to clear the canvas before drawing.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    public Redraw(clear: boolean): void {\r\n        if (this._canvas == null) { return; }\r\n\r\n        // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.\r\n        if (clear) { this.Resize(); }\r\n\r\n        // Call the drawing callback function if specified.\r\n        if (this._drawCallback) {\r\n            this._drawCallback(this._canvas);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - A native map object for the underlying implementation. Implementing derivatives should return the\r\n     * actual native object.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    public abstract SetMap(map: any): void;\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Attaches the canvas to the map.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    protected abstract SetCanvasElement(el: HTMLCanvasElement): void;\r\n\r\n    /**\r\n     * Remove the map event handlers.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @abstract\r\n     * @protected\r\n     */\r\n    protected abstract RemoveEventHandlers(): void;\r\n\r\n    /**\r\n     * Updates the Canvas size based on the map size.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @abstract\r\n     * @protected\r\n     */\r\n    protected abstract Resize(): void;\r\n\r\n    /**\r\n     * Updates the Canvas.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected abstract UpdateCanvas(): void;\r\n\r\n    /**\r\n     * Simple function for updating the CSS position and dimensions of the canvas.\r\n     * @param x The horizontal offset position of the canvas.\r\n     * @param y The vertical offset position of the canvas.\r\n     * @param w The width of the canvas.\r\n     * @param h The height of the canvas.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected UpdatePosition(x: number, y: number, w: number, h: number) {\r\n        // Update CSS position.\r\n        this._canvas.style.left = x + 'px';\r\n        this._canvas.style.top = y + 'px';\r\n\r\n        // Update CSS dimensions.\r\n        this._canvas.style.width = w + 'px';\r\n        this._canvas.style.height = h + 'px';\r\n    }\r\n\r\n}\r\n","import { eachSeries, nextTick } from 'async';\r\nimport { ILayerOptions } from '../../interfaces/ilayer-options';\r\nimport { Layer } from '../layer';\r\nimport { Marker } from '../marker';\r\nimport { Polygon } from '../polygon';\r\nimport { Polyline } from '../polyline';\r\nimport { InfoWindow } from '../info-window';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { MapService} from '../../services/map.service';\r\n\r\n/**\r\n * Concrete implementation of a map layer for the Bing Map Provider.\r\n *\r\n * @export\r\n */\r\nexport class BingLayer implements Layer {\r\n\r\n    private _pendingEntities: Array<Marker|InfoWindow|Polygon|Polyline> = new Array<Marker|InfoWindow|Polygon|Polyline>();\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer.\r\n     *\r\n     * @returns Microsoft.Maps.Layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public get NativePrimitve(): any {\r\n        return this._layer;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new instance of the BingClusterLayer class.\r\n     *\r\n     * @param _layer Microsoft.Maps.ClusterLayer. Native Bing Cluster Layer supporting the cluster layer.\r\n     * @param _maps MapService. MapService implementation to leverage for the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    constructor(private _layer: Microsoft.Maps.Layer, private _maps: MapService) { }\r\n\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        Microsoft.Maps.Events.addHandler(this._layer, eventType, (e) => {\r\n            fn(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds an entity to the layer.\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public AddEntity(entity: Marker|InfoWindow|Polygon|Polyline): void {\r\n        if (entity && entity.NativePrimitve) {\r\n            if (this.GetVisible()) {\r\n                this._layer.add(entity.NativePrimitve);\r\n            }\r\n            else {\r\n                this._pendingEntities.push(entity);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..)\r\n     *\r\n     * @param entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public AddEntities(entities: Array<Marker|InfoWindow|Polygon|Polyline>): void {\r\n        //\r\n        // use eachSeries as opposed to _layer.add([]) to provide a non-blocking experience for larger data sets.\r\n        //\r\n        if (entities != null && Array.isArray(entities) && entities.length !== 0 ) {\r\n            eachSeries([...entities], (e, next) => {\r\n                if (this.GetVisible()) {\r\n                    this._layer.add(e.NativePrimitve);\r\n                }\r\n                else {\r\n                    this._pendingEntities.push(e);\r\n                }\r\n                nextTick(() => next());\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public Delete(): void {\r\n        this._maps.DeleteLayer(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns IClusterOptions. The layer options.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public GetOptions(): ILayerOptions {\r\n        const o: ILayerOptions = {\r\n            id: Number(this._layer.getId())\r\n        };\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns Boolean. True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public GetVisible(): boolean  {\r\n        return this._layer.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Removes an entity from the cluster layer.\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline to be removed from the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public RemoveEntity(entity: Marker|InfoWindow|Polygon|Polyline): void {\r\n        if (entity.NativePrimitve) {\r\n            this._layer.remove(entity.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the entities for the cluster layer.\r\n     *\r\n     * @param entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing the entities to add to the cluster.\r\n     * This replaces any existing entities.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public SetEntities(entities: Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline>): void {\r\n        //\r\n        // we are using removal and add as opposed to set as for large number of objects it yields a non-blocking, smoother performance...\r\n        //\r\n        this._layer.setPrimitives([]);\r\n        this.AddEntities(entities);\r\n\r\n    }\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public SetOptions(options: ILayerOptions) {\r\n        this._layer.metadata.id = options.id.toString();\r\n    }\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof BingLayer\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._layer.setVisible(visible);\r\n        if (visible && this._pendingEntities.length > 0) {\r\n            this.AddEntities(this._pendingEntities.splice(0));\r\n        }\r\n    }\r\n\r\n}\r\n","import { IMapOptions } from '../../interfaces/imap-options';\r\nimport { IBox } from '../../interfaces/ibox';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { IInfoWindowAction } from '../../interfaces/iinfo-window-action';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { MapTypeId } from '../../models/map-type-id';\r\nimport { Marker } from '../../models/marker';\r\nimport { ClusterPlacementMode } from '../../models/cluster-placement-mode';\r\nimport { BingMapService } from './bing-map.service';\r\n\r\n/**\r\n * This class contains helperfunctions to map various interfaces used to represent options and structures into the\r\n * corresponding Bing Maps V8 specific implementations.\r\n *\r\n * @export\r\n */\r\nexport class BingConversions {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n\r\n    /**\r\n     * Map option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _mapOptionsAttributes: string[] = [\r\n        'backgroundColor',\r\n        'credentials',\r\n        'customizeOverlays',\r\n        'disableBirdseye',\r\n        'disableKeyboardInput',\r\n        'disableMouseInput',\r\n        'disablePanning',\r\n        'disableTouchInput',\r\n        'disableUserInput',\r\n        'disableZooming',\r\n        'disableStreetside',\r\n        'enableClickableLogo',\r\n        'enableSearchLogo',\r\n        'fixedMapPosition',\r\n        'height',\r\n        'inertiaIntensity',\r\n        'navigationBarMode',\r\n        'showBreadcrumb',\r\n        'showCopyright',\r\n        'showDashboard',\r\n        'showMapTypeSelector',\r\n        'showScalebar',\r\n        'theme',\r\n        'tileBuffer',\r\n        'useInertia',\r\n        'width',\r\n        'center',\r\n        'zoom',\r\n        'mapTypeId'\r\n    ];\r\n\r\n    /**\r\n     * View option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _viewOptionsAttributes: string[] = [\r\n        'animate',\r\n        'bounds',\r\n        'center',\r\n        'centerOffset',\r\n        'heading',\r\n        'labelOverlay',\r\n        'mapTypeId',\r\n        'padding',\r\n        'zoom'\r\n    ];\r\n\r\n    /**\r\n     * InfoWindow option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _infoWindowOptionsAttributes: string[] = [\r\n        'actions',\r\n        'description',\r\n        'htmlContent',\r\n        'id',\r\n        'position',\r\n        'pixelOffset',\r\n        'showCloseButton',\r\n        'showPointer',\r\n        'pushpin',\r\n        'title',\r\n        'titleClickHandler',\r\n        'typeName',\r\n        'visible',\r\n        'width',\r\n        'height'\r\n    ];\r\n\r\n    /**\r\n     * Marker option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _markerOptionsAttributes: string[] = [\r\n        'anchor',\r\n        'draggable',\r\n        'height',\r\n        'htmlContent',\r\n        'icon',\r\n        'infobox',\r\n        'state',\r\n        'title',\r\n        'textOffset',\r\n        'typeName',\r\n        'visible',\r\n        'width',\r\n        'zIndex'\r\n    ];\r\n\r\n    /**\r\n     * Polygon option attributes that are supported for conversion to Bing Map Polygon properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _polygonOptionsAttributes: string[] = [\r\n        'cursor',\r\n        'fillColor',\r\n        'fillOpacity',\r\n        'strokeColor',\r\n        'strokeOpacity',\r\n        'strokeWeight',\r\n        'visible'\r\n    ];\r\n\r\n    /**\r\n     * Polyline option attributes that are supported for conversion to Bing Map Polyline properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _polylineOptionsAttributes: string[] = [\r\n        'cursor',\r\n        'strokeColor',\r\n        'strokeOpacity',\r\n        'strokeWeight',\r\n        'visible'\r\n    ];\r\n\r\n    /**\r\n     * Cluster option attributes that are supported for conversion to Bing Map properties\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    private static _clusterOptionsAttributes: string[] = [\r\n        'callback',\r\n        'clusteredPinCallback',\r\n        'clusteringEnabled',\r\n        'gridSize',\r\n        'layerOffset',\r\n        'placementMode',\r\n        'visible',\r\n        'zIndex'\r\n    ];\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Maps an IInfoWindowAction to a Microsoft.Maps.IInfoboxActions\r\n     *\r\n     * @param action - Object to be mapped.\r\n     * @returns - Navtive mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateAction(action: IInfoWindowAction): Microsoft.Maps.IInfoboxActions {\r\n        const a: Microsoft.Maps.IInfoboxActions = {\r\n            eventHandler: action.eventHandler,\r\n            label: action.label\r\n        };\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * Maps an Array of IInfoWindowAction to an Array of Microsoft.Maps.IInfoboxActions\r\n     *\r\n     * @param actions - Array of objects to be mapped.\r\n     * @returns - Array of mapped objects.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateActions(actions: Array<IInfoWindowAction>): Array<Microsoft.Maps.IInfoboxActions> {\r\n        const a: Array<Microsoft.Maps.IInfoboxActions> = new Array<Microsoft.Maps.IInfoboxActions>();\r\n        actions.forEach(x => a.push(BingConversions.TranslateAction(x)));\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * Maps an IBox object to a Microsoft.Maps.LocationRect object.\r\n     *\r\n     * @param box - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateBounds(box: IBox): Microsoft.Maps.LocationRect {\r\n        const r: Microsoft.Maps.LocationRect =\r\n            Microsoft.Maps.LocationRect.fromEdges(box.maxLatitude, box.minLongitude, box.minLatitude, box.maxLongitude);\r\n        return r;\r\n    }\r\n\r\n    /**\r\n     * Maps an IClusterOptions object to a Microsoft.Maps.IClusterLayerOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateClusterOptions(options: IClusterOptions): Microsoft.Maps.IClusterLayerOptions {\r\n        const o: Microsoft.Maps.IClusterLayerOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._clusterOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'layerOffset') {\r\n                    o.layerOffset = BingConversions.TranslatePoint(options.layerOffset);\r\n                }\r\n                if (k === 'placementMode') {\r\n                    if (options.placementMode === ClusterPlacementMode.FirstPin) {\r\n                        o.placementMode = Microsoft.Maps.ClusterPlacementType.FirstLocation;\r\n                    }\r\n                    else {\r\n                        o.placementMode = Microsoft.Maps.ClusterPlacementType.MeanAverage;\r\n                    }\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IInfoWindowOptions object to a Microsoft.Maps.IInfoboxOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateInfoBoxOptions(options: IInfoWindowOptions): Microsoft.Maps.IInfoboxOptions {\r\n        const o: Microsoft.Maps.IInfoboxOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._infoWindowOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'pixelOffset') {\r\n                    o.offset = BingConversions.TranslatePoint(options.pixelOffset);\r\n                }\r\n                else if (k === 'position') {\r\n                    o.location = BingConversions.TranslateLocation(options.position);\r\n                }\r\n                else if (k === 'actions') {\r\n                    o.actions = BingConversions.TranslateActions(options.actions);\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMapOptions object to a Microsoft.Maps.IMapLoadOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateLoadOptions(options: IMapOptions): Microsoft.Maps.IMapLoadOptions {\r\n        const o: Microsoft.Maps.IMapLoadOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => {\r\n                return BingConversions._mapOptionsAttributes.indexOf(k) !== -1 || BingConversions._viewOptionsAttributes.indexOf(k) !== -1;\r\n            })\r\n            .forEach((k) => {\r\n                if (k === 'center') {\r\n                    o.center = BingConversions.TranslateLocation(options.center);\r\n                }\r\n                else if (k === 'mapTypeId') {\r\n                    if (options.mapTypeId === MapTypeId.hybrid) {\r\n                        o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;\r\n                        o.labelOverlay = Microsoft.Maps.LabelOverlay.visible;\r\n                    }\r\n                    else if (options.mapTypeId === MapTypeId.aerial) {\r\n                        o.mapTypeId = Microsoft.Maps.MapTypeId.aerial;\r\n                        o.labelOverlay = Microsoft.Maps.LabelOverlay.hidden;\r\n                    }\r\n                    else {\r\n                        o.mapTypeId = Microsoft.Maps.MapTypeId[(<any>MapTypeId)[options.mapTypeId]];\r\n                    }\r\n                }\r\n                else if (k === 'bounds') {\r\n                    o.bounds = BingConversions.TranslateBounds(options.bounds);\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an ILatLong object to a Microsoft.Maps.Location object.\r\n     *\r\n     * @param latlong - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateLocation(latlong: ILatLong): Microsoft.Maps.Location {\r\n        const l: Microsoft.Maps.Location = new Microsoft.Maps.Location(latlong.latitude, latlong.longitude);\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMarkerOptions object to a Microsoft.Maps.IPushpinOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - The mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateMarkerOptions(options: IMarkerOptions): Microsoft.Maps.IPushpinOptions {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._markerOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'anchor') {\r\n                    o.anchor = BingConversions.TranslatePoint(options.anchor);\r\n                }\r\n                else {\r\n                    (<any>o)[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMapOptions object to a Microsoft.Maps.IMapOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateOptions(options: IMapOptions): Microsoft.Maps.IMapOptions {\r\n        const o: Microsoft.Maps.IMapOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._mapOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'center') {\r\n                    o.center = BingConversions.TranslateLocation(options.center);\r\n                }\r\n                else if (k === 'mapTypeId') {\r\n                    o.mapTypeId = Microsoft.Maps.MapTypeId[(<any>MapTypeId)[options.mapTypeId]];\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations\r\n     *\r\n     * @param paths - ILatLong based locations to convert.\r\n     * @returns - converted locations.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslatePaths(paths: Array<ILatLong> | Array<Array<ILatLong>>): Array<Array<Microsoft.Maps.Location>> {\r\n        const p: Array<Array<Microsoft.Maps.Location>> = new Array<Array<Microsoft.Maps.Location>>();\r\n        if (paths == null || !Array.isArray(paths) || paths.length === 0) {\r\n            p.push(new Array<Microsoft.Maps.Location>());\r\n        }\r\n        else if (Array.isArray(paths[0])) {\r\n            // parameter is an array or arrays\r\n            // us for loop for performance\r\n            const p1 = <Array<Array<ILatLong>>>paths;\r\n            for (let i = 0; i < p1.length; i++) {\r\n                const _p: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n                for (let j = 0; j < p1[i].length; j++) {\r\n                    _p.push(new Microsoft.Maps.Location(p1[i][j].latitude, p1[i][j].longitude));\r\n                }\r\n                p.push(_p);\r\n            }\r\n        }\r\n        else {\r\n            // parameter is a simple array....\r\n            const y: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n            const p1 = <Array<ILatLong>>paths;\r\n            for (let i = 0; i < p1.length; i++) {\r\n                y.push(new Microsoft.Maps.Location(p1[i].latitude, p1[i].longitude));\r\n            }\r\n            p.push(y);\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPoint object to a Microsoft.Maps.Point object.\r\n     *\r\n     * @param point - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslatePoint(point: IPoint): Microsoft.Maps.Point {\r\n        const p: Microsoft.Maps.Point = new Microsoft.Maps.Point(point.x, point.y);\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPolygonOptions object to a Microsoft.Maps.IPolygonOptions.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslatePolygonOptions(options: IPolygonOptions): Microsoft.Maps.IPolygonOptions {\r\n        const o: Microsoft.Maps.IPolygonOptions = {};\r\n        const f: (s: string, a: number) => string = (s, a) => {\r\n            const m = /rgba?\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*\\d+[\\.\\d+]*)*\\)/g.exec(s);\r\n            if (m && m.length > 3) {\r\n                a = a > 1 ? (a / 100) : a;\r\n                return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';\r\n            }\r\n            else if (s[0] === '#') {\r\n                const x: number = a > 1 ? a : Math.floor(a * 255);\r\n                const z: string = s.substr(1);\r\n                const r: number = parseInt(z.substr(0, 2), 16);\r\n                const g: number = parseInt(z.substr(2, 2), 16);\r\n                const b: number = parseInt(z.substr(4, 2), 16);\r\n                return 'rgba(' + [r , g, b, a].join(',') + ')';\r\n            }\r\n            else {\r\n                return s;\r\n            }\r\n        };\r\n\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._polygonOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'strokeWeight') {\r\n                    o.strokeThickness = options.strokeWeight;\r\n                }\r\n                else if (k === 'strokeColor') {\r\n                    if (options.strokeOpacity) {\r\n                        o.strokeColor = f(options.strokeColor, options.strokeOpacity);\r\n                    }\r\n                    else {\r\n                        o.strokeColor = options.strokeColor;\r\n                    }\r\n                }\r\n                else if (k === 'strokeOpacity') {}\r\n                else if (k === 'fillColor') {\r\n                    if (options.fillOpacity) {\r\n                        o.fillColor = f(options.fillColor, options.fillOpacity);\r\n                    }\r\n                    else {\r\n                        o.fillColor = options.fillColor;\r\n                    }\r\n                }\r\n                else if (k === 'fillOpacity') {}\r\n                else {\r\n                    (<any>o)[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPolylineOptions object to a Microsoft.Maps.IPolylineOptions.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslatePolylineOptions(options: IPolylineOptions): Microsoft.Maps.IPolylineOptions {\r\n        const o: Microsoft.Maps.IPolylineOptions | any = {};\r\n        const f: (s: string, a: number) => string = (s, a) => {\r\n            const m = /rgba?\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*\\d+[\\.\\d+]*)*\\)/g.exec(s);\r\n            if (m && m.length > 3) {\r\n                a = a > 1 ? (a / 100) : a;\r\n                return 'rgba(' + [m[1], m[2], m[3], a].join(',') + ')';\r\n            }\r\n            else if (s[0] === '#') {\r\n                const x: number = a > 1 ? a : Math.floor(a * 255);\r\n                const z: string = s.substr(1);\r\n                const r: number = parseInt(z.substr(0, 2), 16);\r\n                const g: number = parseInt(z.substr(2, 2), 16);\r\n                const b: number = parseInt(z.substr(4, 2), 16);\r\n                return 'rgba(' + [r , g, b, a].join(',') + ')';\r\n            }\r\n            else {\r\n                return s;\r\n            }\r\n        };\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._polylineOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'strokeWeight') {\r\n                    o.strokeThickness = options.strokeWeight;\r\n                } else if (k === 'strokeColor') {\r\n                    if (options.strokeOpacity) {\r\n                        o.strokeColor = f(options.strokeColor, options.strokeOpacity);\r\n                    }\r\n                    else {\r\n                        o.strokeColor = options.strokeColor;\r\n                    }\r\n                }\r\n                else if (k === 'strokeOpacity') {\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMapOptions object to a Microsoft.Maps.IViewOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof BingConversions\r\n     */\r\n    public static TranslateViewOptions(options: IMapOptions): Microsoft.Maps.IViewOptions {\r\n        const o: Microsoft.Maps.IViewOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => BingConversions._viewOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'center') {\r\n                    o.center = BingConversions.TranslateLocation(options.center);\r\n                } else if (k === 'bounds') {\r\n                    o.bounds = BingConversions.TranslateBounds(options.bounds);\r\n                } else if (k === 'centerOffset') {\r\n                    o.centerOffset = BingConversions.TranslatePoint(options.centerOffset);\r\n                } else if (k === 'mapTypeId') {\r\n                    o.mapTypeId = Microsoft.Maps.MapTypeId[(<any>MapTypeId)[options.mapTypeId]];\r\n                } else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { Marker } from '../marker';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\n\r\n/**\r\n * Concrete implementation of the {@link Marker} contract for the Bing Maps V8 map architecture.\r\n *\r\n * @export\r\n */\r\nexport class BingMarker implements Marker {\r\n\r\n    ///\r\n    /// Field definitions\r\n    ///\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n    private _isFirst = false;\r\n    private _isLast = true;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Indicates that the marker is the first marker in a set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public get IsFirst(): boolean { return this._isFirst; }\r\n    public set IsFirst(val: boolean) { this._isFirst = val; }\r\n\r\n    /**\r\n     * Indicates that the marker is the last marker in the set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public get IsLast(): boolean { return this._isLast; }\r\n    public set IsLast(val: boolean) { this._isLast = val; }\r\n\r\n    /**\r\n     * Gets the Location of the marker\r\n     *\r\n     * @readonly\r\n     * @memberof BingMarker\r\n     */\r\n    public get Location(): ILatLong {\r\n        const l: Microsoft.Maps.Location = this._pushpin.getLocation();\r\n        return {\r\n            latitude: l.latitude,\r\n            longitude: l.longitude\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the marker metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof BingMarker\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the marker, in this case {@link Microsoft.Maps.Pushpin}\r\n     *\r\n     * @readonly\r\n     * @memberof BingMarker\r\n     */\r\n    public get NativePrimitve(): any { return this._pushpin; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingMarker.\r\n     * @param _pushpin - The {@link Microsoft.Maps.Pushpin} underlying the model.\r\n     * @param _map - The context map.\r\n     * @param _layer - The context layer.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    constructor(private _pushpin: Microsoft.Maps.Pushpin, protected _map: Microsoft.Maps.Map, protected _layer: Microsoft.Maps.Layer) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener to the marker.\r\n     *\r\n     * @abstract\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        Microsoft.Maps.Events.addHandler(this._pushpin, eventType, (e) => {\r\n            fn(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes the marker.\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public DeleteMarker(): void {\r\n        if (!this._map && !this._layer) { return; }\r\n        if (this._layer) { this._layer.remove(this.NativePrimitve); }\r\n        else {\r\n            this._map.entities.remove(this.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the marker label\r\n     *\r\n     * @abstract\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public GetLabel(): string {\r\n        return this._pushpin.getText();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the marker is visible.\r\n     *\r\n     * @returns - True if the marker is visible, false otherwise.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._pushpin.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.\r\n     *\r\n     * @abstract\r\n     * @param anchor - Point coordinates for the marker anchor.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetAnchor(anchor: IPoint): void {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        o.anchor = new Microsoft.Maps.Point(anchor.x, anchor.y);\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the draggability of a marker.\r\n     *\r\n     * @abstract\r\n     * @param draggable - True to mark the marker as draggable, false otherwise.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        o.draggable = draggable;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the icon for the marker.\r\n     *\r\n     * @abstract\r\n     * @param icon - String containing the icon in various forms (url, data url, etc.)\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetIcon(icon: string): void {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        o.icon = icon;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker label.\r\n     *\r\n     * @abstract\r\n     * @param label - String containing the label to set.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetLabel(label: string): void {\r\n        const o: Microsoft.Maps.IPushpinOptions = {};\r\n        o.text = label;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker position.\r\n     *\r\n     * @abstract\r\n     * @param latLng - Geo coordinates to set the marker position to.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetPosition(latLng: ILatLong): void {\r\n        const p: Microsoft.Maps.Location = BingConversions.TranslateLocation(latLng);\r\n        this._pushpin.setLocation(p);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker title.\r\n     *\r\n     * @abstract\r\n     * @param title - String containing the title to set.\r\n     *\r\n     * @memberof BingMarker\r\n     */\r\n    public SetTitle(title: string): void {\r\n        const o: Microsoft.Maps.IPushpinOptions | any = {};\r\n        o.title = title;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker options.\r\n     *\r\n     * @abstract\r\n     * @param options - {@link IMarkerOptions} object containing the marker options to set. The supplied options are\r\n     * merged with the underlying marker options.\r\n     * @memberof Marker\r\n     */\r\n    public SetOptions(options: IMarkerOptions): void {\r\n        const o: Microsoft.Maps.IPushpinOptions =  BingConversions.TranslateMarkerOptions(options);\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets whether the marker is visible.\r\n     *\r\n     * @param visible - True to set the marker visible, false otherwise.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        const o: Microsoft.Maps.IPushpinOptions | any = {};\r\n        o.visible = visible;\r\n        this._pushpin.setOptions(o);\r\n    }\r\n\r\n}\r\n","import { BingMarker } from './bing-marker';\r\nimport { SpiderClusterMarker } from '../spider-cluster-marker';\r\n\r\nexport class BingSpiderClusterMarker extends BingMarker implements SpiderClusterMarker {\r\n\r\n    /** The parent pushpin in which the spider pushpin is derived from. */\r\n    public ParentMarker: BingMarker;\r\n\r\n    /** The stick that connects the spider pushpin to the cluster. */\r\n    public Stick: Microsoft.Maps.Polyline;\r\n\r\n}\r\n","import { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { ISpiderClusterOptions } from '../../interfaces/ispider-cluster-options';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { MapService } from '../../services/map.service';\r\nimport { Layer } from '../layer';\r\nimport { Marker } from '../marker';\r\nimport { InfoWindow } from '../info-window';\r\nimport { BingSpiderClusterMarker } from './bing-spider-cluster-marker';\r\nimport { BingMarker } from './bing-marker';\r\n\r\n/**\r\n * Concrete implementation of a clustering layer for the Bing Map Provider.\r\n *\r\n * @export\r\n */\r\nexport class BingClusterLayer implements Layer {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _isClustering = true;\r\n    private _markers: Array<Marker> = new Array<Marker>();\r\n    private _markerLookup: Map<Microsoft.Maps.Pushpin, Marker> = new Map<Microsoft.Maps.Pushpin, Marker>();\r\n    private _pendingMarkers: Array<Marker> = new Array<Marker>();\r\n    private _spiderMarkers: Array<BingSpiderClusterMarker> = new Array<BingSpiderClusterMarker>();\r\n    private _spiderMarkerLookup: Map<Microsoft.Maps.Pushpin, BingSpiderClusterMarker> =\r\n                     new Map<Microsoft.Maps.Pushpin, BingSpiderClusterMarker>();\r\n    private _useSpiderCluster = false;\r\n    private _mapclicks = 0;\r\n    private _spiderLayer: Microsoft.Maps.Layer;\r\n    private _events: Array<Microsoft.Maps.IHandlerId> = new Array<Microsoft.Maps.IHandlerId>();\r\n    private _currentZoom = 0;\r\n    private _spiderOptions: ISpiderClusterOptions = {\r\n        circleSpiralSwitchover: 9,\r\n        collapseClusterOnMapChange: false,\r\n        collapseClusterOnNthClick: 1,\r\n        invokeClickOnHover: true,\r\n        minCircleLength: 60,\r\n        minSpiralAngleSeperation: 25,\r\n        spiralDistanceFactor: 5,\r\n        stickStyle: {\r\n            strokeColor: 'black',\r\n            strokeThickness: 2\r\n        },\r\n        stickHoverStyle: { strokeColor: 'red' },\r\n        markerSelected: null,\r\n        markerUnSelected: null\r\n    };\r\n    private _currentCluster: Microsoft.Maps.ClusterPushpin = null;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer.\r\n     *\r\n     * @returns Microsoft.Maps.ClusterLayer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public get NativePrimitve(): any {\r\n        return this._layer;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new instance of the BingClusterLayer class.\r\n     *\r\n     * @param _layer Microsoft.Maps.ClusterLayer. Native Bing Cluster Layer supporting the cluster layer.\r\n     * @param _maps MapService. MapService implementation to leverage for the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    constructor(private _layer: Microsoft.Maps.ClusterLayer, private _maps: MapService) { }\r\n\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        Microsoft.Maps.Events.addHandler(this._layer, eventType, (e) => {\r\n            fn(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds an entity to the layer. Use this method with caution as it will\r\n     * trigger a recaluation of the clusters (and associated markers if approprite) for\r\n     * each invocation. If you use this method to add many markers to the cluster, use\r\n     *\r\n     * @param entity Marker. Entity to add to the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public AddEntity(entity: Marker): void {\r\n        let isMarker: boolean = entity instanceof Marker;\r\n        isMarker = entity instanceof BingMarker || isMarker;\r\n        if (isMarker) {\r\n            if (entity.IsFirst) {\r\n                this.StopClustering();\r\n            }\r\n        }\r\n        if (entity.NativePrimitve && entity.Location) {\r\n            if (this._isClustering) {\r\n                const p: Array<Microsoft.Maps.Pushpin> = this._layer.getPushpins();\r\n                p.push(entity.NativePrimitve);\r\n                this._layer.setPushpins(p);\r\n                this._markers.push(entity);\r\n            }\r\n            else {\r\n                this._pendingMarkers.push(entity);\r\n            }\r\n            this._markerLookup.set(entity.NativePrimitve, entity);\r\n        }\r\n        if (isMarker) {\r\n            if (entity.IsLast) {\r\n                this.StartClustering();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a number of markers to the layer.\r\n     *\r\n     * @param entities Array<Marker>. Entities to add to the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public AddEntities(entities: Array<Marker>): void {\r\n        if (entities != null && Array.isArray(entities) && entities.length !== 0 ) {\r\n            const e: Array<Microsoft.Maps.Pushpin> = entities.map(p => {\r\n                this._markerLookup.set(p.NativePrimitve, p);\r\n                return p.NativePrimitve;\r\n            });\r\n            if (this._isClustering) {\r\n                const p: Array<Microsoft.Maps.Pushpin> = this._layer.getPushpins();\r\n                p.push(...e);\r\n                this._layer.setPushpins(p);\r\n                this._markers.push(...entities);\r\n            }\r\n            else {\r\n                this._pendingMarkers.push(...entities);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes spider behavior for the clusering layer (when a cluster maker is clicked, it explodes into a spider of the\r\n     * individual underlying pins.\r\n     *\r\n     * @param options ISpiderClusterOptions. Optional. Options governing the behavior of the spider.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public InitializeSpiderClusterSupport(options?: ISpiderClusterOptions): void {\r\n        if (this._useSpiderCluster) { return; }\r\n        const m: Microsoft.Maps.Map = (<BingMapService>this._maps).MapInstance;\r\n        this._useSpiderCluster = true;\r\n        this._spiderLayer = new Microsoft.Maps.Layer();\r\n        this._currentZoom = m.getZoom();\r\n        this.SetSpiderOptions(options);\r\n        m.layers.insert(this._spiderLayer);\r\n\r\n        ///\r\n        /// Add spider related events....\r\n        ///\r\n        this._events.push(Microsoft.Maps.Events.addHandler(m, 'click', e => this.OnMapClick(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(m, 'viewchangestart', e => this.OnMapViewChangeStart(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(m, 'viewchangeend', e => this.OnMapViewChangeEnd(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(this._layer, 'click', e => this.OnLayerClick(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'click', e => this.OnLayerClick(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'mouseover', e => this.OnSpiderMouseOver(e)));\r\n        this._events.push(Microsoft.Maps.Events.addHandler(this._spiderLayer, 'mouseout', e => this.OnSpiderMouseOut(e)));\r\n    }\r\n\r\n    /**\r\n     * Deletes the clustering layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public Delete(): void {\r\n        if (this._useSpiderCluster) {\r\n            this._spiderLayer.clear();\r\n            (<BingMapService>this._maps).MapPromise.then(m => {\r\n                m.layers.remove(this._spiderLayer);\r\n                this._spiderLayer = null;\r\n            });\r\n            this._events.forEach(e => Microsoft.Maps.Events.removeHandler(e));\r\n            this._events.splice(0);\r\n            this._useSpiderCluster = false;\r\n        }\r\n        this._markers.splice(0);\r\n        this._spiderMarkers.splice(0);\r\n        this._pendingMarkers.splice(0);\r\n        this._markerLookup.clear();\r\n        this._maps.DeleteLayer(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the abstract marker used to wrap the Bing Pushpin.\r\n     *\r\n     * @returns Marker. The abstract marker object representing the pushpin.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public GetMarkerFromBingMarker(pin: Microsoft.Maps.Pushpin): Marker {\r\n        const m: Marker = this._markerLookup.get(pin);\r\n        return m;\r\n    }\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns IClusterOptions. The layer options.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public GetOptions(): IClusterOptions {\r\n        const o: Microsoft.Maps.IClusterLayerOptions = this._layer.getOptions();\r\n        const options: IClusterOptions = {\r\n            id: 0,\r\n            gridSize: o.gridSize,\r\n            layerOffset: o.layerOffset,\r\n            clusteringEnabled: o.clusteringEnabled,\r\n            callback: o.callback,\r\n            clusteredPinCallback: o.clusteredPinCallback,\r\n            visible: o.visible,\r\n            zIndex: o.zIndex\r\n        };\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns Boolean. True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._layer.getOptions().visible;\r\n    }\r\n\r\n    /**\r\n     * Returns the abstract marker used to wrap the Bing Pushpin.\r\n     *\r\n     * @returns - The abstract marker object representing the pushpin.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public GetSpiderMarkerFromBingMarker(pin: Microsoft.Maps.Pushpin): BingSpiderClusterMarker {\r\n        const m: BingSpiderClusterMarker = this._spiderMarkerLookup.get(pin);\r\n        return m;\r\n    }\r\n\r\n    /**\r\n     * Removes an entity from the cluster layer.\r\n     *\r\n     * @param entity Marker - Entity to be removed from the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public RemoveEntity(entity: Marker): void {\r\n        if (entity.NativePrimitve && entity.Location) {\r\n            const j: number = this._markers.indexOf(entity);\r\n            const k: number = this._pendingMarkers.indexOf(entity);\r\n            if (j > -1) { this._markers.splice(j, 1); }\r\n            if (k > -1) { this._pendingMarkers.splice(k, 1); }\r\n            if (this._isClustering) {\r\n                const p: Array<Microsoft.Maps.Pushpin> = this._layer.getPushpins();\r\n                const i: number = p.indexOf(entity.NativePrimitve);\r\n                if (i > -1) {\r\n                    p.splice(i, 1);\r\n                    this._layer.setPushpins(p);\r\n                }\r\n            }\r\n            this._markerLookup.delete(entity.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the entities for the cluster layer.\r\n     *\r\n     * @param entities Array<Marker> containing\r\n     * the entities to add to the cluster. This replaces any existing entities.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public SetEntities(entities: Array<Marker>): void {\r\n        const p: Array<Microsoft.Maps.Pushpin> = new Array<Microsoft.Maps.Pushpin>();\r\n        this._markers.splice(0);\r\n        this._markerLookup.clear();\r\n        entities.forEach((e: any) => {\r\n            if (e.NativePrimitve && e.Location) {\r\n                this._markers.push(e);\r\n                this._markerLookup.set(e.NativePrimitve, e);\r\n                p.push(<Microsoft.Maps.Pushpin>e.NativePrimitve);\r\n            }\r\n        });\r\n        this._layer.setPushpins(p);\r\n    }\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public SetOptions(options: IClusterOptions): void {\r\n        const o: Microsoft.Maps.IClusterLayerOptions = BingConversions.TranslateClusterOptions(options);\r\n        this._layer.setOptions(o);\r\n        if (options.spiderClusterOptions) { this.SetSpiderOptions(options.spiderClusterOptions); }\r\n    }\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        const o: Microsoft.Maps.IClusterLayerOptions = this._layer.getOptions();\r\n        o.visible = visible;\r\n        this._layer.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities\r\n     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public StartClustering(): void {\r\n        if (this._isClustering) { return; }\r\n\r\n        const p: Array<Microsoft.Maps.Pushpin> = new Array<Microsoft.Maps.Pushpin>();\r\n        this._markers.forEach(e => {\r\n            if (e.NativePrimitve && e.Location) {\r\n                p.push(<Microsoft.Maps.Pushpin>e.NativePrimitve);\r\n            }\r\n        });\r\n        this._pendingMarkers.forEach(e => {\r\n            if (e.NativePrimitve && e.Location) {\r\n                p.push(<Microsoft.Maps.Pushpin>e.NativePrimitve);\r\n            }\r\n        });\r\n        this._layer.setPushpins(p);\r\n        this._markers = this._markers.concat(this._pendingMarkers.splice(0));\r\n        this._isClustering = true;\r\n    }\r\n\r\n    /**\r\n     * Stop to actually cluster the entities in a cluster layer.\r\n     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    public StopClustering() {\r\n        if (!this._isClustering) { return; }\r\n        this._isClustering = false;\r\n    }\r\n\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Creates a copy of a pushpins basic options.\r\n     *\r\n     * @param pin Pushpin to copy options from.\r\n     * @returns - A copy of a pushpins basic options.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private GetBasicPushpinOptions(pin: Microsoft.Maps.Pushpin): Microsoft.Maps.IPushpinOptions {\r\n        return <Microsoft.Maps.IPushpinOptions>{\r\n            anchor: pin.getAnchor(),\r\n            color: pin.getColor(),\r\n            cursor: pin.getCursor(),\r\n            icon: pin.getIcon(),\r\n            roundClickableArea: pin.getRoundClickableArea(),\r\n            subTitle: pin.getSubTitle(),\r\n            text: pin.getText(),\r\n            textOffset: pin.getTextOffset(),\r\n            title: pin.getTitle()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Hides the spider cluster and resotres the original pin.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private HideSpiderCluster(): void {\r\n        this._mapclicks = 0;\r\n        if (this._currentCluster) {\r\n            this._spiderLayer.clear();\r\n            this._spiderMarkers.splice(0);\r\n            this._spiderMarkerLookup.clear();\r\n            this._currentCluster = null;\r\n            this._mapclicks = -1;\r\n            if (this._spiderOptions.markerUnSelected) { this._spiderOptions.markerUnSelected(); }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Click event handler for when a shape in the cluster layer is clicked.\r\n     *\r\n     * @param e The mouse event argurment from the click event.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private OnLayerClick(e: Microsoft.Maps.IMouseEventArgs): void {\r\n        if (e.primitive instanceof Microsoft.Maps.ClusterPushpin) {\r\n            const cp: Microsoft.Maps.ClusterPushpin = <Microsoft.Maps.ClusterPushpin>e.primitive;\r\n            const showNewCluster: boolean = cp !== this._currentCluster;\r\n            this.HideSpiderCluster();\r\n            if (showNewCluster) {\r\n                this.ShowSpiderCluster(<Microsoft.Maps.ClusterPushpin>e.primitive);\r\n            }\r\n        } else {\r\n            const pin: Microsoft.Maps.Pushpin = <Microsoft.Maps.Pushpin>e.primitive;\r\n            if (pin.metadata && pin.metadata.isClusterMarker) {\r\n                const m: BingSpiderClusterMarker = this.GetSpiderMarkerFromBingMarker(pin);\r\n                const p: BingMarker = m.ParentMarker;\r\n                const ppin: Microsoft.Maps.Pushpin = p.NativePrimitve;\r\n                if (this._spiderOptions.markerSelected) {\r\n                    this._spiderOptions.markerSelected(p, new BingMarker(this._currentCluster, null, null));\r\n                }\r\n                if (Microsoft.Maps.Events.hasHandler(ppin, 'click')) { Microsoft.Maps.Events.invoke(ppin, 'click', e); }\r\n                this._mapclicks = 0;\r\n            } else {\r\n                if (this._spiderOptions.markerSelected) { this._spiderOptions.markerSelected(this.GetMarkerFromBingMarker(pin), null); }\r\n                if (Microsoft.Maps.Events.hasHandler(pin, 'click')) { Microsoft.Maps.Events.invoke(pin, 'click', e); }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delegate handling the click event on the map (outside a spider cluster). Depending on the\r\n     * spider options, closes the cluster or increments the click counter.\r\n     *\r\n     * @param e - Mouse event\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private OnMapClick(e: Microsoft.Maps.IMouseEventArgs | Microsoft.Maps.IMapTypeChangeEventArgs): void {\r\n        if (this._mapclicks === -1) {\r\n            return;\r\n        } else if (++this._mapclicks >= this._spiderOptions.collapseClusterOnNthClick) {\r\n            this.HideSpiderCluster();\r\n        } else {\r\n            // do nothing as this._mapclicks has already been incremented above\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delegate handling the map view changed end event. Hides the spider cluster if the zoom level has changed.\r\n     *\r\n     * @param e - Mouse event.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private OnMapViewChangeEnd(e: Microsoft.Maps.IMouseEventArgs | Microsoft.Maps.IMapTypeChangeEventArgs): void {\r\n        const z: number = (<Microsoft.Maps.Map>e.target).getZoom();\r\n        const hasZoomChanged: boolean = (z !== this._currentZoom);\r\n        this._currentZoom = z;\r\n        if (hasZoomChanged) {\r\n            this.HideSpiderCluster();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delegate handling the map view change start event. Depending on the spider options, hides the\r\n     * the exploded spider or does nothing.\r\n     *\r\n     * @param e - Mouse event.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private OnMapViewChangeStart(e: Microsoft.Maps.IMouseEventArgs | Microsoft.Maps.IMapTypeChangeEventArgs): void {\r\n        if (this._spiderOptions.collapseClusterOnMapChange) {\r\n            this.HideSpiderCluster();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delegate invoked on mouse out on an exploded spider marker. Resets the hover style on the stick.\r\n     *\r\n     * @param e - Mouse event.\r\n     */\r\n    private OnSpiderMouseOut(e: Microsoft.Maps.IMouseEventArgs): void {\r\n        const pin: Microsoft.Maps.Pushpin = <Microsoft.Maps.Pushpin>e.primitive;\r\n        if (pin instanceof Microsoft.Maps.Pushpin && pin.metadata && pin.metadata.isClusterMarker) {\r\n            const m: BingSpiderClusterMarker = this.GetSpiderMarkerFromBingMarker(pin);\r\n            m.Stick.setOptions(this._spiderOptions.stickStyle);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Invoked on mouse over on an exploded spider marker. Sets the hover style on the stick. Also invokes the click event\r\n     * on the underlying original marker dependent on the spider options.\r\n     *\r\n     * @param e - Mouse event.\r\n     */\r\n    private OnSpiderMouseOver(e: Microsoft.Maps.IMouseEventArgs): void {\r\n        const pin: Microsoft.Maps.Pushpin = <Microsoft.Maps.Pushpin>e.primitive;\r\n        if (pin instanceof Microsoft.Maps.Pushpin && pin.metadata && pin.metadata.isClusterMarker) {\r\n            const m: BingSpiderClusterMarker = this.GetSpiderMarkerFromBingMarker(pin);\r\n            m.Stick.setOptions(this._spiderOptions.stickHoverStyle);\r\n            if (this._spiderOptions.invokeClickOnHover) {\r\n                const p: BingMarker = m.ParentMarker;\r\n                const ppin: Microsoft.Maps.Pushpin = p.NativePrimitve;\r\n                if (Microsoft.Maps.Events.hasHandler(ppin, 'click')) { Microsoft.Maps.Events.invoke(ppin, 'click', e); }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the options for spider behavior.\r\n     *\r\n     * @param options ISpiderClusterOptions containing the options enumeration controlling the spider cluster behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private SetSpiderOptions(options: ISpiderClusterOptions): void {\r\n        if (options) {\r\n            if (typeof options.circleSpiralSwitchover === 'number') {\r\n                this._spiderOptions.circleSpiralSwitchover = options.circleSpiralSwitchover;\r\n            }\r\n            if (typeof options.collapseClusterOnMapChange === 'boolean') {\r\n                this._spiderOptions.collapseClusterOnMapChange = options.collapseClusterOnMapChange;\r\n            }\r\n            if (typeof options.collapseClusterOnNthClick === 'number') {\r\n                this._spiderOptions.collapseClusterOnNthClick = options.collapseClusterOnNthClick;\r\n            }\r\n            if (typeof options.invokeClickOnHover === 'boolean') {\r\n                this._spiderOptions.invokeClickOnHover = options.invokeClickOnHover;\r\n            }\r\n            if (typeof options.minSpiralAngleSeperation === 'number') {\r\n                this._spiderOptions.minSpiralAngleSeperation = options.minSpiralAngleSeperation;\r\n            }\r\n            if (typeof options.spiralDistanceFactor === 'number') {\r\n                this._spiderOptions.spiralDistanceFactor = options.spiralDistanceFactor;\r\n            }\r\n            if (typeof options.minCircleLength === 'number') {\r\n                this._spiderOptions.minCircleLength = options.minCircleLength;\r\n            }\r\n            if (options.stickHoverStyle) {\r\n                this._spiderOptions.stickHoverStyle = options.stickHoverStyle;\r\n            }\r\n            if (options.stickStyle) {\r\n                this._spiderOptions.stickStyle = options.stickStyle;\r\n            }\r\n            if (options.markerSelected) {\r\n                this._spiderOptions.markerSelected = options.markerSelected;\r\n            }\r\n            if (options.markerUnSelected) {\r\n                this._spiderOptions.markerUnSelected = options.markerUnSelected;\r\n            }\r\n            if (typeof options.visible === 'boolean') {\r\n                this._spiderOptions.visible = options.visible;\r\n            }\r\n            this.SetOptions(<IClusterOptions>options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Expands a cluster into it's open spider layout.\r\n     *\r\n     * @param cluster The cluster to show in it's open spider layout..\r\n     *\r\n     * @memberof BingClusterLayer\r\n     */\r\n    private ShowSpiderCluster(cluster: Microsoft.Maps.ClusterPushpin): void {\r\n        this.HideSpiderCluster();\r\n        this._currentCluster = cluster;\r\n\r\n        if (cluster && cluster.containedPushpins) {\r\n            // Create spider data.\r\n            const m: Microsoft.Maps.Map = (<BingMapService>this._maps).MapInstance;\r\n            const pins: Array<Microsoft.Maps.Pushpin> = cluster.containedPushpins;\r\n            const center: Microsoft.Maps.Location = cluster.getLocation();\r\n            const centerPoint: Microsoft.Maps.Point =\r\n                <Microsoft.Maps.Point>m.tryLocationToPixel(center, Microsoft.Maps.PixelReference.control);\r\n            let stick: Microsoft.Maps.Polyline;\r\n            let angle = 0;\r\n            const makeSpiral: boolean = pins.length > this._spiderOptions.circleSpiralSwitchover;\r\n            let legPixelLength: number;\r\n            let stepAngle: number;\r\n            let stepLength: number;\r\n\r\n            if (makeSpiral) {\r\n                legPixelLength = this._spiderOptions.minCircleLength / Math.PI;\r\n                stepLength = 2 * Math.PI * this._spiderOptions.spiralDistanceFactor;\r\n            }\r\n            else {\r\n                stepAngle = 2 * Math.PI / pins.length;\r\n                legPixelLength = (this._spiderOptions.spiralDistanceFactor / stepAngle / Math.PI / 2) * pins.length;\r\n                if (legPixelLength < this._spiderOptions.minCircleLength) { legPixelLength = this._spiderOptions.minCircleLength; }\r\n            }\r\n\r\n            for (let i = 0, len = pins.length; i < len; i++) {\r\n                // Calculate spider pin location.\r\n                if (!makeSpiral) {\r\n                    angle = stepAngle * i;\r\n                }\r\n                else {\r\n                    angle += this._spiderOptions.minSpiralAngleSeperation / legPixelLength + i * 0.0005;\r\n                    legPixelLength += stepLength / angle;\r\n                }\r\n                const point: Microsoft.Maps.Point =\r\n                    new Microsoft.Maps.Point(centerPoint.x + legPixelLength * Math.cos(angle),\r\n                        centerPoint.y + legPixelLength * Math.sin(angle));\r\n                const loc: Microsoft.Maps.Location =\r\n                    <Microsoft.Maps.Location>m.tryPixelToLocation(point, Microsoft.Maps.PixelReference.control);\r\n\r\n                // Create stick to pin.\r\n                stick = new Microsoft.Maps.Polyline([center, loc], this._spiderOptions.stickStyle);\r\n                this._spiderLayer.add(stick);\r\n\r\n                // Create pin in spiral that contains same metadata as parent pin.\r\n                const pin: Microsoft.Maps.Pushpin = new Microsoft.Maps.Pushpin(loc);\r\n                pin.metadata = pins[i].metadata || {};\r\n                pin.metadata.isClusterMarker = true;\r\n                pin.setOptions(this.GetBasicPushpinOptions(pins[i]));\r\n                this._spiderLayer.add(pin);\r\n\r\n                const spiderMarker: BingSpiderClusterMarker = new BingSpiderClusterMarker(pin, null, this._spiderLayer);\r\n                spiderMarker.Stick = stick;\r\n                spiderMarker.ParentMarker = <BingMarker>this.GetMarkerFromBingMarker(pins[i]);\r\n                this._spiderMarkers.push(spiderMarker);\r\n                this._spiderMarkerLookup.set(pin, spiderMarker);\r\n\r\n            }\r\n            this._mapclicks = 0;\r\n        }\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { InfoWindow } from '../info-window';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\n\r\n/**\r\n * Concrete implementation of the {@link InfoWindow} contract for the Bing Maps V8 map architecture.\r\n *\r\n * @export\r\n */\r\nexport class BingInfoWindow implements InfoWindow {\r\n\r\n    private _isOpen: boolean;\r\n\r\n    /**\r\n     * Gets whether the info box is currently open.\r\n     *\r\n     * @readonly\r\n     * @memberof BingInfoWindow\r\n     */\r\n    public get IsOpen(): boolean {\r\n        if (this._infoBox && this._infoBox.getOptions().visible === true) { return true; }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets native primitve underlying the model.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @property\r\n     * @readonly\r\n     */\r\n    public get NativePrimitve(): Microsoft.Maps.Infobox {\r\n        return this._infoBox;\r\n    }\r\n\r\n    /**\r\n     * Creates an instance of BingInfoWindow.\r\n     * @param _infoBox - A {@link Microsoft.Maps.Infobox} instance underlying the model\r\n     * @memberof BingInfoWindow\r\n     */\r\n    constructor(private _infoBox: Microsoft.Maps.Infobox) {\r\n        this._isOpen = false;\r\n    }\r\n\r\n    /**\r\n     * Adds an event listener to the InfoWindow.\r\n     *\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        Microsoft.Maps.Events.addHandler(this._infoBox, eventType, (e) => {\r\n            if (e.eventName === 'infoboxChanged') {\r\n                if (this._infoBox.getOptions().visible === true) { this._isOpen = true; }\r\n                else {\r\n                    if (this._infoBox.getOptions().visible === false && this._isOpen === true) {\r\n                        this._isOpen = false;\r\n                        fn(e);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                fn(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Closes the info window.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public Close(): void {\r\n        const o: Microsoft.Maps.IInfoboxOptions = {};\r\n        o.visible = false;\r\n        this._infoBox.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Gets the position of the info window.\r\n     *\r\n     * @returns - Returns the geo coordinates of the info window.\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public GetPosition(): ILatLong {\r\n        const p: ILatLong = {\r\n            latitude: this._infoBox.getLocation().latitude,\r\n            longitude: this._infoBox.getLocation().longitude\r\n        };\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Opens the info window.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public Open(): void {\r\n        const o: Microsoft.Maps.IInfoboxOptions = {};\r\n        o.visible = true;\r\n        this._infoBox.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the info window options.\r\n     *\r\n     * @param options - Info window options to set. The options will be merged with any existing options.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public SetOptions(options: IInfoWindowOptions): void {\r\n        const o: Microsoft.Maps.IInfoboxOptions = BingConversions.TranslateInfoBoxOptions(options);\r\n        this._infoBox.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the info window position.\r\n     *\r\n     * @param position - Geo coordinates to move the anchor of the info window to.\r\n     *\r\n     * @memberof BingInfoWindow\r\n     * @method\r\n     */\r\n    public SetPosition(position: ILatLong): void {\r\n        const l: Microsoft.Maps.Location = BingConversions.TranslateLocation(position);\r\n        this._infoBox.setLocation(l);\r\n    }\r\n}\r\n","import { ILabelOptions } from '../interfaces/ilabel-options';\r\n\r\n/**\r\n * Abstract base implementing a label to be placed on the map.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class MapLabel {\r\n// export class MapLabel extends Microsoft.Maps.CustomOverlay {\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _canvas: HTMLCanvasElement;\r\n\r\n    /**\r\n     * Returns the default label style for the platform\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof MapLabel\r\n     */\r\n    public abstract get DefaultLabelStyle(): ILabelOptions;\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new MapLabel\r\n     * @param options Optional properties to set.\r\n     */\r\n    constructor(options: { [key: string]: any }) {\r\n        this.Set('fontFamily', 'sans-serif');\r\n        this.Set('fontSize', 12);\r\n        this.Set('fontColor', '#ffffff');\r\n        this.Set('strokeWeight', 4);\r\n        this.Set('strokeColor', '#000000');\r\n        this.Set('align', 'center');\r\n        this.SetValues(options);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Deletes the label from the map. This method does not atually delete the label itself, so\r\n     * it can be readded to map later.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public Delete(): void {\r\n        this.SetMap(null);\r\n    }\r\n\r\n    /**\r\n     * Delegate called when underlying properties change.\r\n     *\r\n     * @param prop - The property or properties that have changed.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public Changed(prop: string | Array<string>): void {\r\n        let shouldRunDrawCanvas = false;\r\n        let shouldRunDraw = false;\r\n        if (!Array.isArray(prop)) { prop = [prop]; }\r\n        prop.forEach(p => {\r\n            switch (p) {\r\n                case 'fontFamily':\r\n                case 'fontSize':\r\n                case 'fontColor':\r\n                case 'strokeWeight':\r\n                case 'strokeColor':\r\n                case 'align':\r\n                case 'text':\r\n                    shouldRunDrawCanvas = true;\r\n                    break;\r\n                case 'maxZoom':\r\n                case 'minZoom':\r\n                case 'offset':\r\n                case 'hidden':\r\n                case 'position':\r\n                    shouldRunDraw = true;\r\n                    break;\r\n            }\r\n        });\r\n        if (shouldRunDrawCanvas) { this.DrawCanvas(); }\r\n        if (shouldRunDraw) { this.Draw(); }\r\n    }\r\n\r\n    /**\r\n     * Gets the value of a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @returns - The value of the setting.\r\n     * @memberof MapLabel\r\n     * @abstract\r\n     * @method\r\n     */\r\n    public abstract Get(key: string): any;\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @returns - A native map object for the underlying implementation. Implementing derivatives should return the\r\n     * actual native object.\r\n     * @memberof MapLabel\r\n     * @method\r\n     * @abstract\r\n     */\r\n    public abstract GetMap(): any;\r\n\r\n    /**\r\n     * Set the value for a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @param val - The value to set.\r\n     * @memberof MapLabel\r\n     * @abstract\r\n     * @method\r\n     */\r\n    public abstract Set(key: string, val: any): void;\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - A native map object for the underlying implementation. Implementing derivatives should return the\r\n     * actual native object.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public abstract SetMap(map: any): void;\r\n\r\n    /**\r\n     * Applies settings to the object\r\n     *\r\n     * @param options - An object containing the settings key value pairs.\r\n     * @memberof MapLabel\r\n     * @abstract\r\n     * @method\r\n     */\r\n    public abstract SetValues(options: { [key: string]: any }): void;\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Get the visibility of the label. Visibility depends on Zoom settings.\r\n     * @returns - blank string if visible, 'hidden' if invisible.\r\n     * @protected\r\n     */\r\n    protected GetVisible() {\r\n        const minZoom: number = this.Get('minZoom');\r\n        const maxZoom: number = this.Get('maxZoom');\r\n        const hidden: boolean = this.Get('hidden');\r\n\r\n        if (hidden) {return 'hidden'; }\r\n        if (minZoom === undefined && maxZoom === undefined) { return ''; }\r\n        if (!this.GetMap()) { return ''; }\r\n\r\n        const mapZoom: number = this.GetMap().getZoom();\r\n        if (mapZoom < minZoom || mapZoom > maxZoom) { return 'hidden'; }\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Draws the label on the map.\r\n     * @memberof MapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected abstract Draw(): void;\r\n\r\n    /**\r\n     * Draws the label to the canvas 2d context.\r\n     * @memberof MapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected DrawCanvas () {\r\n        if (!this._canvas) { return; }\r\n\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        style.zIndex = this.Get('zIndex');\r\n\r\n        const ctx: CanvasRenderingContext2D = this._canvas.getContext('2d');\r\n        ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n        ctx.strokeStyle = this.Get('strokeColor');\r\n        ctx.font = this.Get('fontSize') + 'px ' + this.Get('fontFamily');\r\n\r\n        const backgroundColor: string = this.Get('backgroundColor');\r\n        const strokeWeight: number = Number(this.Get('strokeWeight'));\r\n        const text: string = this.Get('text');\r\n        const textMeasure: TextMetrics = ctx.measureText(text);\r\n        const textWidth: number = textMeasure.width;\r\n        if (text && strokeWeight && strokeWeight > 0) {\r\n                ctx.lineWidth = strokeWeight;\r\n                ctx.strokeText(text, 4, 4);\r\n        }\r\n        if (backgroundColor && backgroundColor !== '') {\r\n            ctx.fillStyle = backgroundColor;\r\n            ctx.fillRect(0, 0, textWidth + 8, (parseInt(ctx.font, 10) * 2) - 2);\r\n        }\r\n        ctx.fillStyle = this.Get('fontColor');\r\n        ctx.fillText(text, 4, 4);\r\n\r\n        style.marginLeft = this.GetMarginLeft(textWidth) + 'px';\r\n        style.marginTop = '-0.4em';\r\n        style.pointerEvents = 'none';\r\n            // Bring actual text top in line with desired latitude.\r\n            // Cheaper than calculating height of text.\r\n    }\r\n\r\n    /**\r\n     * Gets the appropriate margin-left for the canvas.\r\n     * @param textWidth  - The width of the text, in pixels.\r\n     * @returns - The margin-left, in pixels.\r\n     * @protected\r\n     * @method\r\n     * @memberof MapLabel\r\n     */\r\n    protected GetMarginLeft(textWidth: number): number {\r\n        switch (this.Get('align')) {\r\n            case 'left':    return 0;\r\n            case 'right':   return -textWidth;\r\n        }\r\n        return textWidth / -2;\r\n    }\r\n\r\n    /**\r\n     * Delegate called when the label is added to the map. Generates and configures\r\n     * the canvas.\r\n     *\r\n     * @memberof MapLabel\r\n     * @method\r\n     * @protected\r\n     * @abstract\r\n     */\r\n    protected abstract OnAdd(): void;\r\n\r\n    /**\r\n     * Called when the label is removed from the map.\r\n     * @method\r\n     * @protected\r\n     * @memberof MapLabel\r\n     */\r\n    protected OnRemove() {\r\n        if (this._canvas && this._canvas.parentNode) {\r\n            this._canvas.parentNode.removeChild(this._canvas);\r\n        }\r\n    }\r\n}\r\n\r\n","import { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { ILabelOptions } from '../../interfaces/ilabel-options';\r\nimport { MapLabel } from '../map-label';\r\n\r\nlet id: number = 0;\r\n\r\n/**\r\n * Implements map a labled to be placed on the map.\r\n *\r\n * @export\r\n */\r\nexport class BingMapLabel extends MapLabel {\r\n\r\n    /**\r\n     * Returns the default label style for the platform\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMapLabel\r\n     */\r\n    public get DefaultLabelStyle(): ILabelOptions {\r\n        return {\r\n            fontSize: 12,\r\n            fontFamily: 'sans-serif',\r\n            fontColor: '#ffffff',\r\n            strokeWeight: 2,\r\n            strokeColor: '#000000'\r\n        };\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new MapLabel\r\n     * @param options Optional properties to set.\r\n     */\r\n    constructor(options: { [key: string]: any }) {\r\n        options.fontSize = options.fontSize || 12;\r\n        options.fontColor = options.fontColor || '#ffffff';\r\n        options.strokeWeight = options.strokeWeight || 2;\r\n        options.strokeColor = options.strokeColor || '#000000';\r\n        super(options);\r\n        (<any>this)._options.beneathLabels = false;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the value of a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @returns - The value of the setting.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public Get(key: string): any {\r\n        return (<any>this)[key];\r\n    }\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public GetMap(): Microsoft.Maps.Map {\r\n        return (<any>this).getMap();\r\n    }\r\n\r\n    /**\r\n     * Set the value for a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @param val - The value to set.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public Set(key: string, val: any): void {\r\n        if (key === 'position' && !val.hasOwnProperty('altitude') && val.hasOwnProperty('latitude') && val.hasOwnProperty('longitude')) {\r\n            val = new Microsoft.Maps.Location(val.latitude, val.longitude);\r\n        }\r\n        if (this.Get(key) !== val) {\r\n            (<any>this)[key] = val;\r\n            this.Changed(key);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - Map to associated with the label.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public SetMap(map: Microsoft.Maps.Map): void {\r\n        const m: Microsoft.Maps.Map = this.GetMap();\r\n        if (map === m) { return; }\r\n        if (m) {\r\n            m.layers.remove(this);\r\n        }\r\n        if (map != null) {\r\n            map.layers.insert(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies settings to the object\r\n     *\r\n     * @param options - An object containing the settings key value pairs.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    public SetValues(options: { [key: string]: any }): void {\r\n        const p: Array<string> = new Array<string>();\r\n        for (const key in options) {\r\n            if (key !== '') {\r\n                if (key === 'position' && !options[key].hasOwnProperty('altitude') &&\r\n                    options[key].hasOwnProperty('latitude') && options[key].hasOwnProperty('longitude')) {\r\n                    options[key] = new Microsoft.Maps.Location(options[key].latitude, options[key].longitude);\r\n                }\r\n                if (this.Get(key) !== options[key]) {\r\n                    (<any>this)[key] = options[key];\r\n                    p.push(key);\r\n                }\r\n            }\r\n        }\r\n        if (p.length > 0) { this.Changed(p); }\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Draws the label on the map.\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected Draw(): void {\r\n        const visibility: string = this.GetVisible();\r\n        const m: Microsoft.Maps.Map = this.GetMap();\r\n        if (!this._canvas) { return; }\r\n        if (!m) { return; }\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        if (visibility !== '') {\r\n            // label is not visible, don't calculate positions etc.\r\n            style['visibility'] = visibility;\r\n            return;\r\n        }\r\n\r\n        let offset: Microsoft.Maps.Point = this.Get('offset');\r\n        const latLng: Microsoft.Maps.Location = this.Get('position');\r\n        if (!latLng) { return; }\r\n        if (!offset) { offset = new Microsoft.Maps.Point(0, 0); }\r\n\r\n        const pos: Microsoft.Maps.Point = <Microsoft.Maps.Point>m.tryLocationToPixel(\r\n            latLng,\r\n            Microsoft.Maps.PixelReference.control);\r\n        style['top'] = (pos.y + offset.y) + 'px';\r\n        style['left'] = (pos.x + offset.x) + 'px';\r\n        style['visibility'] = visibility;\r\n    }\r\n\r\n    /**\r\n     * Delegate called when the label is added to the map. Generates and configures\r\n     * the canvas.\r\n     *\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected OnAdd() {\r\n        this._canvas = document.createElement('canvas');\r\n        this._canvas.id = `xMapLabel${id++}`;\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        style.position = 'absolute';\r\n\r\n        const ctx: CanvasRenderingContext2D = this._canvas.getContext('2d');\r\n        ctx.lineJoin = 'round';\r\n        ctx.textBaseline = 'top';\r\n\r\n        (<any>this).setHtmlElement(this._canvas);\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Delegate callled when the label is loaded\r\n     * @memberof BingMapLabel\r\n     * @method\r\n     */\r\n    private OnLoad() {\r\n        Microsoft.Maps.Events.addHandler(this.GetMap(), 'viewchange', () => {\r\n            this.Changed('position');\r\n        });\r\n        this.DrawCanvas();\r\n        this.Draw();\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to extend the CustomOverlay into the MapLabel\r\n *\r\n * @export\r\n * @method\r\n */\r\nexport function MixinMapLabelWithOverlayView() {\r\n    const x = BingMapLabel.prototype;\r\n    BingMapLabel.prototype = <any> new Microsoft.Maps.CustomOverlay();\r\n    for (const y in x) { if ((<any>x)[y] != null) { (<any>BingMapLabel.prototype)[y] = (<any>x)[y]; }}\r\n    (<any>BingMapLabel.prototype)['onAdd'] = x['OnAdd'];\r\n    (<any>BingMapLabel.prototype)['onLoad'] = x['OnLoad'];\r\n    (<any>BingMapLabel.prototype)['onRemove'] = x['OnRemove'];\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolygonEvent } from '../../interfaces/ipolygon-event';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { BingMapService } from '../../services/bing/bing-map.service';\r\nimport { Polygon } from '../polygon';\r\nimport { BingMapLabel } from './bing-label';\r\n\r\n/**\r\n * Concrete implementation for a polygon model for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\nexport class BingPolygon extends Polygon implements Polygon {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _map: Microsoft.Maps.Map = null;\r\n    private _isEditable: boolean = false;\r\n    private _title: string = '';\r\n    private _maxZoom: number = -1;\r\n    private _minZoom: number = -1;\r\n    private _showLabel: boolean = false;\r\n    private _showTooltip: boolean = false;\r\n    private _label: BingMapLabel = null;\r\n    private _tooltip: BingMapLabel = null;\r\n    private _hasToolTipReceiver: boolean = false;\r\n    private _tooltipVisible: boolean = false;\r\n    private _mouseOverListener: Microsoft.Maps.IHandlerId;\r\n    private _mouseMoveListener: Microsoft.Maps.IHandlerId;\r\n    private _mouseOutListener: Microsoft.Maps.IHandlerId;\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n    private _originalPath: Array<Array<ILatLong>>;\r\n    private _editingCompleteEmitter: (event: IPolygonEvent) => void;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get LabelMaxZoom(): number { return this._maxZoom; }\r\n    public set LabelMaxZoom(val: number) {\r\n        this._maxZoom = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get LabelMinZoom(): number { return this._minZoom; }\r\n    public set LabelMinZoom(val: number) {\r\n        this._minZoom = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof BingPolygon\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the polygon, in this case {@link Microsoft.Maps.Polygon}\r\n     *\r\n     * @readonly\r\n     * @memberof BingPolygon\r\n     */\r\n    public get NativePrimitve(): Microsoft.Maps.Polygon { return this._polygon; }\r\n\r\n    /**\r\n     * Gets or sets whether to show the label\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolygon\r\n     * @property\r\n     */\r\n    public get ShowLabel(): boolean { return this._showLabel; }\r\n    public set ShowLabel(val: boolean) {\r\n        this._showLabel = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolygon\r\n     * @property\r\n     */\r\n    public get ShowTooltip(): boolean { return this._showTooltip; }\r\n    public set ShowTooltip(val: boolean) {\r\n        this._showTooltip = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the title off the polygon\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolygon\r\n     * @property\r\n     */\r\n    public get Title(): string { return this._title; }\r\n    public set Title(val: string) {\r\n        this._title = val;\r\n        this.ManageLabel();\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingPolygon.\r\n     * @param _polygon - The {@link Microsoft.Maps.Polygon} underlying the model.\r\n     * @param _mapService Instance of the Map Service.\r\n     * @param _layer - The context layer.\r\n     * @memberof BingPolygon\r\n     */\r\n    constructor(\r\n        private _polygon: Microsoft.Maps.Polygon,\r\n        protected _mapService: BingMapService,\r\n        protected _layer: Microsoft.Maps.Layer,\r\n    ) {\r\n        super();\r\n        this._map = this._mapService.MapInstance;\r\n        this._originalPath = this.GetPaths();\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n\r\n     * @memberof BingPolygon\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        const supportedEvents = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup'];\r\n        if (supportedEvents.indexOf(eventType) !== -1) {\r\n            Microsoft.Maps.Events.addHandler(this._polygon, eventType, (e) => {\r\n                fn(e);\r\n            });\r\n        }\r\n        if (eventType === 'mousemove') {\r\n            let handlerId: Microsoft.Maps.IHandlerId;\r\n            Microsoft.Maps.Events.addHandler(this._polygon, 'mouseover', e => {\r\n                handlerId = Microsoft.Maps.Events.addHandler(this._map, 'mousemove', m => fn(m));\r\n            });\r\n            Microsoft.Maps.Events.addHandler(this._polygon, 'mouseout', e => {\r\n                if (handlerId) { Microsoft.Maps.Events.removeHandler(handlerId); }\r\n            });\r\n        } if (eventType === 'pathchanged') {\r\n            this._editingCompleteEmitter = <(event: IPolygonEvent) => void>fn;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deleted the polygon.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public Delete(): void {\r\n        if (this._layer) { this._layer.remove(this.NativePrimitve); }\r\n        else {\r\n            this._map.entities.remove(this.NativePrimitve);\r\n        }\r\n        if (this._label) { this._label.Delete(); }\r\n        if (this._tooltip) { this._tooltip.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon is draggable.\r\n     *\r\n     * @returns - True if the polygon is dragable, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetDraggable(): boolean {\r\n        ///\r\n        /// Bing polygons are not draggable by default.\r\n        /// See https://social.msdn.microsoft.com/Forums/en-US/\r\n        ///     7aaae748-4d5f-4be5-a7bb-90498e08b41c/how-can-i-make-polygonpolyline-draggable-in-bing-maps-8?\r\n        ///     forum=bingmaps\r\n        /// for a possible approach to be implemented in the model.\r\n        ///\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon path can be edited.\r\n     *\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetEditable(): boolean {\r\n        return this._isEditable;\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon path.\r\n     *\r\n     * @returns - Array of {@link ILatLong} objects describing the polygon path.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetPath(): Array<ILatLong> {\r\n        const p: Array<Microsoft.Maps.Location> = this._polygon.getLocations();\r\n        const path: Array<ILatLong> = new Array<ILatLong>();\r\n        p.forEach(l => path.push({ latitude: l.latitude, longitude: l.longitude }));\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon paths.\r\n     *\r\n     * @returns - Array of Array of {@link ILatLong} objects describing multiple polygon paths.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetPaths(): Array<Array<ILatLong>> {\r\n        const p: Array<Array<Microsoft.Maps.Location>> = this._polygon.getRings();\r\n        const paths: Array<Array<ILatLong>> = new Array<Array<ILatLong>>();\r\n        p.forEach(x => {\r\n            const path: Array<ILatLong> = new Array<ILatLong>();\r\n            x.forEach(y => path.push({ latitude: y.latitude, longitude: y.longitude }));\r\n            paths.push(path);\r\n        });\r\n        return paths;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon is visible.\r\n     *\r\n     * @returns - True if the polygon is visible, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._polygon.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polygon is dragable.\r\n     *\r\n     * @param draggable - True to make the polygon dragable, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        ///\r\n        /// Bing polygons are not draggable by default.\r\n        /// See https://social.msdn.microsoft.com/Forums/en-US/\r\n        ///     7aaae748-4d5f-4be5-a7bb-90498e08b41c/how-can-i-make-polygonpolyline-draggable-in-bing-maps-8\r\n        //      ?forum=bingmaps\r\n        /// for a possible approach to be implemented in the model.\r\n        ///\r\n        throw (new Error('The bing maps implementation currently does not support draggable polygons.'));\r\n    }\r\n\r\n    /**\r\n     * Sets wether the polygon path is editable.\r\n     *\r\n     * @param editable - True to make polygon path editable, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetEditable(editable: boolean): void {\r\n        const isChanged = this._isEditable !== editable;\r\n        this._isEditable = editable;\r\n        if (!isChanged) {\r\n            return;\r\n        }\r\n\r\n        if (this._isEditable) {\r\n            this._originalPath = this.GetPaths();\r\n            this._mapService.GetDrawingTools().then(t => {\r\n                t.edit(this._polygon);\r\n            });\r\n        }\r\n        else {\r\n            this._mapService.GetDrawingTools().then(t => {\r\n                t.finish((editedPolygon: Microsoft.Maps.Polygon) => {\r\n                    if (editedPolygon !== this._polygon || !this._editingCompleteEmitter) {\r\n                        return;\r\n                    }\r\n                    const newPath: Array<Array<ILatLong>> = this.GetPaths();\r\n                    const originalPath: Array<Array<ILatLong>> = this._originalPath;\r\n                    this.SetPaths(newPath);\r\n                        // this is necessary for the new path to persist it appears.\r\n                    this._editingCompleteEmitter({\r\n                        Click: null,\r\n                        Polygon: this,\r\n                        OriginalPath: originalPath,\r\n                        NewPath: newPath\r\n                    });\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polygon options\r\n     *\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof Polygon\r\n     */\r\n    public SetOptions(options: IPolygonOptions): void {\r\n        const o: Microsoft.Maps.IPolygonOptions = BingConversions.TranslatePolygonOptions(options);\r\n        this._polygon.setOptions(o);\r\n        if (options.visible != null && this._showLabel && this._label) { this._label.Set('hidden', !options.visible); }\r\n\r\n        if (typeof options.editable !== 'undefined') {\r\n            this.SetEditable(options.editable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polygon path.\r\n     *\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polygons path.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetPath(path: Array<ILatLong>): void {\r\n        const p: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n        path.forEach(x => p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)));\r\n        this._originalPath = [path];\r\n        this._polygon.setLocations(p);\r\n        if (this._label) {\r\n            this._centroid = null;\r\n            this.ManageLabel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the polygon path or paths.\r\n     *\r\n     * @param paths\r\n     * An Array of {@link ILatLong} (or array of arrays) describing the polygons path(s).\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetPaths(paths: Array<Array<ILatLong>> | Array<ILatLong>): void {\r\n        if (paths == null) { return; }\r\n        if (!Array.isArray(paths)) { return; }\r\n        if (paths.length === 0) {\r\n            this._polygon.setRings(new Array<Microsoft.Maps.Location>());\r\n            if (this._label) {\r\n                this._label.Delete();\r\n                this._label = null;\r\n            }\r\n            return;\r\n        }\r\n        if (Array.isArray(paths[0])) {\r\n            // parameter is an array or arrays\r\n            const p: Array<Array<Microsoft.Maps.Location>> = new Array<Array<Microsoft.Maps.Location>>();\r\n            (<Array<Array<ILatLong>>>paths).forEach(path => {\r\n                const _p: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n                path.forEach(x => _p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)));\r\n                p.push(_p);\r\n            });\r\n            this._originalPath = <Array<Array<ILatLong>>>paths;\r\n            this._polygon.setRings(p);\r\n            if (this._label) {\r\n                this._centroid = null;\r\n                this.ManageLabel();\r\n            }\r\n        }\r\n        else {\r\n            // parameter is a simple array....\r\n            this.SetPath(<Array<ILatLong>>paths);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polygon is visible.\r\n     *\r\n     * @param visible - True to set the polygon visible, false otherwise.\r\n     *\r\n     * @memberof BingPolygon\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._polygon.setOptions(<Microsoft.Maps.IPolygonOptions>{ visible: visible });\r\n        if (this._showLabel && this._label) { this._label.Set('hidden', !visible); }\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Configures the label for the polygon\r\n     * @memberof Polygon\r\n     */\r\n    private ManageLabel(): void {\r\n        if (this.GetPath == null || this.GetPath().length === 0) { return; }\r\n        if (this._showLabel && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                position: BingConversions.TranslateLocation(this.Centroid)\r\n            };\r\n            if (o.position == null) { return; }\r\n            if (this._minZoom !== -1) { o.minZoom = this._minZoom; }\r\n            if (this._maxZoom !== -1) { o.maxZoom = this._maxZoom; }\r\n            if (this._label == null) {\r\n                this._label = new BingMapLabel(o);\r\n                this._label.SetMap(this._map);\r\n            }\r\n            else {\r\n                this._label.SetValues(o);\r\n            }\r\n            this._label.Set('hidden', !this.GetVisible());\r\n        }\r\n        else {\r\n            if (this._label) {\r\n                this._label.SetMap(null);\r\n                this._label = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Configures the tooltip for the polygon\r\n     * @memberof Polygon\r\n     */\r\n    private ManageTooltip(): void {\r\n        if (this._showTooltip && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                align: 'left',\r\n                offset: new Microsoft.Maps.Point(0, 25),\r\n                backgroundColor: 'bisque',\r\n                hidden: true,\r\n                fontSize: 12,\r\n                fontColor: '#000000',\r\n                strokeWeight: 0\r\n            };\r\n            if (this._tooltip == null) {\r\n                this._tooltip = new BingMapLabel(o);\r\n                this._tooltip.SetMap(this._map);\r\n            }\r\n            else {\r\n                this._tooltip.SetValues(o);\r\n            }\r\n            if (!this._hasToolTipReceiver) {\r\n                this._mouseOverListener = Microsoft.Maps.Events.addHandler(\r\n                    this._polygon, 'mouseover', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                        this._tooltip.Set('position', e.location);\r\n                        if (!this._tooltipVisible) {\r\n                            this._tooltip.Set('hidden', false);\r\n                            this._tooltipVisible = true;\r\n                        }\r\n                        this._mouseMoveListener = Microsoft.Maps.Events.addHandler(\r\n                            this._map, 'mousemove', (m: Microsoft.Maps.IMouseEventArgs) => {\r\n                                if (this._tooltipVisible && m.location && m.primitive === this._polygon) {\r\n                                    this._tooltip.Set('position', m.location);\r\n                                }\r\n                            });\r\n                    });\r\n                this._mouseOutListener = Microsoft.Maps.Events.addHandler(\r\n                    this._polygon, 'mouseout', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                        if (this._tooltipVisible) {\r\n                            this._tooltip.Set('hidden', true);\r\n                            this._tooltipVisible = false;\r\n                        }\r\n                        if (this._mouseMoveListener) { Microsoft.Maps.Events.removeHandler(this._mouseMoveListener); }\r\n                    });\r\n                this._hasToolTipReceiver = true;\r\n            }\r\n        }\r\n        if ((!this._showTooltip || this._title === '' || this._title == null)) {\r\n            if (this._hasToolTipReceiver) {\r\n                if (this._mouseOutListener) { Microsoft.Maps.Events.removeHandler(this._mouseOutListener); }\r\n                if (this._mouseOverListener) { Microsoft.Maps.Events.removeHandler(this._mouseOverListener); }\r\n                if (this._mouseMoveListener) { Microsoft.Maps.Events.removeHandler(this._mouseMoveListener); }\r\n                this._hasToolTipReceiver = false;\r\n            }\r\n            if (this._tooltip) {\r\n                this._tooltip.SetMap(null);\r\n                this._tooltip = null;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { Polyline } from '../polyline';\r\nimport { BingMapLabel } from './bing-label';\r\n\r\n/**\r\n * Concrete implementation for a polyline model for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\nexport class BingPolyline extends Polyline implements Polyline {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _isEditable: boolean = true;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n    private _title: string = '';\r\n    private _showTooltip: boolean = false;\r\n    private _tooltip: BingMapLabel = null;\r\n    private _hasToolTipReceiver: boolean = false;\r\n    private _tooltipVisible: boolean = false;\r\n    private _mouseOverListener: Microsoft.Maps.IHandlerId;\r\n    private _mouseMoveListener: Microsoft.Maps.IHandlerId;\r\n    private _mouseOutListener: Microsoft.Maps.IHandlerId;\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    /**\r\n     * Gets the polyline metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof BingPolyline\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the Navitve Polyline underlying the model\r\n     *\r\n     * @readonly\r\n     * @memberof BingPolyline\r\n     */\r\n    public get NativePrimitve(): Microsoft.Maps.Polyline { return this._polyline; }\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolyline\r\n     * @property\r\n     */\r\n    public get ShowTooltip(): boolean { return this._showTooltip; }\r\n    public set ShowTooltip(val: boolean) {\r\n        this._showTooltip = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the title off the polyline\r\n     *\r\n     * @abstract\r\n     * @memberof BingPolyline\r\n     * @property\r\n     */\r\n    public get Title(): string { return this._title; }\r\n    public set Title(val: string) {\r\n        this._title = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingPolygon.\r\n     * @param _polyline - The {@link Microsoft.Maps.Polyline} underlying the model.\r\n     * @param _map - The context map.\r\n     * @param _layer - The context layer.\r\n     * @memberof BingPolyline\r\n     */\r\n    constructor(private _polyline: Microsoft.Maps.Polyline, protected _map: Microsoft.Maps.Map, protected _layer: Microsoft.Maps.Layer) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n     * @memberof BingPolyline\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        const supportedEvents = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup' ];\r\n        if (supportedEvents.indexOf(eventType) !== -1) {\r\n            Microsoft.Maps.Events.addHandler(this._polyline, eventType, (e) => {\r\n                fn(e);\r\n            });\r\n        }\r\n        if (eventType === 'mousemove') {\r\n            let handlerId: Microsoft.Maps.IHandlerId;\r\n            Microsoft.Maps.Events.addHandler(this._polyline, 'mouseover', e => {\r\n                handlerId = Microsoft.Maps.Events.addHandler(this._map, 'mousemove', m => fn(m));\r\n            });\r\n            Microsoft.Maps.Events.addHandler(this._polyline, 'mouseout', e => {\r\n                if (handlerId) { Microsoft.Maps.Events.removeHandler(handlerId); }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deleted the polyline.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public Delete(): void {\r\n        if (this._layer) { this._layer.remove(this.NativePrimitve); }\r\n        else {\r\n            this._map.entities.remove(this.NativePrimitve);\r\n        }\r\n        if (this._tooltip) { this._tooltip.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline is draggable.\r\n     *\r\n     * @returns - True if the polyline is dragable, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public GetDraggable(): boolean {\r\n        ///\r\n        /// Bing polygons are not draggable by default.\r\n        /// See https://social.msdn.microsoft.com/Forums/en-US/\r\n        ///     7aaae748-4d5f-4be5-a7bb-90498e08b41c/how-can-i-make-polygonpolyline-draggable-in-bing-maps-8\r\n        ///     ?forum=bingmaps\r\n        /// for a possible approach to be implemented in the model.\r\n        ///\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline path can be edited.\r\n     *\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public GetEditable(): boolean {\r\n        return this._isEditable;\r\n    }\r\n\r\n    /**\r\n     * Gets the polyline path.\r\n     *\r\n     * @returns - Array of {@link ILatLong} objects describing the polyline path.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public GetPath(): Array<ILatLong> {\r\n        const p: Array<Microsoft.Maps.Location> = this._polyline.getLocations();\r\n        const path: Array<ILatLong> = new Array<ILatLong>();\r\n        p.forEach(l => path.push({ latitude: l.latitude, longitude: l.longitude }));\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline is visible.\r\n     *\r\n     * @returns - True if the polyline is visible, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._polyline.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polyline is dragable.\r\n     *\r\n     * @param draggable - True to make the polyline dragable, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        ///\r\n        /// Bing polygons are not draggable by default.\r\n        /// See https://social.msdn.microsoft.com/Forums/en-US/\r\n        ///     7aaae748-4d5f-4be5-a7bb-90498e08b41c/how-can-i-make-polygonpolyline-draggable-in-bing-maps-8\r\n        ///     ?forum=bingmaps\r\n        /// for a possible approach to be implemented in the model.\r\n        ///\r\n        throw(new Error('The bing maps implementation currently does not support draggable polylines.'));\r\n    }\r\n\r\n    /**\r\n     * Sets wether the polyline path is editable.\r\n     *\r\n     * @param editable - True to make polyline path editable, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetEditable(editable: boolean): void {\r\n        this._isEditable = editable;\r\n    }\r\n\r\n    /**\r\n     * Sets the polyline options\r\n     *\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetOptions(options: IPolylineOptions): void {\r\n        const o: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolylineOptions(options);\r\n        this._polyline.setOptions(o);\r\n        if (options.path) {\r\n            this.SetPath(<Array<ILatLong>>options.path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polyline path.\r\n     *\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polylines path.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetPath(path: Array<ILatLong>): void {\r\n        const p: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n        path.forEach(x => p.push(new Microsoft.Maps.Location(x.latitude, x.longitude)));\r\n        this._polyline.setLocations(p);\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polyline is visible.\r\n     *\r\n     * @param visible - True to set the polyline visible, false otherwise.\r\n     *\r\n     * @memberof BingPolyline\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._polyline.setOptions(<Microsoft.Maps.IPolylineOptions>{ visible: visible });\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Configures the tooltip for the polygon\r\n     * @memberof Polygon\r\n     */\r\n    private ManageTooltip(): void {\r\n        if (this._showTooltip && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                align: 'left',\r\n                offset: new Microsoft.Maps.Point(0, 25),\r\n                backgroundColor: 'bisque',\r\n                hidden: true,\r\n                fontSize: 12,\r\n                fontColor: '#000000',\r\n                strokeWeight: 0\r\n            };\r\n            if (this._tooltip == null) {\r\n                this._tooltip = new BingMapLabel(o);\r\n                this._tooltip.SetMap(this._map);\r\n            }\r\n            else {\r\n                this._tooltip.SetValues(o);\r\n            }\r\n            if (!this._hasToolTipReceiver) {\r\n                this._mouseOverListener = Microsoft.Maps.Events.addHandler(\r\n                        this._polyline, 'mouseover', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                    this._tooltip.Set('position', e.location);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                });\r\n                this._mouseMoveListener = Microsoft.Maps.Events.addHandler(\r\n                            this._map, 'mousemove', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                    if (this._tooltipVisible && e.location && e.primitive === this._polyline) {\r\n                        this._tooltip.Set('position', e.location);\r\n                    }\r\n                });\r\n                this._mouseOutListener = Microsoft.Maps.Events.addHandler(\r\n                            this._polyline, 'mouseout', (e: Microsoft.Maps.IMouseEventArgs) => {\r\n                    if (this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', true);\r\n                        this._tooltipVisible = false;\r\n                    }\r\n                });\r\n                this._hasToolTipReceiver = true;\r\n            }\r\n        }\r\n        if ((!this._showTooltip || this._title === '' || this._title == null)) {\r\n            if (this._hasToolTipReceiver) {\r\n                if (this._mouseOutListener) { Microsoft.Maps.Events.removeHandler(this._mouseOutListener) ; }\r\n                if (this._mouseOverListener) { Microsoft.Maps.Events.removeHandler(this._mouseOverListener); }\r\n                if (this._mouseMoveListener) { Microsoft.Maps.Events.removeHandler(this._mouseMoveListener); }\r\n                this._hasToolTipReceiver = false;\r\n            }\r\n            if (this._tooltip) {\r\n                this._tooltip.SetMap(null);\r\n                this._tooltip = null;\r\n            }\r\n        }\r\n    }\r\n}\r\n","import { IMapEventLookup } from '../../interfaces/imap-event-lookup';\r\n\r\n/**\r\n * This contstant translates the abstract map events into their corresponding bing map\r\n * equivalents.\r\n */\r\nexport const BingMapEventsLookup: IMapEventLookup = {\r\n    click :             'click',\r\n    dblclick :          'dblclick',\r\n    rightclick :        'rightclick',\r\n    resize :            'resize',\r\n    boundschanged :     'viewchangeend',\r\n    centerchanged :     'viewchangeend',\r\n    zoomchanged :       'viewchangeend',\r\n    mouseover:          'mouseover',\r\n    mouseout :          'mouseout',\r\n    mousemove :         'mousemove',\r\n    infowindowclose:    'infoboxChanged'\r\n};\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { BingConversions } from '../../services/bing/bing-conversions';\r\nimport { CanvasOverlay } from '../canvas-overlay';\r\nimport { MapLabel } from '../map-label';\r\nimport { BingMapLabel } from './bing-label';\r\n\r\n/**\r\n * Concrete implementing a canvas overlay to be placed on the map for Bing Maps.\r\n *\r\n * @export\r\n */\r\nexport class BingCanvasOverlay extends CanvasOverlay {\r\n\r\n    ///\r\n    /// field declarations\r\n    ///\r\n    private _viewChangeEvent: Microsoft.Maps.IHandlerId;\r\n    private _viewChangeEndEvent: Microsoft.Maps.IHandlerId;\r\n    private _mapResizeEvent: Microsoft.Maps.IHandlerId;\r\n\r\n\r\n    /**\r\n     * Creates a new instance of the BingCanvasOverlay class.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @memberof BingCanvasOverlay\r\n     */\r\n    constructor(drawCallback: (canvas: HTMLCanvasElement) => void) {\r\n        super(drawCallback);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Obtains geo coordinates for the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event. Expected to implement {@link Microsoft.Maps.IMouseEventArgs}.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     * @memberof BingCanvasOverlay\r\n     */\r\n    public GetCoordinatesFromClick(e: Microsoft.Maps.IMouseEventArgs): ILatLong {\r\n        return { latitude: e.location.latitude, longitude: e.location.longitude };\r\n    }\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @memberof BingCanvasOverlay\r\n     * @method\r\n     */\r\n    public GetMap(): Microsoft.Maps.Map {\r\n        return (<any>this).getMap();\r\n    }\r\n\r\n    /**\r\n     * Returns a MapLabel instance for the current platform that can be used as a tooltip.\r\n     * This method only generates the map label. Content and placement is the responsibility\r\n     * of the caller. Note that this method returns null until OnLoad has been called.\r\n     *\r\n     * @returns - The label to be used for the tooltip.\r\n     * @memberof BingCanvasOverlay\r\n     * @method\r\n     */\r\n    public GetToolTipOverlay(): MapLabel {\r\n        const o: { [key: string]: any } = {\r\n            align: 'left',\r\n            offset: new Microsoft.Maps.Point(0, 25),\r\n            backgroundColor: 'bisque',\r\n            hidden: true,\r\n            fontSize: 12,\r\n            fontColor: '#000000',\r\n            strokeWeight: 0\r\n        };\r\n        const label: MapLabel = new BingMapLabel(o);\r\n        label.SetMap(this.GetMap());\r\n        return label;\r\n    }\r\n\r\n    /**\r\n     * CanvasOverlay loaded, attach map events for updating canvas.\r\n     * @abstract\r\n     * @method\r\n     * @memberof BingCanvasOverlay\r\n     */\r\n    public OnLoad() {\r\n        const map: Microsoft.Maps.Map = (<any>this).getMap();\r\n\r\n        // Get the current map view information.\r\n        this._zoomStart = map.getZoom();\r\n        this._centerStart = <ILatLong>map.getCenter();\r\n\r\n        // Redraw the canvas.\r\n        this.Redraw(true);\r\n\r\n        // When the map moves, move the canvas accordingly.\r\n        this._viewChangeEvent = Microsoft.Maps.Events.addHandler(map, 'viewchange', (e) => {\r\n            if (map.getMapTypeId() === Microsoft.Maps.MapTypeId.streetside) {\r\n                // Don't show the canvas if the map is in Streetside mode.\r\n                this._canvas.style.display = 'none';\r\n            }\r\n            else {\r\n                // Re-drawing the canvas as it moves would be too slow. Instead, scale and translate canvas element.\r\n                const zoomCurrent: number = map.getZoom();\r\n                const centerCurrent: Microsoft.Maps.Location = map.getCenter();\r\n\r\n                // Calculate map scale based on zoom level difference.\r\n                const scale: number = Math.pow(2, zoomCurrent - this._zoomStart);\r\n\r\n                // Calculate the scaled dimensions of the canvas.\r\n                const newWidth: number = map.getWidth() * scale;\r\n                const newHeight: number = map.getHeight() * scale;\r\n\r\n                // Calculate offset of canvas based on zoom and center offsets.\r\n                const pixelPoints: Array<Microsoft.Maps.Point> = <Array<Microsoft.Maps.Point>>map.tryLocationToPixel([\r\n                        BingConversions.TranslateLocation(this._centerStart),\r\n                        centerCurrent\r\n                    ], Microsoft.Maps.PixelReference.control);\r\n                const centerOffsetX: number = pixelPoints[1].x - pixelPoints[0].x;\r\n                const centerOffsetY: number = pixelPoints[1].y - pixelPoints[0].y;\r\n                const x: number = (-(newWidth - map.getWidth()) / 2) - centerOffsetX;\r\n                const y: number = (-(newHeight - map.getHeight()) / 2) - centerOffsetY;\r\n\r\n                // Update the canvas CSS position and dimensions.\r\n                this.UpdatePosition(x, y, newWidth, newHeight);\r\n            }\r\n        });\r\n\r\n        // When the map stops moving, render new data on the canvas.\r\n        this._viewChangeEndEvent = Microsoft.Maps.Events.addHandler(map, 'viewchangeend', (e) => {\r\n            this.UpdateCanvas();\r\n        });\r\n\r\n        // Update the position of the overlay when the map is resized.\r\n        this._mapResizeEvent = Microsoft.Maps.Events.addHandler(map, 'mapresize', (e) => {\r\n            this.UpdateCanvas();\r\n        });\r\n\r\n        // set the overlay to ready state\r\n        this._readyResolver(true);\r\n    }\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - Map to associated with the label.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    public SetMap(map: Microsoft.Maps.Map): void {\r\n        const m: Microsoft.Maps.Map = this.GetMap();\r\n        if (map === m) { return; }\r\n        if (m) {\r\n            m.layers.remove(this);\r\n        }\r\n        if (map != null) {\r\n            map.layers.insert(this);\r\n        }\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Attaches the canvas to the map.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    protected SetCanvasElement(el: HTMLCanvasElement): void {\r\n        (<any>this).setHtmlElement(el);\r\n    }\r\n\r\n    /**\r\n     * Remove the map event handlers.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected RemoveEventHandlers(): void {\r\n        // Remove all event handlers from the map.\r\n        Microsoft.Maps.Events.removeHandler(this._viewChangeEvent);\r\n        Microsoft.Maps.Events.removeHandler(this._viewChangeEndEvent);\r\n        Microsoft.Maps.Events.removeHandler(this._mapResizeEvent);\r\n    }\r\n\r\n    /**\r\n     * Updates the Canvas size based on the map size.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected Resize(): void {\r\n        const map: Microsoft.Maps.Map = (<any>this).getMap();\r\n\r\n        // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.\r\n        this._canvas.width = map.getWidth();\r\n        this._canvas.height = map.getHeight();\r\n    }\r\n\r\n    /**\r\n     * Updates the Canvas.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected UpdateCanvas(): void {\r\n        const map: Microsoft.Maps.Map = (<any>this).getMap();\r\n\r\n        // Only render the canvas if it isn't in streetside mode.\r\n        if (map.getMapTypeId() !== Microsoft.Maps.MapTypeId.streetside) {\r\n            this._canvas.style.display = '';\r\n\r\n            // Reset CSS position and dimensions of canvas.\r\n            this.UpdatePosition(0, 0, map.getWidth(), map.getHeight());\r\n\r\n            // Redraw the canvas.\r\n            this.Redraw(true);\r\n\r\n            // Get the current map view information.\r\n            this._zoomStart = map.getZoom();\r\n            this._centerStart = <ILatLong>map.getCenter();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to extend the OverlayView into the CanvasOverlay\r\n *\r\n * @export\r\n * @method\r\n */\r\nexport function MixinCanvasOverlay() {\r\n    const x = BingCanvasOverlay.prototype;\r\n    BingCanvasOverlay.prototype = <any> new Microsoft.Maps.CustomOverlay();\r\n    for (const y in x) { if ((<any>x)[y] != null) { (<any>BingCanvasOverlay.prototype)[y] = (<any>x)[y]; }}\r\n    (<any>BingCanvasOverlay.prototype)['onAdd'] = x['OnAdd'];\r\n    (<any>BingCanvasOverlay.prototype)['onLoad'] = x['OnLoad'];\r\n    (<any>BingCanvasOverlay.prototype)['onRemove'] = x['OnRemove'];\r\n}\r\n","import { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { IBox } from '../../interfaces/ibox';\r\nimport { IMapOptions } from '../../interfaces/imap-options';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport * as GoogleMapTypes from './google-map-types';\r\nimport { MapTypeId } from '../../models/map-type-id';\r\n\r\ndeclare var google: any;\r\n\r\n\r\n/**\r\n * This class contains helperfunctions to map various interfaces used to represent options and structures into the\r\n * corresponding Google Maps specific implementations.\r\n *\r\n * @export\r\n */\r\nexport class GoogleConversions {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n\r\n    /**\r\n     * Map option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _mapOptionsAttributes: string[] = [\r\n        'backgroundColor',\r\n        'center',\r\n        'clickableIcons',\r\n        'disableDefaultUI',\r\n        'disableDoubleClickZoom',\r\n        'draggable',\r\n        'draggableCursor',\r\n        'draggingCursor',\r\n        'disableZooming',\r\n        'fullscreenControl',\r\n        'fullscreenControlOptions',\r\n        'gestureHandling',\r\n        'heading',\r\n        'keyboardShortcuts',\r\n        'mapTypeControl',\r\n        'mapTypeControlOptions',\r\n        'mapTypeId',\r\n        'maxZoom',\r\n        'minZoom',\r\n        'noClear',\r\n        'panControl',\r\n        'panControlOptions',\r\n        'rotateControl',\r\n        'rotateControlOptions',\r\n        'scaleControl',\r\n        'scaleControlOptions',\r\n        'scrollwheel',\r\n        'showMapTypeSelector',\r\n        'streetView',\r\n        'streetViewControl',\r\n        'streetViewControlOptions',\r\n        'styles',\r\n        'tilt',\r\n        'zoom',\r\n        'zoomControl',\r\n        'zoomControlOptions'\r\n    ];\r\n\r\n    /**\r\n     * InfoWindow option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _infoWindowOptionsAttributes: string[] = [\r\n        'actions',\r\n        'description',\r\n        'htmlContent',\r\n        'id',\r\n        'position',\r\n        'pixelOffset',\r\n        'showCloseButton',\r\n        'showPointer',\r\n        'pushpin',\r\n        'title',\r\n        'titleClickHandler',\r\n        'typeName',\r\n        'visible',\r\n        'width',\r\n        'height'\r\n    ];\r\n\r\n    /**\r\n     * Marker option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _markerOptionsAttributes: string[] = [\r\n        'anchor',\r\n        'position',\r\n        'title',\r\n        'text',\r\n        'label',\r\n        'draggable',\r\n        'icon',\r\n        'width',\r\n        'height',\r\n        'iconInfo',\r\n        'metadata',\r\n        'visible'\r\n    ];\r\n\r\n    /**\r\n     * Cluster option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _clusterOptionsAttributes: string[] = [\r\n        'callback',\r\n        'clusteredPinCallback',\r\n        'clusteringEnabled',\r\n        'gridSize',\r\n        'layerOffset',\r\n        'placementMode',\r\n        'visible',\r\n        'zIndex'\r\n    ];\r\n\r\n    /**\r\n     * Polygon option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _polygonOptionsAttributes: string[] = [\r\n        'clickable',\r\n        'draggable',\r\n        'editable',\r\n        'fillColor',\r\n        'fillOpacity',\r\n        'geodesic',\r\n        'paths',\r\n        'strokeColor',\r\n        'strokeOpacity',\r\n        'strokeWeight',\r\n        'visible',\r\n        'zIndex'\r\n    ];\r\n\r\n    /**\r\n     * Polyline option attributes that are supported for conversion to Google Map properties\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    private static _polylineOptionsAttributes: string[] = [\r\n        'clickable',\r\n        'draggable',\r\n        'editable',\r\n        'geodesic',\r\n        'strokeColor',\r\n        'strokeOpacity',\r\n        'strokeWeight',\r\n        'visible',\r\n        'zIndex'\r\n    ];\r\n\r\n    /**\r\n     * Maps an IBox object to a GoogleMapTypes.LatLngBoundsLiteral object.\r\n     *\r\n     * @param bounds - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateBounds(bounds: IBox): GoogleMapTypes.LatLngBoundsLiteral {\r\n        const b: GoogleMapTypes.LatLngBoundsLiteral = {\r\n            east: bounds.maxLongitude,\r\n            north: bounds.maxLatitude,\r\n            south: bounds.minLatitude,\r\n            west: bounds.minLongitude,\r\n        };\r\n        return b;\r\n    }\r\n\r\n    /**\r\n     * Maps an IInfoWindowOptions object to a GoogleMapTypes.InfoWindowOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateInfoWindowOptions(options: IInfoWindowOptions): GoogleMapTypes.InfoWindowOptions {\r\n        const o: GoogleMapTypes.InfoWindowOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._infoWindowOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'htmlContent') {\r\n                    o.content = (<any>options)[k];\r\n                } else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        if (o.content == null || o.content === '') {\r\n            if (options.title !== '' && options.description !== '') {\r\n                o.content = `${options.title}: ${options.description}`;\r\n            }\r\n            else if (options.description !== '') { o.content = options.description; }\r\n            else { o.content = options.title; }\r\n        }\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an ILatLong object to a GoogleMapTypes.LatLngLiteral object.\r\n     *\r\n     * @param latlong - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLocation(latlong: ILatLong): GoogleMapTypes.LatLngLiteral {\r\n        const l: GoogleMapTypes.LatLngLiteral = { lat: latlong.latitude, lng: latlong.longitude };\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an GoogleMapTypes.LatLngLiteral object to a ILatLong object.\r\n     *\r\n     * @param latlng - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLatLng(latlng: GoogleMapTypes.LatLngLiteral): ILatLong {\r\n        const l: ILatLong = { latitude: latlng.lat, longitude: latlng.lng };\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an ILatLong object to a GoogleMapTypes.LatLng object.\r\n     *\r\n     * @param latlong - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLocationObject(latlong: ILatLong): GoogleMapTypes.LatLng {\r\n        const l: GoogleMapTypes.LatLng = new google.maps.LatLng(latlong.latitude, latlong.longitude);\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an GoogleMapTypes.LatLng object to a ILatLong object.\r\n     *\r\n     * @param latlng - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLatLngObject(latlng: GoogleMapTypes.LatLng): ILatLong {\r\n        const l: ILatLong = { latitude: latlng.lat(), longitude: latlng.lng() };\r\n        return l;\r\n    }\r\n\r\n    /**\r\n     * Maps an ILatLong array to a array of GoogleMapTypes.LatLng object.\r\n     *\r\n     * @param latlongArray - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateLocationObjectArray(latlongArray: Array<ILatLong>): Array<GoogleMapTypes.LatLng> {\r\n        // use for loop for performance in case we deal with large numbers of points and paths...\r\n        const p: Array<GoogleMapTypes.LatLng> = new Array<GoogleMapTypes.LatLng>();\r\n        for (let i = 0; i < latlongArray.length; i++) {\r\n            p.push(GoogleConversions.TranslateLocationObject(latlongArray[i]));\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Maps a MapTypeId object to a Google maptype string.\r\n     *\r\n     * @param mapTypeId - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateMapTypeId(mapTypeId: MapTypeId): string {\r\n        switch (mapTypeId) {\r\n            case MapTypeId.road: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.roadmap];\r\n            case MapTypeId.grayscale: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.terrain];\r\n            case MapTypeId.hybrid: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.hybrid];\r\n            case MapTypeId.ordnanceSurvey: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.terrain];\r\n            default: return GoogleMapTypes.MapTypeId[GoogleMapTypes.MapTypeId.satellite];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maps an IMarkerOptions object to a GoogleMapTypes.MarkerOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Promise that when resolved contains the mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateMarkerOptions(options: IMarkerOptions): GoogleMapTypes.MarkerOptions {\r\n        const o: GoogleMapTypes.MarkerOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._markerOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'position') {\r\n                    const latlng = GoogleConversions.TranslateLocationObject(options[k]);\r\n                    o.position = latlng;\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Maps an IMapOptions object to a GoogleMapTypes.MapOptions object.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslateOptions(options: IMapOptions): GoogleMapTypes.MapOptions {\r\n        const o: GoogleMapTypes.MapOptions = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._mapOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'center') {\r\n                    o.center = GoogleConversions.TranslateLocation(options.center);\r\n                }\r\n                else if (k === 'mapTypeId') {\r\n                    o.mapTypeId = GoogleConversions.TranslateMapTypeId(options.mapTypeId);\r\n                }\r\n                else if (k === 'disableZooming') {\r\n                    o.gestureHandling = 'none';\r\n                    o.zoomControl =  false;\r\n                }\r\n                else if (k === 'showMapTypeSelector') {\r\n                    o.mapTypeControl = false;\r\n                }\r\n                else {\r\n                    (<any>o)[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     * Translates an array of locations or an array or arrays of location to and array of arrays of Bing Map Locations\r\n     *\r\n     * @param paths - ILatLong based locations to convert.\r\n     * @returns - converted locations.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslatePaths(paths: Array<ILatLong> | Array<Array<ILatLong>>): Array<Array<GoogleMapTypes.LatLng>> {\r\n        const p: Array<Array<GoogleMapTypes.LatLng>> = new Array<Array<GoogleMapTypes.LatLng>>();\r\n        if (paths == null || !Array.isArray(paths) || paths.length === 0) {\r\n            p.push(new Array<GoogleMapTypes.LatLng>());\r\n        }\r\n        else if (Array.isArray(paths[0])) {\r\n            // parameter is an array or arrays\r\n            // use for loop for performance in case we deal with large numbers of points and paths...\r\n            const p1 = <Array<Array<ILatLong>>>paths;\r\n            for (let i = 0; i < p1.length; i++) {\r\n                p.push(GoogleConversions.TranslateLocationObjectArray(p1[i]));\r\n            }\r\n        }\r\n        else {\r\n            // parameter is a simple array....\r\n            p.push(GoogleConversions.TranslateLocationObjectArray(<Array<ILatLong>>paths));\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPolygonOptions object to a GoogleMapTypes.PolygonOptions.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslatePolygonOptions(options: IPolygonOptions): GoogleMapTypes.PolygonOptions {\r\n        const o: GoogleMapTypes.PolygonOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._polygonOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                if (k === 'paths') {\r\n                    if (!Array.isArray(options.paths)) { return; }\r\n                    if (options.paths.length === 0) {\r\n                        o.paths = new Array<GoogleMapTypes.LatLng>();\r\n                    }\r\n                    else if (Array.isArray(options.paths[0])) {\r\n                        o.paths = new Array<Array<GoogleMapTypes.LatLngLiteral>>();\r\n                        // use for loop for performance in case we deal with large numbers of points and paths..\r\n                        const p1 = <Array<Array<ILatLong>>>options.paths;\r\n                        for (let i = 0; i < p1.length; i++) {\r\n                            o.paths[i] = new Array<GoogleMapTypes.LatLngLiteral>();\r\n                            for (let j = 0; j < p1[i].length; j++) {\r\n                                o.paths[i][j] = {lat: p1[i][j].latitude, lng: p1[i][j].longitude};\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        o.paths = new Array<GoogleMapTypes.LatLngLiteral>();\r\n                        // use for loop for performance in case we deal with large numbers of points and paths..\r\n                        const p1 = <Array<ILatLong>>options.paths;\r\n                        for (let i = 0; i < p1.length; i++) {\r\n                            o.paths[i] = {lat: p1[i].latitude, lng: p1[i].longitude};\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    o[k] = (<any>options)[k];\r\n                }\r\n            });\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     *  Maps an IPolylineOptions object to a GoogleMapTypes.PolylineOptions.\r\n     *\r\n     * @param options - Object to be mapped.\r\n     * @returns - Mapped object.\r\n     *\r\n     * @memberof GoogleConversions\r\n     */\r\n    public static TranslatePolylineOptions(options: IPolylineOptions): GoogleMapTypes.PolylineOptions {\r\n        const o: GoogleMapTypes.PolylineOptions | any = {};\r\n        Object.keys(options)\r\n            .filter(k => GoogleConversions._polylineOptionsAttributes.indexOf(k) !== -1)\r\n            .forEach((k) => {\r\n                o[k] = (<any>options)[k];\r\n            });\r\n        return o;\r\n    }\r\n}\r\n","import { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { GoogleConversions } from '../../services/google/google-conversions';\r\nimport { GoogleMapService} from '../../services/google/google-map.service';\r\nimport { InfoWindow } from '../info-window';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Concrete implementation for a {@link InfoWindow}} model for Google Maps.\r\n *\r\n * @export\r\n */\r\nexport class GoogleInfoWindow implements InfoWindow {\r\n\r\n    private _isOpen: boolean;\r\n\r\n    /**\r\n     * Gets whether the info box is currently open.\r\n     *\r\n     * @readonly\r\n     * @memberof InfoWGoogleInfoWindowindow\r\n     */\r\n    public get IsOpen(): boolean {\r\n        if (this._isOpen === true) { return true; }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying native object.\r\n     *\r\n     * @property\r\n     * @readonly\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.InfoWindow {\r\n        return this._infoWindow;\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleInfoWindow.\r\n     * @param _infoWindow - A {@link GoogleMapTypes.InfoWindow} instance underlying the model.\r\n     * @param _mapService - An instance of the {@link GoogleMapService}.\r\n     * @memberof GoogleInfoWindow\r\n     */\r\n    constructor(private _infoWindow: GoogleMapTypes.InfoWindow, private _mapService: GoogleMapService) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n   /**\r\n     * Adds an event listener to the InfoWindow.\r\n     *\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        this._infoWindow.addListener(eventType, (e: any) => {\r\n            if (eventType === 'closeclick') { this._isOpen = false; }\r\n            fn(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Closes the info window.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public Close() {\r\n        this._isOpen = false;\r\n        this._infoWindow.close();\r\n    }\r\n\r\n    /**\r\n     * Gets the position of the info window\r\n     *\r\n     * @returns - The geo coordinates of the info window.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public GetPosition(): ILatLong {\r\n        return GoogleConversions.TranslateLatLngObject(this._infoWindow.getPosition());\r\n    }\r\n\r\n    /**\r\n     * Opens the info window\r\n     *\r\n     * @param [anchor] - Optional Anchor.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public Open(anchor?: any) {\r\n        this._mapService.MapPromise.then(m => {\r\n            this._isOpen = true;\r\n            this._infoWindow.open(m, anchor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the info window options\r\n     *\r\n     * @param options - The options to set. This object will be merged with the existing options.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public SetOptions(options: IInfoWindowOptions): void {\r\n        const o: GoogleMapTypes.InfoWindowOptions = GoogleConversions.TranslateInfoWindowOptions(options);\r\n        this._infoWindow.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets the info window position\r\n     *\r\n     * @param position - Geo coordinates at which to anchor the info window.\r\n     *\r\n     * @memberof GoogleInfoWindow\r\n     * @method\r\n     */\r\n    public SetPosition(position: ILatLong): void {\r\n        const l: GoogleMapTypes.LatLngLiteral = GoogleConversions.TranslateLocation(position);\r\n        this._infoWindow.setPosition(l);\r\n    }\r\n}\r\n","import { GoogleConversions } from '../../services/google/google-conversions';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { Marker } from '../marker';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\n\r\n/**\r\n * Concrete implementation of the {@link Marker} contract for the Google Maps map architecture.\r\n *\r\n * @export\r\n */\r\nexport class GoogleMarker implements Marker {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n    private _isFirst = false;\r\n    private _isLast = true;\r\n\r\n    ///\r\n    /// Public properties\r\n    ///\r\n\r\n    /**\r\n     * Indicates that the marker is the first marker in a set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public get IsFirst(): boolean { return this._isFirst; }\r\n    public set IsFirst(val: boolean) { this._isFirst = val; }\r\n\r\n    /**\r\n     * Indicates that the marker is the last marker in the set.\r\n     *\r\n     * @memberof Marker\r\n     */\r\n    public get IsLast(): boolean { return this._isLast; }\r\n    public set IsLast(val: boolean) { this._isLast = val; }\r\n\r\n    /**\r\n     * Gets the marker metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof BingMarker\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the marker, in this case {@link Microsoft.Maps.Pushpin}\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMarker\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.Marker { return this._marker; }\r\n\r\n    /**\r\n     * Gets the Location of the marker\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMarker\r\n     */\r\n    public get Location(): ILatLong {\r\n        const l: GoogleMapTypes.LatLng = this._marker.getPosition();\r\n        return {\r\n            latitude: l.lat(),\r\n            longitude: l.lng()\r\n        };\r\n    }\r\n\r\n    ///\r\n    /// Constructors\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleMarker.\r\n     * @param _marker\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    constructor(private _marker: GoogleMapTypes.Marker) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener to the marker.\r\n     *\r\n     * @param eventType - String containing the event for which to register the listener (e.g. \"click\")\r\n     * @param fn - Delegate invoked when the event occurs.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        this._marker.addListener(eventType, fn);\r\n    }\r\n\r\n    /**\r\n     * Deletes the marker.\r\n     *\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public DeleteMarker(): void {\r\n        this._marker.setMap(null);\r\n    }\r\n\r\n    /**\r\n     * Gets the marker label\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public GetLabel(): string {\r\n        return this._marker.getLabel().text;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the marker is visible.\r\n     *\r\n     * @returns - True if the marker is visible, false otherwise.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._marker.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets the anchor for the marker. Use this to adjust the root location for the marker to accomodate various marker image sizes.\r\n     *\r\n     * @param anchor - Point coordinates for the marker anchor.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetAnchor(anchor: any): void {\r\n        // not implemented\r\n        // TODO: we need to switch the model to complex icons for google to\r\n        // support anchors, sizes and origins.\r\n        // https://developers.google.com/maps/documentation/javascript/markers\r\n    }\r\n\r\n    /**\r\n     * Sets the draggability of a marker.\r\n     *\r\n     * @param draggable - True to mark the marker as draggable, false otherwise.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        this._marker.setDraggable(draggable);\r\n    }\r\n\r\n    /**\r\n     * Sets the icon for the marker.\r\n     *\r\n     * @param icon - String containing the icon in various forms (url, data url, etc.)\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetIcon(icon: string): void {\r\n        this._marker.setIcon(icon);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker label.\r\n     *\r\n     * @param label - String containing the label to set.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetLabel(label: string): void {\r\n        this._marker.setLabel(label);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker position.\r\n     *\r\n     * @param latLng - Geo coordinates to set the marker position to.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetPosition(latLng: ILatLong): void {\r\n        const p: GoogleMapTypes.LatLng = GoogleConversions.TranslateLocationObject(latLng);\r\n        this._marker.setPosition(p);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker title.\r\n     *\r\n     * @param title - String containing the title to set.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetTitle(title: string): void {\r\n        this._marker.setTitle(title);\r\n    }\r\n\r\n    /**\r\n     * Sets the marker options.\r\n     *\r\n     * @param options - {@link IMarkerOptions} object containing the marker options to set. The supplied options are\r\n     * merged with the underlying marker options.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetOptions(options: IMarkerOptions): void {\r\n        const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(options);\r\n        this._marker.setOptions(o);\r\n    }\r\n\r\n    /**\r\n     * Sets whether the marker is visible.\r\n     *\r\n     * @param visible - True to set the marker visible, false otherwise.\r\n     *\r\n     * @memberof GoogleMarker\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._marker.setVisible(visible);\r\n    }\r\n\r\n}\r\n","import * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { MapLabel } from '../map-label';\r\nimport { ILabelOptions } from '../../interfaces/ilabel-options';\r\ndeclare var google: any;\r\n\r\n/**\r\n * Implements map a labled to be placed on the map.\r\n *\r\n * @export\r\n */\r\nexport class GoogleMapLabel extends MapLabel {\r\n\r\n    /**\r\n     * Returns the default label style for the platform\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof GoogleMapLabel\r\n     */\r\n    public get DefaultLabelStyle(): ILabelOptions {\r\n        return {\r\n            fontSize: 12,\r\n            fontFamily: 'sans-serif',\r\n            fontColor: '#ffffff',\r\n            strokeWeight: 3,\r\n            strokeColor: '#000000'\r\n        };\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new MapLabel\r\n     * @param options Optional properties to set.\r\n     */\r\n    constructor(options: { [key: string]: any }) {\r\n        options.fontSize = options.fontSize || 12;\r\n        options.fontColor = options.fontColor || '#ffffff';\r\n        options.strokeWeight = options.strokeWeight || 3;\r\n        options.strokeColor = options.strokeColor || '#000000';\r\n        super(options);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the value of a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @returns - The value of the setting.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public Get(key: string): any {\r\n        return (<any>this).get(key);\r\n    }\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @memberof GoogleMapLabel\r\n     * @method\r\n     */\r\n    public GetMap(): GoogleMapTypes.GoogleMap {\r\n        return (<any>this).getMap();\r\n    }\r\n\r\n    /**\r\n     * Set the value for a setting.\r\n     *\r\n     * @param key - Key specifying the setting.\r\n     * @param val - The value to set.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public Set(key: string, val: any): void {\r\n        if (key === 'position' && val.hasOwnProperty('latitude') && val.hasOwnProperty('longitude')) {\r\n            val = new google.maps.LatLng(val.latitude, val.longitude);\r\n        }\r\n        if (this.Get(key) !== val) {\r\n            (<any>this).set(key, val);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the map for the label. Settings this to null remove the label from hte map.\r\n     *\r\n     * @param map - Map to associated with the label.\r\n     * @memberof GoogleMapLabel\r\n     * @method\r\n     */\r\n    public SetMap(map: GoogleMapTypes.GoogleMap): void {\r\n        (<any>this).setMap(map);\r\n    }\r\n\r\n    /**\r\n     * Applies settings to the object\r\n     *\r\n     * @param options - An object containing the settings key value pairs.\r\n     * @memberof MapLabel\r\n     * @method\r\n     */\r\n    public SetValues(options: { [key: string]: any }): void {\r\n        for (const key in options) {\r\n            if (key !== '') {\r\n                if (key === 'position' &&  options[key].hasOwnProperty('latitude') &&  options[key].hasOwnProperty('longitude')) {\r\n                    options[key] = new google.maps.LatLng( options[key].latitude,  options[key].longitude);\r\n                }\r\n                if (this.Get(key) === options[key]) { delete options[key]; }\r\n            }\r\n        }\r\n        (<any>this).setValues(options);\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Draws the label on the map.\r\n     * @memberof GoogleMapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected Draw(): void {\r\n        const projection = (<any>this).getProjection();\r\n        const visibility: string = this.GetVisible();\r\n        if (!projection) {\r\n            // The map projection is not ready yet so do nothing\r\n            return;\r\n        }\r\n        if (!this._canvas) {\r\n            // onAdd has not been called yet.\r\n            return;\r\n        }\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        if (visibility !== '') {\r\n            // label is not visible, don't calculate positions etc.\r\n            style['visibility'] = visibility;\r\n            return;\r\n        }\r\n\r\n        let offset: GoogleMapTypes.Point = this.Get('offset');\r\n        let latLng: GoogleMapTypes.LatLng|GoogleMapTypes.LatLngLiteral = this.Get('position');\r\n        if (!latLng) { return; }\r\n        if (!(latLng instanceof google.maps.LatLng)) { latLng = new google.maps.LatLng(latLng.lat, latLng.lng); }\r\n        if (!offset) { offset = new google.maps.Point(0, 0); }\r\n\r\n        const pos = projection.fromLatLngToDivPixel(latLng);\r\n        style['top'] = (pos.y + offset.y) + 'px';\r\n        style['left'] = (pos.x + offset.x) + 'px';\r\n        style['visibility'] = visibility;\r\n    }\r\n\r\n    /**\r\n     * Delegate called when the label is added to the map. Generates and configures\r\n     * the canvas.\r\n     *\r\n     * @memberof GoogleMapLabel\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected OnAdd() {\r\n        this._canvas = document.createElement('canvas');\r\n        const style: CSSStyleDeclaration = this._canvas.style;\r\n        style.position = 'absolute';\r\n\r\n        const ctx: CanvasRenderingContext2D = this._canvas.getContext('2d');\r\n        ctx.lineJoin = 'round';\r\n        ctx.textBaseline = 'top';\r\n\r\n        this.DrawCanvas();\r\n        const panes = (<any>this).getPanes();\r\n        if (panes) {\r\n            panes.overlayLayer.appendChild(this._canvas);\r\n                // 4: floatPane (infowindow)\r\n                // 3: overlayMouseTarget (mouse events)\r\n                // 2: markerLayer (marker images)\r\n                // 1: overlayLayer (polygons, polylines, ground overlays, tile layer overlays)\r\n                // 0: mapPane (lowest pane above the map tiles)\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to extend the OverlayView into the MapLabel\r\n *\r\n * @export\r\n * @method\r\n */\r\nexport function MixinMapLabelWithOverlayView() {\r\n    const x = GoogleMapLabel.prototype;\r\n    GoogleMapLabel.prototype = new google.maps.OverlayView;\r\n    for (const y in x) { if ((<any>x)[y] != null) { (<any>GoogleMapLabel.prototype)[y] = (<any>x)[y]; }}\r\n    (<any>GoogleMapLabel.prototype)['changed'] = x['Changed'];\r\n    (<any>GoogleMapLabel.prototype)['onAdd'] = x['OnAdd'];\r\n    (<any>GoogleMapLabel.prototype)['draw'] = x['Draw'];\r\n    (<any>GoogleMapLabel.prototype)['onRemove'] = x['OnRemove'];\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolygonEvent } from '../../interfaces/ipolygon-event';\r\nimport { GoogleConversions } from '../../services/google/google-conversions';\r\nimport { Polygon } from '../polygon';\r\nimport { GoogleMapLabel } from './google-label';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Concrete implementation for a polygon model for Google Maps.\r\n *\r\n * @export\r\n */\r\nexport class GooglePolygon extends Polygon implements Polygon {\r\n\r\n    private _title: string = '';\r\n    private _showLabel: boolean = false;\r\n    private _showTooltip: boolean = false;\r\n    private _maxZoom: number = -1;\r\n    private _minZoom: number = -1;\r\n    private _label: GoogleMapLabel = null;\r\n    private _tooltip: GoogleMapLabel = null;\r\n    private _tooltipVisible: boolean = false;\r\n    private _hasToolTipReceiver: boolean = false;\r\n    private _originalPath: Array<Array<ILatLong>>;\r\n    private _mouseOverListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _mouseOutListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _mouseMoveListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n    private _editingCompleteEmitter: (event: IPolygonEvent) => void = null;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets or sets the maximum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get LabelMaxZoom(): number { return this._maxZoom; }\r\n    public set LabelMaxZoom(val: number) {\r\n        this._maxZoom = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the minimum zoom at which the label is displayed. Ignored or ShowLabel is false.\r\n     *\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get LabelMinZoom(): number { return this._minZoom; }\r\n    public set LabelMinZoom(val: number) {\r\n        this._minZoom = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof GoolePolygon\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the polygon, in this case {@link GoogleMapTypes.Polygon}\r\n     *\r\n     * @readonly\r\n     * @memberof GooglePolygon\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.Polygon { return this._polygon; }\r\n\r\n    /**\r\n     * Gets or sets whether to show the label\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get ShowLabel(): boolean { return this._showLabel; }\r\n    public set ShowLabel(val: boolean) {\r\n        this._showLabel = val;\r\n        this.ManageLabel();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get ShowTooltip(): boolean { return this._showTooltip; }\r\n    public set ShowTooltip(val: boolean) {\r\n        this._showTooltip = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the title off the polygon\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get Title(): string { return this._title; }\r\n    public set Title(val: string) {\r\n        this._title = val;\r\n        this.ManageLabel();\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GooglePolygon.\r\n     * @param _polygon - The {@link GoogleMapTypes.Polygon} underlying the model.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    constructor(private _polygon: GoogleMapTypes.Polygon) {\r\n        super();\r\n        this._originalPath = this.GetPaths();\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n\r\n     * @memberof GooglePolygon\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        const supportedEvents = [\r\n            'click',\r\n            'dblclick',\r\n            'drag', 'dragend',\r\n            'dragstart',\r\n            'mousedown',\r\n            'mousemove',\r\n            'mouseout',\r\n            'mouseover',\r\n            'mouseup',\r\n            'rightclick'\r\n        ];\r\n        if (supportedEvents.indexOf(eventType) !== -1) {\r\n            this._polygon.addListener(eventType, fn);\r\n        }\r\n        if (eventType === 'pathchanged') {\r\n            this._editingCompleteEmitter = <(event: IPolygonEvent) => void>fn;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deleted the polygon.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public Delete(): void {\r\n        this._polygon.setMap(null);\r\n        if (this._label) { this._label.Delete(); }\r\n        if (this._tooltip) { this._tooltip.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon is draggable.\r\n     *\r\n     * @returns - True if the polygon is dragable, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetDraggable(): boolean {\r\n        return this._polygon.getDraggable();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon path can be edited.\r\n     *\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetEditable(): boolean {\r\n        return this._polygon.getEditable();\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon path.\r\n     *\r\n     * @returns - Array of {@link ILatLong} objects describing the polygon path.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetPath(): Array<ILatLong> {\r\n        const p: Array<GoogleMapTypes.LatLng> = this._polygon.getPath();\r\n        const path: Array<ILatLong> = new Array<ILatLong>();\r\n        p.forEach(x => path.push({ latitude: x.lat(), longitude: x.lng() }));\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Gets the polygon paths.\r\n     *\r\n     * @returns - Array of Array of {@link ILatLong} objects describing multiple polygon paths.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetPaths(): Array<Array<ILatLong>> {\r\n        const p: Array<Array<GoogleMapTypes.LatLng>> = this._polygon.getPaths();\r\n        const paths: Array<Array<ILatLong>> = new Array<Array<ILatLong>>();\r\n        p.forEach(x => {\r\n            const path: Array<ILatLong> = new Array<ILatLong>();\r\n            x.forEach(y => path.push({ latitude: y.lat(), longitude: y.lng() }));\r\n            paths.push(path);\r\n        });\r\n        return paths;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polygon is visible.\r\n     *\r\n     * @returns - True if the polygon is visible, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._polygon.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polygon is dragable.\r\n     *\r\n     * @param draggable - True to make the polygon dragable, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        this._polygon.setDraggable(draggable);\r\n    }\r\n\r\n    /**\r\n     * Sets wether the polygon path is editable.\r\n     *\r\n     * @param editable - True to make polygon path editable, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetEditable(editable: boolean): void {\r\n        const previous = this._polygon.getEditable();\r\n        this._polygon.setEditable(editable);\r\n        if (previous && !editable && this._editingCompleteEmitter) {\r\n            this._editingCompleteEmitter({\r\n                Click: null,\r\n                Polygon: this,\r\n                OriginalPath: this._originalPath,\r\n                NewPath: this.GetPaths()\r\n            });\r\n            this._originalPath = this.GetPaths();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polygon options\r\n     *\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetOptions(options: IPolygonOptions): void {\r\n        const o: GoogleMapTypes.PolygonOptions = GoogleConversions.TranslatePolygonOptions(options);\r\n\r\n        if (typeof o.editable !== 'undefined') {\r\n            this.SetEditable(o.editable);\r\n            delete o.editable;\r\n        }\r\n\r\n        this._polygon.setOptions(o);\r\n        if (options.visible != null && this._showLabel && this._label) { this._label.Set('hidden', !options.visible); }\r\n    }\r\n\r\n    /**\r\n     * Sets the polygon path.\r\n     *\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polygons path.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetPath(path: Array<ILatLong>): void {\r\n        const p: Array<GoogleMapTypes.LatLng> = new Array<GoogleMapTypes.LatLng>();\r\n        path.forEach(x => p.push(new google.maps.LatLng(x.latitude, x.longitude)));\r\n        this._polygon.setPath(p);\r\n        this._originalPath = [path];\r\n        if (this._label) {\r\n            this._centroid = null;\r\n            this.ManageLabel();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the polygon path or paths.\r\n     *\r\n     * @param paths An Array of {@link ILatLong}\r\n     * (or array of arrays) describing the polygons path(s).\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetPaths(paths: Array<Array<ILatLong>> | Array<ILatLong>): void {\r\n        if (paths == null) { return; }\r\n        if (!Array.isArray(paths)) { return; }\r\n        if (paths.length === 0) {\r\n            this._polygon.setPaths(new Array<GoogleMapTypes.LatLng>());\r\n            if (this._label) {\r\n                this._label.Delete();\r\n                this._label = null;\r\n            }\r\n            return;\r\n        }\r\n        if (Array.isArray(paths[0])) {\r\n            // parameter is an array or arrays\r\n            const p: Array<Array<GoogleMapTypes.LatLng>> = new Array<Array<GoogleMapTypes.LatLng>>();\r\n            (<Array<Array<ILatLong>>>paths).forEach(path => {\r\n                const _p: Array<GoogleMapTypes.LatLng> = new Array<GoogleMapTypes.LatLng>();\r\n                path.forEach(x => _p.push(new google.maps.LatLng(x.latitude, x.longitude)));\r\n                p.push(_p);\r\n            });\r\n            this._polygon.setPaths(p);\r\n            this._originalPath = <Array<Array<ILatLong>>>paths;\r\n            if (this._label) {\r\n                this._centroid = null;\r\n                this.ManageLabel();\r\n            }\r\n        } else {\r\n            // parameter is a simple array....\r\n            this.SetPath(<Array<ILatLong>>paths);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polygon is visible.\r\n     *\r\n     * @param visible - True to set the polygon visible, false otherwise.\r\n     *\r\n     * @memberof GooglePolygon\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._polygon.setVisible(visible);\r\n        if (this._showLabel && this._label) { this._label.Set('hidden', !visible); }\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Configures the label for the polygon\r\n     * @memberof GooglePolygon\r\n     */\r\n    private ManageLabel(): void {\r\n        if (this.GetPath == null || this.GetPath().length === 0) { return; }\r\n        if (this._showLabel && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                position: GoogleConversions.TranslateLocationObject(this.Centroid)\r\n            };\r\n            if (o.position == null) { return; }\r\n            if (this._minZoom !== -1) { o.minZoom = this._minZoom; }\r\n            if (this._maxZoom !== -1) { o.maxZoom = this._maxZoom; }\r\n            if (this._label == null) {\r\n                o.map = this.NativePrimitve.getMap();\r\n                o.zIndex = this.NativePrimitve.zIndex ? this.NativePrimitve.zIndex + 1 : 100;\r\n                this._label = new GoogleMapLabel(o);\r\n            }\r\n            else {\r\n                this._label.SetValues(o);\r\n            }\r\n            this._label.Set('hidden', !this.GetVisible());\r\n        }\r\n        else {\r\n            if (this._label) {\r\n                this._label.SetMap(null);\r\n                this._label = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Configures the tooltip for the polygon\r\n     * @memberof GooglePolygon\r\n     */\r\n    private ManageTooltip(): void {\r\n        if (this._showTooltip && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                align: 'left',\r\n                offset: new google.maps.Point(0, 25),\r\n                backgroundColor: 'bisque',\r\n                hidden: true,\r\n                fontSize: 12,\r\n                fontColor: '#000000',\r\n                strokeWeight: 0\r\n            };\r\n            if (this._tooltip == null) {\r\n                o.map = this.NativePrimitve.getMap();\r\n                o.zIndex = 100000;\r\n                this._tooltip = new GoogleMapLabel(o);\r\n            }\r\n            else {\r\n                this._tooltip.SetValues(o);\r\n            }\r\n            if (!this._hasToolTipReceiver) {\r\n                this._mouseOverListener = this.NativePrimitve.addListener('mouseover', (e: GoogleMapTypes.MouseEvent) => {\r\n                    this._tooltip.Set('position', e.latLng);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                });\r\n                this._mouseMoveListener = this.NativePrimitve.addListener('mousemove', (e: GoogleMapTypes.MouseEvent) => {\r\n                    if (this._tooltipVisible) { this._tooltip.Set('position', e.latLng); }\r\n                });\r\n                this._mouseOutListener = this.NativePrimitve.addListener('mouseout', (e: GoogleMapTypes.MouseEvent) => {\r\n                    if (this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', true);\r\n                        this._tooltipVisible = false;\r\n                    }\r\n                });\r\n                this._hasToolTipReceiver = true;\r\n            }\r\n        }\r\n        if ((!this._showTooltip || this._title === '' || this._title == null)) {\r\n            if (this._hasToolTipReceiver) {\r\n                if (this._mouseOutListener) { google.maps.event.removeListener(this._mouseOutListener); }\r\n                if (this._mouseOverListener) { google.maps.event.removeListener(this._mouseOverListener); }\r\n                if (this._mouseMoveListener) { google.maps.event.removeListener(this._mouseMoveListener); }\r\n                this._hasToolTipReceiver = false;\r\n            }\r\n            if (this._tooltip) {\r\n                this._tooltip.SetMap(null);\r\n                this._tooltip = null;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { GoogleConversions } from '../../services/google/google-conversions';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { GoogleMapLabel } from './google-label';\r\nimport { Polyline } from '../polyline';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Concrete implementation for a polyline model for Google Maps.\r\n *\r\n * @export\r\n */\r\nexport class GooglePolyline extends Polyline implements Polyline {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _title: string = '';\r\n    private _showTooltip: boolean = false;\r\n    private _tooltip: GoogleMapLabel = null;\r\n    private _tooltipVisible: boolean = false;\r\n    private _hasToolTipReceiver: boolean = false;\r\n    private _mouseOverListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _mouseOutListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _mouseMoveListener: GoogleMapTypes.MapsEventListener = null;\r\n    private _metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets the polyline metadata.\r\n     *\r\n     * @readonly\r\n     * @memberof GooglePolyline\r\n     */\r\n    public get Metadata(): Map<string, any> { return this._metadata; }\r\n\r\n    /**\r\n     * Gets the native primitve implementing the marker, in this case {@link GoogleMApTypes.Polyline}\r\n     *\r\n     * @readonly\r\n     * @memberof GooglePolygon\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.Polyline { return this._polyline; }\r\n\r\n    /**\r\n     * Gets or sets whether to show the tooltip\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get ShowTooltip(): boolean { return this._showTooltip; }\r\n    public set ShowTooltip(val: boolean) {\r\n        this._showTooltip = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the title off the polygon\r\n     *\r\n     * @abstract\r\n     * @memberof GooglePolygon\r\n     * @property\r\n     */\r\n    public get Title(): string { return this._title; }\r\n    public set Title(val: string) {\r\n        this._title = val;\r\n        this.ManageTooltip();\r\n    }\r\n\r\n    ///\r\n    /// constructor\r\n    ///\r\n\r\n     /**\r\n     * Creates an instance of GooglePolygon.\r\n     * @param _polyline - The {@link GoogleMApTypes.Polyline} underlying the model.\r\n     *\r\n     * @memberof GooglePolyline\r\n     */\r\n    constructor(private _polyline: GoogleMapTypes.Polyline) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Adds a delegate for an event.\r\n     *\r\n     * @param eventType - String containing the event name.\r\n     * @param fn - Delegate function to execute when the event occurs.\r\n     * @memberof Polyline\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        const supportedEvents = [\r\n            'click',\r\n            'dblclick',\r\n            'drag', 'dragend',\r\n            'dragstart',\r\n            'mousedown',\r\n            'mousemove',\r\n            'mouseout',\r\n            'mouseover',\r\n            'mouseup',\r\n            'rightclick'\r\n        ];\r\n        if (supportedEvents.indexOf(eventType) !== -1) {\r\n            this._polyline.addListener(eventType, fn);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deleted the polyline.\r\n     *\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public Delete(): void {\r\n        this._polyline.setMap(null);\r\n        if (this._tooltip) { this._tooltip.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline is draggable.\r\n     *\r\n     * @returns - True if the polyline is dragable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public GetDraggable(): boolean {\r\n        return this._polyline.getDraggable();\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline path can be edited.\r\n     *\r\n     * @returns - True if the path can be edited, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public GetEditable(): boolean {\r\n        return this._polyline.getEditable();\r\n    }\r\n\r\n    /**\r\n     * Gets the polyline path.\r\n     *\r\n     * @returns - Array of {@link ILatLong} objects describing the polyline path.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public GetPath(): Array<ILatLong> {\r\n        const p: Array<GoogleMapTypes.LatLng> = this._polyline.getPath();\r\n        const path: Array<ILatLong> = new Array<ILatLong>();\r\n        p.forEach(x => path.push({ latitude: x.lat(), longitude: x.lng() }));\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the polyline is visible.\r\n     *\r\n     * @returns - True if the polyline is visible, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._polyline.getVisible();\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polyline is dragable.\r\n     *\r\n     * @param draggable - True to make the polyline dragable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetDraggable(draggable: boolean): void {\r\n        this._polyline.setDraggable(draggable);\r\n    }\r\n\r\n    /**\r\n     * Sets wether the polyline path is editable.\r\n     *\r\n     * @param editable - True to make polyline path editable, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetEditable(editable: boolean): void {\r\n        this._polyline.setEditable(editable);\r\n    }\r\n\r\n    /**\r\n     * Sets the polyline options\r\n     *\r\n     * @param options - {@link ILatLong} object containing the options. The options are merged with hte ones\r\n     * already on the underlying model.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetOptions(options: IPolylineOptions): void {\r\n        const o: GoogleMapTypes.PolylineOptions = GoogleConversions.TranslatePolylineOptions(options);\r\n        this._polyline.setOptions(o);\r\n        if (options.path) {\r\n            this.SetPath(<Array<ILatLong>>options.path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the polyline path.\r\n     *\r\n     * @param path - An Array of {@link ILatLong} (or array of arrays) describing the polylines path.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetPath(path: Array<ILatLong>): void {\r\n        const p: Array<GoogleMapTypes.LatLng> = new Array<GoogleMapTypes.LatLng>();\r\n        path.forEach(x => p.push(new google.maps.LatLng(x.latitude, x.longitude)));\r\n        this._polyline.setPath(p);\r\n    }\r\n\r\n    /**\r\n     * Sets whether the polyline is visible.\r\n     *\r\n     * @param visible - True to set the polyline visible, false otherwise.\r\n     *\r\n     * @memberof Polyline\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        this._polyline.setVisible(visible);\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n    /**\r\n     * Configures the tooltip for the polyline\r\n     * @memberof GooglePolyline\r\n     */\r\n    private ManageTooltip(): void {\r\n        if (this._showTooltip && this._title != null && this._title !== '') {\r\n            const o: { [key: string]: any } = {\r\n                text: this._title,\r\n                align: 'left',\r\n                offset: new google.maps.Point(0, 25),\r\n                backgroundColor: 'bisque',\r\n                hidden: true,\r\n                fontSize: 12,\r\n                fontColor: '#000000',\r\n                strokeWeight: 0\r\n            };\r\n            if (this._tooltip == null) {\r\n                o.map = this.NativePrimitve.getMap();\r\n                o.zIndex = 100000;\r\n                this._tooltip = new GoogleMapLabel(o);\r\n            }\r\n            else {\r\n                this._tooltip.SetValues(o);\r\n            }\r\n            if (!this._hasToolTipReceiver) {\r\n                this._mouseOverListener = this.NativePrimitve.addListener('mouseover', (e: GoogleMapTypes.MouseEvent) => {\r\n                    this._tooltip.Set('position', e.latLng);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                });\r\n                this._mouseMoveListener = this.NativePrimitve.addListener('mousemove', (e: GoogleMapTypes.MouseEvent) => {\r\n                    if (this._tooltipVisible) { this._tooltip.Set('position', e.latLng); }\r\n                });\r\n                this._mouseOutListener = this.NativePrimitve.addListener('mouseout', (e: GoogleMapTypes.MouseEvent) => {\r\n                    if (this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', true);\r\n                        this._tooltipVisible = false;\r\n                    }\r\n                });\r\n                this._hasToolTipReceiver = true;\r\n            }\r\n        }\r\n        if ((!this._showTooltip || this._title === '' || this._title == null)) {\r\n            if (this._hasToolTipReceiver) {\r\n                if (this._mouseOutListener) { google.maps.event.removeListener(this._mouseOutListener); }\r\n                if (this._mouseOverListener) { google.maps.event.removeListener(this._mouseOverListener); }\r\n                if (this._mouseMoveListener) { google.maps.event.removeListener(this._mouseMoveListener); }\r\n                this._hasToolTipReceiver = false;\r\n            }\r\n            if (this._tooltip) {\r\n                this._tooltip.SetMap(null);\r\n                this._tooltip = null;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import { IMapEventLookup } from '../../interfaces/imap-event-lookup';\r\n\r\n/**\r\n * This contstant translates the abstract map events into their corresponding google map\r\n * equivalents.\r\n */\r\nexport const GoogleMapEventsLookup: IMapEventLookup = {\r\n    click :             'click',\r\n    dblclick :          'dblclick',\r\n    rightclick :        'rightclick',\r\n    resize :            'resize',\r\n    boundschanged :     'bounds_changed',\r\n    centerchanged :     'center_changed',\r\n    zoomchanged :       'zoom_changed',\r\n    mouseover:          'mouseover',\r\n    mouseout :          'mouseout',\r\n    mousemove :         'mousemove',\r\n    infowindowclose:    'closeclick'\r\n};\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { GoogleConversions } from '../../services/google/google-conversions';\r\nimport { CanvasOverlay } from '../canvas-overlay';\r\nimport { MapLabel } from '../map-label';\r\nimport { GoogleMapLabel } from './google-label';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\ndeclare var google: any;\r\n\r\n/**\r\n * Concrete implementing a canvas overlay to be placed on the map for Google Maps.\r\n *\r\n * @export\r\n */\r\nexport class GoogleCanvasOverlay extends CanvasOverlay {\r\n\r\n    ///\r\n    /// field declarations\r\n    ///\r\n    private _viewChangeEndEvent: GoogleMapTypes.MapsEventListener;\r\n    private _mapResizeEvent: GoogleMapTypes.MapsEventListener;\r\n\r\n    /**\r\n     * Creates a new instance of the GoogleCanvasOverlay class.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    constructor(drawCallback: (canvas: HTMLCanvasElement) => void) {\r\n        super(drawCallback);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Obtains geo coordinates for the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    public GetCoordinatesFromClick(e: GoogleMapTypes.MouseEvent): ILatLong {\r\n        if (!e) { return null; }\r\n        if (!e.latLng) { return null; }\r\n        if (!e.latLng.lat || !e.latLng.lng) { return null; }\r\n        return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };\r\n    }\r\n\r\n    /**\r\n     * Gets the map associted with the label.\r\n     *\r\n     * @memberof GoogleCanvasOverlay\r\n     * @method\r\n     */\r\n    public GetMap(): GoogleMapTypes.GoogleMap {\r\n        return (<any>this).getMap();\r\n    }\r\n\r\n    /**\r\n     * Returns a MapLabel instance for the current platform that can be used as a tooltip.\r\n     * This method only generates the map label. Content and placement is the responsibility\r\n     * of the caller.\r\n     *\r\n     * @returns - The label to be used for the tooltip.\r\n     * @memberof GoogleCanvasOverlay\r\n     * @method\r\n     */\r\n    public GetToolTipOverlay(): MapLabel {\r\n        const o: { [key: string]: any } = {\r\n            align: 'left',\r\n            offset: new google.maps.Point(0, 25),\r\n            backgroundColor: 'bisque',\r\n            hidden: true,\r\n            fontSize: 12,\r\n            fontColor: '#000000',\r\n            strokeWeight: 0\r\n        };\r\n        o.zIndex = 100000;\r\n        const label: MapLabel = new GoogleMapLabel(o);\r\n        label.SetMap(this.GetMap());\r\n        return label;\r\n    }\r\n\r\n    /**\r\n     * Called when the custom overlay is added to the map. Triggers Onload....\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    public OnAdd(): void {\r\n        super.OnAdd();\r\n        this.OnLoad();\r\n        this._canvas.style.zIndex = '100';\r\n            // move the canvas above primitives such as polygons.\r\n\r\n        // set the overlay to ready state\r\n        this._readyResolver(true);\r\n    }\r\n\r\n    /**\r\n     * Called whenever the canvas needs to be redrawn. This method does not do the actual\r\n     * update, it simply scales the canvas. The actual redraw happens once the map is idle.\r\n     * @memberof GoogleCanvasOverly\r\n     * @method\r\n     */\r\n    public OnDraw(): void {\r\n        const isStreetView: boolean = false;\r\n        const map: GoogleMapTypes.GoogleMap = this.GetMap();\r\n\r\n        if (isStreetView) {\r\n            // Don't show the canvas if the map is in Streetside mode.\r\n            this._canvas.style.display = 'none';\r\n        }\r\n        else {\r\n            // Re-drawing the canvas as it moves would be too slow. Instead, scale and translate canvas element.\r\n            // Upon idle or drag end, we can then redraw the canvas....\r\n            const zoomCurrent: number = map.getZoom();\r\n            const centerCurrent: GoogleMapTypes.LatLng = map.getCenter();\r\n\r\n            // Calculate map scale based on zoom level difference.\r\n            const scale: number = Math.pow(2, zoomCurrent - this._zoomStart);\r\n\r\n            // Calculate the scaled dimensions of the canvas.\r\n            const el: HTMLDivElement = map.getDiv();\r\n            const w: number = el.offsetWidth;\r\n            const h: number = el.offsetHeight;\r\n            const newWidth: number = w * scale;\r\n            const newHeight: number = h * scale;\r\n\r\n            // Calculate offset of canvas based on zoom and center offsets.\r\n            const projection = (<any>this).getProjection();\r\n            const cc = projection.fromLatLngToDivPixel(centerCurrent);\r\n\r\n            // Update the canvas CSS position and dimensions.\r\n            this.UpdatePosition(cc.x - newWidth / 2, cc.y - newHeight / 2, newWidth, newHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * CanvasOverlay loaded, attach map events for updating canvas.\r\n     * @method\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    public OnLoad(): void {\r\n        const isStreetView: boolean = false;\r\n        const map: GoogleMapTypes.GoogleMap = (<any>this).getMap();\r\n\r\n        // Get the current map view information.\r\n        this._zoomStart = map.getZoom();\r\n        const c: GoogleMapTypes.LatLng = map.getCenter();\r\n        this._centerStart = {\r\n            latitude: c.lat(),\r\n            longitude: c.lng()\r\n        };\r\n\r\n        // When the map stops moving, render new data on the canvas.\r\n        this._viewChangeEndEvent = google.maps.event.addListener(map, 'idle', (e: any) => {\r\n            this.UpdateCanvas();\r\n        });\r\n\r\n        // Update the position of the overlay when the map is resized.\r\n        this._mapResizeEvent = google.maps.event.addListener(map, 'resize', (e: any) => {\r\n            this.UpdateCanvas();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Associates the cnavas overlay with a map.\r\n     * @method\r\n     * @memberof GoogleCanvasOverlay\r\n     */\r\n    public SetMap(map: GoogleMapTypes.GoogleMap): void {\r\n        (<any>this).setMap(map);\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Attaches the canvas to the map.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     */\r\n    protected SetCanvasElement(el: HTMLCanvasElement): void {\r\n        const panes = (<any>this).getPanes();\r\n        if (panes) {\r\n            if (el != null) {\r\n                panes.overlayLayer.appendChild(el);\r\n                // 4: floatPane (infowindow)\r\n                // 3: overlayMouseTarget (mouse events)\r\n                // 2: markerLayer (marker images)\r\n                // 1: overlayLayer (polygons, polylines, ground overlays, tile layer overlays)\r\n                // 0: mapPane (lowest pane above the map tiles)\r\n            }\r\n            else {\r\n                panes.overlayLayer.removeChild(this._canvas);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove the map event handlers.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected RemoveEventHandlers(): void {\r\n        // Remove all event handlers from the map.\r\n        if (this._viewChangeEndEvent) { google.maps.event.removeListener(this._viewChangeEndEvent); }\r\n        if (this._mapResizeEvent) { google.maps.event.removeListener(this._mapResizeEvent); }\r\n    }\r\n\r\n    /**\r\n     * Updates the Canvas size based on the map size.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected Resize(): void {\r\n        const map: GoogleMapTypes.GoogleMap = (<any>this).getMap();\r\n\r\n        // Clear canvas by updating dimensions. This also ensures canvas stays the same size as the map.\r\n        const el: HTMLDivElement = map.getDiv();\r\n        this._canvas.width = el.offsetWidth;\r\n        this._canvas.height = el.offsetHeight;\r\n    }\r\n\r\n    /**\r\n     * Updates the Canvas.\r\n     * @memberof CanvasOverlay\r\n     * @method\r\n     * @protected\r\n     */\r\n    protected UpdateCanvas(): void {\r\n        const map: GoogleMapTypes.GoogleMap = (<any>this).getMap();\r\n\r\n        // Only render the canvas if it isn't in streetside mode.\r\n        if (true) {\r\n            this._canvas.style.display = '';\r\n\r\n            // Reset CSS position and dimensions of canvas.\r\n            const el: HTMLDivElement = map.getDiv();\r\n            const w: number = el.offsetWidth;\r\n            const h: number = el.offsetHeight;\r\n            const centerPoint = (<any>this).getProjection().fromLatLngToDivPixel(map.getCenter());\r\n            this.UpdatePosition((centerPoint.x - w / 2), (centerPoint.y - h / 2), w, h);\r\n\r\n            // Redraw the canvas.\r\n            this.Redraw(true);\r\n\r\n            // Get the current map view information.\r\n            this._zoomStart = map.getZoom();\r\n            const c: GoogleMapTypes.LatLng = map.getCenter();\r\n            this._centerStart = {\r\n                latitude: c.lat(),\r\n                longitude: c.lng()\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to extend the OverlayView into the CanvasOverlay\r\n *\r\n * @export\r\n * @method\r\n */\r\nexport function MixinCanvasOverlay() {\r\n    const x = GoogleCanvasOverlay.prototype;\r\n    GoogleCanvasOverlay.prototype = <any> new google.maps.OverlayView();\r\n    for (const y in x) { if ((<any>x)[y] != null) { (<any>GoogleCanvasOverlay.prototype)[y] = (<any>x)[y]; }}\r\n    (<any>GoogleCanvasOverlay.prototype)['onAdd'] = x['OnAdd'];\r\n    (<any>GoogleCanvasOverlay.prototype)['draw'] = x['OnDraw'];\r\n    (<any>GoogleCanvasOverlay.prototype)['onRemove'] = x['OnRemove'];\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { MapService } from './map.service';\r\nimport { MarkerService } from './marker.service';\r\nimport { InfoBoxService } from './infobox.service';\r\nimport { LayerService } from './layer.service';\r\nimport { ClusterService } from './cluster.service';\r\nimport { PolygonService } from './polygon.service';\r\nimport { PolylineService } from './polyline.service';\r\n\r\n/**\r\n * Implements a factory to create all the implementation specifc services for a map implementation\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class MapServiceFactory {\r\n\r\n    /**\r\n     * Creates the map service.\r\n     *\r\n     * @abstract\r\n     * @returns - {@link MapService} implementing a specific underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract Create(): MapService;\r\n\r\n    /**\r\n     * Creates the cluster service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @returns - {@link ClusterService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreateClusterService(map: MapService): ClusterService;\r\n\r\n    /**\r\n     * Creates the info box service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param marker - {@link MarkerService} implementation for thh underlying marker archticture.\r\n     * @returns - {@link InfoBoxService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreateInfoBoxService(map: MapService, marker: MarkerService): InfoBoxService;\r\n\r\n    /**\r\n     * Creates the layer service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @returns - {@link LayerService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreateLayerService(map: MapService): LayerService;\r\n\r\n    /**\r\n     * Creates the marker service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @param clusters  - {@link ClusterService} implementation for the underlying map architecture.\r\n     * @returns - {@link MarkerService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreateMarkerService(map: MapService, layers: LayerService, clusters: ClusterService): MarkerService;\r\n\r\n    /**\r\n     * Creates the polygon service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolygonService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreatePolygonService(map: MapService, layers: LayerService): PolygonService;\r\n\r\n    /**\r\n     * Creates the polyline service.\r\n     *\r\n     * @abstract\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolylineService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    abstract CreatePolylineService(map: MapService, layers: LayerService): PolylineService;\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { IMapOptions } from '../interfaces/imap-options';\r\nimport { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ISize } from '../interfaces/isize';\r\nimport { IBox } from '../interfaces/ibox';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { IInfoWindowOptions } from '../interfaces/iinfo-window-options';\r\nimport { Marker } from '../models/marker';\r\nimport { Layer } from '../models/layer';\r\nimport { Polygon } from '../models/polygon';\r\nimport { Polyline } from '../models/polyline';\r\nimport { InfoWindow } from '../models/info-window';\r\nimport { CanvasOverlay } from '../models/canvas-overlay';\r\n\r\n/**\r\n * Abstract class to implement map api. A concrete implementation should be created for each\r\n * Map provider supported (e.g. Bing, Goolge, ESRI)\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class MapService {\r\n\r\n    ///\r\n    /// Public properties\r\n    ///\r\n\r\n    /**\r\n     * Gets the Map control instance underlying the implementation\r\n     *\r\n     * @readonly\r\n     * @memberof MapService\r\n     */\r\n    abstract get MapInstance(): any;\r\n\r\n    /**\r\n     * Gets a Promise for a Map control instance underlying the implementation. Use this instead of {@link MapInstance} if you\r\n     * are not sure if and when the instance will be created.\r\n     * @readonly\r\n     * @memberof MapService\r\n     */\r\n    abstract get MapPromise(): Promise<any>;\r\n\r\n    /**\r\n     * Gets the maps physical size.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof MapService\r\n     */\r\n    abstract get MapSize(): ISize;\r\n\r\n\r\n    ///\r\n    /// Public methods and MapService interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Gets a random geo locations filling the bounding box.\r\n     *\r\n     * @param count - number of locations to return\r\n     * @param bounds  - bounding box.\r\n     * @returns - Array of geo locations.\r\n     * @memberof MapService\r\n     */\r\n    public static GetRandonLocations(count: number, bounds: IBox): Array<ILatLong> {\r\n        const a: Array<ILatLong> = [];\r\n        const _getRandomLocation = (b: IBox) => {\r\n            const lat: number = Math.random() * (b.maxLatitude - b.minLatitude) + b.minLatitude;\r\n            let lng: number = 0;\r\n            if (crossesDateLine) {\r\n                lng = Math.random() * (b.minLongitude + 360 - b.maxLongitude) + b.maxLongitude;\r\n                if (lng > 180) { lng = lng - 360; }\r\n            }\r\n            else {\r\n                lng = Math.random() * (b.maxLongitude - b.minLongitude) + b.minLongitude;\r\n            }\r\n            const p: ILatLong = { latitude: lat, longitude: lng };\r\n            return p;\r\n        };\r\n        let crossesDateLine: boolean = false;\r\n\r\n        if (bounds == null) { bounds = <IBox>{\r\n                maxLatitude: 360,\r\n                minLatitude: 0,\r\n                maxLongitude: 170,\r\n                minLongitude: 0\r\n            };\r\n        }\r\n        if (bounds.center.longitude < bounds.minLongitude  || bounds.center.longitude > bounds.maxLongitude) { crossesDateLine = true; }\r\n        if (!count || count <= 0) {\r\n            return [_getRandomLocation(bounds)];\r\n        }\r\n        for (let r = 0; r < count; r++) { a.push(_getRandomLocation(bounds)); }\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * Creates a canvas overlay layer to perform custom drawing over the map with out\r\n     * some of the overhead associated with going through the Map objects.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @returns - Promise of a {@link CanvasOverlay} object.\r\n     * @memberof MapService\r\n     * @abstract\r\n     */\r\n    public abstract CreateCanvasOverlay(drawCallback: (canvas: HTMLCanvasElement) => void): Promise<CanvasOverlay>;\r\n\r\n    /**\r\n     * Creates a map cluster layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link IClusterOptions}.\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying native layer object.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateClusterLayer(options: ILayerOptions): Promise<Layer>;\r\n\r\n    /**\r\n     * Creates an information window for a map position\r\n     *\r\n     * @param [options] - Infowindow options. See {@link IInfoWindowOptions}\r\n     * @returns - Promise of a {@link InfoWindow} object, which models the underlying natvie infobox object.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateInfoWindow(options?: IInfoWindowOptions): Promise<InfoWindow>;\r\n\r\n    /**\r\n     * Creates a map layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link ILayerOptions}\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying native layer object.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateLayer(options: ILayerOptions): Promise<Layer>;\r\n\r\n    /**\r\n     * Creates a map instance\r\n     *\r\n     * @param el - HTML element to host the map.\r\n     * @param mapOptions - Map options\r\n     * @returns - Promise fullfilled once the map has been created.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateMap(el: HTMLElement, mapOptions: IMapOptions): Promise<void>;\r\n\r\n    /**\r\n     * Creates a map marker within the map context\r\n     *\r\n     * @param [options=<IMarkerOptions>{}] - Options for the marker. See {@link IMarkerOptions}.\r\n     * @returns - Promise of a {@link Marker} object, which models the underlying native pushpin object.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreateMarker(options: IMarkerOptions): Promise<Marker>;\r\n\r\n    /**\r\n     * Creates a polygon within the map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polygon. See {@link IPolygonOptions}.\r\n     * @returns - Promise of a {@link Polygon} object, which models the underlying native polygon.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreatePolygon(options: IPolygonOptions): Promise<Polygon>;\r\n\r\n    /**\r\n     * Creates a polyline within the map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polyline. See {@link IPolylineOptions}.\r\n     * @returns - Promise of a {@link Polyline} object (or an array thereof for complex paths),\r\n     * which models the underlying native polyline.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract CreatePolyline(options: IPolylineOptions): Promise<Polyline|Array<Polyline>>;\r\n\r\n    /**\r\n     * Deletes a layer from the map.\r\n     *\r\n     * @param layer - Layer to delete. See {@link Layer}.\r\n     * @returns - Promise fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract DeleteLayer(layer: Layer): Promise<void>;\r\n\r\n    /**\r\n     * Dispaose the map and associated resoures.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract DisposeMap(): void;\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map bounds\r\n     *\r\n     * @returns - A promise that when fullfilled contains the bounding box of the screen. See {@link IBox}.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract GetBounds(): Promise<IBox>;\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map center\r\n     *\r\n     * @returns - A promise that when fullfilled contains the goe location of the center. See {@link ILatLong}.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract GetCenter(): Promise<ILatLong>;\r\n\r\n    /**\r\n     * Gets the current zoom level of the map.\r\n     *\r\n     * @returns - A promise that when fullfilled contains the zoom level.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract GetZoom(): Promise<number>;\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface representing the pixels. This promise resolves to null\r\n     * if the goe coordinates are not in the view port.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract LocationToPoint(loc: ILatLong): Promise<IPoint>;\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface array representing the pixels.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract LocationsToPoints(locs: Array<ILatLong>): Promise<Array<IPoint>>;\r\n\r\n    /**\r\n     * Centers the map on a geo location.\r\n     *\r\n     * @param latLng - GeoCoordinates around which to center the map. See {@link ILatLong}\r\n     * @returns - Promise that is fullfilled when the center operations has been completed.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SetCenter(latLng: ILatLong): Promise<void>;\r\n\r\n    /**\r\n     * Sets the generic map options.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SetMapOptions(options: IMapOptions): void;\r\n\r\n    /**\r\n     * Sets the view options of the map.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SetViewOptions(options: IMapOptions): void;\r\n\r\n    /**\r\n     * Sets the zoom level of the map.\r\n     *\r\n     * @param zoom - Zoom level to set.\r\n     * @returns - A Promise that is fullfilled once the zoom operation is complete.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SetZoom(zoom: number): Promise<void>;\r\n\r\n    /**\r\n     * Creates an event subscription\r\n     *\r\n     * @param eventName - The name of the event (e.g. 'click')\r\n     * @returns - An observable of tpye E that fires when the event occurs.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract SubscribeToMapEvent<E>(eventName: string): Observable<E>;\r\n\r\n    /**\r\n     * Triggers the given event name on the map instance.\r\n     *\r\n     * @param eventName - Event to trigger.\r\n     * @returns - A promise that is fullfilled once the event is triggered.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    abstract TriggerMapEvent(eventName: string): Promise<void>;\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { Marker } from '../models/marker';\r\nimport { MapMarkerDirective } from '../components/map-marker';\r\n\r\n/**\r\n * The abstract class represents the contract defintions for a marker service to be implemented by an acutaly underlying\r\n * map architecture.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class MarkerService {\r\n\r\n    /**\r\n     * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.\r\n     *\r\n     * @abstract\r\n     * @param marker - The {@link MapMarkerDirective} to be added.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract AddMarker(marker: MapMarkerDirective): void;\r\n\r\n    /**\r\n     * Registers an event delegate for a marker.\r\n     *\r\n     * @abstract\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param marker - The {@link MapMarker} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract CreateEventObservable<T>(eventName: string, marker: MapMarkerDirective): Observable<T>;\r\n\r\n    /**\r\n     * Deletes a marker.\r\n     *\r\n     * @abstract\r\n     * @param marker - {@link MapMarkerDirective} to be deleted.\r\n     * @returns - A promise fullfilled once the marker has been deleted.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract DeleteMarker(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Obtains geo coordinates for the marker on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract GetCoordinatesFromClick(e: MouseEvent| any): ILatLong;\r\n\r\n    /**\r\n     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.\r\n     *\r\n     * @abstract\r\n     * @param marker - The {@link MapMarkerDirective} for which to obtain the marker model.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} implementation of the underlying platform.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract GetNativeMarker(marker: MapMarkerDirective): Promise<Marker>;\r\n\r\n    /**\r\n     * Obtains the marker pixel location for the marker on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the pixels of the marker on the map canvas.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract GetPixelsFromClick(e: MouseEvent| any): IPoint;\r\n\r\n    /**\r\n     * Converts a geo location to a pixel location relative to the map canvas.\r\n     *\r\n     * @abstract\r\n     * @param target - Either a {@link MapMarkerDirective} or a {@link ILatLong}\r\n     * for the basis of translation.\r\n     * @returns - A promise that when fullfilled contains a {@link IPoint}\r\n     * with the pixel coordinates of the MapMarkerDirective or ILatLong relative to the map canvas.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract LocationToPoint(target: MapMarkerDirective | ILatLong): Promise<IPoint>;\r\n\r\n    /**\r\n     * Updates the anchor position for the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the anchor.\r\n     * Anchor information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the anchor position has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateAnchor(maker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates whether the marker is draggable.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate dragability.\r\n     * Dragability information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the marker has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateDraggable(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the Icon on the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the icon.\r\n     * Icon information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the icon information has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateIcon(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the label on the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the label.\r\n     * Label information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the label has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateLabel(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the geo coordinates for the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the coordinates.\r\n     * Coordinate information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the position has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateMarkerPosition(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the title on the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the title.\r\n     * Title information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the title has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateTitle(marker: MapMarkerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Updates the visibility on the marker.\r\n     *\r\n     * @abstract\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the visibility.\r\n     * Visibility information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the visibility has been updated.\r\n     *\r\n     * @memberof MarkerService\r\n     */\r\n    public abstract UpdateVisible(marker: MapMarkerDirective): Promise<void>;\r\n\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { InfoBoxComponent } from '../components/infobox';\r\nimport { IInfoWindowOptions } from '../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { InfoWindow } from '../models/info-window';\r\n\r\n/**\r\n * This class defines the contract for an InfoBoxService. Each Map Architecture provider is expected the furnish a concrete implementation.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class InfoBoxService {\r\n\r\n    /**\r\n     * Adds an info window to the map or layer.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract AddInfoWindow(info: InfoBoxComponent): void;\r\n\r\n    /**\r\n     * Closes an infobox that is open.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been closed.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract Close(info: InfoBoxComponent): Promise<void>;\r\n\r\n    /**\r\n     * Subscribe to events on the infowindow.\r\n     *\r\n     * @abstract\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param infoComponent - The {@link InfoBoxComponent} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract CreateEventObservable<T>(event: string, infoBoxComponent: InfoBoxComponent): Observable<T>;\r\n\r\n\r\n    /**\r\n     * Deletes an infobox.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been deleted.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract DeleteInfoWindow(info: InfoBoxComponent): Promise<void>;\r\n\r\n    /**\r\n     * Opens an infobox that is closed.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been opened.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract Open(info: InfoBoxComponent, loc?: ILatLong): Promise<void>;\r\n\r\n    /**\r\n     * Sets the infobox options.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @param options - {@link IInfoWindowOptions} object containing the options to set. Options provided are\r\n     * merged with the existing options of the underlying infobox.\r\n     * @returns - A promise that is fullfilled when the infobox options have been updated.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract SetOptions(info: InfoBoxComponent, options: IInfoWindowOptions): Promise<void>;\r\n\r\n    /**\r\n     * Set the position of the infobox based on the properties set on the InfoBox component.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @param latlng - The position to set\r\n     * @returns - A promise that is fullfilled when the infobox position has been updated.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    abstract SetPosition(info: InfoBoxComponent, latlng?: ILatLong): Promise<void>;\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { Marker } from '../models/marker';\r\nimport { Polygon } from '../models/polygon';\r\nimport { Polyline } from '../models/polyline';\r\nimport { Layer } from '../models/layer';\r\nimport { MapLayerDirective } from '../components/map-layer';\r\n\r\n/**\r\n * Abstract class to to define the layer service contract. Must be realized by implementing provider.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class LayerService {\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract AddLayer(layer: MapLayerDirective): void;\r\n\r\n    /**\r\n     * Adds a marker to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the marker.\r\n     * @param options - Marker options defining the marker.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Marker model.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreateMarker(layer: number, options: IMarkerOptions): Promise<Marker>;\r\n\r\n    /**\r\n     * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk\r\n     * operations.\r\n     *\r\n     * @abstract\r\n     * @param options - Marker options defining the markers.\r\n     * @param markerIcon - Optional information to generate custom markers. This will be applied to all markers.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Marker models.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreateMarkers(options: Array<IMarkerOptions>, markerIcon?: IMarkerIconInfo): Promise<Array<Marker>>;\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polygon options defining the line.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon>;\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>>;\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polyline options defining the marker.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an\r\n     * array of polylines for complex paths) model.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreatePolyline(layer: number, options: IPolygonOptions): Promise<Polyline|Array<Polyline>>;\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>>;\r\n\r\n    /**\r\n     * Deletes the layer\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object for which to retrieve the layer.\r\n     * @returns - A promise that is fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract DeleteLayer(layer: MapLayerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Returns the Layer model represented by this layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object or MapLayerId for which to retrieve the layer model.\r\n     * @returns - A promise that when resolved contains the Layer model.\r\n     *\r\n     * @memberof LayerService\r\n     */\r\n    public abstract GetNativeLayer(layer: MapLayerDirective|number): Promise<Layer>;\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { Polygon } from '../models/polygon';\r\nimport { MapPolygonDirective } from '../components/map-polygon';\r\n\r\n/**\r\n * The abstract class represents the contract defintions for a polygon service to be implemented by an acutaly underlying\r\n * map architecture.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class PolygonService {\r\n\r\n  /**\r\n   * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a\r\n   * correcsponding layer.\r\n   *\r\n   * @abstract\r\n   * @param polygon - The {@link MapPolygonDirective} to be added.\r\n   *\r\n   * @memberof PolygonService\r\n   */\r\n  public abstract AddPolygon(polygon: MapPolygonDirective): void;\r\n\r\n  /**\r\n    * Registers an event delegate for a marker.\r\n    *\r\n    * @abstract\r\n    * @param eventName - The name of the event to register (e.g. 'click')\r\n    * @param polygon - The {@link MapPolygonDirective} for which to register the event.\r\n    * @returns - Observable emiting an instance of T each time the event occurs.\r\n    *\r\n    * @memberof PolygonService\r\n    */\r\n  public abstract CreateEventObservable<T>(eventName: string, polygon: MapPolygonDirective): Observable<T>;\r\n\r\n  /**\r\n    * Deletes a polygon.\r\n    *\r\n    * @abstract\r\n    * @param polygon - {@link MapPolygonDirective} to be deleted.\r\n    * @returns - A promise fullfilled once the polygon has been deleted.\r\n    *\r\n    * @memberof PolygonService\r\n    */\r\n  public abstract DeletePolygon(polygon: MapPolygonDirective): Promise<void>;\r\n\r\n  /**\r\n   * Obtains geo coordinates for the marker on the click location\r\n   *\r\n   * @abstract\r\n   * @param e - The mouse event.\r\n   * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n   *\r\n   * @memberof MarkerService\r\n   */\r\n  public abstract GetCoordinatesFromClick(e: MouseEvent | any): ILatLong;\r\n\r\n  /**\r\n   * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.\r\n   *\r\n   * @abstract\r\n   * @param polygon - The {@link MapPolygonDirective} for which to obtain the polygon model.\r\n   * @returns - A promise that when fullfilled contains the {@link Polygon} implementation of the underlying platform.\r\n   *\r\n   * @memberof PolygonService\r\n   */\r\n  public abstract GetNativePolygon(polygon: MapPolygonDirective): Promise<Polygon>;\r\n\r\n  /**\r\n   * Set the polygon options.\r\n   *\r\n   * @abstract\r\n   * @param polygon - {@link MapPolygonDirective} to be updated.\r\n   * @param options - {@link IPolygonOptions} object containing the options. Options will be merged with the\r\n   * options already on the underlying object.\r\n   * @returns - A promise fullfilled once the polygon options have been set.\r\n   *\r\n   * @memberof PolygonService\r\n   */\r\n  public abstract SetOptions(polygon: MapPolygonDirective, options: IPolygonOptions): Promise<void>;\r\n\r\n  /**\r\n   * Updates the Polygon path\r\n   *\r\n   * @abstract\r\n   * @param polygon - {@link MapPolygonDirective} to be updated.\r\n   * @returns - A promise fullfilled once the polygon has been updated.\r\n   *\r\n   * @memberof PolygonService\r\n   */\r\n  public abstract UpdatePolygon(polygon: MapPolygonDirective): Promise<void>;\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { Polyline } from '../models/polyline';\r\nimport { MapPolylineDirective } from '../components/map-polyline';\r\n\r\n/**\r\n * The abstract class represents the contract defintions for a polyline service to be implemented by an acutaly underlying\r\n * map architecture.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class PolylineService {\r\n\r\n  /**\r\n   * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a\r\n   * correcsponding layer.\r\n   *\r\n   * @abstract\r\n   * @param polyline - The {@link MapPolylineDirective} to be added.\r\n   *\r\n   * @memberof PolylineService\r\n   */\r\n  public abstract AddPolyline(polyline: MapPolylineDirective): void;\r\n\r\n  /**\r\n    * Registers an event delegate for a marker.\r\n    *\r\n    * @abstract\r\n    * @param eventName - The name of the event to register (e.g. 'click')\r\n    * @param polyline - The {@link MapPolylineDirective} for which to register the event.\r\n    * @returns - Observable emiting an instance of T each time the event occurs.\r\n    *\r\n    * @memberof PolylineService\r\n    */\r\n  public abstract CreateEventObservable<T>(eventName: string, polyline: MapPolylineDirective): Observable<T>;\r\n\r\n  /**\r\n    * Deletes a polyline.\r\n    *\r\n    * @abstract\r\n    * @param polyline - {@link MapPolylineDirective} to be deleted.\r\n    * @returns - A promise fullfilled once the polyline has been deleted.\r\n    *\r\n    * @memberof PolylineService\r\n    */\r\n  public abstract DeletePolyline(polyline: MapPolylineDirective): Promise<void>;\r\n\r\n  /**\r\n   * Obtains geo coordinates for the marker on the click location\r\n   *\r\n   * @abstract\r\n   * @param e - The mouse event.\r\n   * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n   *\r\n   * @memberof MarkerService\r\n   */\r\n  public abstract GetCoordinatesFromClick(e: MouseEvent | any): ILatLong;\r\n\r\n  /**\r\n   * Obtains the polyline model for the polyline allowing access to native implementation functionatiliy.\r\n   *\r\n   * @abstract\r\n   * @param polyline - The {@link MapPolylineDirective} for which to obtain the polyline model.\r\n   * @returns - A promise that when fullfilled contains the {@link Polyline} implementation (or an\r\n   * array of polylines) for complex paths of the underlying platform.\r\n   *\r\n   * @memberof PolylineService\r\n   */\r\n  public abstract GetNativePolyline(polyline: MapPolylineDirective): Promise<Polyline|Array<Polyline>>;\r\n\r\n  /**\r\n   * Set the polyline options.\r\n   *\r\n   * @abstract\r\n   * @param polyline - {@link MapPolylineDirective} to be updated.\r\n   * @param options - {@link IPolylineOptions} object containing the options. Options will be merged with the\r\n   * options already on the underlying object.\r\n   * @returns - A promise fullfilled once the polyline options have been set.\r\n   *\r\n   * @memberof PolylineService\r\n   */\r\n  public abstract SetOptions(polyline: MapPolylineDirective, options: IPolylineOptions): Promise<void>;\r\n\r\n  /**\r\n   * Updates the Polyline path\r\n   *\r\n   * @abstract\r\n   * @param polyline - {@link MapPolylineDirective} to be updated.\r\n   * @returns - A promise fullfilled once the polyline has been updated.\r\n   *\r\n   * @memberof PolylineService\r\n   */\r\n  public abstract UpdatePolyline(polyline: MapPolylineDirective): Promise<void>;\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { Marker } from '../models/marker';\r\nimport { Layer } from '../models/layer';\r\nimport { Polygon } from '../models/polygon';\r\nimport { Polyline } from '../models/polyline';\r\nimport { ClusterLayerDirective } from '../components/cluster-layer';\r\nimport { LayerService } from './layer.service';\r\n\r\n/**\r\n * Abstract class to to define teh cluster layer service contract. Must be realized by implementing provider.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class ClusterService extends LayerService {\r\n\r\n    /**\r\n     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities\r\n     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @param layer - ClusterLayerDirective component object for which to retrieve the layer.\r\n     *\r\n     * @memberof ClusterService\r\n     */\r\n    public abstract StartClustering(layer: ClusterLayerDirective): Promise<void>;\r\n\r\n    /**\r\n     * Stop to actually cluster the entities in a cluster layer.\r\n     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @param layer - ClusterLayerDirective component object for which to retrieve the layer.\r\n     *\r\n     * @memberof ClusterService\r\n     */\r\n    public abstract StopClustering(layer: ClusterLayerDirective): Promise<void>;\r\n\r\n}\r\n","import { Directive, Input, Output, EventEmitter } from '@angular/core';\r\n\r\n/**\r\n * InfoBoxAction renders an action in an info window {@link InfoBox}\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective, InfoBoxComponent, InfoBoxActionDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *    .map-container { height: 300px; }\r\n *  `],\r\n *  template: `\r\n *    <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-marker [Latitude]=\"lat\" [Longitude]=\"lng\" [Label]=\"'M'\">\r\n *        <x-info-box>\r\n *          <x-info-box-action [Label]=\"actionlabel\" (ActionClicked)=\"actionClicked(this)\"></x-info-box-action>\r\n *        </x-info-box>\r\n *      </x-map-marker>\r\n *    </x-map>\r\n *  `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-info-box-action'\r\n})\r\nexport class InfoBoxActionDirective {\r\n\r\n    /**\r\n     * The label to display on the action\r\n     *\r\n     * @memberof InfoBoxActionDirective\r\n     */\r\n    @Input()\r\n    Label: string;\r\n\r\n    /**\r\n     * Emits an event when the action has been clicked\r\n     *\r\n     * @memberof InfoBoxActionDirective\r\n     */\r\n    @Output()\r\n    ActionClicked: EventEmitter<void> = new EventEmitter<void>();\r\n\r\n}\r\n","import {\r\n    AfterViewInit,\r\n    Component,\r\n    ContentChildren,\r\n    ElementRef,\r\n    EventEmitter,\r\n    Input,\r\n    OnChanges,\r\n    OnDestroy,\r\n    Output,\r\n    QueryList,\r\n    SimpleChange,\r\n    ViewChild,\r\n    ViewEncapsulation\r\n} from '@angular/core';\r\nimport { IInfoWindowOptions } from '../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { InfoBoxService } from '../services/infobox.service';\r\nimport { MapMarkerDirective } from './map-marker';\r\nimport { InfoBoxActionDirective } from './infobox-action';\r\n\r\n/**\r\n * internal counter to use as ids for multiple infoboxes.\r\n */\r\nlet infoBoxId = 0;\r\n\r\n/**\r\n * InfoBox renders a info window inside a {@link MapMarkerDirective} or standalone.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective, InfoBoxComponent, InfoBoxActionDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *    .map-container { height: 300px; }\r\n * `],\r\n *  template: `\r\n *    <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-marker [Latitude]=\"lat\" [Longitude]=\"lng\" [Label]=\"'M'\">\r\n *        <x-info-box [DisableAutoPan]=\"true\">\r\n *          Hi, this is the content of the <strong>info window</strong>\r\n *         </x-info-box>\r\n *       </x-map-marker>\r\n *     </x-map>\r\n *  `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Component({\r\n    selector: 'x-info-box',\r\n    template: `\r\n        <div #infoBoxContent class='info-box-content'>\r\n            <ng-content></ng-content>\r\n        </div>`,\r\n    styles: [`\r\n        x-map .MicrosoftMap .Infobox .infobox-title { padding: 10px 10px 5px 10px }\r\n        x-map .MicrosoftMap .Infobox .infobox-info { padding: 3px 10px 10px 10px }\r\n        x-map .MicrosoftMap .Infobox .infobox-actions { height: auto }\r\n    `],\r\n    encapsulation: ViewEncapsulation.None\r\n})\r\nexport class InfoBoxComponent implements OnDestroy, OnChanges, AfterViewInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _infoBoxAddedToManager = false;\r\n    private _id: string = (infoBoxId++).toString();\r\n\r\n    /**\r\n     * HTML conent of the infobox\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @ViewChild('infoBoxContent') private _content: ElementRef;\r\n\r\n    /**\r\n     * Zero or more actions to show on the info window\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @ContentChildren(InfoBoxActionDirective) public InfoWindowActions: QueryList<InfoBoxActionDirective>;\r\n\r\n\r\n    /**\r\n     * The latitude position of the info window (only usefull if you use it ouside of a {@link MapMarker}).\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Latitude: number;\r\n\r\n    /**\r\n     * The longitude position of the info window (only usefull if you use it ouside of a {@link MapMarker}).\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Longitude: number;\r\n\r\n    /**\r\n     * The title to display in the info window\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Title: string;\r\n\r\n    /**\r\n     * The description to display in the info window.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Description: string;\r\n\r\n    /**\r\n     * Disable auto-pan on open. By default, the info window will pan the map so that it is fully\r\n     * visible when it opens.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public DisableAutoPan: boolean;\r\n\r\n    /**\r\n     *  Maximum width of the infowindow, regardless of content's width. This value is only considered\r\n     *  if it is set before a call to open. To change the maximum width when changing content, call\r\n     *  close, update maxWidth, and then open.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public MaxWidth: number;\r\n\r\n    /**\r\n     * Determine whether only one infobox can be open at a time. Note that ANY info box settings.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Modal = true;\r\n\r\n    /**\r\n     * Holds the marker that is the host of the info window (if available)\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public HostMarker: MapMarkerDirective;\r\n\r\n    /**\r\n     * Determines visibility of infobox\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public Visible = false;\r\n\r\n    /**\r\n     * Horizontal offset of the infobox from the host marker lat/long or the sepecified coordinates.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public xOffset: number;\r\n\r\n    /**\r\n     * Vertical offset for the infobox from the host marker lat/long or the specified coordinates.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public yOffset: number;\r\n\r\n    /**\r\n     * Determines if other info boxes should be closed before opening this one\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Input() public CloseInfoBoxesOnOpen = true;\r\n\r\n    ///\r\n    /// Delegate defintions\r\n    ///\r\n\r\n    /**\r\n     * Emits an event when the info window is closed.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    @Output() public InfoBoxClose: EventEmitter<string> = new EventEmitter<string>();\r\n\r\n    ///\r\n    /// Property declarations.\r\n    ///\r\n\r\n    /**\r\n     * Gets the HTML content of the info box.\r\n     *\r\n     * @readonly\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public get HtmlContent(): string {\r\n        if (this._content.nativeElement && this._content.nativeElement.innerText && this._content.nativeElement.innerText.trim() !== '') {\r\n            return this._content.nativeElement.outerHTML;\r\n        }\r\n        return '';\r\n    }\r\n\r\n    /**\r\n     * Gets the Id of the info box as a string.\r\n     *\r\n     * @readonly\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public get Id(): string { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of InfoBoxComponent.\r\n     * @param _infoBoxService - Concrete {@link InfoBoxService} implementation for underlying Map architecture.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    constructor(private _infoBoxService: InfoBoxService) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Closes the Infobox.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public Close(): Promise<void> {\r\n        return this._infoBoxService.Close(this).then(() => {\r\n            this.InfoBoxClose.emit(this._id);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called on after component view as been initialized. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof Map\r\n     */\r\n    public ngAfterViewInit() {\r\n        this._infoBoxService.AddInfoWindow(this);\r\n        this._infoBoxAddedToManager = true;\r\n        this.HandleEvents();\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof Map\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        if (!this._infoBoxAddedToManager) { return; }\r\n        if ((changes['latitude'] || changes['longitude']) && typeof this.Latitude === 'number' &&\r\n            typeof this.Longitude === 'number') {\r\n            this._infoBoxService.SetPosition(this, {\r\n                latitude: changes['latitude'].currentValue,\r\n                longitude: changes['longitude'].currentValue\r\n            });\r\n        }\r\n        this.SetInfoWindowOptions(changes);\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof Map\r\n     */\r\n    public ngOnDestroy() { this._infoBoxService.DeleteInfoWindow(this); }\r\n\r\n    /**\r\n     * Opens a closed info window.\r\n     *\r\n     * @param [loc]  - {@link ILatLong } representing position on which to open the window.\r\n     * @returns - Promise that is fullfilled when the infobox has been opened.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public Open(loc?: ILatLong): Promise<void> {\r\n        return this._infoBoxService.Open(this, loc);\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the info box.\r\n     *\r\n     * @returns - string representation of the info box.\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    public ToString(): string { return 'InfoBoxComponent-' + this._id; }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Delegate handling the map click events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleEvents(): void {\r\n        this._infoBoxService.CreateEventObservable('infowindowclose', this).subscribe(e => {\r\n            this.InfoBoxClose.emit(this._id);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the info window options\r\n     *\r\n     * @param changes\r\n     *\r\n     * @memberof InfoBoxComponent\r\n     */\r\n    private SetInfoWindowOptions(changes: { [key: string]: SimpleChange }) {\r\n        const options: IInfoWindowOptions = {};\r\n        if (changes['title']) { options.title = this.Title; }\r\n        if (changes['description']) { options.description = this.Description; }\r\n        if (changes['disableAutoPan']) { options.disableAutoPan = this.DisableAutoPan; }\r\n        if (changes['visible']) { options.visible = this.Visible; }\r\n        if (changes['xOffset'] || changes['yOffset']) {\r\n            if (options.pixelOffset == null) { options.pixelOffset = { x: 0, y: 0 }; }\r\n            options.pixelOffset.x = this.xOffset;\r\n            options.pixelOffset.y = this.yOffset;\r\n        }\r\n        this._infoBoxService.SetOptions(this, options);\r\n    }\r\n}\r\n","import {\r\n    Directive, SimpleChange, Input, Output, OnDestroy, OnChanges,\r\n    EventEmitter, ContentChild, AfterContentInit, ViewContainerRef\r\n} from '@angular/core';\r\nimport { Subscription, timer } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IMarkerEvent } from '../interfaces/imarker-event';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { MarkerService } from '../services/marker.service';\r\nimport { InfoBoxComponent } from './infobox';\r\n\r\n/**\r\n * internal counter to use as ids for marker.\r\n */\r\nlet markerId = 0;\r\n\r\n/**\r\n * MapMarkerDirective renders a map marker inside a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-marker [Latitude]=\"lat\" [Longitude]=\"lng\" [Label]=\"'M'\"></x-map-marker>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-marker'\r\n})\r\nexport class MapMarkerDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _clickTimeout: Subscription = null;\r\n    private _events: Subscription[] = [];\r\n    private _id: string;\r\n    private _inClusterLayer = false;\r\n    private _inCustomLayer = false;\r\n\r\n    /**\r\n     * Any InfoBox that is a direct children of the marker\r\n     *\r\n     * @protected\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @ContentChild(InfoBoxComponent) protected _infoBox: InfoBoxComponent;\r\n\r\n    private _layerId: number;\r\n    private _markerAddedToManger = false;\r\n\r\n    /**\r\n     *  Icon anchor relative to marker root\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Anchor: IPoint;\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() DblClick: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is repeatedly fired while the user drags the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() Drag: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user stops dragging the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() DragEnd: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * If true, the marker can be dragged. Default value is false.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Draggable = false;\r\n\r\n    /**\r\n     * This event is fired when the user starts dragging the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() DragStart: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when a marker icon is being created.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() public DynamicMarkerCreated: EventEmitter<IMarkerIconInfo> = new EventEmitter<IMarkerIconInfo>();\r\n\r\n    /**\r\n     * Icon height\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Height: number;\r\n\r\n    /**\r\n     * Information for dynamic, custom created icons.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public IconInfo: IMarkerIconInfo;\r\n\r\n    /**\r\n     * Icon (the URL of the image) for the foreground.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public IconUrl: string;\r\n\r\n    /**\r\n     * True to indiciate whether this is the first marker in a set.\r\n     * Use this for bulk operations (particularily clustering) to ensure performance.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public IsFirstInSet = false;\r\n\r\n    /**\r\n     * True to indiciate whether this is the last marker in a set.\r\n     * Use this for bulk operations (particularily clustering) to ensure performance.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public IsLastInSet = true;\r\n\r\n    /**\r\n     * The label (a single uppercase character) for the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Label: string;\r\n\r\n    /**\r\n     * The latitude position of the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Latitude: number;\r\n\r\n    /**\r\n     * The longitude position of the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Longitude: number;\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks on the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() public MarkerClick: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * Arbitary metadata to assign to the Marker. This is useful for events\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousedown event is fired on the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseDown: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseMove: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired on marker mouseout.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseOut: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired on marker mouseover.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseOver: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired whe the DOM mouseup event is fired on the marker\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() MouseUp: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This even is fired when the marker is right-clicked on.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Output() RightClick: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     *  The title of the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Title: string;\r\n\r\n    /**\r\n     * Sets the visibility of the marker\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * Icon Width\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    @Input() public Width: number;\r\n\r\n    ///\r\n    /// Delegates\r\n    ///\r\n\r\n\r\n\r\n\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Getswhether the marker has already been added to the marker service and is ready for use.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get AddedToManager(): boolean { return this._markerAddedToManger; }\r\n\r\n    /**\r\n     * Gets the id of the marker as a string.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get Id(): string { return this._id; }\r\n\r\n    /**\r\n     * Gets whether the marker is in a cluster layer. See {@link ClusterLayer}.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get InClusterLayer(): boolean { return this._inClusterLayer; }\r\n\r\n    /**\r\n     * Gets whether the marker is in a custom layer. See {@link MapLayer}.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get InCustomLayer(): boolean { return this._inCustomLayer; }\r\n\r\n    /**\r\n     * gets the id of the Layer the marker belongs to.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public get LayerId(): number { return this._layerId; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapMarkerDirective.\r\n     * @param _markerService - Concreate implementation of a {@link MarkerService}.\r\n     * @param _containerRef - View container hosting the marker.\r\n     * Used to determine parent layer through markup.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    constructor(private _markerService: MarkerService, private _containerRef: ViewContainerRef) {\r\n        this._id = (markerId++).toString();\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Translates a marker geo location to a pixel location relative to the map viewport.\r\n     *\r\n     * @param [loc] - {@link ILatLong} containing the geo coordinates. If null, the marker's coordinates are used.\r\n     * @returns - A promise that when fullfilled contains an {@link IPoint} representing the pixel coordinates.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public LocationToPixel(loc?: ILatLong): Promise<IPoint> {\r\n        return this._markerService.LocationToPoint(loc ? loc : this);\r\n    }\r\n\r\n    /**\r\n     * Called after Component content initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public ngAfterContentInit() {\r\n        if (this._infoBox != null) { this._infoBox.HostMarker = this; }\r\n        if (this._containerRef.element.nativeElement.parentElement) {\r\n            const parentName: string = this._containerRef.element.nativeElement.parentElement.tagName;\r\n            if (parentName.toLowerCase() === 'x-cluster-layer') {\r\n                this._inClusterLayer = true;\r\n            } else if (parentName.toLowerCase() === 'x-map-layer') {\r\n                this._inCustomLayer = true;\r\n            }\r\n            this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);\r\n        }\r\n        if (!this._markerAddedToManger) {\r\n            this._markerService.AddMarker(this);\r\n            this._markerAddedToManger = true;\r\n            this.AddEventListeners();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        if (typeof this.Latitude !== 'number' || typeof this.Longitude !== 'number') {\r\n            return;\r\n        }\r\n        if (!this._markerAddedToManger) { return; }\r\n        if (changes['Latitude'] || changes['Longitude']) {\r\n            this._markerService.UpdateMarkerPosition(this);\r\n        }\r\n        if (changes['Title']) {\r\n            this._markerService.UpdateTitle(this);\r\n        }\r\n        if (changes['Label']) {\r\n            this._markerService.UpdateLabel(this);\r\n        }\r\n        if (changes['Draggable']) {\r\n            this._markerService.UpdateDraggable(this);\r\n        }\r\n        if (changes['IconUrl'] || changes['IconInfo']) {\r\n            this._markerService.UpdateIcon(this);\r\n        }\r\n        if (changes['Anchor']) {\r\n            this._markerService.UpdateAnchor(this);\r\n        }\r\n        if (changes['Visible']) {\r\n            this._markerService.UpdateVisible(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public ngOnDestroy() {\r\n        this._markerService.DeleteMarker(this);\r\n        this._events.forEach((s) => s.unsubscribe());\r\n    }\r\n\r\n    /**\r\n     * Obtains a string representation of the Marker Id.\r\n     * @returns - string representation of the marker id.\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    public toString(): string { return 'MapMarker-' + this._id.toString(); }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Adds various event listeners for the marker.\r\n     *\r\n     * @memberof MapMarkerDirective\r\n     */\r\n    private AddEventListeners(): void {\r\n        const _getEventArg: (e: MouseEvent) => IMarkerEvent = e => {\r\n            return {\r\n                Marker: this,\r\n                Click: e,\r\n                Location: this._markerService.GetCoordinatesFromClick(e),\r\n                Pixels: this._markerService.GetPixelsFromClick(e)\r\n            };\r\n        };\r\n\r\n        this._events.push(this._markerService.CreateEventObservable('click', this).subscribe((e: MouseEvent) => {\r\n            ///\r\n            /// this is necessary since map will treat a doubleclick first as two clicks...'\r\n            ///\r\n            this._clickTimeout = timer(300).subscribe(n => {\r\n                if (this._infoBox != null) {\r\n                    this._infoBox.Open(this._markerService.GetCoordinatesFromClick(e));\r\n                }\r\n                this.MarkerClick.emit(_getEventArg(e));\r\n            });\r\n        }));\r\n\r\n        this._events.push(this._markerService.CreateEventObservable('dblclick', this).subscribe((e: MouseEvent) => {\r\n            if (this._clickTimeout) {\r\n                this._clickTimeout.unsubscribe();\r\n                this._clickTimeout = null;\r\n            }\r\n            this.DblClick.emit(_getEventArg(e));\r\n        }));\r\n\r\n        const handlers = [\r\n            { name: 'drag', handler: (ev: MouseEvent) => this.Drag.emit(_getEventArg(ev)) },\r\n            { name: 'dragend', handler: (ev: MouseEvent) => this.DragEnd.emit(_getEventArg(ev)) },\r\n            { name: 'dragstart', handler: (ev: MouseEvent) => this.DragStart.emit(_getEventArg(ev)) },\r\n            { name: 'mousedown', handler: (ev: MouseEvent) => this.MouseDown.emit(_getEventArg(ev)) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.MouseMove.emit(_getEventArg(ev)) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.MouseOut.emit(_getEventArg(ev)) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.MouseOver.emit(_getEventArg(ev)) },\r\n            { name: 'mouseup', handler: (ev: MouseEvent) => this.MouseUp.emit(_getEventArg(ev)) },\r\n            { name: 'rightclick', handler: (ev: MouseEvent) => this.RightClick.emit(_getEventArg(ev)) },\r\n        ];\r\n        handlers.forEach((obj) => {\r\n            const os = this._markerService.CreateEventObservable(obj.name, this).subscribe(obj.handler);\r\n            this._events.push(os);\r\n        });\r\n    }\r\n\r\n}\r\n","import {\r\n    Component,\r\n    EventEmitter,\r\n    OnChanges,\r\n    OnInit,\r\n    OnDestroy,\r\n    SimpleChange,\r\n    ViewChild,\r\n    ContentChildren,\r\n    Input,\r\n    Output,\r\n    ElementRef,\r\n    HostBinding,\r\n    ViewEncapsulation,\r\n    ChangeDetectionStrategy,\r\n    NgZone\r\n} from '@angular/core';\r\nimport { MapServiceFactory } from '../services/mapservicefactory';\r\nimport { MapService } from '../services/map.service';\r\nimport { MarkerService } from '../services/marker.service';\r\nimport { InfoBoxService } from '../services/infobox.service';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { PolygonService } from '../services/polygon.service';\r\nimport { PolylineService } from '../services/polyline.service';\r\nimport { ClusterService } from '../services/cluster.service';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IBox } from '../interfaces/ibox';\r\nimport { IMapOptions } from '../interfaces/imap-options';\r\nimport { MapTypeId } from '../models/map-type-id';\r\nimport { MapMarkerDirective } from './map-marker';\r\n\r\n/**\r\n * Renders a map based on a given provider.\r\n * **Important note**: To be able see a map in the browser, you have to define a height for the CSS\r\n * class `map-container`.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map',\r\n *  styles: [`\r\n *    .map-container { height: 300px; }\r\n * `],\r\n *  template: `\r\n *    <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\"></x-map>\r\n *  `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Component({\r\n    selector: 'x-map',\r\n    providers: [\r\n        { provide: MapService, deps: [MapServiceFactory], useFactory: MapServiceCreator },\r\n        { provide: MarkerService, deps: [MapServiceFactory, MapService, LayerService, ClusterService], useFactory: MarkerServiceFactory },\r\n        {\r\n            provide: InfoBoxService, deps: [MapServiceFactory, MapService,\r\n                MarkerService], useFactory: InfoBoxServiceFactory\r\n        },\r\n        { provide: LayerService, deps: [MapServiceFactory, MapService], useFactory: LayerServiceFactory },\r\n        { provide: ClusterService, deps: [MapServiceFactory, MapService], useFactory: ClusterServiceFactory },\r\n        { provide: PolygonService, deps: [MapServiceFactory, MapService, LayerService], useFactory: PolygonServiceFactory },\r\n        { provide: PolylineService, deps: [MapServiceFactory, MapService, LayerService], useFactory: PolylineServiceFactory }\r\n    ],\r\n    template: `\r\n        <div #container class='map-container-inner'></div>\r\n        <div class='map-content'>\r\n            <ng-content></ng-content>\r\n        </div>\r\n    `,\r\n    styles: [`\r\n        .map-container-inner { width: inherit; height: inherit; }\r\n        .map-container-inner div { background-repeat: no-repeat; }\r\n        .map-content { display:none; }\r\n    `],\r\n    encapsulation: ViewEncapsulation.None,\r\n    changeDetection: ChangeDetectionStrategy.OnPush\r\n})\r\nexport class MapComponent implements OnChanges, OnInit, OnDestroy {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _longitude = 0;\r\n    private _latitude = 0;\r\n    private _zoom = 0;\r\n    private _clickTimeout: number | NodeJS.Timer;\r\n    private _options: IMapOptions = {};\r\n    private _box: IBox = null;\r\n    private _mapPromise: Promise<void>;\r\n    @HostBinding('class.map-container') public _containerClass: boolean = true;\r\n    @ViewChild('container') private _container: ElementRef;\r\n    @ContentChildren(MapMarkerDirective) private _markers: Array<MapMarkerDirective>;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Get or sets the maximum and minimum bounding box for map.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Box(): IBox { return this._box; }\r\n    public set Box(val: IBox) { this._box = val; }\r\n\r\n    /**\r\n     * Gets or sets the latitude that sets the center of the map.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Latitude(): number | string { return this._longitude; }\r\n    public set Latitude(value: number | string) {\r\n        this._latitude = this.ConvertToDecimal(value);\r\n        this.UpdateCenter();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the longitude that sets the center of the map.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Longitude(): number | string { return this._longitude; }\r\n    public set Longitude(value: number | string) {\r\n        this._longitude = this.ConvertToDecimal(value);\r\n        this.UpdateCenter();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets general map Options\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Options(): IMapOptions { return this._options; }\r\n    public set Options(val: IMapOptions) { this._options = val; }\r\n\r\n    /**\r\n     * Gets or sets the zoom level of the map. The default value is `8`.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Input()\r\n    public get Zoom(): number | string { return this._zoom; }\r\n    public set Zoom(value: number | string) {\r\n        this._zoom = this.ConvertToDecimal(value, 8);\r\n        if (typeof this._zoom === 'number') {\r\n            this._mapService.SetZoom(this._zoom);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This event emitter is fired when the map bounding box changes.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    BoundsChange: EventEmitter<IBox> = new EventEmitter<IBox>();\r\n\r\n    /**\r\n     * This event emitter is fired when the map center changes.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    CenterChange: EventEmitter<ILatLong> = new EventEmitter<ILatLong>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks on the map (but not when they click on a\r\n     * marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapClick: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user double-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapDblClick: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user right-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapRightClick: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user double-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapMouseOver: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user double-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapMouseOut: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user double-clicks on the map (but not when they click\r\n     * on a marker or infoWindow).\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapMouseMove: EventEmitter<MouseEvent> = new EventEmitter<MouseEvent>();\r\n\r\n    /**\r\n     * The event emitter is fired when the map service is available and the maps has been\r\n     * Initialized (but not necessarily created). It contains a Promise that when fullfilled returns\r\n     * the main map object of the underlying platform.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    MapPromise: EventEmitter<Promise<any>> = new EventEmitter<Promise<any>>();\r\n\r\n    /**\r\n     * This event emiiter is fired when the map zoom changes\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    @Output()\r\n    ZoomChange: EventEmitter<Number> = new EventEmitter<Number>();\r\n\r\n    /**\r\n     * This event emitter is fired when the map service is available and the maps has been\r\n     * Initialized\r\n     * @memberOf MapComponent\r\n     */\r\n    @Output()\r\n    MapService: EventEmitter<MapService> = new EventEmitter<MapService>();\r\n\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapComponent.\r\n     *\r\n     * @param _mapService - Concreted implementation of a map service for the underlying maps implementations.\r\n     *                                   Generally provided via injections.\r\n     * @memberof MapComponent\r\n     */\r\n    constructor(private _mapService: MapService, private _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called on Component initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    public ngOnInit(): void {\r\n        this.InitMapInstance(this._container.nativeElement);\r\n        this.MapPromise.emit(this._mapService.MapPromise);\r\n        this.MapService.emit(this._mapService);\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    public ngOnChanges(changes: { [propName: string]: SimpleChange }): void {\r\n        if (this._mapPromise) {\r\n            if (changes['Box']) {\r\n                if (this._box != null) {\r\n                    this._mapService.SetViewOptions(<IMapOptions>{\r\n                        bounds: this._box\r\n                    });\r\n                }\r\n            }\r\n            if (changes['Options']) {\r\n                this._mapService.SetMapOptions(this._options);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    public ngOnDestroy(): void {\r\n        this._mapService.DisposeMap();\r\n    }\r\n\r\n    /**\r\n     * Triggers a resize event on the map instance.\r\n     *\r\n     * @returns - A promise that gets resolved after the event was triggered.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    public TriggerResize(): Promise<void> {\r\n        // Note: When we would trigger the resize event and show the map in the same turn (which is a\r\n        // common case for triggering a resize event), then the resize event would not\r\n        // work (to show the map), so we trigger the event in a timeout.\r\n        return new Promise<void>((resolve) => {\r\n            setTimeout(\r\n                () => { return this._mapService.TriggerMapEvent('resize').then(() => resolve()); });\r\n        });\r\n    }\r\n\r\n    ///\r\n    /// Private methods.\r\n    ///\r\n\r\n    /**\r\n     * Converts a number-ish value to a number.\r\n     *\r\n     * @param value - The value to convert.\r\n     * @param [defaultValue=null] - Default value to use if the conversion cannot be performed.\r\n     * @returns - Converted number of the default.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private ConvertToDecimal(value: string | number, defaultValue: number = null): number {\r\n        if (typeof value === 'string') {\r\n            return parseFloat(value);\r\n        } else if (typeof value === 'number') {\r\n            return <number>value;\r\n        }\r\n        return defaultValue;\r\n    }\r\n\r\n    /**\r\n     * Delegate handling the map click events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleMapClickEvents(): void {\r\n        this._mapService.SubscribeToMapEvent<any>('click').subscribe(e => {\r\n            //\r\n            // this is necessary since bing will treat a doubleclick first as two clicks...'\r\n            ///\r\n            this._clickTimeout = setTimeout(() => {\r\n                this.MapClick.emit(<MouseEvent>e);\r\n            }, 300);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('dblclick').subscribe(e => {\r\n            if (this._clickTimeout) {\r\n                clearTimeout(<NodeJS.Timer>this._clickTimeout);\r\n            }\r\n            this.MapDblClick.emit(<MouseEvent>e);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('rightclick').subscribe(e => {\r\n            this.MapRightClick.emit(<MouseEvent>e);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('mouseover').subscribe(e => {\r\n            this.MapMouseOver.emit(<MouseEvent>e);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('mouseout').subscribe(e => {\r\n            this.MapMouseOut.emit(<MouseEvent>e);\r\n        });\r\n        this._mapService.SubscribeToMapEvent<any>('mousemove').subscribe(e => {\r\n            this.MapMouseMove.emit(<MouseEvent>e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Delegate handling map center change events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleMapBoundsChange(): void {\r\n        this._mapService.SubscribeToMapEvent<void>('boundschanged').subscribe(() => {\r\n            this._mapService.GetBounds().then((bounds: IBox) => {\r\n                this.BoundsChange.emit(bounds);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Delegate handling map center change events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleMapCenterChange(): void {\r\n        this._mapService.SubscribeToMapEvent<void>('centerchanged').subscribe(() => {\r\n            this._mapService.GetCenter().then((center: ILatLong) => {\r\n                if (this._latitude !== center.latitude || this._longitude !== center.longitude) {\r\n                    this._latitude = center.latitude;\r\n                    this._longitude = center.longitude;\r\n                    this.CenterChange.emit(<ILatLong>{ latitude: this._latitude, longitude: this._longitude });\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Delegate handling map zoom change events.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private HandleMapZoomChange(): void {\r\n        this._mapService.SubscribeToMapEvent<void>('zoomchanged').subscribe(() => {\r\n            this._mapService.GetZoom().then((z: number) => {\r\n                if (this._zoom !== z) {\r\n                    this._zoom = z;\r\n                    this.ZoomChange.emit(z);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Initializes the map.\r\n     *\r\n     * @param el - Html elements which will host the map canvas.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private InitMapInstance(el: HTMLElement) {\r\n        this._zone.runOutsideAngular(() => {\r\n            if (this._options.center == null) { this._options.center = { latitude: this._latitude, longitude: this._longitude }; }\r\n            if (this._options.zoom == null) { this._options.zoom = this._zoom; }\r\n            if (this._options.mapTypeId == null) { this._options.mapTypeId = MapTypeId.hybrid; }\r\n            if (this._box != null) { this._options.bounds = this._box; }\r\n            this._mapPromise = this._mapService.CreateMap(el, this._options);\r\n            this.HandleMapCenterChange();\r\n            this.HandleMapBoundsChange();\r\n            this.HandleMapZoomChange();\r\n            this.HandleMapClickEvents();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the map center based on the geo properties of the component.\r\n     *\r\n     * @memberof MapComponent\r\n     */\r\n    private UpdateCenter(): void {\r\n        if (typeof this._latitude !== 'number' || typeof this._longitude !== 'number') {\r\n            return;\r\n        }\r\n        this._mapService.SetCenter({\r\n            latitude: this._latitude,\r\n            longitude: this._longitude,\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Factory function to generate a cluster service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @returns - A concrete instance of a Cluster Service based on the underlying map architecture\r\n */\r\nexport function ClusterServiceFactory(f: MapServiceFactory, m: MapService): ClusterService { return f.CreateClusterService(m); }\r\n\r\n/**\r\n * Factory function to generate a infobox service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @param m - A {@link MarkerService} instance.\r\n * @returns - A concrete instance of a InfoBox Service based on the underlying map architecture.\r\n */\r\nexport function InfoBoxServiceFactory(f: MapServiceFactory, m: MapService,\r\n    ma: MarkerService): InfoBoxService { return f.CreateInfoBoxService(m, ma); }\r\n\r\n/**\r\n * Factory function to generate a layer service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @returns - A concrete instance of a Layer Service based on the underlying map architecture.\r\n */\r\nexport function LayerServiceFactory(f: MapServiceFactory, m: MapService): LayerService { return f.CreateLayerService(m); }\r\n\r\n/**\r\n * Factory function to generate a map service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @returns - A concrete instance of a MapService based on the underlying map architecture.\r\n */\r\nexport function MapServiceCreator(f: MapServiceFactory): MapService { return f.Create(); }\r\n\r\n/**\r\n * Factory function to generate a marker service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @param l - A {@link LayerService} instance.\r\n * @param c - A {@link ClusterService} instance.\r\n * @returns - A concrete instance of a Marker Service based on the underlying map architecture.\r\n */\r\nexport function MarkerServiceFactory(f: MapServiceFactory, m: MapService, l: LayerService, c: ClusterService): MarkerService {\r\n    return f.CreateMarkerService(m, l, c);\r\n}\r\n\r\n/**\r\n * Factory function to generate a polygon service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @param l - A {@link LayerService} instance.\r\n * @returns - A concrete instance of a Polygon Service based on the underlying map architecture.\r\n */\r\nexport function PolygonServiceFactory(f: MapServiceFactory, m: MapService, l: LayerService): PolygonService {\r\n    return f.CreatePolygonService(m, l);\r\n}\r\n\r\n/**\r\n * Factory function to generate a polyline service instance. This is necessary because of constraints with AOT that do no allow\r\n * us to use lamda functions inline.\r\n *\r\n * @export\r\n * @param f - The {@link MapServiceFactory} implementation.\r\n * @param m - A {@link MapService} instance.\r\n * @param l - A {@link LayerService} instance.\r\n * @returns - A concrete instance of a Polyline Service based on the underlying map architecture.\r\n */\r\nexport function PolylineServiceFactory(f: MapServiceFactory, m: MapService, l: LayerService): PolylineService {\r\n    return f.CreatePolylineService(m, l);\r\n}\r\n","import { Directive, EventEmitter, OnInit, OnDestroy, OnChanges, AfterContentInit, SimpleChange,\r\n    ContentChildren, Input, ViewContainerRef } from '@angular/core';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { MapMarkerDirective } from './map-marker';\r\n\r\n/**\r\n * internal counter to use as ids for multiple layers.\r\n */\r\nlet layerId = 0;\r\n\r\n/**\r\n * MapLayerDirective creates a layer on a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]='lat' [Longitude]='lng' [Zoom]='zoom'>\r\n *     <x-map-layer [Visible]='visible'>\r\n *         <x-map-marker [Latitude]='lat' [Longitude]='lng' [Label]=''M''></x-map-marker>\r\n *     </x-map-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-layer'\r\n})\r\nexport class MapLayerDirective implements OnInit, OnDestroy, OnChanges {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _visible = true;\r\n    protected _addedToManager = false;\r\n    protected _id: number;\r\n\r\n    @ContentChildren(MapMarkerDirective) protected _markers: Array<MapMarkerDirective>;\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets or sets the layer visibility.\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    @Input()\r\n        public get Visible(): boolean { return this._visible; }\r\n        public set Visible(val: boolean) { this._visible = val; }\r\n\r\n    /**\r\n     * Gets the layer id.\r\n     *\r\n     * @readonly\r\n     * @memberof MapLayerDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapLayerDirective.\r\n     * @param _layerService - Concreted implementation of a layer service for the underlying maps implementations.\r\n     * Generally provided via injections.\r\n     * @param _containerRef - Reference to the container hosting the map canvas. Generally provided via injection.\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    constructor(protected _layerService: LayerService, protected _containerRef: ViewContainerRef) {\r\n        this._id = layerId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called on Component initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    public ngOnInit(): void {\r\n        this._containerRef.element.nativeElement.attributes['layerId'] = this._id.toString();\r\n        this._layerService.AddLayer(this);\r\n        this._addedToManager = true;\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [propName: string]: SimpleChange }): void {\r\n        if (!this._addedToManager) { return; }\r\n        if (changes['Visible']) {\r\n            this._layerService.GetNativeLayer(this).then(l => {\r\n                l.SetVisible(!l.GetVisible());\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     *\r\n     * @memberof MapLayerDirective\r\n     */\r\n    public ngOnDestroy(): void {\r\n        this._layerService.DeleteLayer(this);\r\n    }\r\n}\r\n","import { IClusterIconInfo } from '../interfaces/icluster-icon-info';\r\nimport { Directive, EventEmitter, OnInit, OnDestroy, OnChanges, SimpleChange,\r\n    ContentChildren, Input, ViewContainerRef } from '@angular/core';\r\nimport { Marker } from '../models/marker';\r\nimport { Layer } from '../models/layer';\r\nimport { ClusterPlacementMode } from '../models/cluster-placement-mode';\r\nimport { ClusterClickAction } from '../models/cluster-click-action';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { IClusterOptions } from '../interfaces/icluster-options';\r\nimport { IMarkerIconInfo} from '../interfaces/imarker-icon-info';\r\nimport { ClusterService } from '../services/cluster.service';\r\nimport { ISpiderClusterOptions } from '../interfaces/ispider-cluster-options';\r\nimport { MapMarkerDirective } from './map-marker';\r\nimport { MapLayerDirective } from './map-layer';\r\n\r\n/**\r\n *\r\n * Creates a cluster layer on a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]='lat' [Longitude]='lng' [Zoom]='zoom'>\r\n *     <x-cluster-layer [Visible]='visible'>\r\n *         <x-map-marker [Latitude]='lat' [Longitude]='lng' [Label]=''M''></x-map-marker>\r\n *     </x-cluster-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-cluster-layer'\r\n})\r\nexport class ClusterLayerDirective extends MapLayerDirective implements OnInit, OnDestroy, OnChanges {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _clusteringEnabled = true;\r\n    private _clusterPlacementMode: ClusterPlacementMode = ClusterPlacementMode.MeanValue;\r\n    private _clusterClickAction: ClusterClickAction = ClusterClickAction.ZoomIntoCluster;\r\n    private _spiderClusterOptions: ISpiderClusterOptions;\r\n    private _zIndex: number;\r\n    private _gridSize: number;\r\n    private _layerOffset: IPoint;\r\n    private _iconInfo: IMarkerIconInfo;\r\n    private _minimumClusterSize: number;\r\n    private _styles: Array<IClusterIconInfo>;\r\n    private _useDynamicSizeMarker = false;\r\n    private _dynamicMarkerBaseSize = 18;\r\n    private _dynamicMarkerRanges: Map<number, string> = new Map<number, string>([\r\n        [10, 'rgba(20, 180, 20, 0.5)'],\r\n        [100, 'rgba(255, 210, 40, 0.5)'],\r\n        [Number.MAX_SAFE_INTEGER , 'rgba(255, 40, 40, 0.5)']\r\n    ]);\r\n    private _zoomOnClick = true;\r\n    private _iconCreationCallback: (m: Array<Marker>, i: IMarkerIconInfo) => string;\r\n\r\n    ///\r\n    /// Property defintions\r\n    ///\r\n\r\n    /**\r\n     * Gets or sets the the Cluster Click Action {@link ClusterClickAction}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ClusterClickAction(): ClusterClickAction  { return this._clusterClickAction; }\r\n        public set ClusterClickAction(val: ClusterClickAction) { this._clusterClickAction = val; }\r\n\r\n    /**\r\n     * Gets or sets whether the clustering layer enables clustering. When set to false, the layer\r\n     * behaves like a generic layer. This is handy if you want to prevent clustering at certain zoom levels.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ClusteringEnabled(): boolean  { return this._clusteringEnabled; }\r\n        public set ClusteringEnabled(val: boolean) { this._clusteringEnabled = val; }\r\n\r\n    /**\r\n     * Gets or sets the cluster placement mode. {@link ClusterPlacementMode}\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ClusterPlacementMode(): ClusterPlacementMode  { return this._clusterPlacementMode; }\r\n        public set ClusterPlacementMode(val: ClusterPlacementMode) { this._clusterPlacementMode = val; }\r\n\r\n    /**\r\n     * Gets or sets the callback invoked to create a custom cluster marker. Note that when {@link UseDynamicSizeMarkers} is enabled,\r\n     * you cannot set a custom marker callback.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get CustomMarkerCallback(): (m: Array<Marker>, i: IMarkerIconInfo) => string  { return this._iconCreationCallback; }\r\n        public set CustomMarkerCallback(val: (m: Array<Marker>, i: IMarkerIconInfo) => string) {\r\n            if (this._useDynamicSizeMarker) {\r\n                throw(\r\n                    new Error(`You cannot set a custom marker callback when UseDynamicSizeMarkers is set to true.\r\n                    Set UseDynamicSizeMakers to false.`)\r\n                );\r\n            }\r\n            this._iconCreationCallback = val;\r\n        }\r\n\r\n    /**\r\n     * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.\r\n     * See {@link UseDynamicSizeMarkers}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get DynamicMarkerBaseSize(): number  { return this._dynamicMarkerBaseSize; }\r\n        public set DynamicMarkerBaseSize(val: number) { this._dynamicMarkerBaseSize = val; }\r\n\r\n    /**\r\n     * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.\r\n     * The map contains key/value pairs, with the keys being\r\n     * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {@link UseDynamicSizeMarkers}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get DynamicMarkerRanges(): Map<number, string>  { return this._dynamicMarkerRanges; }\r\n        public set DynamicMarkerRanges(val: Map<number, string>) { this._dynamicMarkerRanges = val; }\r\n\r\n    /**\r\n     * Gets or sets the grid size to be used for clustering.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get GridSize(): number  { return this._gridSize; }\r\n        public set GridSize(val: number) { this._gridSize = val; }\r\n\r\n    /**\r\n     * Gets or sets the IconInfo to be used to create a custom cluster marker. Supports font-based, SVG, graphics and more.\r\n     * See {@link IMarkerIconInfo}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get IconInfo(): IMarkerIconInfo  { return this._iconInfo; }\r\n        public set IconInfo(val: IMarkerIconInfo) { this._iconInfo = val; }\r\n\r\n    /**\r\n     * Gets or sets An offset applied to the positioning of the layer.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get LayerOffset(): IPoint  { return this._layerOffset; }\r\n        public set LayerOffset(val: IPoint) { this._layerOffset = val; }\r\n\r\n    /**\r\n     * Gets or sets the minimum pins required to form a cluster\r\n     *\r\n     * @readonly\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get MinimumClusterSize(): number  { return this._minimumClusterSize; }\r\n        public set MinimumClusterSize(val: number) { this._minimumClusterSize = val; }\r\n\r\n    /**\r\n     * Gets or sets the options for spider clustering behavior. See {@link ISpiderClusterOptions}\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get SpiderClusterOptions(): ISpiderClusterOptions { return this._spiderClusterOptions; }\r\n        public set SpiderClusterOptions(val: ISpiderClusterOptions) { this._spiderClusterOptions = val; }\r\n\r\n    /**\r\n     * Gets or sets the cluster styles\r\n     *\r\n     * @readonly\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get Styles(): Array<IClusterIconInfo> { return this._styles; }\r\n        public set Styles(val: Array<IClusterIconInfo>) { this._styles = val; }\r\n\r\n    /**\r\n     * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of\r\n     * pins in the cluster. If set to true, this will take precendence over any custom marker creation.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get UseDynamicSizeMarkers(): boolean { return this._useDynamicSizeMarker; }\r\n        public set UseDynamicSizeMarkers(val: boolean) {\r\n            this._useDynamicSizeMarker = val;\r\n            if (val) {\r\n                this._iconCreationCallback = (m: Array<Marker>, info: IMarkerIconInfo) => {\r\n                    return ClusterLayerDirective.CreateDynamicSizeMarker(\r\n                        m.length, info, this._dynamicMarkerBaseSize, this._dynamicMarkerRanges);\r\n                };\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ZIndex(): number { return this._zIndex; }\r\n        public set ZIndex(val: number) { this._zIndex = val; }\r\n\r\n    /**\r\n     * Gets or sets whether the cluster should zoom in on click\r\n     *\r\n     * @readonly\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get ZoomOnClick(): boolean { return this._zoomOnClick; }\r\n        public set ZoomOnClick(val: boolean) { this._zoomOnClick = val; }\r\n\r\n    /**\r\n     * Creates the dynamic size marker to be used for cluster markers if UseDynamicSizeMarkers is set to true.\r\n     *\r\n     * @param size - The number of markers in the cluster.\r\n     * @param info  - The icon info to be used. This will be hydrated with\r\n     * the actualy dimensions of the created markers and is used by the underlying model/services\r\n     * to correctly offset the marker for correct positioning.\r\n     * @param baseMarkerSize - The base size for dynmic markers.\r\n     * @param ranges - The ranges to use to calculate breakpoints and colors for dynamic markers.\r\n     * The map contains key/value pairs, with the keys being\r\n     * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range.\r\n     * @returns - An string containing the SVG for the marker.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    public static CreateDynamicSizeMarker(size: number, info: IMarkerIconInfo,\r\n                                             baseMarkerSize: number, ranges: Map<number, string>): string {\r\n        const mr: number = baseMarkerSize;\r\n        const outline: number = mr * 0.35;\r\n        const total: number = size;\r\n        const r: number = Math.log(total) / Math.log(10) * 5 + mr;\r\n        const d: number = r * 2;\r\n        let fillColor: string;\r\n        ranges.forEach((v, k) => {\r\n            if (total <= k && !fillColor) { fillColor = v; }\r\n        });\r\n        if (!fillColor) { fillColor = 'rgba(20, 180, 20, 0.5)'; }\r\n\r\n        // Create an SVG string of two circles, one on top of the other, with the specified radius and color.\r\n        const svg: Array<any> = [`<svg xmlns='http://www.w3.org/2000/svg' width='${d}' height='${d}'>`,\r\n            `<circle cx='${r}' cy='${r}' r='${r}' fill='${fillColor}'/>`,\r\n            `<circle cx='${r}' cy='${r}' r='${r - outline}' fill='${fillColor}'/>`,\r\n            `</svg>`];\r\n        info.size = { width: d, height: d };\r\n        info.markerOffsetRatio = { x: 0.5, y: 0.5 };\r\n        info.textOffset = { x: 0, y: r - 8 };\r\n        return svg.join('');\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of ClusterLayerDirective.\r\n     *\r\n     * @param _layerService - Concreted implementation of a cluster layer service for the underlying maps\r\n     * implementations. Generally provided via injections.\r\n     * @param _containerRef - A reference to the view container of the layer. Generally provided via injection.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    constructor(_layerService: ClusterService, _containerRef: ViewContainerRef) {\r\n        super(_layerService, _containerRef);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [propName: string]: SimpleChange }): void {\r\n        if (!this._addedToManager) { return; }\r\n        if (changes['ClusterClickAction']) {\r\n            throw (\r\n                new Error('You cannot change the ClusterClickAction after the layer has been added to the layerservice.')\r\n            );\r\n        }\r\n\r\n        const options: IClusterOptions = { id: this._id };\r\n        if (changes['ClusteringEnabled']) { options.clusteringEnabled = this._clusteringEnabled; }\r\n        if (changes['GridSize']) { options.gridSize = this._gridSize; }\r\n        if (changes['LayerOffset']) { options.layerOffset = this._layerOffset; }\r\n        if (changes['SpiderClusterOptions']) { options.spiderClusterOptions = this._spiderClusterOptions; }\r\n        if (changes['ZIndex']) { options.zIndex = this._zIndex; }\r\n        if (changes['Visible']) { options.visible = this._visible; }\r\n\r\n        this._layerService.GetNativeLayer(this).then((l: Layer) => {\r\n            l.SetOptions(options);\r\n        });\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, Input, Output, OnDestroy, OnChanges, ViewContainerRef,\r\n    EventEmitter, ContentChild, AfterContentInit, SimpleChanges\r\n} from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { IPolygonEvent } from '../interfaces/ipolygon-event';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { PolygonService } from '../services/polygon.service';\r\nimport { InfoBoxComponent } from './infobox';\r\n\r\nlet polygonId = 0;\r\n\r\n/**\r\n *\r\n * MapPolygonDirective renders a polygon inside a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapPolygonDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map,\r\n *  styles: [`\r\n *   .map-container { height: 300px; }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-polygon [Paths]=\"path\"></x-map-polygon>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-polygon'\r\n})\r\nexport class MapPolygonDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _inCustomLayer = false;\r\n    private _id: number;\r\n    private _layerId: number;\r\n    private _addedToService = false;\r\n    private _events: Subscription[] = [];\r\n\r\n    ///\r\n    /// Any InfoBox that is a direct children of the polygon\r\n    ///\r\n    @ContentChild(InfoBoxComponent) protected _infoBox: InfoBoxComponent;\r\n\r\n\r\n    /**\r\n     * Gets or sets whether this Polygon handles mouse events.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Clickable = true;\r\n\r\n    /**\r\n     * If set to true, the user can drag this shape over the map.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Draggable = false;\r\n\r\n    /**\r\n     * If set to true, the user can edit this shape by dragging the control\r\n     * points shown at the vertices and on each segment.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Editable = false;\r\n\r\n    /**\r\n     * The fill color of the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public FillColor: string;\r\n\r\n    /**\r\n     * The fill opacity between 0.0 and 1.0\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public FillOpacity: number;\r\n\r\n    /**\r\n     * When true, edges of the polygon are interpreted as geodesic and will\r\n     * follow the curvature of the Earth. When false, edges of the polygon are\r\n     * rendered as straight lines in screen space. Note that the shape of a\r\n     * geodesic polygon may appear to change when dragged, as the dimensions\r\n     * are maintained relative to the surface of the earth. Defaults to false.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Geodesic = false;\r\n\r\n    /**\r\n     * Set the maximum zoom at which the polygon lable is visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public LabelMaxZoom: number;\r\n\r\n    /**\r\n     * Set the minimum zoom at which the polygon lable is visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public LabelMinZoom: number;\r\n\r\n    /**\r\n     * Arbitary metadata to assign to the Polygon. This is useful for events\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    /**\r\n     * The ordered sequence of coordinates that designates a closed loop.\r\n     * Unlike polylines, a polygon may consist of one or more paths.\r\n     * As a result, the paths property may specify one or more arrays of\r\n     * LatLng coordinates. Paths are closed automatically; do not repeat the\r\n     * first vertex of the path as the last vertex. Simple polygons may be\r\n     * defined using a single array of LatLngs. More complex polygons may\r\n     * specify an array of arrays (for inner loops ). Any simple arrays are converted into Arrays.\r\n     * Inserting or removing LatLngs from the Array will automatically update\r\n     * the polygon on the map.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Paths: Array<ILatLong> | Array<Array<ILatLong>> = [];\r\n\r\n    /**\r\n     * Whether to show the title as the label on the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public ShowLabel: boolean;\r\n\r\n    /**\r\n     * Whether to show the title of the polygon as the tooltip on the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public ShowTooltip: boolean = true;\r\n\r\n    /**\r\n     * The stroke color.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public StrokeColor: string;\r\n\r\n    /**\r\n     * The stroke opacity between 0.0 and 1.0\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public StrokeOpacity: number;\r\n\r\n    /**\r\n     * The stroke width in pixels.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public StrokeWeight: number;\r\n\r\n    /**\r\n     * The title of the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Title: string;\r\n\r\n    /**\r\n     * Whether this polygon is visible on the map. Defaults to true.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * The zIndex compared to other polys.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Input() public zIndex: number;\r\n\r\n    ///\r\n    /// Delegate definitions\r\n    ///\r\n\r\n    /**\r\n     * This event is fired when the DOM click event is fired on the Polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() Click: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on the Polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() DblClick: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is repeatedly fired while the user drags the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() Drag: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user stops dragging the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() DragEnd: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user starts dragging the polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() DragStart: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousedown event is fired on the Polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseDown: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on the Polygon.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseMove: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired on Polygon mouseout.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseOut: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired on Polygon mouseover.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseOver: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired whe the DOM mouseup event is fired on the Polygon\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() MouseUp: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n\r\n    /**\r\n     * This event is fired when the Polygon is right-clicked on.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() RightClick: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when editing has completed.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    @Output() PathChanged: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets whether the polygon has been registered with the service.\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get AddedToService(): boolean { return this._addedToService; }\r\n\r\n    /**\r\n     * Get the id of the polygon.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    /**\r\n     * Gets the id of the polygon as a string.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get IdAsString(): string { return this._id.toString(); }\r\n\r\n    /**\r\n     * Gets whether the polygon is in a custom layer. See {@link MapLayer}.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get InCustomLayer(): boolean { return this._inCustomLayer; }\r\n\r\n    /**\r\n     * gets the id of the Layer the polygon belongs to.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    public get LayerId(): number { return this._layerId; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapPolygonDirective.\r\n     * @param _polygonManager\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    constructor(private _polygonService: PolygonService, private _containerRef: ViewContainerRef) {\r\n        this._id = polygonId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    ngAfterContentInit(): void {\r\n        if (this._containerRef.element.nativeElement.parentElement) {\r\n            const parentName: string = this._containerRef.element.nativeElement.parentElement.tagName;\r\n            if (parentName.toLowerCase() === 'x-map-layer') {\r\n                this._inCustomLayer = true;\r\n                this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);\r\n            }\r\n        }\r\n        if (!this._addedToService) {\r\n            this._polygonService.AddPolygon(this);\r\n            this._addedToService = true;\r\n            this.AddEventListeners();\r\n        }\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): any {\r\n        if (!this._addedToService) { return; }\r\n\r\n        const o: IPolygonOptions = this.GeneratePolygonChangeSet(changes);\r\n        if (o != null) { this._polygonService.SetOptions(this, o); }\r\n        if (changes['Paths'] && !changes['Paths'].isFirstChange()) {\r\n            this._polygonService.UpdatePolygon(this);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Called when the poygon is being destroyed. Part of the ng Component life cycle. Release resources.\r\n     *\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    ngOnDestroy() {\r\n        this._polygonService.DeletePolygon(this);\r\n        this._events.forEach((s) => s.unsubscribe());\r\n        ///\r\n        /// remove event subscriptions\r\n        ///\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Wires up the event receivers.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    private AddEventListeners() {\r\n        const _getEventArg: (e: MouseEvent) => IPolygonEvent = e => {\r\n            return {\r\n                Polygon: this,\r\n                Click: e\r\n            };\r\n        };\r\n        this._events.push(this._polygonService.CreateEventObservable('click', this).subscribe((ev: MouseEvent) => {\r\n            const t: MapPolygonDirective = this;\r\n            if (this._infoBox != null) {\r\n                this._infoBox.Open(this._polygonService.GetCoordinatesFromClick(ev));\r\n            }\r\n            this.Click.emit(_getEventArg(ev));\r\n        }));\r\n        const handlers = [\r\n            { name: 'dblclick', handler: (ev: MouseEvent) => this.DblClick.emit(_getEventArg(ev)) },\r\n            { name: 'drag', handler: (ev: MouseEvent) => this.Drag.emit(_getEventArg(ev)) },\r\n            { name: 'dragend', handler: (ev: MouseEvent) => this.DragEnd.emit(_getEventArg(ev)) },\r\n            { name: 'dragstart', handler: (ev: MouseEvent) => this.DragStart.emit(_getEventArg(ev)) },\r\n            { name: 'mousedown', handler: (ev: MouseEvent) => this.MouseDown.emit(_getEventArg(ev)) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.MouseMove.emit(_getEventArg(ev)) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.MouseOut.emit(_getEventArg(ev)) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.MouseOver.emit(_getEventArg(ev)) },\r\n            { name: 'mouseup', handler: (ev: MouseEvent) => this.MouseUp.emit(_getEventArg(ev)) },\r\n            { name: 'rightclick', handler: (ev: MouseEvent) => this.RightClick.emit(_getEventArg(ev)) },\r\n            { name: 'pathchanged', handler: (ev: IPolygonEvent) => this.PathChanged.emit(ev) }\r\n        ];\r\n        handlers.forEach((obj) => {\r\n            const os = this._polygonService.CreateEventObservable(obj.name, this).subscribe(obj.handler);\r\n            this._events.push(os);\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Generates IPolygon option changeset from directive settings.\r\n     *\r\n     * @param changes - {@link SimpleChanges} identifying the changes that occured.\r\n     * @returns - {@link IPolygonOptions} containing the polygon options.\r\n     *\r\n     * @memberof MapPolygonDirective\r\n     */\r\n    private GeneratePolygonChangeSet(changes: SimpleChanges): IPolygonOptions {\r\n        const options: IPolygonOptions = { id: this._id };\r\n        let hasOptions: boolean = false;\r\n        if (changes['Clickable']) { options.clickable = this.Clickable; hasOptions = true; }\r\n        if (changes['Draggable']) { options.draggable = this.Draggable; hasOptions = true; }\r\n        if (changes['Editable']) { options.editable = this.Editable; hasOptions = true; }\r\n        if (changes['FillColor'] || changes['FillOpacity']) {\r\n            options.fillColor = this.FillColor;\r\n            options.fillOpacity = this.FillOpacity;\r\n            hasOptions = true;\r\n        }\r\n        if (changes['Geodesic']) { options.geodesic = this.Geodesic; hasOptions = true; }\r\n        if (changes['LabelMaxZoom']) { options.labelMaxZoom = this.LabelMaxZoom; hasOptions = true; }\r\n        if (changes['LabelMinZoom']) { options.labelMinZoom = this.LabelMinZoom; hasOptions = true; }\r\n        if (changes['ShowTooltip']) { options.showTooltip = this.ShowTooltip; hasOptions = true; }\r\n        if (changes['ShowLabel']) { options.showLabel = this.ShowLabel; hasOptions = true; }\r\n        if (changes['StrokeColor'] || changes['StrokeOpacity']) {\r\n            options.strokeColor = this.StrokeColor;\r\n            options.strokeOpacity = this.StrokeOpacity;\r\n            hasOptions = true;\r\n        }\r\n        if (changes['StrokeWeight']) { options.strokeWeight = this.StrokeWeight; hasOptions = true; }\r\n        if (changes['Title']) { options.title = this.Title; hasOptions = true; }\r\n        if (changes['Visible']) { options.visible = this.Visible; hasOptions = true; }\r\n        if (changes['zIndex']) { options.zIndex = this.zIndex; hasOptions = true; }\r\n        return hasOptions ? options : null;\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, Input, Output, OnDestroy, OnChanges, ViewContainerRef,\r\n    EventEmitter, ContentChild, AfterContentInit, SimpleChanges\r\n} from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { PolylineService } from '../services/polyline.service';\r\nimport { IPolylineEvent } from '../interfaces/ipolyline-event';\r\nimport { InfoBoxComponent } from './infobox';\r\n\r\nlet polylineId = 0;\r\n\r\n/**\r\n *\r\n * MapPolylineDirective renders a polyline inside a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapPolylineDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map,\r\n *  styles: [`\r\n *   .map-container { height: 300px; }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-polyline [Paths]=\"path\"></x-map-polyline>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-polyline'\r\n})\r\nexport class MapPolylineDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _inCustomLayer = false;\r\n    private _id: number;\r\n    private _layerId: number;\r\n    private _addedToService = false;\r\n    private _events: Subscription[] = [];\r\n\r\n    ///\r\n    /// Any InfoBox that is a direct children of the polyline\r\n    ///\r\n    @ContentChild(InfoBoxComponent) protected _infoBox: InfoBoxComponent;\r\n\r\n\r\n    /**\r\n     * Gets or sets whether this Polyline handles mouse events.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Clickable = true;\r\n\r\n    /**\r\n     * If set to true, the user can drag this shape over the map.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Draggable = false;\r\n\r\n    /**\r\n     * If set to true, the user can edit this shape by dragging the control\r\n     * points shown at the vertices and on each segment.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Editable = false;\r\n\r\n    /**\r\n     * When true, edges of the polyline are interpreted as geodesic and will\r\n     * follow the curvature of the Earth. When false, edges of the polyline are\r\n     * rendered as straight lines in screen space. Note that the shape of a\r\n     * geodesic polyline may appear to change when dragged, as the dimensions\r\n     * are maintained relative to the surface of the earth. Defaults to false.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Geodesic = false;\r\n\r\n    /**\r\n     * Arbitary metadata to assign to the Polyline. This is useful for events\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Metadata: Map<string, any> = new Map<string, any>();\r\n\r\n    /**\r\n     * The ordered sequence of coordinates that designates a polyline.\r\n     * Simple polylines may be defined using a single array of LatLngs. More\r\n     * complex polylines may specify an array of arrays.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Path: Array<ILatLong> | Array<Array<ILatLong>> = [];\r\n\r\n    /**\r\n     * Whether to show the title of the polyline as the tooltip on the polygon.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public ShowTooltip: boolean = true;\r\n\r\n    /**\r\n     * The stroke color.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public StrokeColor: string;\r\n\r\n    /**\r\n     * The stroke opacity between 0.0 and 1.0\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public StrokeOpacity: number;\r\n\r\n    /**\r\n     * The stroke width in pixels.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public StrokeWeight: number;\r\n\r\n    /**\r\n     * The title of the polygon.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Title: string;\r\n\r\n    /**\r\n     * Whether this polyline is visible on the map. Defaults to true.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * The zIndex compared to other polys.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Input() public zIndex: number;\r\n\r\n    ///\r\n    /// Delegate definitions\r\n    ///\r\n\r\n    /**\r\n     * This event is fired when the DOM click event is fired on the Polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() Click: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on the Polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() DblClick: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is repeatedly fired while the user drags the polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() Drag: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user stops dragging the polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() DragEnd: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user starts dragging the polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() DragStart: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousedown event is fired on the Polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseDown: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on the Polyline.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseMove: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired on Polyline mouseout.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseOut: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired on Polyline mouseover.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseOver: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired whe the DOM mouseup event is fired on the Polyline\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() MouseUp: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This even is fired when the Polyline is right-clicked on.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    @Output() RightClick: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets whether the polyline has been registered with the service.\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get AddedToService(): boolean { return this._addedToService; }\r\n\r\n    /**\r\n     * Get the id of the polyline.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    /**\r\n     * Gets the id of the polyline as a string.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get IdAsString(): string { return this._id.toString(); }\r\n\r\n    /**\r\n     * Gets whether the polyline is in a custom layer. See {@link MapLayer}.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get InCustomLayer(): boolean { return this._inCustomLayer; }\r\n\r\n    /**\r\n     * gets the id of the Layer the polyline belongs to.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    public get LayerId(): number { return this._layerId; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapPolylineDirective.\r\n     * @param _polylineManager\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    constructor(private _polylineService: PolylineService, private _containerRef: ViewContainerRef) {\r\n        this._id = polylineId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called after the content intialization of the directive is complete. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    ngAfterContentInit(): void {\r\n        if (this._containerRef.element.nativeElement.parentElement) {\r\n            const parentName: string = this._containerRef.element.nativeElement.parentElement.tagName;\r\n            if (parentName.toLowerCase() === 'x-map-layer') {\r\n                this._inCustomLayer = true;\r\n                this._layerId = Number(this._containerRef.element.nativeElement.parentElement.attributes['layerId']);\r\n            }\r\n        }\r\n        if (!this._addedToService) {\r\n            this._polylineService.AddPolyline(this);\r\n            this._addedToService = true;\r\n            this.AddEventListeners();\r\n        }\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Called when changes to the databoud properties occur. Part of the ng Component life cycle.\r\n     *\r\n     * @param changes - Changes that have occured.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): any {\r\n        if (!this._addedToService) { return; }\r\n\r\n        const o: IPolylineOptions = this.GeneratePolylineChangeSet(changes);\r\n        if (o != null) {\r\n            this._polylineService.SetOptions(this, o);\r\n        }\r\n        if (changes['Path'] && !changes['Path'].isFirstChange()) {\r\n            this._polylineService.UpdatePolyline(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called when the polyline is being destroyed. Part of the ng Component life cycle. Release resources.\r\n     *\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    ngOnDestroy() {\r\n        this._polylineService.DeletePolyline(this);\r\n        this._events.forEach((s) => s.unsubscribe());\r\n            ///\r\n            /// remove event subscriptions\r\n            ///\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Wires up the event receivers.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    private AddEventListeners() {\r\n        const _getEventArg: (e: MouseEvent) => IPolylineEvent = e => {\r\n            return {\r\n                Polyline: this,\r\n                Click: e\r\n            };\r\n        };\r\n        this._polylineService.CreateEventObservable('click', this).subscribe((ev: MouseEvent) => {\r\n            if (this._infoBox != null) {\r\n                this._infoBox.Open(this._polylineService.GetCoordinatesFromClick(ev));\r\n            }\r\n            this.Click.emit(_getEventArg(ev));\r\n        });\r\n        const handlers = [\r\n            { name: 'dblclick', handler: (ev: MouseEvent) => this.DblClick.emit(_getEventArg(ev)) },\r\n            { name: 'drag', handler: (ev: MouseEvent) => this.Drag.emit(_getEventArg(ev)) },\r\n            { name: 'dragend', handler: (ev: MouseEvent) => this.DragEnd.emit(_getEventArg(ev)) },\r\n            { name: 'dragstart', handler: (ev: MouseEvent) => this.DragStart.emit(_getEventArg(ev)) },\r\n            { name: 'mousedown', handler: (ev: MouseEvent) => this.MouseDown.emit(_getEventArg(ev)) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.MouseMove.emit(_getEventArg(ev)) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.MouseOut.emit(_getEventArg(ev)) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.MouseOver.emit(_getEventArg(ev)) },\r\n            { name: 'mouseup', handler: (ev: MouseEvent) => this.MouseUp.emit(_getEventArg(ev)) },\r\n            { name: 'rightclick', handler: (ev: MouseEvent) => this.RightClick.emit(_getEventArg(ev)) },\r\n        ];\r\n        handlers.forEach((obj) => {\r\n            const os = this._polylineService.CreateEventObservable(obj.name, this).subscribe(obj.handler);\r\n            this._events.push(os);\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Generates IPolyline option changeset from directive settings.\r\n     *\r\n     * @param changes - {@link SimpleChanges} identifying the changes that occured.\r\n     * @returns - {@link IPolylineOptions} containing the polyline options.\r\n     *\r\n     * @memberof MapPolylineDirective\r\n     */\r\n    private GeneratePolylineChangeSet(changes: SimpleChanges): IPolylineOptions {\r\n        const options: IPolylineOptions = { id: this._id };\r\n        let hasOptions: boolean = false;\r\n        if (changes['Clickable']) { options.clickable = this.Clickable; hasOptions = true; }\r\n        if (changes['Draggable']) { options.draggable = this.Draggable; hasOptions = true; }\r\n        if (changes['Editable']) { options.editable = this.Editable; hasOptions = true; }\r\n        if (changes['Geodesic']) { options.geodesic = this.Geodesic; hasOptions = true; }\r\n        if (changes['ShowTooltip']) { options.showTooltip = this.ShowTooltip; hasOptions = true; }\r\n        if (changes['StrokeColor']) { options.strokeColor = this.StrokeColor; hasOptions = true; }\r\n        if (changes['StrokeOpacity']) { options.strokeOpacity = this.StrokeOpacity; hasOptions = true; }\r\n        if (changes['StrokeWeight']) { options.strokeWeight = this.StrokeWeight; hasOptions = true; }\r\n        if (changes['Title']) { options.title = this.Title; hasOptions = true; }\r\n        if (changes['Visible']) { options.visible = this.Visible; hasOptions = true; }\r\n        if (changes['zIndex']) { options.zIndex = this.zIndex; hasOptions = true; }\r\n        return hasOptions ? options : null;\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, SimpleChange, Input, Output, OnDestroy, OnChanges,\r\n    EventEmitter, ContentChild, AfterContentInit, ViewContainerRef, NgZone\r\n} from '@angular/core';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IMarkerEvent } from '../interfaces/imarker-event';\r\nimport { IMarkerOptions } from '../interfaces/imarker-options';\r\nimport { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { IMarkerIconInfo } from '../interfaces/imarker-icon-info';\r\nimport { IClusterIconInfo } from '../interfaces/icluster-icon-info';\r\nimport { IClusterOptions } from '../interfaces/icluster-options';\r\nimport { MarkerService } from '../services/marker.service';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { ClusterService } from '../services/cluster.service';\r\nimport { MapService } from '../services/map.service';\r\nimport { Layer } from '../models/layer';\r\nimport { Marker } from '../models/marker';\r\nimport { ClusterClickAction } from '../models/cluster-click-action';\r\nimport { ClusterPlacementMode } from '../models/cluster-placement-mode';\r\nimport { ClusterLayerDirective } from './cluster-layer';\r\n\r\n/**\r\n * internal counter to use as ids for marker.\r\n */\r\nlet layerId = 1000000;\r\n\r\n/**\r\n * MapMarkerLayerDirective performantly renders a large set of map marker inside a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent, MapMarkerDirective} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-marker-layer [MarkerOptions]=\"_markers\"></x-map-marker-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-marker-layer'\r\n})\r\nexport class MapMarkerLayerDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _id: number;\r\n    private _layerPromise: Promise<Layer>;\r\n    private _service: LayerService;\r\n    private _styles: Array<IClusterIconInfo>;\r\n    private _useDynamicSizeMarker = false;\r\n    private _dynamicMarkerBaseSize = 18;\r\n    private _dynamicMarkerRanges: Map<number, string> = new Map<number, string>([\r\n        [10, 'rgba(20, 180, 20, 0.5)'],\r\n        [100, 'rgba(255, 210, 40, 0.5)'],\r\n        [Number.MAX_SAFE_INTEGER , 'rgba(255, 40, 40, 0.5)']\r\n    ]);\r\n    private _iconCreationCallback: (m: Array<Marker>, i: IMarkerIconInfo) => string;\r\n    private _streaming: boolean = false;\r\n    private _markers: Array<IMarkerOptions> = new Array<IMarkerOptions>();\r\n    private _markersLast: Array<IMarkerOptions> = new Array<IMarkerOptions>();\r\n\r\n\r\n    /**\r\n     * Gets or sets the the Cluster Click Action {@link ClusterClickAction}.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public ClusterClickAction: ClusterClickAction =  ClusterClickAction.ZoomIntoCluster;\r\n\r\n    /**\r\n     * Gets or sets the IconInfo to be used to create a custom cluster marker. Supports font-based, SVG, graphics and more.\r\n     * See {@link IMarkerIconInfo}.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public ClusterIconInfo: IMarkerIconInfo;\r\n\r\n    /**\r\n     * Gets or sets the cluster placement mode. {@link ClusterPlacementMode}\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()  public ClusterPlacementMode: ClusterPlacementMode = ClusterPlacementMode.MeanValue;\r\n\r\n    /**\r\n     * Gets or sets the callback invoked to create a custom cluster marker. Note that when {@link UseDynamicSizeMarkers} is enabled,\r\n     * you cannot set a custom marker callback.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get CustomMarkerCallback(): (m: Array<Marker>, i: IMarkerIconInfo) => string  { return this._iconCreationCallback; }\r\n        public set CustomMarkerCallback(val: (m: Array<Marker>, i: IMarkerIconInfo) => string) {\r\n            if (this._useDynamicSizeMarker) {\r\n                throw(\r\n                    new Error(`You cannot set a custom marker callback when UseDynamicSizeMarkers is set to true.\r\n                    Set UseDynamicSizeMakers to false.`)\r\n                );\r\n            }\r\n            this._iconCreationCallback = val;\r\n        }\r\n\r\n    /**\r\n     * Gets or sets the base size of dynamic markers in pixels. The actualy size of the dynamic marker is based on this.\r\n     * See {@link UseDynamicSizeMarkers}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get DynamicMarkerBaseSize(): number  { return this._dynamicMarkerBaseSize; }\r\n        public set DynamicMarkerBaseSize(val: number) { this._dynamicMarkerBaseSize = val; }\r\n\r\n    /**\r\n     * Gets or sets the ranges to use to calculate breakpoints and colors for dynamic markers.\r\n     * The map contains key/value pairs, with the keys being\r\n     * the breakpoint sizes and the values the colors to be used for the dynamic marker in that range. See {@link UseDynamicSizeMarkers}.\r\n     *\r\n     * @memberof ClusterLayerDirective\r\n     */\r\n    @Input()\r\n        public get DynamicMarkerRanges(): Map<number, string>  { return this._dynamicMarkerRanges; }\r\n        public set DynamicMarkerRanges(val: Map<number, string>) { this._dynamicMarkerRanges = val; }\r\n\r\n    /**\r\n     * Determines whether the layer clusters. This property can only be set on creation of the layer.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public EnableClustering: boolean = false;\r\n\r\n    /**\r\n     * Gets or sets the grid size to be used for clustering.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public GridSize: number = 150;\r\n\r\n    /**\r\n     * Gets or sets the IconInfo to be used to create a custom marker images. Supports font-based, SVG, graphics and more.\r\n     * See {@link IMarkerIconInfo}.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public IconInfo: IMarkerIconInfo;\r\n\r\n    /**\r\n     * Gets or sets An offset applied to the positioning of the layer.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public LayerOffset: IPoint = null;\r\n\r\n    /**\r\n     *  IMarkerOptions array holding the marker info.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get MarkerOptions(): Array<IMarkerOptions> { return this._markers; }\r\n        public set MarkerOptions(val: Array<IMarkerOptions>) {\r\n            if (this._streaming) {\r\n                this._markersLast.push(...val.slice(0));\r\n                this._markers.push(...val);\r\n            }\r\n            else {\r\n                this._markers = val.slice(0);\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Gets or sets the cluster styles\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get Styles(): Array<IClusterIconInfo> { return this._styles; }\r\n        public set Styles(val: Array<IClusterIconInfo>) { this._styles = val; }\r\n\r\n    /**\r\n     * Sets whether to treat changes in the MarkerOptions as streams of new markers. In thsi mode, changing the\r\n     * Array supplied in MarkerOptions will be incrementally drawn on the map as opposed to replace the markers on the map.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get TreatNewMarkerOptionsAsStream(): boolean { return this._streaming; }\r\n        public set TreatNewMarkerOptionsAsStream(val: boolean) { this._streaming = val; }\r\n\r\n    /**\r\n     * Gets or sets whether to use dynamic markers. Dynamic markers change in size and color depending on the number of\r\n     * pins in the cluster. If set to true, this will take precendence over any custom marker creation.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input()\r\n        public get UseDynamicSizeMarkers(): boolean { return this._useDynamicSizeMarker; }\r\n        public set UseDynamicSizeMarkers(val: boolean) {\r\n            this._useDynamicSizeMarker = val;\r\n            if (val) {\r\n                this._iconCreationCallback = (m: Array<Marker>, info: IMarkerIconInfo) => {\r\n                    return ClusterLayerDirective.CreateDynamicSizeMarker(\r\n                        m.length, info, this._dynamicMarkerBaseSize, this._dynamicMarkerRanges);\r\n                };\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Sets the visibility of the marker layer\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public ZIndex: number = 0;\r\n\r\n    /**\r\n     * Gets or sets whether the cluster should zoom in on click\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Input() public ZoomOnClick: boolean = true;\r\n\r\n\r\n    ///\r\n    /// Delegates\r\n    ///\r\n\r\n    /**\r\n     * This event emitter gets emitted when the dynamic icon for a marker is being created.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Output() public DynamicMarkerCreated: EventEmitter<IMarkerIconInfo> = new EventEmitter<IMarkerIconInfo>();\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks a marker in the layer.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Output() public MarkerClick: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n    /**\r\n     * This event is fired when the user stops dragging a marker.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    @Output() public DragEnd: EventEmitter<IMarkerEvent> = new EventEmitter<IMarkerEvent>();\r\n\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets the id of the marker layer.\r\n     *\r\n     * @readonly\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapMarkerLayerDirective.\r\n     * @param _markerService - Concreate implementation of a {@link MarkerService}.\r\n     * @param _layerService - Concreate implementation of a {@link LayerService}.\r\n     * @param _clusterService - Concreate implementation of a {@link ClusterService}.\r\n     * @param _mapService - Concreate implementation of a {@link MapService}.\r\n     * @param _zone - Concreate implementation of a {@link NgZone} service.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    constructor(\r\n        private _markerService: MarkerService,\r\n        private _layerService: LayerService,\r\n        private _clusterService: ClusterService,\r\n        private _mapService: MapService,\r\n        private _zone: NgZone) {\r\n        this._id = layerId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Translates a geo location to a pixel location relative to the map viewport.\r\n     *\r\n     * @param [loc] - {@link ILatLong} containing the geo coordinates.\r\n     * @returns - A promise that when fullfilled contains an {@link IPoint} representing the pixel coordinates.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public LocationToPixel(loc: ILatLong): Promise<IPoint> {\r\n        return this._markerService.LocationToPoint(loc);\r\n    }\r\n\r\n    /**\r\n     * Called after Component content initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public ngAfterContentInit() {\r\n        const layerOptions: ILayerOptions = {\r\n            id: this._id\r\n        };\r\n        this._zone.runOutsideAngular(() => {\r\n            const fakeLayerDirective: any = {\r\n                Id : this._id,\r\n                Visible: this.Visible\r\n            };\r\n            if (!this.EnableClustering) {\r\n                this._layerService.AddLayer(fakeLayerDirective);\r\n                this._layerPromise = this._layerService.GetNativeLayer(fakeLayerDirective);\r\n                this._service = this._layerService;\r\n            }\r\n            else {\r\n                fakeLayerDirective.LayerOffset = this.LayerOffset;\r\n                fakeLayerDirective.ZIndex = this.ZIndex;\r\n                fakeLayerDirective.ClusteringEnabled = this.EnableClustering;\r\n                fakeLayerDirective.ClusterPlacementMode = this.ClusterPlacementMode;\r\n                fakeLayerDirective.GridSize = this.GridSize;\r\n                fakeLayerDirective.ClusterClickAction = this.ClusterClickAction;\r\n                fakeLayerDirective.IconInfo = this.ClusterIconInfo;\r\n                fakeLayerDirective.CustomMarkerCallback = this.CustomMarkerCallback;\r\n                fakeLayerDirective.UseDynamicSizeMarkers = this.UseDynamicSizeMarkers;\r\n                this._clusterService.AddLayer(fakeLayerDirective);\r\n                this._layerPromise = this._clusterService.GetNativeLayer(fakeLayerDirective);\r\n                this._service = this._clusterService;\r\n            }\r\n            this._layerPromise.then(l => {\r\n                l.SetVisible(this.Visible);\r\n                if (this.MarkerOptions) {\r\n                    this._zone.runOutsideAngular(() => this.UpdateMarkers());\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public ngOnDestroy() {\r\n        this._layerPromise.then(l => {\r\n            l.Delete();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        let shouldSetOptions: boolean = false;\r\n        const o: IClusterOptions = {\r\n            id: this._id\r\n        };\r\n        if (changes['MarkerOptions']) {\r\n            this._zone.runOutsideAngular(() => {\r\n                this.UpdateMarkers();\r\n            });\r\n        }\r\n        if (changes['Visible'] && !changes['Visible'].firstChange) {\r\n            this._zone.runOutsideAngular(() => {\r\n                this._layerPromise.then(l => l.SetVisible(this.Visible));\r\n            });\r\n        }\r\n        if (changes['EnableClustering'] && !changes['EnableClustering'].firstChange) {\r\n            if ('StopClustering' in this._service) {\r\n                o.clusteringEnabled = this.EnableClustering;\r\n                shouldSetOptions = true;\r\n            }\r\n            else {\r\n                throw (new Error('You cannot change EnableClustering after the layer has been created.'));\r\n            }\r\n        }\r\n        if (changes['ClusterPlacementMode'] && !changes['ClusterPlacementMode'].firstChange && 'StopClustering' in this._service) {\r\n            o.placementMode = this.ClusterPlacementMode;\r\n            shouldSetOptions = true;\r\n        }\r\n        if (changes['GridSize'] && !changes['GridSize'].firstChange && 'StopClustering' in this._service) {\r\n            o.gridSize = this.GridSize;\r\n            shouldSetOptions = true;\r\n        }\r\n        if (changes['ClusterClickAction'] && !changes['ClusterClickAction'].firstChange && 'StopClustering' in this._service) {\r\n            o.zoomOnClick = this.ClusterClickAction === ClusterClickAction.ZoomIntoCluster;\r\n            shouldSetOptions = true;\r\n        }\r\n        if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||\r\n            (changes['LayerOffset'] && !changes['LayerOffset'].firstChange) ||\r\n            (changes['IconInfo'] && !changes['IconInfo'].firstChange)\r\n        ) {\r\n            throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));\r\n        }\r\n\r\n        if (shouldSetOptions) {\r\n            this._zone.runOutsideAngular(() => {\r\n                const fakeLayerDirective: any = {Id : this._id};\r\n                this._layerPromise.then(l => l.SetOptions(o));\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtains a string representation of the Marker Id.\r\n     * @returns - string representation of the marker id.\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    public toString(): string { return 'MapMarkerLayer-' + this._id.toString(); }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Adds various event listeners for the marker.\r\n     *\r\n     * @param m - the marker for which to add the event.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     */\r\n    private AddEventListeners(m: Marker): void {\r\n        m.AddListener('click', (e: MouseEvent) => this.MarkerClick.emit({\r\n                Marker: m,\r\n                Click: e,\r\n                Location: this._markerService.GetCoordinatesFromClick(e),\r\n                Pixels: this._markerService.GetPixelsFromClick(e)\r\n            }));\r\n        m.AddListener('dragend', (e: MouseEvent) => this.DragEnd.emit({\r\n                Marker: m,\r\n                Click: e,\r\n                Location: this._markerService.GetCoordinatesFromClick(e),\r\n                Pixels: this._markerService.GetPixelsFromClick(e)\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Sets or updates the markers based on the marker options. This will place the markers on the map\r\n     * and register the associated events.\r\n     *\r\n     * @memberof MapMarkerLayerDirective\r\n     * @method\r\n     */\r\n    private UpdateMarkers(): void {\r\n        if (this._layerPromise == null) { return; }\r\n        this._layerPromise.then(l => {\r\n            const markers: Array<IMarkerOptions> = this._streaming ? this._markersLast.splice(0) : this._markers;\r\n\r\n            // generate the promise for the markers\r\n            const mp: Promise<Array<Marker>> = this._service.CreateMarkers(markers, this.IconInfo);\r\n\r\n            // set markers once promises are fullfilled.\r\n            mp.then(m => {\r\n                m.forEach(marker => {\r\n                     this.AddEventListeners(marker);\r\n                });\r\n                this._streaming ? l.AddEntities(m) : l.SetEntities(m);\r\n            });\r\n        });\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, SimpleChange, Input, Output, OnDestroy, OnChanges,\r\n    EventEmitter, ContentChild, AfterContentInit, ViewContainerRef, NgZone,\r\n    SimpleChanges\r\n} from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ISize } from '../interfaces/isize';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolygonEvent } from '../interfaces/ipolygon-event';\r\nimport { IPolygonOptions } from '../interfaces/ipolygon-options';\r\nimport { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { ILabelOptions } from '../interfaces/ilabel-options';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { MapService } from '../services/map.service';\r\nimport { Layer } from '../models/layer';\r\nimport { Polygon } from '../models/polygon';\r\nimport { MapLabel } from '../models/map-label';\r\nimport { CanvasOverlay } from '../models/canvas-overlay';\r\n\r\n/**\r\n * internal counter to use as ids for polygons.\r\n */\r\nlet layerId = 1000000;\r\n\r\n/**\r\n * MapPolygonLayerDirective performantly renders a large set of polygons on a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-polygon-layer [PolygonOptions]=\"_polygons\"></x-map-polygon-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-polygon-layer'\r\n})\r\nexport class MapPolygonLayerDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _id: number;\r\n    private _layerPromise: Promise<Layer>;\r\n    private _service: LayerService;\r\n    private _canvas: CanvasOverlay;\r\n    private _labels: Array<{loc: ILatLong, title: string}> = new Array<{loc: ILatLong, title: string}>();\r\n    private _tooltip: MapLabel;\r\n    private _tooltipSubscriptions: Array<Subscription> = new Array<Subscription>();\r\n    private _tooltipVisible: boolean = false;\r\n    private _defaultOptions: ILabelOptions = {\r\n        fontSize: 11,\r\n        fontFamily: 'sans-serif',\r\n        strokeWeight: 2,\r\n        strokeColor: '#000000',\r\n        fontColor: '#ffffff'\r\n    };\r\n    private _streaming: boolean = false;\r\n    private _polygons: Array<IPolygonOptions> = new Array<IPolygonOptions>();\r\n    private _polygonsLast: Array<IPolygonOptions> = new Array<IPolygonOptions>();\r\n\r\n    /**\r\n     * Set the maximum zoom at which the polygon labels are visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public LabelMaxZoom: number = Number.MAX_SAFE_INTEGER;\r\n\r\n    /**\r\n     * Set the minimum zoom at which the polygon labels are visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public LabelMinZoom: number = -1;\r\n\r\n    /**\r\n     * Sepcifies styleing options for on-map polygon labels.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public LabelOptions: ILabelOptions;\r\n\r\n    /**\r\n     * Gets or sets An offset applied to the positioning of the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public LayerOffset: IPoint = null;\r\n\r\n    /**\r\n     * An array of polygon options representing the polygons in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input()\r\n        public get PolygonOptions(): Array<IPolygonOptions> { return this._polygons; }\r\n        public set PolygonOptions(val: Array<IPolygonOptions>) {\r\n            if (this._streaming) {\r\n                this._polygonsLast.push(...val.slice(0));\r\n                this._polygons.push(...val);\r\n            }\r\n            else {\r\n                this._polygons = val.slice(0);\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Whether to show the polygon titles as the labels on the polygons.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public ShowLabels: boolean = false;\r\n\r\n    /**\r\n     * Whether to show the titles of the polygosn as the tooltips on the polygons.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public ShowTooltips: boolean = true;\r\n\r\n    /**\r\n     * Sets whether to treat changes in the PolygonOptions as streams of new markers. In this mode, changing the\r\n     * Array supplied in PolygonOptions will be incrementally drawn on the map as opposed to replace the polygons on the map.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input()\r\n        public get TreatNewPolygonOptionsAsStream(): boolean { return this._streaming; }\r\n        public set TreatNewPolygonOptionsAsStream(val: boolean) { this._streaming = val; }\r\n\r\n    /**\r\n     * Sets the visibility of the marker layer\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Input() public ZIndex: number = 0;\r\n\r\n    ///\r\n    /// Delegates\r\n    ///\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks a polygon in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() public PolygonClick: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on a polygon in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() PolygonDblClick: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on a polygon in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() PolygonMouseMove: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired on mouseout on a polygon in the layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() PolygonMouseOut: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n    /**\r\n     * This event is fired on mouseover on a polygon in a layer.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    @Output() PolygonMouseOver: EventEmitter<IPolygonEvent> = new EventEmitter<IPolygonEvent>();\r\n\r\n\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets the id of the marker layer.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapPolygonLayerDirective.\r\n     * @param _layerService - Concreate implementation of a {@link LayerService}.\r\n     * @param _mapService - Concreate implementation of a {@link MapService}.\r\n     * @param _zone - Concreate implementation of a {@link NgZone} service.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    constructor(\r\n        private _layerService: LayerService,\r\n        private _mapService: MapService,\r\n        private _zone: NgZone) {\r\n        this._id = layerId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called after Component content initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public ngAfterContentInit() {\r\n        const layerOptions: ILayerOptions = {\r\n            id: this._id\r\n        };\r\n        this._zone.runOutsideAngular(() => {\r\n            const fakeLayerDirective: any = {\r\n                Id : this._id,\r\n                Visible: this.Visible,\r\n                LayerOffset: this.LayerOffset,\r\n                ZIndex: this.ZIndex\r\n            };\r\n            this._layerService.AddLayer(fakeLayerDirective);\r\n            this._layerPromise = this._layerService.GetNativeLayer(fakeLayerDirective);\r\n\r\n            Promise.all([\r\n                this._layerPromise,\r\n                this._mapService.CreateCanvasOverlay(el => this.DrawLabels(el))\r\n            ]).then(values => {\r\n                values[0].SetVisible(this.Visible);\r\n                this._canvas = values[1];\r\n                this._canvas._canvasReady.then(b => {\r\n                    this._tooltip = this._canvas.GetToolTipOverlay();\r\n                    this.ManageTooltip(this.ShowTooltips);\r\n                });\r\n                if (this.PolygonOptions) {\r\n                    this._zone.runOutsideAngular(() => this.UpdatePolygons());\r\n                }\r\n            });\r\n            this._service = this._layerService;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public ngOnDestroy() {\r\n        this._tooltipSubscriptions.forEach(s => s.unsubscribe());\r\n        this._layerPromise.then(l => {\r\n            l.Delete();\r\n        });\r\n        if (this._canvas) { this._canvas.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        if (changes['PolygonOptions']) {\r\n            this._zone.runOutsideAngular(() => {\r\n                this.UpdatePolygons();\r\n            });\r\n        }\r\n        if (changes['Visible'] && !changes['Visible'].firstChange) {\r\n            this._layerPromise.then(l => l.SetVisible(this.Visible));\r\n        }\r\n        if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||\r\n            (changes['LayerOffset'] && !changes['LayerOffset'].firstChange)\r\n        ) {\r\n            throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));\r\n        }\r\n        if ((changes['ShowLabels'] && !changes['ShowLabels'].firstChange) ||\r\n            (changes['LabelMinZoom'] && !changes['LabelMinZoom'].firstChange) ||\r\n            (changes['LabelMaxZoom'] && !changes['LabelMaxZoom'].firstChange)\r\n        ) {\r\n            if (this._canvas) {\r\n                this._canvas.Redraw(true);\r\n            }\r\n        }\r\n        if (changes['ShowTooltips'] && this._tooltip) {\r\n            this.ManageTooltip(changes['ShowTooltips'].currentValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtains a string representation of the Marker Id.\r\n     * @returns - string representation of the marker id.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    public toString(): string { return 'MapPolygonLayer-' + this._id.toString(); }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Adds various event listeners for the marker.\r\n     *\r\n     * @param p - the polygon for which to add the event.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    private AddEventListeners(p: Polygon): void {\r\n        const handlers = [\r\n            { name: 'click', handler: (ev: MouseEvent) => this.PolygonClick.emit({Polygon: p, Click: ev}) },\r\n            { name: 'dblclick', handler: (ev: MouseEvent) => this.PolygonDblClick.emit({Polygon: p, Click: ev}) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.PolygonMouseMove.emit({Polygon: p, Click: ev}) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.PolygonMouseOut.emit({Polygon: p, Click: ev}) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.PolygonMouseOver.emit({Polygon: p, Click: ev}) }\r\n        ];\r\n        handlers.forEach((obj) => p.AddListener(obj.name, obj.handler));\r\n    }\r\n\r\n    /**\r\n     * Draws the polygon labels. Called by the Canvas overlay.\r\n     *\r\n     * @param el - The canvas on which to draw the labels.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    private DrawLabels(el: HTMLCanvasElement): void {\r\n        if (this.ShowLabels) {\r\n            this._mapService.GetZoom().then(z => {\r\n                if (this.LabelMinZoom <= z && this.LabelMaxZoom >= z) {\r\n                    const ctx: CanvasRenderingContext2D = el.getContext('2d');\r\n                    const labels = this._labels.map(x => x.title);\r\n                    this._mapService.LocationsToPoints(this._labels.map(x => x.loc)).then(locs => {\r\n                        const size: ISize = this._mapService.MapSize;\r\n                        for (let i = 0, len = locs.length; i < len; i++) {\r\n                            // Don't draw the point if it is not in view. This greatly improves performance when zoomed in.\r\n                            if (locs[i].x >= 0 && locs[i].y >= 0 && locs[i].x <= size.width && locs[i].y <= size.height) {\r\n                                this.DrawText(ctx, locs[i], labels[i]);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the label text at the appropriate place on the canvas.\r\n     * @param ctx - Canvas drawing context.\r\n     * @param loc - Pixel location on the canvas where to center the text.\r\n     * @param text - Text to draw.\r\n     */\r\n    private DrawText(ctx: CanvasRenderingContext2D, loc: IPoint, text: string) {\r\n        let lo: ILabelOptions = this.LabelOptions;\r\n        if (lo == null && this._tooltip) { lo = this._tooltip.DefaultLabelStyle; }\r\n        if (lo == null) { lo = this._defaultOptions; }\r\n\r\n        ctx.strokeStyle = lo.strokeColor;\r\n        ctx.font = `${lo.fontSize}px ${lo.fontFamily}`;\r\n        ctx.textAlign = 'center';\r\n        const strokeWeight: number = lo.strokeWeight;\r\n        if (text && strokeWeight && strokeWeight > 0) {\r\n                ctx.lineWidth = strokeWeight;\r\n                ctx.strokeText(text, loc.x, loc.y);\r\n        }\r\n        ctx.fillStyle = lo.fontColor;\r\n        ctx.fillText(text, loc.x, loc.y);\r\n    }\r\n\r\n    /**\r\n     * Manages the tooltip and the attachment of the associated events.\r\n     *\r\n     * @param show - True to enable the tooltip, false to disable.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    private ManageTooltip(show: boolean): void {\r\n        if (show && this._canvas) {\r\n            // add tooltip subscriptions\r\n            this._tooltip.Set('hidden', true);\r\n            this._tooltipVisible = false;\r\n            this._tooltipSubscriptions.push(this.PolygonMouseMove.asObservable().subscribe(e => {\r\n                if (this._tooltipVisible) {\r\n                    const loc: ILatLong = this._canvas.GetCoordinatesFromClick(e.Click);\r\n                    this._tooltip.Set('position', loc);\r\n                }\r\n            }));\r\n            this._tooltipSubscriptions.push(this.PolygonMouseOver.asObservable().subscribe(e => {\r\n                if (e.Polygon.Title && e.Polygon.Title.length > 0) {\r\n                    const loc: ILatLong = this._canvas.GetCoordinatesFromClick(e.Click);\r\n                    this._tooltip.Set('text', e.Polygon.Title);\r\n                    this._tooltip.Set('position', loc);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                }\r\n            }));\r\n            this._tooltipSubscriptions.push(this.PolygonMouseOut.asObservable().subscribe(e => {\r\n                if (this._tooltipVisible) {\r\n                    this._tooltip.Set('hidden', true);\r\n                    this._tooltipVisible = false;\r\n                }\r\n            }));\r\n        }\r\n        else {\r\n            // remove tooltip subscriptions\r\n            this._tooltipSubscriptions.forEach(s => s.unsubscribe());\r\n            this._tooltipSubscriptions.splice(0);\r\n            this._tooltip.Set('hidden', true);\r\n            this._tooltipVisible = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets or updates the polygons based on the polygon options. This will place the polygons on the map\r\n     * and register the associated events.\r\n     *\r\n     * @memberof MapPolygonLayerDirective\r\n     * @method\r\n     */\r\n    private UpdatePolygons(): void {\r\n        if (this._layerPromise == null) {\r\n            return;\r\n        }\r\n        this._layerPromise.then(l => {\r\n            const polygons: Array<IPolygonOptions> = this._streaming ? this._polygonsLast.splice(0) : this._polygons;\r\n            if (!this._streaming) { this._labels.splice(0); }\r\n\r\n            // generate the promise for the markers\r\n            const lp: Promise<Array<Polygon>> = this._service.CreatePolygons(l.GetOptions().id, polygons);\r\n\r\n            // set markers once promises are fullfilled.\r\n            lp.then(p => {\r\n                p.forEach(poly => {\r\n                    if (poly.Title != null && poly.Title.length > 0) { this._labels.push({loc: poly.Centroid, title: poly.Title}); }\r\n                    this.AddEventListeners(poly);\r\n                });\r\n                this._streaming ? l.AddEntities(p) : l.SetEntities(p);\r\n                if (this._canvas) { this._canvas.Redraw(!this._streaming); }\r\n            });\r\n        });\r\n    }\r\n\r\n}\r\n","import {\r\n    Directive, SimpleChange, Input, Output, OnDestroy, OnChanges,\r\n    EventEmitter, ContentChild, AfterContentInit, ViewContainerRef, NgZone,\r\n    SimpleChanges\r\n} from '@angular/core';\r\nimport { Subscription } from 'rxjs';\r\nimport { IPoint } from '../interfaces/ipoint';\r\nimport { ISize } from '../interfaces/isize';\r\nimport { ILatLong } from '../interfaces/ilatlong';\r\nimport { IPolylineEvent } from '../interfaces/ipolyline-event';\r\nimport { IPolylineOptions } from '../interfaces/ipolyline-options';\r\nimport { ILayerOptions } from '../interfaces/ilayer-options';\r\nimport { ILabelOptions } from '../interfaces/ilabel-options';\r\nimport { LayerService } from '../services/layer.service';\r\nimport { MapService } from '../services/map.service';\r\nimport { Layer } from '../models/layer';\r\nimport { Polyline } from '../models/polyline';\r\nimport { MapLabel } from '../models/map-label';\r\nimport { CanvasOverlay } from '../models/canvas-overlay';\r\n\r\n/**\r\n * internal counter to use as ids for polylines.\r\n */\r\nlet layerId = 1000000;\r\n\r\n/**\r\n * MapPolylineLayerDirective performantly renders a large set of polyline on a {@link MapComponent}.\r\n *\r\n * ### Example\r\n * ```typescript\r\n * import {Component} from '@angular/core';\r\n * import {MapComponent} from '...';\r\n *\r\n * @Component({\r\n *  selector: 'my-map-cmp',\r\n *  styles: [`\r\n *   .map-container {\r\n *     height: 300px;\r\n *   }\r\n * `],\r\n * template: `\r\n *   <x-map [Latitude]=\"lat\" [Longitude]=\"lng\" [Zoom]=\"zoom\">\r\n *      <x-map-polyline-layer [PolygonOptions]=\"_polyline\"></x-map-polyline-layer>\r\n *   </x-map>\r\n * `\r\n * })\r\n * ```\r\n *\r\n * @export\r\n */\r\n@Directive({\r\n    selector: 'x-map-polyline-layer'\r\n})\r\nexport class MapPolylineLayerDirective implements OnDestroy, OnChanges, AfterContentInit {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _id: number;\r\n    private _layerPromise: Promise<Layer>;\r\n    private _service: LayerService;\r\n    private _canvas: CanvasOverlay;\r\n    private _labels: Array<{loc: ILatLong, title: string}> = new Array<{loc: ILatLong, title: string}>();\r\n    private _tooltip: MapLabel;\r\n    private _tooltipSubscriptions: Array<Subscription> = new Array<Subscription>();\r\n    private _tooltipVisible: boolean = false;\r\n    private _defaultOptions: ILabelOptions = {\r\n        fontSize: 11,\r\n        fontFamily: 'sans-serif',\r\n        strokeWeight: 2,\r\n        strokeColor: '#000000',\r\n        fontColor: '#ffffff'\r\n    };\r\n    private _streaming: boolean = false;\r\n    private _polylines: Array<IPolylineOptions> = new Array<IPolylineOptions>();\r\n    private _polylinesLast: Array<IPolylineOptions> = new Array<IPolylineOptions>();\r\n\r\n    /**\r\n     * Set the maximum zoom at which the polyline labels are visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public LabelMaxZoom: number = Number.MAX_SAFE_INTEGER;\r\n\r\n    /**\r\n     * Set the minimum zoom at which the polyline labels are visible. Ignored if ShowLabel is false.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public LabelMinZoom: number = -1;\r\n\r\n    /**\r\n     * Sepcifies styleing options for on-map polyline labels.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public LabelOptions: ILabelOptions;\r\n\r\n    /**\r\n     * Gets or sets An offset applied to the positioning of the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public LayerOffset: IPoint = null;\r\n\r\n    /**\r\n     * An array of polyline options representing the polylines in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input()\r\n        public get PolylineOptions(): Array<IPolylineOptions> { return this._polylines; }\r\n        public set PolylineOptions(val: Array<IPolylineOptions>) {\r\n            if (this._streaming) {\r\n                this._polylinesLast.push(...val.slice(0));\r\n                this._polylines.push(...val);\r\n            }\r\n            else {\r\n                this._polylines = val.slice(0);\r\n            }\r\n        }\r\n\r\n    /**\r\n     * Whether to show the polylines titles as the labels on the polylines.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public ShowLabels: boolean = false;\r\n\r\n    /**\r\n     * Whether to show the titles of the polylines as the tooltips on the polylines.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public ShowTooltips: boolean = true;\r\n\r\n    /**\r\n     * Sets whether to treat changes in the PolylineOptions as streams of new markers. In this mode, changing the\r\n     * Array supplied in PolylineOptions will be incrementally drawn on the map as opposed to replace the polylines on the map.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input()\r\n        public get TreatNewPolylineOptionsAsStream(): boolean { return this._streaming; }\r\n        public set TreatNewPolylineOptionsAsStream(val: boolean) { this._streaming = val; }\r\n\r\n    /**\r\n     * Sets the visibility of the marker layer\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public Visible: boolean;\r\n\r\n    /**\r\n     * Gets or sets the z-index of the layer. If not used, layers get stacked in the order created.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Input() public ZIndex: number = 0;\r\n\r\n    ///\r\n    /// Delegates\r\n    ///\r\n\r\n    /**\r\n     * This event emitter gets emitted when the user clicks a polyline in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() public PolylineClick: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM dblclick event is fired on a polyline in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() PolylineDblClick: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired when the DOM mousemove event is fired on a polyline in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() PolylineMouseMove: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired on mouseout on a polyline in the layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() PolylineMouseOut: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n    /**\r\n     * This event is fired on mouseover on a polyline in a layer.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    @Output() PolylineMouseOver: EventEmitter<IPolylineEvent> = new EventEmitter<IPolylineEvent>();\r\n\r\n\r\n\r\n    ///\r\n    /// Property declarations\r\n    ///\r\n\r\n    /**\r\n     * Gets the id of the polyline layer.\r\n     *\r\n     * @readonly\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public get Id(): number { return this._id; }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of MapPolylineLayerDirective.\r\n     * @param _layerService - Concreate implementation of a {@link LayerService}.\r\n     * @param _mapService - Concreate implementation of a {@link MapService}.\r\n     * @param _zone - Concreate implementation of a {@link NgZone} service.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    constructor(\r\n        private _layerService: LayerService,\r\n        private _mapService: MapService,\r\n        private _zone: NgZone) {\r\n        this._id = layerId++;\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Called after Component content initialization. Part of ng Component life cycle.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public ngAfterContentInit() {\r\n        const layerOptions: ILayerOptions = {\r\n            id: this._id\r\n        };\r\n        this._zone.runOutsideAngular(() => {\r\n            const fakeLayerDirective: any = {\r\n                Id : this._id,\r\n                Visible: this.Visible,\r\n                LayerOffset: this.LayerOffset,\r\n                ZIndex: this.ZIndex\r\n            };\r\n            this._layerService.AddLayer(fakeLayerDirective);\r\n            this._layerPromise = this._layerService.GetNativeLayer(fakeLayerDirective);\r\n\r\n            Promise.all([\r\n                    this._layerPromise,\r\n                    this._mapService.CreateCanvasOverlay(el => this.DrawLabels(el))\r\n                ]).then(values => {\r\n                    values[0].SetVisible(this.Visible);\r\n                    this._canvas = values[1];\r\n                    this._canvas._canvasReady.then(b => {\r\n                        this._tooltip = this._canvas.GetToolTipOverlay();\r\n                        this.ManageTooltip(this.ShowTooltips);\r\n                    });\r\n                    if (this.PolylineOptions) {\r\n                        this._zone.runOutsideAngular(() => this.UpdatePolylines());\r\n                    }\r\n                });\r\n            this._service = this._layerService;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called on component destruction. Frees the resources used by the component. Part of the ng Component life cycle.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public ngOnDestroy() {\r\n        this._tooltipSubscriptions.forEach(s => s.unsubscribe());\r\n        this._layerPromise.then(l => {\r\n            l.Delete();\r\n        });\r\n        if (this._canvas) { this._canvas.Delete(); }\r\n    }\r\n\r\n    /**\r\n     * Reacts to changes in data-bound properties of the component and actuates property changes in the underling layer model.\r\n     *\r\n     * @param changes - collection of changes.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public ngOnChanges(changes: { [key: string]: SimpleChange }) {\r\n        if (changes['PolylineOptions']) {\r\n            this._zone.runOutsideAngular(() => {\r\n                this.UpdatePolylines();\r\n            });\r\n        }\r\n        if (changes['Visible'] && !changes['Visible'].firstChange) {\r\n            this._layerPromise.then(l => l.SetVisible(this.Visible));\r\n        }\r\n        if ((changes['ZIndex'] && !changes['ZIndex'].firstChange) ||\r\n            (changes['LayerOffset'] && !changes['LayerOffset'].firstChange)\r\n        ) {\r\n            throw (new Error('You cannot change ZIndex or LayerOffset after the layer has been created.'));\r\n        }\r\n        if ((changes['ShowLabels'] && !changes['ShowLabels'].firstChange) ||\r\n            (changes['LabelMinZoom'] && !changes['LabelMinZoom'].firstChange) ||\r\n            (changes['LabelMaxZoom'] && !changes['LabelMaxZoom'].firstChange)\r\n        ) {\r\n            if (this._canvas) {\r\n                this._canvas.Redraw(true);\r\n            }\r\n        }\r\n        if (changes['ShowTooltips'] && this._tooltip) {\r\n            this.ManageTooltip(changes['ShowTooltips'].currentValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtains a string representation of the Layer Id.\r\n     * @returns - string representation of the layer id.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    public toString(): string { return 'MapPolylineLayer-' + this._id.toString(); }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Adds various event listeners for the polylines.\r\n     *\r\n     * @param p - the polyline for which to add the event.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    private AddEventListeners(p: Polyline): void {\r\n        const handlers = [\r\n            { name: 'click', handler: (ev: MouseEvent) => this.PolylineClick.emit({Polyline: p, Click: ev}) },\r\n            { name: 'dblclick', handler: (ev: MouseEvent) => this.PolylineDblClick.emit({Polyline: p, Click: ev}) },\r\n            { name: 'mousemove', handler: (ev: MouseEvent) => this.PolylineMouseMove.emit({Polyline: p, Click: ev}) },\r\n            { name: 'mouseout', handler: (ev: MouseEvent) => this.PolylineMouseOut.emit({Polyline: p, Click: ev}) },\r\n            { name: 'mouseover', handler: (ev: MouseEvent) => this.PolylineMouseOver.emit({Polyline: p, Click: ev}) }\r\n        ];\r\n        handlers.forEach((obj) => p.AddListener(obj.name, obj.handler));\r\n    }\r\n\r\n    /**\r\n     * Draws the polyline labels. Called by the Canvas overlay.\r\n     *\r\n     * @param el - The canvas on which to draw the labels.\r\n     * @memberof MapPolylineLayerDirective\r\n     */\r\n    private DrawLabels(el: HTMLCanvasElement): void {\r\n        if (this.ShowLabels) {\r\n            this._mapService.GetZoom().then(z => {\r\n                if (this.LabelMinZoom <= z && this.LabelMaxZoom >= z) {\r\n                    const ctx: CanvasRenderingContext2D = el.getContext('2d');\r\n                    const labels = this._labels.map(x => x.title);\r\n                    this._mapService.LocationsToPoints(this._labels.map(x => x.loc)).then(locs => {\r\n                        const size: ISize = this._mapService.MapSize;\r\n                        for (let i = 0, len = locs.length; i < len; i++) {\r\n                            // Don't draw the point if it is not in view. This greatly improves performance when zoomed in.\r\n                            if (locs[i].x >= 0 && locs[i].y >= 0 && locs[i].x <= size.width && locs[i].y <= size.height) {\r\n                                this.DrawText(ctx, locs[i], labels[i]);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the label text at the appropriate place on the canvas.\r\n     * @param ctx - Canvas drawing context.\r\n     * @param loc - Pixel location on the canvas where to center the text.\r\n     * @param text - Text to draw.\r\n     */\r\n    private DrawText(ctx: CanvasRenderingContext2D, loc: IPoint, text: string) {\r\n        let lo: ILabelOptions = this.LabelOptions;\r\n        if (lo == null && this._tooltip) { lo = this._tooltip.DefaultLabelStyle; }\r\n        if (lo == null) { lo = this._defaultOptions; }\r\n\r\n        ctx.strokeStyle = lo.strokeColor;\r\n        ctx.font = `${lo.fontSize}px ${lo.fontFamily}`;\r\n        ctx.textAlign = 'center';\r\n        const strokeWeight: number = lo.strokeWeight;\r\n        if (text && strokeWeight && strokeWeight > 0) {\r\n                ctx.lineWidth = strokeWeight;\r\n                ctx.strokeText(text, loc.x, loc.y);\r\n        }\r\n        ctx.fillStyle = lo.fontColor;\r\n        ctx.fillText(text, loc.x, loc.y);\r\n    }\r\n\r\n    /**\r\n     * Manages the tooltip and the attachment of the associated events.\r\n     *\r\n     * @param show - True to enable the tooltip, false to disable.\r\n     * @memberof MapPolygonLayerDirective\r\n     */\r\n    private ManageTooltip(show: boolean): void {\r\n        if (show && this._canvas) {\r\n            // add tooltip subscriptions\r\n            this._tooltip.Set('hidden', true);\r\n            this._tooltipVisible = false;\r\n            this._tooltipSubscriptions.push(this.PolylineMouseMove.asObservable().subscribe(e => {\r\n                if (this._tooltipVisible) {\r\n                    const loc: ILatLong = this._canvas.GetCoordinatesFromClick(e.Click);\r\n                    this._tooltip.Set('position', loc);\r\n                }\r\n            }));\r\n            this._tooltipSubscriptions.push(this.PolylineMouseOver.asObservable().subscribe(e => {\r\n                if (e.Polyline.Title && e.Polyline.Title.length > 0) {\r\n                    const loc: ILatLong = this._canvas.GetCoordinatesFromClick(e.Click);\r\n                    this._tooltip.Set('text', e.Polyline.Title);\r\n                    this._tooltip.Set('position', loc);\r\n                    if (!this._tooltipVisible) {\r\n                        this._tooltip.Set('hidden', false);\r\n                        this._tooltipVisible = true;\r\n                    }\r\n                }\r\n            }));\r\n            this._tooltipSubscriptions.push(this.PolylineMouseOut.asObservable().subscribe(e => {\r\n                if (this._tooltipVisible) {\r\n                    this._tooltip.Set('hidden', true);\r\n                    this._tooltipVisible = false;\r\n                }\r\n            }));\r\n        }\r\n        else {\r\n            // remove tooltip subscriptions\r\n            this._tooltipSubscriptions.forEach(s => s.unsubscribe());\r\n            this._tooltipSubscriptions.splice(0);\r\n            this._tooltip.Set('hidden', true);\r\n            this._tooltipVisible = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets or updates the polyliness based on the polyline options. This will place the polylines on the map\r\n     * and register the associated events.\r\n     *\r\n     * @memberof MapPolylineLayerDirective\r\n     * @method\r\n     */\r\n    private UpdatePolylines(): void {\r\n        if (this._layerPromise == null) {\r\n            return;\r\n        }\r\n        this._layerPromise.then(l => {\r\n            const polylines: Array<IPolylineOptions> = this._streaming ? this._polylinesLast.splice(0) : this._polylines;\r\n            if (!this._streaming) { this._labels.splice(0); }\r\n\r\n            // generate the promise for the polylines\r\n            const lp: Promise<Array<Polyline|Array<Polyline>>> = this._service.CreatePolylines(l.GetOptions().id, polylines);\r\n\r\n            // set polylines once promises are fullfilled.\r\n            lp.then(p => {\r\n                const y: Array<Polyline> = new Array<Polyline>();\r\n                p.forEach(poly => {\r\n                    if (Array.isArray(poly)) {\r\n                        let title: string = '';\r\n                        const centroids: Array<ILatLong> = new Array<ILatLong>();\r\n                        poly.forEach(x => {\r\n                            y.push(x);\r\n                            this.AddEventListeners(x);\r\n                            centroids.push(x.Centroid);\r\n                            if (x.Title != null && x.Title.length > 0 && title.length === 0) { title = x.Title; }\r\n                        });\r\n                        this._labels.push({loc: Polyline.GetPolylineCentroid(centroids), title: title});\r\n                    }\r\n                    else {\r\n                        y.push(poly);\r\n                        if (poly.Title != null && poly.Title.length > 0) { this._labels.push({loc: poly.Centroid, title: poly.Title}); }\r\n                        this.AddEventListeners(poly);\r\n                    }\r\n                });\r\n                this._streaming ? l.AddEntities(y) : l.SetEntities(y);\r\n                if (this._canvas) { this._canvas.Redraw(!this._streaming); }\r\n            });\r\n        });\r\n    }\r\n\r\n}\r\n","import { Injectable } from '@angular/core';\r\n\r\n/**\r\n * Abstract implementation. USed for defintion only and as a base to implement your\r\n * own provider.\r\n *\r\n * @export\r\n * @abstract\r\n */\r\n@Injectable()\r\nexport abstract class MapAPILoader {\r\n\r\n    /**\r\n     * Loads the necessary resources for a given map architecture.\r\n     *\r\n     * @abstract\r\n     * @returns - Promise fullfilled when the resources have been loaded.\r\n     *\r\n     * @memberof MapAPILoader\r\n     */\r\n    abstract Load(): Promise<void>;\r\n\r\n}\r\n\r\n/**\r\n * Document Reference service to assist with abstracting the availability of document. Needed for AOT and\r\n * Server Side rendering\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class DocumentRef {\r\n\r\n    /**\r\n     * Gets whether a document implementation is available. Generally will be true in the browser and false otherwise, unless there\r\n     * there is a browser-less implementation in the current non-browser environment.\r\n     *\r\n     * @readonly\r\n     * @memberof DocumentRef\r\n     */\r\n    public get IsAvailable(): boolean {\r\n        return !(typeof (document) === 'undefined');\r\n    }\r\n\r\n    /**\r\n     * Returns the document object of the current environment.\r\n     *\r\n     * @returns - The document object.\r\n     *\r\n     * @memberof DocumentRef\r\n     */\r\n    public GetNativeDocument(): any {\r\n        if (typeof (document) === 'undefined') {\r\n            return null;\r\n        }\r\n        return document;\r\n    }\r\n}\r\n\r\n/**\r\n * Window Reference service to assist with abstracting the availability of window. Needed for AOT and\r\n * Server Side rendering\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class WindowRef {\r\n\r\n    /**\r\n     * Gets whether a window implementation is available. Generally will be true in the browser and false otherwise, unless there\r\n     * there is a browser-less implementation in the current non-browser environment.\r\n     *\r\n     * @readonly\r\n     * @memberof WindowRef\r\n     */\r\n    public get IsAvailable(): boolean {\r\n        return !(typeof (window) === 'undefined');\r\n    }\r\n\r\n    /**\r\n     * Returns the window object of the current environment.\r\n     *\r\n     * @returns - The window object.\r\n     *\r\n     * @memberof WindowRef\r\n     */\r\n    public GetNativeWindow(): any {\r\n        if (typeof (window) === 'undefined') {\r\n            return null;\r\n        }\r\n        return window;\r\n    }\r\n}\r\n\r\n","import { Injectable, Optional } from '@angular/core';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from '../mapapiloader';\r\n\r\n/**\r\n * Protocol enumeration\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum ScriptProtocol {\r\n    HTTP,\r\n    HTTPS,\r\n    AUTO\r\n}\r\n\r\n/**\r\n * Bing Maps V8 specific loader configuration to be used with the {@link BingMapAPILoader}\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMapAPILoaderConfig  {\r\n\r\n    ///\r\n    /// API key for bing maps\r\n    ///\r\n    apiKey = '';\r\n\r\n    ///\r\n    /// Host and Path used for the `<script>` tag.\r\n    ///\r\n    hostAndPath = 'www.bing.com/api/maps/mapcontrol';\r\n\r\n    ///\r\n    /// Protocol used for the `<script>` tag.\r\n    ///\r\n    protocol: ScriptProtocol = ScriptProtocol.HTTPS;\r\n\r\n    ///\r\n    /// The branch to be used. Leave empty for production. Use experimental\r\n    ///\r\n    branch = '';\r\n}\r\n\r\n/**\r\n * Default loader configuration.\r\n */\r\nconst DEFAULT_CONFIGURATION = new BingMapAPILoaderConfig();\r\n\r\n/**\r\n * Bing Maps V8 implementation for the {@link MapAPILoader} service.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMapAPILoader extends MapAPILoader {\r\n\r\n    ///\r\n    /// Field defintitions.\r\n    ///\r\n    private _scriptLoadingPromise: Promise<void>;\r\n\r\n    ///\r\n    /// Property declarations.\r\n    ///\r\n\r\n    /**\r\n     * Gets the loader configuration.\r\n     *\r\n     * @readonly\r\n     * @memberof BingMapAPILoader\r\n     */\r\n    public get Config(): BingMapAPILoaderConfig { return this._config; }\r\n\r\n    /**\r\n     * Creates an instance of BingMapAPILoader.\r\n     * @param _config  - The loader configuration.\r\n     * @param _windowRef - An instance of {@link WindowRef}. Necessary because Bing Map V8 interacts with the window object.\r\n     * @param _documentRef - An instance of {@link DocumentRef}.\r\n     * Necessary because Bing Map V8 interacts with the document object.\r\n     *\r\n     * @memberof BingMapAPILoader\r\n     */\r\n    constructor( @Optional() private _config: BingMapAPILoaderConfig, private _windowRef: WindowRef, private _documentRef: DocumentRef) {\r\n        super();\r\n        if (this._config === null || this._config === undefined) {\r\n            this._config = DEFAULT_CONFIGURATION;\r\n        }\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapAPILoader implementation.\r\n    ///\r\n\r\n    /**\r\n     * Loads the necessary resources for Bing Maps V8.\r\n     *\r\n     * @memberof BingMapAPILoader\r\n     */\r\n    public Load(): Promise<void> {\r\n        if (this._scriptLoadingPromise) {\r\n            return this._scriptLoadingPromise;\r\n        }\r\n\r\n        const script = this._documentRef.GetNativeDocument().createElement('script');\r\n        script.type = 'text/javascript';\r\n        script.async = true;\r\n        script.defer = true;\r\n        const callbackName = `angular2bingmaps${new Date().getMilliseconds()}`;\r\n        script.src = this.GetScriptSrc(callbackName);\r\n\r\n        this._scriptLoadingPromise = new Promise<void>((resolve: Function, reject: Function) => {\r\n            (<any>this._windowRef.GetNativeWindow())[callbackName] = () => {\r\n                resolve();\r\n            };\r\n            script.onerror = (error: Event) => { reject(error); };\r\n        });\r\n        this._documentRef.GetNativeDocument().head.appendChild(script);\r\n        return this._scriptLoadingPromise;\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the Bing Map V8 scripts url for injections into the header.\r\n     *\r\n     * @param callbackName - Name of the function to be called when the Bing Maps V8 scripts are loaded.\r\n     * @returns - The url to be used to load the Bing Map scripts.\r\n     *\r\n     * @memberof BingMapAPILoader\r\n     */\r\n    private GetScriptSrc(callbackName: string): string {\r\n        const protocolType: ScriptProtocol = (this._config && this._config.protocol) || DEFAULT_CONFIGURATION.protocol;\r\n        let protocol: string;\r\n\r\n        switch (protocolType) {\r\n            case ScriptProtocol.AUTO:\r\n                protocol = '';\r\n                break;\r\n            case ScriptProtocol.HTTP:\r\n                protocol = 'http:';\r\n                break;\r\n            case ScriptProtocol.HTTPS:\r\n                protocol = 'https:';\r\n                break;\r\n        }\r\n\r\n        const hostAndPath: string = this._config.hostAndPath || DEFAULT_CONFIGURATION.hostAndPath;\r\n        const queryParams: { [key: string]: string } = {\r\n            callback: callbackName\r\n        };\r\n        if (this._config.branch !== '') {\r\n            queryParams['branch'] = this._config.branch;\r\n        }\r\n        const params: string = Object.keys(queryParams)\r\n            .map((k: string, i: number) => {\r\n                let param = (i === 0) ? '?' : '&';\r\n                return param += `${k}=${queryParams[k]}`;\r\n            })\r\n            .join('');\r\n        return `${protocol}//${hostAndPath}${params}`;\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { InfoWindow } from '../../models/info-window';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { InfoBoxActionDirective } from '../../components/infobox-action';\r\nimport { InfoBoxService } from '../infobox.service';\r\nimport { MapService } from '../../services/map.service';\r\nimport { InfoBoxComponent } from '../../components/infobox';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingInfoWindow } from '../../models/bing/bing-info-window';\r\nimport { BingMapEventsLookup } from '../../models/bing/bing-events-lookup';\r\n\r\n/**\r\n * Concrete implementation of the {@link InfoBoxService} contract for the Bing Maps V8 architecture.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingInfoBoxService implements InfoBoxService {\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _boxes: Map<InfoBoxComponent, Promise<InfoWindow>> = new Map<InfoBoxComponent, Promise<InfoWindow>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingInfoBoxService.\r\n     * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.\r\n     * @param _zone - An instance of NgZone to provide zone aware promises.\r\n     *\r\n     * @memberof BingInfoBoxService\r\n     */\r\n    constructor(private _mapService: MapService, private _zone: NgZone) { }\r\n\r\n    /**\r\n     * Adds an info window to the map or layer.\r\n     *\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     *\r\n     * @memberof BingInfoBoxService\r\n     */\r\n    public AddInfoWindow(info: InfoBoxComponent): void {\r\n        const options: IInfoWindowOptions = {};\r\n        if (typeof info.Latitude === 'number' && typeof info.Longitude === 'number') {\r\n            options.position = {\r\n                latitude: info.Latitude,\r\n                longitude: info.Longitude\r\n            };\r\n        }\r\n        if (typeof info.InfoWindowActions !== 'undefined' && info.InfoWindowActions.length > 0) {\r\n            options.actions = [];\r\n            info.InfoWindowActions.forEach((action: InfoBoxActionDirective) => {\r\n                options.actions.push({\r\n                    label: action.Label,\r\n                    eventHandler: () => { action.ActionClicked.emit(null); }\r\n                });\r\n            });\r\n        }\r\n        if (info.HtmlContent !== '') {\r\n            options.htmlContent = info.HtmlContent;\r\n        }\r\n        else {\r\n            options.title = info.Title;\r\n            options.description = info.Description;\r\n        }\r\n        if (info.xOffset || info.yOffset) {\r\n            if (options.pixelOffset == null) { options.pixelOffset = { x: 0, y: 0 }; }\r\n            if (info.xOffset) { options.pixelOffset.x = info.xOffset; }\r\n            if (info.yOffset) { options.pixelOffset.y = info.yOffset; }\r\n        }\r\n\r\n        options.visible = info.Visible;\r\n        const infoPromise = this._mapService.CreateInfoWindow(options);\r\n        this._boxes.set(info, infoPromise);\r\n    }\r\n\r\n    /**\r\n     * Closes an InfoBoxComponent that is open.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been closed.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public Close(info: InfoBoxComponent): Promise<void> {\r\n        return this._boxes.get(info).then((w) => w.Close());\r\n    }\r\n\r\n    /**\r\n     * Registers an event delegate for an info window.\r\n     *\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param infoComponent - The {@link InfoBoxComponent} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public CreateEventObservable<T>(eventName: string, infoComponent: InfoBoxComponent): Observable<T> {\r\n        const eventNameTranslated = BingMapEventsLookup[eventName];\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._boxes.get(infoComponent).then((b: InfoWindow) => {\r\n                b.AddListener(eventNameTranslated, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes an infobox.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been deleted.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public DeleteInfoWindow(info: InfoBoxComponent): Promise<void> {\r\n        const w = this._boxes.get(info);\r\n        if (w == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return w.then((i: InfoWindow) => {\r\n            return this._zone.run(() => {\r\n                i.Close();\r\n                this._boxes.delete(info);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Opens an infobox that is closed.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox has been opened.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public Open(info: InfoBoxComponent, loc?: ILatLong): Promise<void> {\r\n        if (info.CloseInfoBoxesOnOpen || info.Modal) {\r\n            // close all open info boxes.\r\n            this._boxes.forEach((v: Promise<InfoWindow>, i: InfoBoxComponent) => {\r\n                if (info.Id !== i.Id) {\r\n                    v.then(w => {\r\n                        if (w.IsOpen) {\r\n                            w.Close();\r\n                            i.Close();\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        return this._boxes.get(info).then((w) => {\r\n            const options: IInfoWindowOptions = {};\r\n            if (info.HtmlContent !== '') {\r\n                options.htmlContent = info.HtmlContent;\r\n            }\r\n            else {\r\n                options.title = info.Title;\r\n                options.description = info.Description;\r\n            }\r\n            w.SetOptions(options);\r\n\r\n            if (info.Latitude && info.Longitude) {\r\n                w.SetPosition({ latitude: info.Latitude, longitude: info.Longitude });\r\n            }\r\n            else if (loc) {\r\n                ///\r\n                /// this situation is specifically used for cluster layers that use spidering.\r\n                ///\r\n                w.SetPosition(loc);\r\n            }\r\n            else if (info.HostMarker) {\r\n                w.SetPosition({ latitude: info.HostMarker.Latitude, longitude: info.HostMarker.Longitude });\r\n            }\r\n            w.Open();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the infobox options.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @param options - {@link IInfoWindowOptions} object containing the options to set. Options provided are\r\n     * merged with the existing options of the underlying infobox.\r\n     * @returns - A promise that is fullfilled when the infobox options have been updated.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public SetOptions(info: InfoBoxComponent, options: IInfoWindowOptions): Promise<void> {\r\n        return this._boxes.get(info).then((i: InfoWindow) => i.SetOptions(options));\r\n    }\r\n\r\n    /**\r\n     * Set the position of the infobox based on the properties set on the InfoBox component.\r\n     *\r\n     * @abstract\r\n     * @param info - {@link InfoBoxComponent} component object representing the infobox.\r\n     * @returns - A promise that is fullfilled when the infobox position has been updated.\r\n     *\r\n     * @memberof InfoBoxService\r\n     */\r\n    public SetPosition(info: InfoBoxComponent): Promise<void> {\r\n        return this._boxes.get(info).then((i: InfoWindow) => i.SetPosition({\r\n            latitude: info.Latitude,\r\n            longitude: info.Longitude\r\n        }));\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer, Subject } from 'rxjs';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { MapMarkerDirective } from '../../components/map-marker';\r\nimport { MarkerService } from '../../services/marker.service';\r\nimport { MapService } from '../../services/map.service';\r\nimport { LayerService } from '../../services/layer.service';\r\nimport { ClusterService } from '../../services/cluster.service';\r\nimport { Marker } from '../../models/marker';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingConversions } from './bing-conversions';\r\n\r\n/**\r\n * Concrete implementation of the MarkerService abstract class for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMarkerService implements MarkerService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _markers: Map<MapMarkerDirective, Promise<Marker>> = new Map<MapMarkerDirective, Promise<Marker>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingMarkerService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.\r\n     * @param _layerService - {@link LayerService} instance.\r\n     * The concrete {@link BingLayerService} implementation is expected.\r\n     * @param _clusterService - {@link ClusterService} instance.\r\n     * The concrete {@link BingClusterService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n                private _layerService: LayerService,\r\n                private _clusterService: ClusterService,\r\n                private _zone: NgZone) {\r\n    }\r\n\r\n    ///\r\n    /// Public members and MarkerService implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.\r\n     *\r\n     * @param marker - The {@link MapMarkerDirective} to be added.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public AddMarker(marker: MapMarkerDirective): void {\r\n        const o: IMarkerOptions = {\r\n            position: { latitude: marker.Latitude, longitude: marker.Longitude },\r\n            title: marker.Title,\r\n            label: marker.Label,\r\n            draggable: marker.Draggable,\r\n            icon: marker.IconUrl,\r\n            iconInfo: marker.IconInfo,\r\n            isFirst: marker.IsFirstInSet,\r\n            isLast: marker.IsLastInSet\r\n        };\r\n        if (marker.Width) { o.width = marker.Width; }\r\n        if (marker.Height) { o.height = marker.Height; }\r\n        if (marker.Anchor) { o.anchor = marker.Anchor; }\r\n        if (marker.Metadata) { o.metadata = marker.Metadata; }\r\n\r\n        // create marker via promise.\r\n        let markerPromise: Promise<Marker> = null;\r\n        if (marker.InClusterLayer) {\r\n            markerPromise = this._clusterService.CreateMarker(marker.LayerId, o);\r\n        }\r\n        else if (marker.InCustomLayer) {\r\n            markerPromise = this._layerService.CreateMarker(marker.LayerId, o);\r\n        }\r\n        else {\r\n            markerPromise = this._mapService.CreateMarker(o);\r\n        }\r\n\r\n        this._markers.set(marker, markerPromise);\r\n        if (marker.IconInfo) {\r\n            markerPromise.then((m: Marker) => {\r\n                // update iconInfo to provide hook to do post icon creation activities and\r\n                // also re-anchor the marker\r\n                marker.DynamicMarkerCreated.emit(o.iconInfo);\r\n                const p: IPoint = {\r\n                    x: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.width * o.iconInfo.markerOffsetRatio.x) : 0,\r\n                    y: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.height * o.iconInfo.markerOffsetRatio.y) : 0,\r\n                };\r\n                m.SetAnchor(p);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers an event delegate for a marker.\r\n     *\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param marker - The {@link MapMarker} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public CreateEventObservable<T>(eventName: string, marker: MapMarkerDirective): Observable<T> {\r\n        const b: Subject<T> = new Subject<T>();\r\n        if (eventName === 'mousemove') {\r\n            return b.asObservable();\r\n        }\r\n        if (eventName === 'rightclick') {\r\n            return b.asObservable();\r\n        }\r\n        ///\r\n        /// mousemove and rightclick are not supported by bing polygons.\r\n        ///\r\n\r\n\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._markers.get(marker).then((m: Marker) => {\r\n                m.AddListener(eventName, (e: T) => this._zone.run(() =>\r\n                    observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes a marker.\r\n     *\r\n     * @param marker - {@link MapMarker} to be deleted.\r\n     * @returns - A promise fullfilled once the marker has been deleted.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public DeleteMarker(marker: MapMarkerDirective): Promise<void> {\r\n        const m = this._markers.get(marker);\r\n        let p: Promise<void> = Promise.resolve();\r\n        if (m != null) {\r\n            p = m.then((ma: Marker) => {\r\n                if (marker.InClusterLayer) {\r\n                    this._clusterService.GetNativeLayer(marker.LayerId).then(l => { l.RemoveEntity(ma); });\r\n                }\r\n                if (marker.InCustomLayer) {\r\n                    this._layerService.GetNativeLayer(marker.LayerId).then(l => { l.RemoveEntity(ma); });\r\n                }\r\n                return this._zone.run(() => {\r\n                    ma.DeleteMarker();\r\n                    this._markers.delete(marker);\r\n                });\r\n            });\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the marker on the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        if (!e) {\r\n            return null;\r\n        }\r\n        if (!e.primitive) {\r\n            return null;\r\n        }\r\n        if (!(e.primitive instanceof Microsoft.Maps.Pushpin)) {\r\n            return null;\r\n        }\r\n        const p: Microsoft.Maps.Pushpin = e.primitive;\r\n        const loc: Microsoft.Maps.Location = p.getLocation();\r\n        return { latitude: loc.latitude, longitude: loc.longitude };\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param marker - The {@link MapMarker} for which to obtain the marker model.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} implementation of the underlying platform.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public GetNativeMarker(marker: MapMarkerDirective): Promise<Marker> {\r\n        return this._markers.get(marker);\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker pixel location for the marker on the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the pixels of the marker on the map canvas.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public GetPixelsFromClick(e: MouseEvent | any): IPoint {\r\n        const loc: ILatLong = this.GetCoordinatesFromClick(e);\r\n        if (loc == null) {\r\n            return null;\r\n        }\r\n        const l: Microsoft.Maps.Location = BingConversions.TranslateLocation(loc);\r\n        const p: Microsoft.Maps.Point = <Microsoft.Maps.Point>(<BingMapService>\r\n            this._mapService).MapInstance.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control);\r\n        if (p == null) { return null; }\r\n        return { x: p.x, y: p.y };\r\n    }\r\n\r\n    /**\r\n     * Converts a geo location to a pixel location relative to the map canvas.\r\n     *\r\n     * @param target - Either a {@link MapMarker} or a {@link ILatLong} for the basis of translation.\r\n     * @returns - A promise that when fullfilled contains a {@link IPoint}\r\n     * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public LocationToPoint(target: MapMarkerDirective | ILatLong): Promise<IPoint> {\r\n        if (target == null) {\r\n            return Promise.resolve(null);\r\n        }\r\n        if (target instanceof MapMarkerDirective) {\r\n            return this._markers.get(target).then((m: Marker) => {\r\n                const l: ILatLong = m.Location;\r\n                const p: Promise<IPoint> = this._mapService.LocationToPoint(l);\r\n                return p;\r\n            });\r\n        }\r\n        return this._mapService.LocationToPoint(target);\r\n    }\r\n\r\n    /**\r\n     * Updates the anchor position for the marker.\r\n     *\r\n     * @param - The {@link MapMarker} object for which to upate the anchor.\r\n     * Anchor information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the anchor position has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateAnchor(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => {\r\n            m.SetAnchor(marker.Anchor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates whether the marker is draggable.\r\n     *\r\n     * @param - The {@link MapMarker} object for which to upate dragability.\r\n     * Dragability information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the marker has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateDraggable(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetDraggable(marker.Draggable));\r\n    }\r\n\r\n    /**\r\n     * Updates the Icon on the marker.\r\n     *\r\n     * @param - The {@link MapMarker} object for which to upate the icon.\r\n     * Icon information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the icon information has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateIcon(marker: MapMarkerDirective): Promise<void> {\r\n        const payload = (m: Marker, icon: string, iconInfo: IMarkerIconInfo) => {\r\n            if (icon && icon !== '') {\r\n                m.SetIcon(icon);\r\n                marker.DynamicMarkerCreated.emit(iconInfo);\r\n            }\r\n        };\r\n        return this._markers.get(marker).then((m: Marker) => {\r\n            if (marker.IconInfo) {\r\n                const s = Marker.CreateMarker(marker.IconInfo);\r\n                if (typeof(s) === 'string') { return(payload(m, s, marker.IconInfo)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        return(payload(m, x.icon, x.iconInfo));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return(m.SetIcon(marker.IconUrl));\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the label on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the label.\r\n     * Label information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the label has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateLabel(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => { m.SetLabel(marker.Label); });\r\n    }\r\n\r\n    /**\r\n     * Updates the geo coordinates for the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the coordinates.\r\n     * Coordinate information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the position has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateMarkerPosition(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then(\r\n            (m: Marker) => m.SetPosition({\r\n                latitude: marker.Latitude,\r\n                longitude: marker.Longitude\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Updates the title on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the title.\r\n     * Title information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the title has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateTitle(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetTitle(marker.Title));\r\n    }\r\n\r\n    /**\r\n     * Updates the visibility on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the visiblity.\r\n     * Visibility information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the visibility has been updated.\r\n     *\r\n     * @memberof BingMarkerService\r\n     */\r\n    public UpdateVisible(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetVisible(marker.Visible));\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observer, Observable } from 'rxjs';\r\n\r\nimport { MapService } from '../map.service';\r\nimport { MapAPILoader } from '../mapapiloader';\r\nimport { BingMapAPILoader, BingMapAPILoaderConfig } from './bing-map.api-loader.service';\r\nimport { BingConversions } from './bing-conversions';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { InfoWindow } from '../../models/info-window';\r\nimport { BingMarker } from '../../models/bing/bing-marker';\r\nimport { Layer } from '../../models/layer';\r\nimport { BingLayer } from '../../models/bing/bing-layer';\r\nimport { BingClusterLayer } from '../../models/bing/bing-cluster-layer';\r\nimport { BingInfoWindow } from '../../models/bing/bing-info-window';\r\nimport { BingPolygon } from '../../models/bing/bing-polygon';\r\nimport { BingPolyline } from '../../models/bing/bing-polyline';\r\nimport { MixinMapLabelWithOverlayView } from '../../models/bing/bing-label';\r\nimport { MixinCanvasOverlay } from '../../models/bing/bing-canvas-overlay';\r\nimport { BingCanvasOverlay } from '../../models/bing/bing-canvas-overlay';\r\nimport { CanvasOverlay } from '../../models/canvas-overlay';\r\nimport { ILayerOptions } from '../../interfaces/ilayer-options';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { IMapOptions } from '../../interfaces/imap-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { ISize } from '../../interfaces/isize';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IBox } from '../../interfaces/ibox';\r\n\r\nimport { BingMapEventsLookup } from '../../models/bing/bing-events-lookup';\r\n\r\n/**\r\n * Concrete implementation of the MapService abstract implementing a Bin Map V8 provider\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMapService implements MapService {\r\n    ///\r\n    /// Field Declarations\r\n    ///\r\n\r\n    private _map: Promise<Microsoft.Maps.Map>;\r\n    private _mapInstance: Microsoft.Maps.Map;\r\n    private _mapResolver: (value?: Microsoft.Maps.Map) => void;\r\n    private _config: BingMapAPILoaderConfig;\r\n    private _modules: Map<string, Object> = new Map<string, Object>();\r\n\r\n    ///\r\n    /// Property Definitions\r\n    ///\r\n\r\n    /**\r\n     * Gets an array of loaded Bong modules.\r\n     *\r\n     * @readonly\r\n     * @memberof BingMapService\r\n     */\r\n    public get LoadedModules(): Map<string, Object> { return this._modules; }\r\n\r\n    /**\r\n     * Gets the Bing Map control instance underlying the implementation\r\n     *\r\n     * @readonly\r\n     * @memberof BingMapService\r\n     */\r\n    public get MapInstance(): Microsoft.Maps.Map { return this._mapInstance; }\r\n\r\n    /**\r\n     * Gets a Promise for a Bing Map control instance underlying the implementation. Use this instead of {@link MapInstance} if you\r\n     * are not sure if and when the instance will be created.\r\n     * @readonly\r\n     * @memberof BingMapService\r\n     */\r\n    public get MapPromise(): Promise<Microsoft.Maps.Map> { return this._map; }\r\n\r\n    /**\r\n     * Gets the maps physical size.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMapService\r\n     */\r\n    public get MapSize(): ISize {\r\n        if (this.MapInstance) {\r\n            const s: ISize = { width: this.MapInstance.getWidth(), height: this.MapInstance.getHeight() };\r\n            return s;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingMapService.\r\n     * @param _loader MapAPILoader instance implemented for Bing Maps. This instance will generally be injected.\r\n     * @param _zone NgZone object to enable zone aware promises. This will generally be injected.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    constructor(private _loader: MapAPILoader, private _zone: NgZone) {\r\n        this._map = new Promise<Microsoft.Maps.Map>((resolve: () => void) => { this._mapResolver = resolve; });\r\n        this._config = (<BingMapAPILoader>this._loader).Config;\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapService interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Creates a canvas overlay layer to perform custom drawing over the map with out\r\n     * some of the overhead associated with going through the Map objects.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @returns - Promise of a {@link CanvasOverlay} object.\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateCanvasOverlay(drawCallback: (canvas: HTMLCanvasElement) => void): Promise<CanvasOverlay> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const overlay: BingCanvasOverlay = new BingCanvasOverlay(drawCallback);\r\n            map.layers.insert(overlay);\r\n            return overlay;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a Bing map cluster layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link IClusterOptions}.\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.ClusterLayer object.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateClusterLayer(options: IClusterOptions): Promise<Layer> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const p: Promise<Layer> = new Promise<Layer>(resolve => {\r\n                this.LoadModule('Microsoft.Maps.Clustering', () => {\r\n                    const o: Microsoft.Maps.IClusterLayerOptions = BingConversions.TranslateClusterOptions(options);\r\n                    const layer: Microsoft.Maps.ClusterLayer = new Microsoft.Maps.ClusterLayer(new Array<Microsoft.Maps.Pushpin>(), o);\r\n                    let bl: BingClusterLayer;\r\n                    map.layers.insert(layer);\r\n                    bl = new BingClusterLayer(layer, this);\r\n                    bl.SetOptions(options);\r\n                    resolve(bl);\r\n                });\r\n            });\r\n            return p;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an information window for a map position\r\n     *\r\n     * @param [options] - Infowindow options. See {@link IInfoWindowOptions}\r\n     * @returns - Promise of a {@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateInfoWindow(options?: IInfoWindowOptions): Promise<InfoWindow> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            let loc: Microsoft.Maps.Location;\r\n            if (options.position == null) {\r\n                loc = map.getCenter();\r\n            } else {\r\n                loc = new Microsoft.Maps.Location(options.position.latitude, options.position.longitude);\r\n            }\r\n            const infoBox: Microsoft.Maps.Infobox = new Microsoft.Maps.Infobox(loc, BingConversions.TranslateInfoBoxOptions(options));\r\n            infoBox.setMap(map);\r\n            return new BingInfoWindow(infoBox);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a map layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link ILayerOptions}\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.Layer object.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateLayer(options: ILayerOptions): Promise<Layer> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const layer: Microsoft.Maps.Layer = new Microsoft.Maps.Layer(options.id.toString());\r\n            map.layers.insert(layer);\r\n            return new BingLayer(layer, this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a map instance\r\n     *\r\n     * @param el - HTML element to host the map.\r\n     * @param mapOptions - Map options\r\n     * @returns - Promise fullfilled once the map has been created.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateMap(el: HTMLElement, mapOptions: IMapOptions): Promise<void> {\r\n        return this._loader.Load().then(() => {\r\n            // apply mixins\r\n            MixinMapLabelWithOverlayView();\r\n            MixinCanvasOverlay();\r\n\r\n            // map startup...\r\n            if (this._mapInstance != null) {\r\n                this.DisposeMap();\r\n            }\r\n            const o: Microsoft.Maps.IMapLoadOptions = BingConversions.TranslateLoadOptions(mapOptions);\r\n            if (!o.credentials) {\r\n                o.credentials = this._config.apiKey;\r\n            }\r\n            const map = new Microsoft.Maps.Map(el, o);\r\n            this._mapInstance = map;\r\n            this._mapResolver(map);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a Bing map marker within the map context\r\n     *\r\n     * @param [options=<IMarkerOptions>{}] - Options for the marker. See {@link IMarkerOptions}.\r\n     * @returns - Promise of a {@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public CreateMarker(options: IMarkerOptions = <IMarkerOptions>{}): Promise<Marker> {\r\n        const payload = (icon: string, map: Microsoft.Maps.Map): BingMarker => {\r\n            const loc: Microsoft.Maps.Location = BingConversions.TranslateLocation(options.position);\r\n            const o: Microsoft.Maps.IPushpinOptions = BingConversions.TranslateMarkerOptions(options);\r\n            if (icon && icon !== '') { o.icon = icon; }\r\n            const pushpin: Microsoft.Maps.Pushpin = new Microsoft.Maps.Pushpin(loc, o);\r\n            const marker: BingMarker = new BingMarker(pushpin, map, null);\r\n            if (options.metadata) { options.metadata.forEach((v, k) => marker.Metadata.set(k, v)); }\r\n            map.entities.push(pushpin);\r\n            return marker;\r\n        };\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            if (options.iconInfo && options.iconInfo.markerType) {\r\n                const s = Marker.CreateMarker(options.iconInfo);\r\n                if (typeof (s) === 'string') { return (payload(s, map)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        return (payload(x.icon, map));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return (payload(null, map));\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a polygon within the Bing Maps V8 map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polygon. See {@link IPolygonOptions}.\r\n     * @returns - Promise of a {@link Polygon} object, which models the underlying native polygon.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    public CreatePolygon(options: IPolygonOptions): Promise<Polygon> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(options.paths);\r\n            const o: Microsoft.Maps.IPolygonOptions = BingConversions.TranslatePolygonOptions(options);\r\n            const poly: Microsoft.Maps.Polygon = new Microsoft.Maps.Polygon(locs, o);\r\n            map.entities.push(poly);\r\n\r\n            const p = new BingPolygon(poly, this, null);\r\n            if (options.metadata) { options.metadata.forEach((v, k) => p.Metadata.set(k, v)); }\r\n            if (options.title && options.title !== '') { p.Title = options.title; }\r\n            if (options.showLabel != null) { p.ShowLabel = options.showLabel; }\r\n            if (options.showTooltip != null) { p.ShowTooltip = options.showTooltip; }\r\n            if (options.labelMaxZoom != null) { p.LabelMaxZoom = options.labelMaxZoom; }\r\n            if (options.labelMinZoom != null) { p.LabelMinZoom = options.labelMinZoom; }\r\n            if (options.editable) { p.SetEditable(options.editable); }\r\n            return p;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a polyline within the Bing Maps V8 map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polyline. See {@link IPolylineOptions}.\r\n     * @returns - Promise of a {@link Polyline} object (or an array thereof for complex paths),\r\n     * which models the underlying native polygon.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    public CreatePolyline(options: IPolylineOptions): Promise<Polyline | Array<Polyline>> {\r\n        let polyline: Microsoft.Maps.Polyline;\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const o: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolylineOptions(options);\r\n            const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(options.path);\r\n            if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {\r\n                polyline = new Microsoft.Maps.Polyline(locs[0], o);\r\n                map.entities.push(polyline);\r\n\r\n                const pl = new BingPolyline(polyline, map, null);\r\n                if (options.metadata) { options.metadata.forEach((v, k) => pl.Metadata.set(k, v)); }\r\n                if (options.title && options.title !== '') { pl.Title = options.title; }\r\n                if (options.showTooltip != null) { pl.ShowTooltip = options.showTooltip; }\r\n                return pl;\r\n            }\r\n            else {\r\n                const lines: Array<Polyline> = new Array<Polyline>();\r\n                locs.forEach(p => {\r\n                    polyline = new Microsoft.Maps.Polyline(p, o);\r\n                    map.entities.push(polyline);\r\n\r\n                    const pl = new BingPolyline(polyline, map, null);\r\n                    if (options.metadata) { options.metadata.forEach((v, k) => pl.Metadata.set(k, v)); }\r\n                    if (options.title && options.title !== '') { pl.Title = options.title; }\r\n                    if (options.showTooltip != null) { pl.ShowTooltip = options.showTooltip; }\r\n                    lines.push(pl);\r\n                });\r\n                return lines;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes a layer from the map.\r\n     *\r\n     * @param layer - Layer to delete. See {@link Layer}. This method expects the Bing specific Layer model implementation.\r\n     * @returns - Promise fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public DeleteLayer(layer: Layer): Promise<void> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            map.layers.remove(layer.NativePrimitve);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispaose the map and associated resoures.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public DisposeMap(): void {\r\n        if (this._map == null && this._mapInstance == null) {\r\n            return;\r\n        }\r\n        if (this._mapInstance != null) {\r\n            this._mapInstance.dispose();\r\n            this._mapInstance = null;\r\n            this._map = new Promise<Microsoft.Maps.Map>((resolve: () => void) => { this._mapResolver = resolve; });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map center\r\n     *\r\n     * @returns - A promise that when fullfilled contains the goe location of the center. See {@link ILatLong}.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public GetCenter(): Promise<ILatLong> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const center = map.getCenter();\r\n            return <ILatLong>{\r\n                latitude: center.latitude,\r\n                longitude: center.longitude\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map bounding box\r\n     *\r\n     * @returns - A promise that when fullfilled contains the goe location of the bounding box. See {@link IBox}.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public GetBounds(): Promise<IBox> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => {\r\n            const box = map.getBounds();\r\n            return <IBox>{\r\n                maxLatitude: box.getNorth(),\r\n                maxLongitude: box.crossesInternationalDateLine() ? box.getWest() : box.getEast(),\r\n                minLatitude: box.getSouth(),\r\n                minLongitude: box.crossesInternationalDateLine() ? box.getEast() : box.getWest(),\r\n                center: { latitude: box.center.latitude, longitude: box.center.longitude },\r\n                padding: 0\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets a shared or private instance of the map drawing tools.\r\n     *\r\n     * @param [useSharedInstance=true] - Set to false to create a private instance.\r\n     * @returns - Promise that when resolved containst an instance of the drawing tools.\r\n     * @memberof BingMapService\r\n     */\r\n    public GetDrawingTools (useSharedInstance: boolean = true): Promise<Microsoft.Maps.DrawingTools> {\r\n        return new Promise<Microsoft.Maps.DrawingTools>((resolve, reject) => {\r\n            this.LoadModuleInstance('Microsoft.Maps.DrawingTools', useSharedInstance).then((o: Microsoft.Maps.DrawingTools) => {\r\n                resolve(o);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the current zoom level of the map.\r\n     *\r\n     * @returns - A promise that when fullfilled contains the zoom level.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public GetZoom(): Promise<number> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => map.getZoom());\r\n    }\r\n\r\n    /**\r\n     * Loads a module into the Map.\r\n     *\r\n     * @param moduleName - The module to load.\r\n     * @param callback - Callback to call once loading is complete.\r\n     * @method\r\n     * @memberof BingMapService\r\n     */\r\n    public LoadModule(moduleName: string, callback: () => void) {\r\n        if (this._modules.has(moduleName)) {\r\n            callback();\r\n        }\r\n        else {\r\n            Microsoft.Maps.loadModule(moduleName, () => {\r\n                this._modules.set(moduleName, null);\r\n                callback();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a module into the Map and delivers and instance of the module payload.\r\n     *\r\n     * @param moduleName - The module to load.\r\n     * @param useSharedInstance- Use a shared instance if true, create a new instance if false.\r\n     * @method\r\n     * @memberof BingMapService\r\n     */\r\n    public LoadModuleInstance(moduleName: string, useSharedInstance: boolean = true): Promise<Object> {\r\n        const s: string = moduleName.substr(moduleName.lastIndexOf('.') + 1);\r\n        if (this._modules.has(moduleName)) {\r\n            let o: any = null;\r\n            if (!useSharedInstance)  {\r\n                o = new (<any>Microsoft.Maps)[s](this._mapInstance);\r\n            }\r\n            else if (this._modules.get(moduleName) != null) {\r\n                o = this._modules.get(moduleName);\r\n            }\r\n            else {\r\n                o = new (<any>Microsoft.Maps)[s](this._mapInstance);\r\n                this._modules.set(moduleName, o);\r\n            }\r\n            return Promise.resolve(o);\r\n        }\r\n        else {\r\n            return new Promise<Object>((resolve, reject) => {\r\n                try {\r\n                Microsoft.Maps.loadModule(moduleName, () => {\r\n                    const o = new (<any>Microsoft.Maps)[s](this._mapInstance);\r\n                    if (useSharedInstance) {\r\n                        this._modules.set(moduleName, o);\r\n                    }\r\n                    else {\r\n                        this._modules.set(moduleName, null);\r\n                    }\r\n                    resolve(o);\r\n                });\r\n                } catch (e) {\r\n                    reject('Could not load module or create instance.');\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface representing the pixels. This promise resolves to null\r\n     * if the goe coordinates are not in the view port.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public LocationToPoint(loc: ILatLong): Promise<IPoint> {\r\n        return this._map.then((m: Microsoft.Maps.Map) => {\r\n            const l: Microsoft.Maps.Location = BingConversions.TranslateLocation(loc);\r\n            const p: Microsoft.Maps.Point = <Microsoft.Maps.Point>m.tryLocationToPixel(l, Microsoft.Maps.PixelReference.control);\r\n            if (p != null) {\r\n                return { x: p.x, y: p.y };\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface array representing the pixels.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public LocationsToPoints(locs: Array<ILatLong>): Promise<Array<IPoint>> {\r\n        return this._map.then((m: Microsoft.Maps.Map) => {\r\n            const l = locs.map(loc => BingConversions.TranslateLocation(loc));\r\n            const p: Array<Microsoft.Maps.Point> = <Array<Microsoft.Maps.Point>>m.tryLocationToPixel(l,\r\n                Microsoft.Maps.PixelReference.control);\r\n            return p ? p : new Array<IPoint>();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Centers the map on a geo location.\r\n     *\r\n     * @param latLng - GeoCoordinates around which to center the map. See {@link ILatLong}\r\n     * @returns - Promise that is fullfilled when the center operations has been completed.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SetCenter(latLng: ILatLong): Promise<void> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => map.setView({\r\n            center: BingConversions.TranslateLocation(latLng)\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Sets the generic map options.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SetMapOptions(options: IMapOptions) {\r\n        this._map.then((m: Microsoft.Maps.Map) => {\r\n            const o: Microsoft.Maps.IMapOptions = BingConversions.TranslateOptions(options);\r\n            m.setOptions(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the view options of the map.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SetViewOptions(options: IMapOptions) {\r\n        this._map.then((m: Microsoft.Maps.Map) => {\r\n            const o: Microsoft.Maps.IViewOptions = BingConversions.TranslateViewOptions(options);\r\n            m.setView(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the zoom level of the map.\r\n     *\r\n     * @param zoom - Zoom level to set.\r\n     * @returns - A Promise that is fullfilled once the zoom operation is complete.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SetZoom(zoom: number): Promise<void> {\r\n        return this._map.then((map: Microsoft.Maps.Map) => map.setView({\r\n            zoom: zoom\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Creates an event subscription\r\n     *\r\n     * @param eventName - The name of the event (e.g. 'click')\r\n     * @returns - An observable of tpye E that fires when the event occurs.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public SubscribeToMapEvent<E>(eventName: string): Observable<E> {\r\n        const eventNameTranslated = BingMapEventsLookup[eventName];\r\n        return Observable.create((observer: Observer<E>) => {\r\n            this._map.then((m: Microsoft.Maps.Map) => {\r\n                Microsoft.Maps.Events.addHandler(m, eventNameTranslated, (e: any) => {\r\n                    this._zone.run(() => observer.next(e));\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Triggers the given event name on the map instance.\r\n     *\r\n     * @param eventName - Event to trigger.\r\n     * @returns - A promise that is fullfilled once the event is triggered.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public TriggerMapEvent(eventName: string): Promise<void> {\r\n        return this._map.then((m) => Microsoft.Maps.Events.invoke(m, eventName, null));\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { Marker } from '../../models/marker';\r\nimport { BingMarker } from '../../models/bing/bing-marker';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { MapService } from '../map.service';\r\nimport { MapLayerDirective } from '../../components/map-layer';\r\nimport { LayerService } from '../layer.service';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingConversions } from './bing-conversions';\r\n\r\n/**\r\n * This abstract partially implements the contract for the {@link LayerService}\r\n * and {@link ClusterService} for the Bing Maps V8 archtiecture. It serves\r\n * as the base class for basic layer ({@link BingLayerService}) and cluster layer ({@link BingClusterLayer}).\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class BingLayerBase {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n\r\n    protected _layers: Map<number, Promise<Layer>> = new Map<number, Promise<Layer>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingLayerBase.\r\n     * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    constructor(protected _mapService: MapService, protected _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public abstract AddLayer(layer: MapLayerDirective): void;\r\n\r\n    /**\r\n     * Creates a marker in the layer.\r\n     *\r\n     * @param layer - The Id of the layer in which to create the marker.\r\n     * @param options - {@link IMarkerOptions} object containing the marker properties.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} model for the created marker.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public CreateMarker(layer: number, options: IMarkerOptions): Promise<Marker> {\r\n        const payload = (icon: string, l: Layer): BingMarker => {\r\n            const loc: Microsoft.Maps.Location = BingConversions.TranslateLocation(options.position);\r\n            const o: Microsoft.Maps.IPushpinOptions = BingConversions.TranslateMarkerOptions(options);\r\n            if (icon && icon !== '') { o.icon = icon; }\r\n            const pushpin: Microsoft.Maps.Pushpin = new Microsoft.Maps.Pushpin(loc, o);\r\n            const marker: BingMarker = new BingMarker(pushpin, null, l.NativePrimitve);\r\n            marker.IsFirst = options.isFirst;\r\n            marker.IsLast = options.isLast;\r\n            if (options.metadata) { options.metadata.forEach((v, k) => marker.Metadata.set(k, v)); }\r\n            l.AddEntity(marker);\r\n            return marker;\r\n        };\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            if (options.iconInfo && options.iconInfo.markerType) {\r\n                const s = Marker.CreateMarker(options.iconInfo);\r\n                if (typeof(s) === 'string') { return(payload(s, l)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        return(payload(x.icon, l));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return (payload(null, l));\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param options - Marker options defining the markers.\r\n     * @param markerIcon - Optional information to generate custom markers. This will be applied to all markers.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Marker models.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public CreateMarkers(options: Array<IMarkerOptions>, markerIcon?: IMarkerIconInfo): Promise<Array<Marker>> {\r\n        const payload = (icon: string, op: Array<IMarkerOptions>): Array<BingMarker> => {\r\n            const markers: Array<BingMarker> = op.map(mo => {\r\n                let s: string;\r\n                const o: Microsoft.Maps.IPushpinOptions = BingConversions.TranslateMarkerOptions(mo);\r\n                if (icon && icon !== '' ) { s = icon; }\r\n                else if (o.icon) {\r\n                    s = o.icon;\r\n                }\r\n                if (o.icon) { delete o.icon; }\r\n                const loc: Microsoft.Maps.Location = BingConversions.TranslateLocation(mo.position);\r\n                const pushpin: Microsoft.Maps.Pushpin = new Microsoft.Maps.Pushpin(loc, o);\r\n                const img = Marker.GetImageForMarker(s);\r\n                if (img != null) { (<any>pushpin).image = img; }\r\n\r\n                const marker: BingMarker = new BingMarker(pushpin, null, null);\r\n                marker.IsFirst = mo.isFirst;\r\n                marker.IsLast = mo.isLast;\r\n                if (mo.metadata) { mo.metadata.forEach((v, k) => marker.Metadata.set(k, v)); }\r\n                return marker;\r\n            });\r\n            return markers;\r\n        };\r\n        const p: Promise<Array<Marker>> = new Promise<Array<Marker>>((resolve, reject) => {\r\n            if (markerIcon && markerIcon.markerType) {\r\n                const s = Marker.CreateMarker(markerIcon);\r\n                if (typeof(s) === 'string') { resolve(payload(s, options)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        resolve(payload(x.icon, options));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                resolve(payload(null, options));\r\n            }\r\n        });\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Deletes the layer\r\n     *\r\n     * @param layer - MapLayerDirective component object for which to retrieve the layer.\r\n     * @returns - A promise that is fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public DeleteLayer(layer: MapLayerDirective): Promise<void> {\r\n        const l = this._layers.get(layer.Id);\r\n        if (l == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return l.then((l1: Layer) => {\r\n            return this._zone.run(() => {\r\n                l1.Delete();\r\n                this._layers.delete(layer.Id);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the Layer model represented by this layer.\r\n     *\r\n     * @param layer - MapLayerDirective component object or Layer Id for which to retrieve the layer model.\r\n     * @returns - A promise that when resolved contains the Layer model.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    public GetNativeLayer(layer: MapLayerDirective|number): Promise<Layer> {\r\n        let p: Promise<Layer> = null;\r\n        if (typeof(layer) === 'number') {\r\n            p = this._layers.get(layer);\r\n        }\r\n        else {\r\n            p = this._layers.get((<MapLayerDirective>layer).Id);\r\n        }\r\n        return p;\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the layer based on its id.\r\n     *\r\n     * @protected\r\n     * @param id - Layer Id.\r\n     * @returns - A promise that when fullfilled contains the {@link Layer} model for the layer.\r\n     *\r\n     * @memberof BingLayerBase\r\n     */\r\n    protected GetLayerById(id: number): Promise<Layer> {\r\n        let p: Promise<Layer>;\r\n        this._layers.forEach((l: Promise<Layer>, k: number) => { if (k === id) { p = l; } });\r\n        return p;\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { BingMarker } from '../../models/bing/bing-marker';\r\nimport { BingPolygon } from '../../models/bing/bing-polygon';\r\nimport { BingPolyline } from '../../models/bing/bing-polyline';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { MapService } from '../map.service';\r\nimport { MapLayerDirective } from '../../components/map-layer';\r\nimport { LayerService } from '../layer.service';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingLayerBase } from './bing-layer-base';\r\nimport { BingConversions } from './bing-conversions';\r\n\r\n/**\r\n * Implements the {@link LayerService} contract for a  Bing Maps V8 specific implementation.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingLayerService extends BingLayerBase implements LayerService {\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingLayerService.\r\n     * @param _mapService - Instance of the Bing Maps Service. Will generally be injected.\r\n     * @param _zone - NgZone instance to provide zone aware promises.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    constructor(_mapService: MapService, _zone: NgZone) {\r\n        super(_mapService, _zone);\r\n    }\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public AddLayer(layer: MapLayerDirective): void {\r\n        const layerPromise = this._mapService.CreateLayer({ id: layer.Id });\r\n        this._layers.set(layer.Id, layerPromise);\r\n        layerPromise.then(l => l.SetVisible(layer.Visible));\r\n    }\r\n\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygon.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(options.paths);\r\n            const o: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolygonOptions(options);\r\n            const poly: Microsoft.Maps.Polygon = new Microsoft.Maps.Polygon(locs, o);\r\n            const polygon: Polygon = new BingPolygon(poly, <BingMapService>this._mapService, l.NativePrimitve);\r\n\r\n            if (options.metadata) { options.metadata.forEach((v, k) => polygon.Metadata.set(k, v)); }\r\n            if (options.title && options.title !== '') {polygon.Title = options.title; }\r\n            if (options.showLabel != null) { polygon.ShowLabel = options.showLabel; }\r\n            if (options.showTooltip != null) { polygon.ShowTooltip = options.showTooltip; }\r\n            if (options.labelMaxZoom != null) { polygon.LabelMaxZoom = options.labelMaxZoom; }\r\n            if (options.labelMinZoom != null) { polygon.LabelMinZoom = options.labelMinZoom; }\r\n            l.AddEntity(polygon);\r\n            return polygon;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const polygons: Promise<Array<Polygon>> = new Promise<Array<Polygon>>((resolve, reject) => {\r\n                const polys: Array<BingPolygon> = options.map(o => {\r\n                    const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(o.paths);\r\n                    const op: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolygonOptions(o);\r\n                    const poly: Microsoft.Maps.Polygon = new Microsoft.Maps.Polygon(locs, op);\r\n                    const polygon: BingPolygon = new BingPolygon(poly, <BingMapService>this._mapService, l.NativePrimitve);\r\n                    if (o.title && o.title !== '') { polygon.Title = o.title; }\r\n                    if (o.metadata) { o.metadata.forEach((v, k) => polygon.Metadata.set(k, v)); }\r\n                    return polygon;\r\n                });\r\n                resolve(polys);\r\n            });\r\n            return polygons;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polyline options defining the line.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an array\r\n     * of polygons for complex paths) model.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public CreatePolyline(layer: number, options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        let polyline: Microsoft.Maps.Polyline;\r\n        let line: Polyline;\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(options.path);\r\n            const o: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolylineOptions(options);\r\n            if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {\r\n                polyline = new Microsoft.Maps.Polyline(locs[0], o);\r\n                line = new BingPolyline(polyline, this._mapService.MapInstance, l.NativePrimitve);\r\n                l.AddEntity(line);\r\n\r\n                if (options.metadata) { options.metadata.forEach((v, k) => line.Metadata.set(k, v)); }\r\n                if (options.title && options.title !== '') {line.Title = options.title; }\r\n                if (options.showTooltip != null) { line.ShowTooltip = options.showTooltip; }\r\n                return line;\r\n            }\r\n            else {\r\n                const lines: Array<Polyline> = new Array<Polyline>();\r\n                locs.forEach(x => {\r\n                    polyline = new Microsoft.Maps.Polyline(x, o);\r\n                    line = new BingPolyline(polyline, this._mapService.MapInstance, l.NativePrimitve);\r\n                    l.AddEntity(line);\r\n\r\n                    if (options.metadata) { options.metadata.forEach((v, k) => line.Metadata.set(k, v)); }\r\n                    if (options.title && options.title !== '') {line.Title = options.title; }\r\n                    if (options.showTooltip != null) { line.ShowTooltip = options.showTooltip; }\r\n                    lines.push(line);\r\n                });\r\n                return lines;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof BingLayerService\r\n     */\r\n    public CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const polylines: Promise<Array<Polyline|Array<Polyline>>> = new Promise<Array<Polyline|Array<Polyline>>>((resolve, reject) => {\r\n                const polys: Array<Polyline|Array<Polyline>> = options.map(o => {\r\n                    const locs: Array<Array<Microsoft.Maps.Location>> = BingConversions.TranslatePaths(o.path);\r\n                    const op: Microsoft.Maps.IPolylineOptions = BingConversions.TranslatePolylineOptions(o);\r\n                    if (locs && locs.length > 0 && !Array.isArray(locs[0])) {\r\n                        const poly: Microsoft.Maps.Polyline = new Microsoft.Maps.Polyline(locs[0], op);\r\n                        const polyline: BingPolyline = new BingPolyline(poly, this._mapService.MapInstance, l.NativePrimitve);\r\n                        if (o.title && o.title !== '') { polyline.Title = o.title; }\r\n                        if (o.metadata) { o.metadata.forEach((v, k) => polyline.Metadata.set(k, v)); }\r\n                        return polyline;\r\n                    }\r\n                    else {\r\n                        const lines: Array<Polyline> = new Array<Polyline>();\r\n                        locs.forEach(x => {\r\n                            const poly = new Microsoft.Maps.Polyline(x, op);\r\n                            const polyline: BingPolyline = new BingPolyline(poly, this._mapService.MapInstance, l.NativePrimitve);\r\n                            if (o.metadata) { o.metadata.forEach((v, k) => polyline.Metadata.set(k, v)); }\r\n                            if (o.title && o.title !== '') {polyline.Title = o.title; }\r\n                            lines.push(polyline);\r\n                        });\r\n                        return lines;\r\n                    }\r\n                });\r\n                resolve(polys);\r\n            });\r\n            return polylines;\r\n        });\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { BingMarker } from '../../models/bing/bing-marker';\r\nimport { BingClusterLayer } from '../../models/bing/bing-cluster-layer';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { ClusterClickAction } from '../../models/cluster-click-action';\r\nimport { MapService } from '../map.service';\r\nimport { ClusterLayerDirective } from '../../components/cluster-layer';\r\nimport { ClusterService } from '../cluster.service';\r\nimport { BingLayerBase } from './bing-layer-base';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingConversions } from './bing-conversions';\r\n\r\n/**\r\n * Implements the {@link ClusterService} contract for a  Bing Maps V8 specific implementation.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingClusterService extends BingLayerBase implements ClusterService {\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingClusterService.\r\n     * @param _mapService - Concrete {@link MapService} implementation for Bing Maps V8. An instance of {@link BingMapService}.\r\n     * @param _zone - NgZone instance to provide zone aware promises.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    constructor(_mapService: MapService, _zone: NgZone) {\r\n        super(_mapService, _zone);\r\n    }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - ClusterLayerDirective component object.\r\n     * Generally, MapLayer will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public AddLayer(layer: ClusterLayerDirective): void {\r\n        const options: IClusterOptions = {\r\n            id: layer.Id,\r\n            visible: layer.Visible,\r\n            clusteringEnabled: layer.ClusteringEnabled,\r\n            placementMode: layer.ClusterPlacementMode\r\n        };\r\n        if (layer.GridSize) { options.gridSize = layer.GridSize; }\r\n        if (layer.LayerOffset) { options.layerOffset = layer.LayerOffset; }\r\n        if (layer.ZIndex) { options.zIndex = layer.ZIndex; }\r\n        if (layer.IconInfo) {\r\n            options.clusteredPinCallback = (pin: Microsoft.Maps.ClusterPushpin) => { this.CreateClusterPushPin(pin, layer); };\r\n        }\r\n        if (layer.CustomMarkerCallback) {\r\n            options.clusteredPinCallback = (pin: Microsoft.Maps.ClusterPushpin) => { this.CreateCustomClusterPushPin(pin, layer); };\r\n        }\r\n        if (layer.SpiderClusterOptions) { options.spiderClusterOptions = layer.SpiderClusterOptions; }\r\n\r\n        const layerPromise: Promise<Layer> = this._mapService.CreateClusterLayer(options);\r\n        (<BingMapService>this._mapService).MapPromise.then(m => {\r\n            Microsoft.Maps.Events.addHandler(m, 'viewchangeend', (e) => {\r\n                if (layer.ClusteringEnabled && m.getZoom() === 19) {\r\n                    layerPromise.then((l: BingClusterLayer) => {\r\n                        l.SetOptions({ id: layer.Id, clusteringEnabled: false });\r\n                    });\r\n                }\r\n                if (layer.ClusteringEnabled && m.getZoom() < 19) {\r\n                    layerPromise.then((l: BingClusterLayer) => {\r\n                        if (!l.GetOptions().clusteringEnabled) {\r\n                            l.SetOptions({ id: layer.Id, clusteringEnabled: true });\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        });\r\n        this._layers.set(layer.Id, layerPromise);\r\n    }\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygon.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon> {\r\n        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>> {\r\n        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polyline options defining the line.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an array\r\n     * of polygons for complex paths) model.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public CreatePolyline(layer: number, options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>> {\r\n        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities\r\n     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @param layer - ClusterLayerDirective component object for which to retrieve the layer.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public StartClustering(layer: ClusterLayerDirective): Promise<void> {\r\n        const l = this._layers.get(layer.Id);\r\n        if (l == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return l.then((l1: BingClusterLayer) => {\r\n            return this._zone.run(() => {\r\n                l1.StartClustering();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stop to actually cluster the entities in a cluster layer.\r\n     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @param layer - ClusterLayerDirective component object for which to retrieve the layer.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    public StopClustering(layer: ClusterLayerDirective): Promise<void> {\r\n        const l = this._layers.get(layer.Id);\r\n        if (l == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return l.then((l1: BingClusterLayer) => {\r\n            return this._zone.run(() => {\r\n                l1.StopClustering();\r\n            });\r\n        });\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Creates the default cluster pushpin as a callback from BingMaps when clustering occurs. The {@link ClusterLayerDirective} model\r\n     * can provide an IconInfo property that would govern the apparenace of the pin. This method will assign the same pin to all\r\n     * clusters in the layer.\r\n     *\r\n     * @param cluster - The cluster for which to create the pushpin.\r\n     * @param layer - The {@link ClusterLayerDirective} component representing the layer.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    private CreateClusterPushPin(cluster: Microsoft.Maps.ClusterPushpin, layer: ClusterLayerDirective): void {\r\n        this._layers.get(layer.Id).then((l: BingClusterLayer) => {\r\n            if (layer.IconInfo) {\r\n                const o: Microsoft.Maps.IPushpinOptions = {};\r\n                const payload: (ico: string, info: IMarkerIconInfo) => void = (ico, info) => {\r\n                        o.icon = ico;\r\n                        o.anchor = new Microsoft.Maps.Point(\r\n                            (info.size && info.markerOffsetRatio) ? (info.size.width * info.markerOffsetRatio.x) : 0,\r\n                            (info.size && info.markerOffsetRatio) ? (info.size.height * info.markerOffsetRatio.y) : 0\r\n                        );\r\n                        cluster.setOptions(o);\r\n                };\r\n                const icon: string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> = Marker.CreateMarker(layer.IconInfo);\r\n                if (typeof(icon) === 'string') {\r\n                    payload(icon, layer.IconInfo);\r\n                }\r\n                else {\r\n                    icon.then(x => {\r\n                        payload(x.icon, x.iconInfo);\r\n                    });\r\n                }\r\n            }\r\n            if (layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster) {\r\n                Microsoft.Maps.Events.addHandler(cluster, 'click', (e: Microsoft.Maps.IMouseEventArgs) => this.ZoomIntoCluster(e));\r\n            }\r\n            if (layer.ClusterClickAction === ClusterClickAction.Spider) {\r\n                Microsoft.Maps.Events.addHandler(cluster, 'dblclick', (e: Microsoft.Maps.IMouseEventArgs) => this.ZoomIntoCluster(e));\r\n                l.InitializeSpiderClusterSupport();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Provides a hook for consumers to provide a custom function to create cluster bins for a cluster. This is particuarily useful\r\n     * in situation where the pin should differ to represent information about the pins in the cluster.\r\n     *\r\n     * @param cluster - The cluster for which to create the pushpin.\r\n     * @param layer - The {@link ClusterLayerDirective} component\r\n     * representing the layer. Set the {@link ClusterLayerDirective.CustomMarkerCallback}\r\n     * property to define the callback generating the pin.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    private CreateCustomClusterPushPin(cluster: Microsoft.Maps.ClusterPushpin, layer: ClusterLayerDirective): void {\r\n        this._layers.get(layer.Id).then((l: BingClusterLayer) => {\r\n            // assemble markers for callback\r\n            const m: Array<Marker> = new Array<Marker>();\r\n            cluster.containedPushpins.forEach(p => {\r\n                const marker: Marker = l.GetMarkerFromBingMarker(p);\r\n                if (marker) { m.push(marker); }\r\n            });\r\n            const iconInfo: IMarkerIconInfo = { markerType: MarkerTypeId.None };\r\n            const o: Microsoft.Maps.IPushpinOptions = {};\r\n            o.icon = layer.CustomMarkerCallback(m, iconInfo);\r\n            if (o.icon !== '') {\r\n                o.anchor = new Microsoft.Maps.Point(\r\n                    (iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.width * iconInfo.markerOffsetRatio.x) : 0,\r\n                    (iconInfo.size && iconInfo.markerOffsetRatio) ? (iconInfo.size.height * iconInfo.markerOffsetRatio.y) : 0\r\n                );\r\n                if (iconInfo.textOffset) { o.textOffset = new Microsoft.Maps.Point(iconInfo.textOffset.x, iconInfo.textOffset.y); }\r\n                cluster.setOptions(o);\r\n            }\r\n            if (layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster) {\r\n                Microsoft.Maps.Events.addHandler(cluster, 'click', (e: Microsoft.Maps.IMouseEventArgs) => this.ZoomIntoCluster(e));\r\n            }\r\n            if (layer.ClusterClickAction === ClusterClickAction.Spider) {\r\n                Microsoft.Maps.Events.addHandler(cluster, 'dblclick', (e: Microsoft.Maps.IMouseEventArgs) => this.ZoomIntoCluster(e));\r\n                l.InitializeSpiderClusterSupport();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Zooms into the cluster on click so that the members of the cluster comfortable fit into the zommed area.\r\n     *\r\n     * @param e - Mouse Event.\r\n     *\r\n     * @memberof BingClusterService\r\n     */\r\n    private ZoomIntoCluster(e: Microsoft.Maps.IMouseEventArgs): void {\r\n        const pin: Microsoft.Maps.ClusterPushpin = <Microsoft.Maps.ClusterPushpin>e.target;\r\n        if (pin && pin.containedPushpins) {\r\n            let bounds: Microsoft.Maps.LocationRect;\r\n            const locs: Array<Microsoft.Maps.Location> = new Array<Microsoft.Maps.Location>();\r\n            pin.containedPushpins.forEach(p => locs.push(p.getLocation()));\r\n            bounds = Microsoft.Maps.LocationRect.fromLocations(locs);\r\n\r\n            // Zoom into the bounding box of the cluster.\r\n            // Add a padding to compensate for the pixel area of the pushpins.\r\n            (<BingMapService>this._mapService).MapPromise.then((m: Microsoft.Maps.Map) => {\r\n                m.setView({ bounds: bounds, padding: 75 });\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer, Subject } from 'rxjs';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { MapPolygonDirective } from '../../components/map-polygon';\r\nimport { PolygonService } from '../polygon.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\n\r\n/**\r\n * Concrete implementation of the Polygon Service abstract class for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingPolygonService implements PolygonService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _polygons: Map<MapPolygonDirective, Promise<Polygon>> = new Map<MapPolygonDirective, Promise<Polygon>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingPolygonService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.\r\n     * @param _layerService - {@link BingLayerService} instance.\r\n     * The concrete {@link BingLayerService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _zone: NgZone) {\r\n    }\r\n\r\n    /**\r\n     * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a\r\n     * correcsponding layer.\r\n     *\r\n     * @param polygon - The {@link MapPolygonDirective} to be added.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public AddPolygon(polygon: MapPolygonDirective): void {\r\n        const o: IPolygonOptions = {\r\n            id: polygon.Id,\r\n            clickable: polygon.Clickable,\r\n            draggable: polygon.Draggable,\r\n            editable: polygon.Editable,\r\n            fillColor: polygon.FillColor,\r\n            fillOpacity: polygon.FillOpacity,\r\n            geodesic: polygon.Geodesic,\r\n            labelMaxZoom: polygon.LabelMaxZoom,\r\n            labelMinZoom: polygon.LabelMinZoom,\r\n            paths: polygon.Paths,\r\n            showLabel: polygon.ShowLabel,\r\n            showTooltip: polygon.ShowTooltip,\r\n            strokeColor: polygon.StrokeColor,\r\n            strokeOpacity: polygon.StrokeOpacity,\r\n            strokeWeight: polygon.StrokeWeight,\r\n            title: polygon.Title,\r\n            visible: polygon.Visible,\r\n            zIndex: polygon.zIndex,\r\n        };\r\n        let polygonPromise: Promise<Polygon>;\r\n        if (polygon.InCustomLayer) {\r\n            polygonPromise = this._layerService.CreatePolygon(polygon.LayerId, o);\r\n        }\r\n        else {\r\n            polygonPromise = this._mapService.CreatePolygon(o);\r\n        }\r\n        this._polygons.set(polygon, polygonPromise);\r\n    }\r\n\r\n    /**\r\n      * Registers an event delegate for a polygon.\r\n      *\r\n      * @param eventName - The name of the event to register (e.g. 'click')\r\n      * @param polygon - The {@link MapPolygonDirective} for which to register the event.\r\n      * @returns - Observable emiting an instance of T each time the event occurs.\r\n      *\r\n      * @memberof BingPolygonService\r\n      */\r\n    public CreateEventObservable<T>(eventName: string, polygon: MapPolygonDirective): Observable<T> {\r\n        const b: Subject<T> = new Subject<T>();\r\n        if (eventName === 'mousemove') {\r\n            return b.asObservable();\r\n        }\r\n        if (eventName === 'rightclick') {\r\n            return b.asObservable();\r\n        }\r\n        ///\r\n        /// mousemove and rightclick are not supported by bing polygons.\r\n        ///\r\n\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._polygons.get(polygon).then((p: Polygon) => {\r\n                p.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Deletes a polygon.\r\n      *\r\n      * @param polygon - {@link MapPolygonDirective} to be deleted.\r\n      * @returns - A promise fullfilled once the polygon has been deleted.\r\n      *\r\n      * @memberof BingPolygonService\r\n      */\r\n    public DeletePolygon(polygon: MapPolygonDirective): Promise<void> {\r\n        const m = this._polygons.get(polygon);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polygon) => {\r\n            return this._zone.run(() => {\r\n                l.Delete();\r\n                this._polygons.delete(polygon);\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the polygon on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event. Expected to implement {@link Microsoft.Maps.IMouseEventArgs}.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        const x: Microsoft.Maps.IMouseEventArgs = <Microsoft.Maps.IMouseEventArgs>e;\r\n        return { latitude: x.location.latitude, longitude: x.location.longitude };\r\n    }\r\n\r\n    /**\r\n     * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param polygon - The {@link MapPolygonDirective} for which to obtain the polygon model.\r\n     * @returns - A promise that when fullfilled contains the {@link Polygon} implementation of the underlying platform.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public GetNativePolygon(polygon: MapPolygonDirective): Promise<Polygon> {\r\n        return this._polygons.get(polygon);\r\n    }\r\n\r\n    /**\r\n     * Set the polygon options.\r\n     *\r\n     * @param polygon - {@link MapPolygonDirective} to be updated.\r\n     * @param options - {@link IPolygonOptions} object containing the options. Options will be merged with the\r\n     * options already on the underlying object.\r\n     * @returns - A promise fullfilled once the polygon options have been set.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public SetOptions(polygon: MapPolygonDirective, options: IPolygonOptions): Promise<void> {\r\n        return this._polygons.get(polygon).then((l: Polygon) => { l.SetOptions(options); });\r\n    }\r\n\r\n    /**\r\n     * Updates the Polygon path\r\n     *\r\n     * @param polygon - {@link MapPolygonDirective} to be updated.\r\n     * @returns - A promise fullfilled once the polygon has been updated.\r\n     *\r\n     * @memberof BingPolygonService\r\n     */\r\n    public UpdatePolygon(polygon: MapPolygonDirective): Promise<void> {\r\n        const m = this._polygons.get(polygon);\r\n        if (m == null || polygon.Paths == null || !Array.isArray(polygon.Paths) || polygon.Paths.length === 0) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polygon) =>  {\r\n            if (Array.isArray(polygon.Paths[0])) {\r\n                l.SetPaths(polygon.Paths);\r\n            }\r\n            else {\r\n                l.SetPath(<Array<ILatLong>>polygon.Paths);\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer, Subject } from 'rxjs';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { MapPolylineDirective } from '../../components/map-polyline';\r\nimport { PolylineService } from '../polyline.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\n\r\n/**\r\n * Concrete implementation of the Polyline Service abstract class for Bing Maps V8.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingPolylineService implements PolylineService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _polylines: Map<MapPolylineDirective, Promise<Polyline|Array<Polyline>>> =\r\n    new Map<MapPolylineDirective, Promise<Polyline|Array<Polyline>>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingPolylineService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link BingMapService} implementation is expected.\r\n     * @param _layerService - {@link LayerService} instance.\r\n     * The concrete {@link BingLayerService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _zone: NgZone) {\r\n    }\r\n\r\n    ///\r\n    /// Public members and MarkerService implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a\r\n     * corresponding layer.\r\n     *\r\n     * @param polyline - The {@link MapPolylineDirective} to be added.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public AddPolyline(polyline: MapPolylineDirective): void {\r\n        const o: IPolylineOptions = {\r\n            id: polyline.Id,\r\n            clickable: polyline.Clickable,\r\n            draggable: polyline.Draggable,\r\n            editable: polyline.Editable,\r\n            geodesic: polyline.Geodesic,\r\n            path: polyline.Path,\r\n            showTooltip: polyline.ShowTooltip,\r\n            strokeColor: polyline.StrokeColor,\r\n            strokeOpacity: polyline.StrokeOpacity,\r\n            strokeWeight: polyline.StrokeWeight,\r\n            title: polyline.Title,\r\n            visible: polyline.Visible,\r\n            zIndex: polyline.zIndex,\r\n        };\r\n        let polylinePromise: Promise<Polyline|Array<Polyline>>;\r\n        if (polyline.InCustomLayer) {\r\n            polylinePromise = this._layerService.CreatePolyline(polyline.LayerId, o);\r\n        } else {\r\n            polylinePromise = this._mapService.CreatePolyline(o);\r\n        }\r\n        this._polylines.set(polyline, polylinePromise);\r\n    }\r\n\r\n    /**\r\n      * Registers an event delegate for a line.\r\n      *\r\n      * @param eventName - The name of the event to register (e.g. 'click')\r\n      * @param polyline - The {@link MapPolylineDirective} for which to register the event.\r\n      * @returns - Observable emiting an instance of T each time the event occurs.\r\n      *\r\n      * @memberof BingPolylineService\r\n      */\r\n    public CreateEventObservable<T>(eventName: string, polyline: MapPolylineDirective): Observable<T> {\r\n        const b: Subject<T> = new Subject<T>();\r\n        if (eventName === 'mousemove') {\r\n            return b.asObservable();\r\n        }\r\n        if (eventName === 'rightclick') {\r\n            return b.asObservable();\r\n        }\r\n        ///\r\n        /// mousemove and rightclick are not supported by bing polygons.\r\n        ///\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._polylines.get(polyline).then(p => {\r\n                const x: Array<Polyline> = Array.isArray(p) ? p : [p];\r\n                x.forEach(line => line.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e))));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Deletes a polyline.\r\n      *\r\n      * @param polyline - {@link MapPolylineDirective} to be deleted.\r\n      * @returns - A promise fullfilled once the polyline has been deleted.\r\n      *\r\n      * @memberof BingPolylineService\r\n      */\r\n    public DeletePolyline(polyline: MapPolylineDirective): Promise<void> {\r\n        const m = this._polylines.get(polyline);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polyline) => {\r\n            return this._zone.run(() => {\r\n                const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n                x.forEach(line =>  line.Delete());\r\n                this._polylines.delete(polyline);\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the marker on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public GetCoordinatesFromClick(e: Microsoft.Maps.IMouseEventArgs): ILatLong {\r\n        if (!e) { return null; }\r\n        if (!e.location) { return null; }\r\n        return { latitude: e.location.latitude, longitude: e.location.longitude };\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param polyline - The {@link MapPolylineDirective} for which to obtain the polyline model.\r\n     * @returns - A promise that when fullfilled contains the {@link Polyline}\r\n     * implementation of the underlying platform. For complex paths, returns an array of polylines.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public GetNativePolyline(polyline: MapPolylineDirective): Promise<Polyline|Array<Polyline>> {\r\n        return this._polylines.get(polyline);\r\n    }\r\n\r\n    /**\r\n     * Set the polyline options.\r\n     *\r\n     * @param polyline - {@link MapPolylineDirective} to be updated.\r\n     * @param options - {@link IPolylineOptions} object containing the options. Options will be merged with the\r\n     * options already on the underlying object.\r\n     * @returns - A promise fullfilled once the polyline options have been set.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public SetOptions(polyline: MapPolylineDirective, options: IPolylineOptions): Promise<void> {\r\n        return this._polylines.get(polyline).then(l => {\r\n            const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n            x.forEach(line => line.SetOptions(options));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the Polyline path\r\n     *\r\n     * @param polyline - {@link MapPolylineDirective} to be updated.\r\n     * @returns - A promise fullfilled once the polyline has been updated.\r\n     *\r\n     * @memberof BingPolylineService\r\n     */\r\n    public UpdatePolyline(polyline: MapPolylineDirective): Promise<void> {\r\n        const m = this._polylines.get(polyline);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then(l => this._zone.run(() => {\r\n            const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n            const p: Array<Array<ILatLong>> =\r\n                polyline.Path.length > 0 && Array.isArray(polyline.Path[0]) ? <Array<Array<ILatLong>>>polyline.Path :\r\n                <Array<Array<ILatLong>>>[polyline.Path];\r\n             x.forEach((line, index) => {\r\n                 if (p.length > index) { line.SetPath(p[index]); }\r\n            });\r\n            if (Array.isArray(l) && l.length > p.length) {\r\n                l.splice(p.length - 1).forEach(line => line.Delete());\r\n            }\r\n        }));\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { MapServiceFactory } from '../mapservicefactory';\r\nimport { MapService } from '../map.service';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from '../mapapiloader';\r\nimport { MarkerService } from '../marker.service';\r\nimport { InfoBoxService } from '../infobox.service';\r\nimport { LayerService } from '../layer.service';\r\nimport { ClusterService } from '../cluster.service';\r\nimport { PolygonService } from '../polygon.service';\r\nimport { PolylineService } from '../polyline.service';\r\nimport { BingMapAPILoader, BingMapAPILoaderConfig } from './bing-map.api-loader.service';\r\nimport { BingInfoBoxService } from './bing-infobox.service';\r\nimport { BingMarkerService } from './bing-marker.service';\r\nimport { BingMapService } from './bing-map.service';\r\nimport { BingLayerService } from './bing-layer.service';\r\nimport { BingClusterService } from './bing-cluster.service';\r\nimport { BingPolygonService } from './bing-polygon.service';\r\nimport { BingPolylineService } from './bing-polyline.service';\r\n\r\n/**\r\n * Implements a factory to create thre necessary Bing Maps V8 specific service instances.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class BingMapServiceFactory implements MapServiceFactory {\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of BingMapServiceFactory.\r\n     * @param _loader - {@link MapAPILoader} implementation for the Bing Map V8 provider.\r\n     * @param _zone - NgZone object to implement zone aware promises.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    constructor(private _loader: MapAPILoader, private _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public methods and MapServiceFactory implementation.\r\n    ///\r\n\r\n    /**\r\n     * Creates the map service for the Bing Maps V8 implementation.\r\n     *\r\n     * @returns - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public Create(): MapService {\r\n        return new BingMapService(this._loader, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the cluster service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     * @returns - {@link ClusterService}. A concreted instance of the {@link BingClusterService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public CreateClusterService(_mapService: BingMapService): ClusterService {\r\n        return new BingClusterService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates thh info box service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     * @returns - {@link InfoBoxService}. A concreted instance of the {@link BingInfoBoxService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public CreateInfoBoxService(_mapService: BingMapService): InfoBoxService {\r\n        return new BingInfoBoxService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the layer service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     * @returns - {@link LayerService}. A concreted instance of the {@link BingLayerService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public CreateLayerService(_mapService: BingMapService): LayerService {\r\n        return new BingLayerService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the marker service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link BingMapService}.\r\n     * @param layers - {@link LayerService}. A concreted instance of the {@link BingLayerService}.\r\n     * @param clusters  - {@link ClusterService}. A concreted instance of the {@link BingClusterService}.\r\n     * @returns - {@link MarkerService}. A concreted instance of the {@link BingMarkerService}.\r\n     *\r\n     * @memberof BingMapServiceFactory\r\n     */\r\n    public CreateMarkerService(_mapService: BingMapService,\r\n        _layerService: BingLayerService, _clusterService: BingClusterService): MarkerService {\r\n        return new BingMarkerService(_mapService, _layerService, _clusterService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolygonService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    public CreatePolygonService(map: MapService, layers: LayerService): PolygonService {\r\n        return new BingPolygonService(map, layers, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the polyline service for the Bing Maps V8 implementation.\r\n     *\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolylineService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    public CreatePolylineService(map: MapService, layers: LayerService): PolylineService {\r\n        return new BingPolylineService(map, layers, this._zone);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Creates a new instance of a plaform specific MapServiceFactory.\r\n *\r\n * @export\r\n * @param apiLoader - An {@link MapAPILoader} instance. This is expected to the a {@link BingMapAPILoader}.\r\n * @param zone - An NgZone instance to provide zone aware promises.\r\n *\r\n * @returns -  A {@link MapServiceFactory} instance.\r\n */\r\nexport function BingMapServiceFactoryFactory(apiLoader: MapAPILoader, zone: NgZone): MapServiceFactory {\r\n    return new BingMapServiceFactory(apiLoader, zone);\r\n}\r\n\r\n/**\r\n * Creates a new instance of a plaform specific MapLoaderFactory.\r\n *\r\n * @export\r\n * @returns - A {@link MapAPILoader} instance.\r\n */\r\nexport function BingMapLoaderFactory(): MapAPILoader {\r\n    return new BingMapAPILoader(new BingMapAPILoaderConfig(), new WindowRef(), new DocumentRef());\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { Marker } from '../../models/marker';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { MapService } from '../map.service';\r\nimport { MapLayerDirective } from '../../components/map-layer';\r\nimport { LayerService } from '../layer.service';\r\nimport { GoogleMapService } from './google-map.service';\r\nimport { GoogleConversions } from './google-conversions';\r\nimport { GoogleMarker } from '../../models/google/google-marker';\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * This abstract partially implements the contract for the {@link LayerService}\r\n * and {@link ClusterService} for the Google Maps archtiecture. It serves\r\n * as the base class for basic layer ({@link GoogleLayerService}) and cluster layer ({@link GoogleClusterLayer}).\r\n *\r\n * @export\r\n * @abstract\r\n */\r\nexport abstract class GoogleLayerBase {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected abstract _layers: Map<number, Promise<Layer>>;\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleLayerBase.\r\n     * @param _mapService - Concrete {@link MapService} implementation for Google Maps.\r\n     * An instance of {@link GoogleMapService}.\r\n     * @param _zone - NgZone instance to provide zone aware promises.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    constructor(protected _mapService: MapService, protected _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public methods\r\n    ///\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public abstract AddLayer(layer: MapLayerDirective): void;\r\n\r\n    /**\r\n     * Deletes the layer\r\n     *\r\n     * @param layer - MapLayerDirective component object for which to retrieve the layer.\r\n     * @returns - A promise that is fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public DeleteLayer(layer: MapLayerDirective): Promise<void> {\r\n        const l = this._layers.get(layer.Id);\r\n        if (l == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return l.then((l1: Layer) => {\r\n            return this._zone.run(() => {\r\n                l1.Delete();\r\n                this._layers.delete(layer.Id);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the Layer model represented by this layer.\r\n     *\r\n     * @param layer - MapLayerDirective component object or layer id for which to retrieve the layer model.\r\n     * @returns - A promise that when resolved contains the Layer model.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public GetNativeLayer(layer: MapLayerDirective|number): Promise<Layer> {\r\n        let p: Promise<Layer> = null;\r\n        if (typeof(layer) === 'number') {\r\n            p = this._layers.get(layer);\r\n        }\r\n        else {\r\n            p = this._layers.get((<MapLayerDirective>layer).Id);\r\n        }\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Creates a marker in the layer.\r\n     *\r\n     * @param layer - The Id of the layer in which to create the marker.\r\n     * @param options - {@link IMarkerOptions} object containing the marker properties.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} model for the created marker.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public CreateMarker(layer: number, options: IMarkerOptions): Promise<Marker> {\r\n        const mp: Promise<GoogleMapTypes.GoogleMap> = this._mapService.MapPromise;\r\n        const lp: Promise<Layer> = this._layers.get(layer);\r\n\r\n        return Promise.all([mp, lp]).then(([map, l]) => {\r\n            const payload = (x: GoogleMapTypes.MarkerOptions): GoogleMarker => {\r\n                const marker = new google.maps.Marker(x);\r\n                if (options.metadata) { options.metadata.forEach((val: any, key: string) => marker.Metadata.set(key, val)); }\r\n                marker.setMap(map);\r\n                const m = new GoogleMarker(marker);\r\n                m.IsFirst = options.isFirst;\r\n                m.IsLast = options.isLast;\r\n                if (options.metadata) { options.metadata.forEach((val: any, key: string) => m.Metadata.set(key, val)); }\r\n                l.AddEntity(m);\r\n                return m;\r\n            };\r\n            const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(options);\r\n            if (options.iconInfo && options.iconInfo.markerType) {\r\n                const s = Marker.CreateMarker(options.iconInfo);\r\n                if (typeof(s) === 'string') {\r\n                    o.icon = s;\r\n                    return payload(o);\r\n                }\r\n                else {\r\n                    return s.then(x => {\r\n                        o.icon = x.icon;\r\n                        return payload(o);\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return payload(o);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound markers. Use this method to create arrays of markers to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param options - Marker options defining the markers.\r\n     * @param markerIcon - Optional information to generate custom markers. This will be applied to all markers.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Marker models.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    public CreateMarkers(options: Array<IMarkerOptions>, markerIcon?: IMarkerIconInfo): Promise<Array<Marker>> {\r\n        const payload = (icon: string): Array<GoogleMarker> => {\r\n            const markers: Array<GoogleMarker> = options.map(mo => {\r\n                const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(mo);\r\n                if (icon && icon !== '') { o.icon = icon; }\r\n                const pushpin = new google.maps.Marker(o);\r\n                const marker: GoogleMarker = new GoogleMarker(pushpin);\r\n                marker.IsFirst = mo.isFirst;\r\n                marker.IsLast = mo.isLast;\r\n                if (mo.metadata) { mo.metadata.forEach((val: any, key: string) => marker.Metadata.set(key, val)); }\r\n                return marker;\r\n            });\r\n            return markers;\r\n        };\r\n        const p: Promise<Array<Marker>> = new Promise<Array<Marker>>((resolve, reject) => {\r\n            if (markerIcon && markerIcon.markerType) {\r\n                const s = Marker.CreateMarker(markerIcon);\r\n                if (typeof(s) === 'string') { resolve(payload(s)); }\r\n                else {\r\n                    return s.then(x => {\r\n                        resolve(payload(x.icon));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                resolve (payload(null));\r\n            }\r\n        });\r\n        return p;\r\n    }\r\n\r\n    ///\r\n    /// Protected methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the layer based on its id.\r\n     *\r\n     * @protected\r\n     * @param id - Layer Id.\r\n     * @returns - A promise that when fullfilled contains the {@link Layer} model for the layer.\r\n     *\r\n     * @memberof GoogleLayerBase\r\n     */\r\n    protected GetLayerById(id: number): Promise<Layer> {\r\n        let p: Promise<Layer>;\r\n        this._layers.forEach((l: Promise<Layer>, k: number) => { if (k === id) { p = l; } });\r\n        return p;\r\n    }\r\n\r\n}\r\n","ï»¿import { IClusterIconInfo } from '../../interfaces/icluster-icon-info';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { MarkerService } from '../marker.service';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { Marker } from '../../models/marker';\r\nimport { Layer } from '../../models/layer';\r\nimport { MarkerTypeId } from '../../models/marker-type-id';\r\nimport { ClusterClickAction } from '../../models/cluster-click-action';\r\nimport { ClusterLayerDirective } from '../../components/cluster-layer';\r\nimport { ClusterService } from '../cluster.service';\r\nimport { MapService } from '../map.service';\r\nimport { GoogleLayerBase } from './google-layer-base';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\n@Injectable()\r\nexport class GoogleClusterService extends GoogleLayerBase implements ClusterService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    protected _layers: Map<number, Promise<Layer>> = new Map<number, Promise<Layer>>();\r\n    protected _layerStyles: Map<number, Array<GoogleMapTypes.ClusterStyle>> = new Map<number, Array<GoogleMapTypes.ClusterStyle>>();\r\n\r\n    ///\r\n    /// Static methods\r\n    ///\r\n\r\n    /**\r\n     * Creates the cluster icon from the styles\r\n     *\r\n     * @param styles\r\n     * @returns - Promise that when resolved contains an Array of IClusterIconInfo objects\r\n     * containing the hydrated cluster icons.\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public static CreateClusterIcons(styles: Array<IClusterIconInfo>): Promise<Array<IClusterIconInfo>> {\r\n        const i: Promise<Array<IClusterIconInfo>> = new Promise<Array<IClusterIconInfo>>((resolve, reject) => {\r\n            const pa = new Array<Promise<{icon: string, iconInfo: IMarkerIconInfo}>>();\r\n            styles.forEach((style, index) => {\r\n                if (style.iconInfo) {\r\n                    const s: string|Promise<{icon: string, iconInfo: IMarkerIconInfo}> = Marker.CreateMarker(style.iconInfo);\r\n                    if (typeof(s) === 'string') {\r\n                        style.url = s;\r\n                        if (style.width == null) {\r\n                            style.width = style.iconInfo.size.width;\r\n                            style.height = style.iconInfo.size.height;\r\n                        }\r\n                        if (style.iconInfo.markerOffsetRatio && style.iconInfo.size && style.anchor == null) {\r\n                            const o: IMarkerIconInfo = style.iconInfo;\r\n                            style.anchor = [\r\n                                o.size.width * o.markerOffsetRatio.x,\r\n                                o.size.height * o.markerOffsetRatio.y\r\n                            ];\r\n                        }\r\n                        delete style.iconInfo;\r\n                    }\r\n                    else {\r\n                        s.then(x => {\r\n                            style.url = x.icon;\r\n                            if (style.width == null) {\r\n                                style.width = x.iconInfo.size.width;\r\n                                style.height = x.iconInfo.size.height;\r\n                            }\r\n                            if (x.iconInfo.markerOffsetRatio && x.iconInfo.size && style.anchor == null) {\r\n                                const o: IMarkerIconInfo = x.iconInfo;\r\n                                style.anchor = [\r\n                                    o.size.width * o.markerOffsetRatio.x,\r\n                                    o.size.height * o.markerOffsetRatio.y\r\n                                ];\r\n                            }\r\n                            delete style.iconInfo;\r\n                        });\r\n                        pa.push(s);\r\n                    }\r\n                }\r\n            });\r\n            if (pa.length === 0) { resolve(styles); }\r\n            else {\r\n                Promise.all(pa).then(() => {\r\n                    resolve(styles);\r\n                });\r\n            }\r\n        });\r\n        return i;\r\n    }\r\n\r\n    ///\r\n    /// Constructors\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleClusterService.\r\n     * @param _mapService\r\n     * @param _zone\r\n     * @memberof GoogleClusterService\r\n     */\r\n    constructor(_mapService: MapService, _zone: NgZone) {\r\n        super(_mapService, _zone);\r\n    }\r\n\r\n    /**\r\n     * Adds the cluster layer to the map\r\n     *\r\n     * @param layer\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public AddLayer(layer: ClusterLayerDirective): void {\r\n        const options: IClusterOptions = {\r\n            id: layer.Id,\r\n            visible: layer.Visible,\r\n            clusteringEnabled: layer.ClusteringEnabled,\r\n            zoomOnClick: layer.ClusterClickAction === ClusterClickAction.ZoomIntoCluster\r\n        };\r\n        if (layer.GridSize) { options.gridSize = layer.GridSize; }\r\n        if (layer.MinimumClusterSize) { options.minimumClusterSize = layer.MinimumClusterSize; }\r\n        if (layer.Styles) { options.styles = layer.Styles; }\r\n        if (layer.UseDynamicSizeMarkers) {\r\n            options.styles = null;\r\n            // do not to attempt to setup styles here as the dynamic call back will generate them.\r\n        }\r\n        else {\r\n            options.styles = [{\r\n                height: 30,\r\n                width: 35,\r\n                textColor: 'white',\r\n                textSize: 11,\r\n                backgroundPosition: 'center',\r\n                iconInfo: {\r\n                    markerType: MarkerTypeId.FontMarker,\r\n                    fontName: 'FontAwesome',\r\n                    fontSize: 30,\r\n                    color: 'green',\r\n                    text: '\\uF111'\r\n                }\r\n            }];\r\n        }\r\n        const dynamicClusterCallback = (markers: Array<GoogleMapTypes.Marker>, numStyles: number,\r\n            clusterer: GoogleMapTypes.MarkerClusterer) => {\r\n            // dynamically ensure that the necessary style for this cluster icon exists and\r\n            // the clusterer is already hooked up to the styles array via pointer, so we only\r\n            // need to update the style. Since the clusterer re-renders a cluster icon is the\r\n            // the marker count changes, we will only need to retain the current icon as opposed\r\n            // to all cluster icon.\r\n            const styles: Array<GoogleMapTypes.ClusterStyle> = this._layerStyles.get(layer.Id);\r\n            const iconInfo: IMarkerIconInfo = {\r\n                markerType: MarkerTypeId.None\r\n            };\r\n            const icon: string = layer.CustomMarkerCallback(<any>markers, iconInfo);\r\n            styles[0] = {\r\n                url: `\\\"data:image/svg+xml;utf8,${icon}\\\"`,\r\n                height: iconInfo.size.height,\r\n                width: iconInfo.size.width,\r\n                textColor: 'white',\r\n                textSize: 11,\r\n                backgroundPosition: 'center',\r\n            };\r\n            return {\r\n                text: markers.length.toString(),\r\n                index: 1\r\n            };\r\n        };\r\n        const resetStyles = (clusterer: GoogleMapTypes.MarkerClusterer) => {\r\n            if (this._layerStyles.has(layer.Id)) { this._layerStyles.get(layer.Id).splice(0); }\r\n            else {\r\n                const styles: Array<GoogleMapTypes.ClusterStyle> = new Array<GoogleMapTypes.ClusterStyle>();\r\n                styles.push({});\r\n                this._layerStyles.set(layer.Id, styles);\r\n                clusterer.setStyles(styles);\r\n                    // this is important for dynamic styles as the pointer to this array gets passed\r\n                    // around key objects in the clusterer. Therefore, it must be initialized here in order for\r\n                    // updates to the styles to be visible.\r\n                    // also, we need to add at least one style to prevent the default styles from being picked up.\r\n            }\r\n        };\r\n\r\n        const layerPromise = this._mapService.CreateClusterLayer(options);\r\n        this._layers.set(layer.Id, layerPromise);\r\n        layerPromise.then(l => {\r\n            const clusterer: GoogleMapTypes.MarkerClusterer = <GoogleMapTypes.MarkerClusterer>l.NativePrimitve;\r\n            if (options.styles) {\r\n                const s  = GoogleClusterService.CreateClusterIcons(options.styles);\r\n                s.then(x => {\r\n                    clusterer.setStyles(<Array<GoogleMapTypes.ClusterStyle>>x);\r\n                });\r\n            }\r\n            else {\r\n                resetStyles(clusterer);\r\n                this._mapService.MapPromise.then((m: GoogleMapTypes.GoogleMap) => {\r\n                    m.addListener('zoom_changed', () => {\r\n                        resetStyles(clusterer);\r\n                    });\r\n                });\r\n                clusterer.setCalculator((m, n) => {\r\n                    return dynamicClusterCallback(m, n, clusterer);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a marker in the cluster\r\n     *\r\n     * @param layer\r\n     * @param options\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreateMarker(layer: number, options: IMarkerOptions): Promise<Marker> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n\r\n        return p.then((l: Layer) => {\r\n            return this._mapService.CreateMarker(options)\r\n                .then((marker: Marker) => {\r\n                    marker.IsFirst = options.isFirst;\r\n                    marker.IsLast = options.isLast;\r\n                    l.AddEntity(marker);\r\n                    return marker;\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Starts the clustering\r\n     *\r\n     * @param layer\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public StartClustering(layer: ClusterLayerDirective): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Stops the clustering\r\n     *\r\n     * @param layer\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public StopClustering(layer: ClusterLayerDirective): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygon.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon> {\r\n        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>> {\r\n        throw (new Error('Polygons are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the line.\r\n     * @param options - Polyline options defining the line.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an\r\n     * array of polygons for complex paths) model.\r\n     *\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreatePolyline(layer: number, options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof GoogleClusterService\r\n     */\r\n    public CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>> {\r\n        throw (new Error('Polylines are not supported in clustering layers. You can only use markers.'));\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { InfoBoxComponent } from '../../components/infobox';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { InfoBoxService } from '../infobox.service';\r\nimport { MarkerService } from '../marker.service';\r\nimport { MapService } from '../map.service';\r\nimport { InfoWindow } from '../../models/info-window';\r\nimport { GoogleInfoWindow } from '../../models/google/google-info-window';\r\nimport { GoogleMarker } from '../../models/google/google-marker';\r\nimport { GoogleMapEventsLookup } from '../../models/google/google-events-lookup';\r\n\r\n@Injectable()\r\nexport class GoogleInfoBoxService extends InfoBoxService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n\r\n    private _boxes: Map<InfoBoxComponent, Promise<InfoWindow>> = new Map<InfoBoxComponent, Promise<GoogleInfoWindow>>();\r\n\r\n    ///\r\n    /// Constructors\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleInfoBoxService.\r\n     * @param _mapService\r\n     * @param _markerService\r\n     * @param _zone\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _markerService: MarkerService,\r\n        private _zone: NgZone) {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of an info window\r\n     *\r\n     * @param info\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public AddInfoWindow(info: InfoBoxComponent): void {\r\n        const options: IInfoWindowOptions = {};\r\n        if (info.HtmlContent !== '') {\r\n            options.htmlContent = info.HtmlContent;\r\n        }\r\n        else {\r\n            options.title = info.Title;\r\n            options.description = info.Description;\r\n        }\r\n        if (info.xOffset || info.yOffset) {\r\n            if (options.pixelOffset == null) { options.pixelOffset = { x: 0, y: 0 }; }\r\n            if (info.xOffset) { options.pixelOffset.x = info.xOffset; }\r\n            if (info.yOffset) { options.pixelOffset.y = info.yOffset; }\r\n        }\r\n        options.disableAutoPan = info.DisableAutoPan;\r\n        options.visible = info.Visible;\r\n\r\n        if (typeof info.Latitude === 'number' && typeof info.Longitude === 'number') {\r\n            options.position = { latitude: info.Latitude, longitude: info.Longitude };\r\n        }\r\n        const infoWindowPromise = this._mapService.CreateInfoWindow(options);\r\n        this._boxes.set(info, infoWindowPromise);\r\n    }\r\n\r\n    /**\r\n     * Closes the info window\r\n     *\r\n     * @param info\r\n     * @returns -  A promise that is resolved when the info box is closed.\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public Close(info: InfoBoxComponent): Promise<void> {\r\n        return this._boxes.get(info).then(w => {\r\n            w.Close();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Registers an event delegate for an info window.\r\n     *\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param infoComponent - The {@link InfoBoxComponent} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public CreateEventObservable<T>(eventName: string, infoComponent: InfoBoxComponent): Observable<T> {\r\n        const googleEventName: string = GoogleMapEventsLookup[eventName];\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._boxes.get(infoComponent).then((b: InfoWindow) => {\r\n                b.AddListener(googleEventName, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes the info window\r\n     *\r\n     * @param info\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public DeleteInfoWindow(info: InfoBoxComponent): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Opens the info window. Window opens on a marker, if supplied, or a specific location if given\r\n     *\r\n     * @param info\r\n     * @param [loc]\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public Open(info: InfoBoxComponent, loc?: ILatLong): Promise<void> {\r\n        if (info.CloseInfoBoxesOnOpen || info.Modal) {\r\n            // close all open info boxes\r\n            this._boxes.forEach((box: Promise<InfoWindow>, i: InfoBoxComponent) => {\r\n                if (info.Id !== i.Id) {\r\n                    box.then((w) => {\r\n                        if (w.IsOpen) {\r\n                            w.Close();\r\n                            i.Close();\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        return this._boxes.get(info).then((w: GoogleInfoWindow) => {\r\n            const options: IInfoWindowOptions = {};\r\n            if (info.HtmlContent !== '') {\r\n                options.htmlContent = info.HtmlContent;\r\n            }\r\n            else {\r\n                options.title = info.Title;\r\n                options.description = info.Description;\r\n            }\r\n            w.SetOptions(options);\r\n            if (info.HostMarker != null) {\r\n                return this._markerService.GetNativeMarker(info.HostMarker).then((marker) => {\r\n                    return this._mapService.MapPromise.then((map) => (<GoogleInfoWindow>w).Open((<GoogleMarker>marker).NativePrimitve));\r\n                });\r\n            }\r\n            return this._mapService.MapPromise.then((map) => {\r\n                if (loc) { w.SetPosition(loc); }\r\n                w.Open();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the info window options\r\n     *\r\n     * @param info\r\n     * @param options\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public SetOptions(info: InfoBoxComponent, options: IInfoWindowOptions): Promise<void> {\r\n        return this._boxes.get(info).then((w: GoogleInfoWindow) => {\r\n            w.SetOptions(options);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the info window position\r\n     *\r\n     * @param info\r\n     * @param latlng\r\n     *\r\n     * @memberof GoogleInfoBoxService\r\n     */\r\n    public SetPosition(info: InfoBoxComponent, latlng: ILatLong): Promise<void> {\r\n        this._boxes.get(info).then((w) => {\r\n            w.SetPosition(latlng);\r\n        });\r\n        return Promise.resolve();\r\n    }\r\n\r\n}\r\n","import { eachSeries, nextTick } from 'async';\r\nimport { GoogleMarker } from './google-marker';\r\nimport { ILayerOptions } from '../../interfaces/ilayer-options';\r\nimport { MapService } from '../../services/map.service';\r\nimport { Layer } from '../layer';\r\nimport { Marker } from '../marker';\r\nimport { InfoWindow } from '../info-window';\r\nimport { Polygon } from '../polygon';\r\nimport { Polyline } from '../polyline';\r\nimport { ClusterPlacementMode } from '../cluster-placement-mode';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\n\r\n/**\r\n * Concrete implementation of a layer for the Google Map Provider.\r\n *\r\n * @export\r\n */\r\nexport class GoogleLayer implements Layer {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _entities: Array<Marker|InfoWindow|Polygon|Polyline> = new Array<Marker|InfoWindow|Polygon|Polyline>();\r\n    private _visible: boolean = true;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer. Google does not have the concept of a custom layer,\r\n     * so we are returning the Map as the native object because it hosts all the markers.\r\n     *\r\n     * @returns GoogleMapTypes.GoogleMap.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.GoogleMap {\r\n        return this._layer;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new instance of the GoogleMarkerClusterer class.\r\n     *\r\n     * @param _layer GoogleMapTypes.MarkerClusterer. Native Google Maps Marker Clusterer supporting the cluster layer.\r\n     * @param _maps MapService. MapService implementation to leverage for the layer.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    constructor(private _layer: GoogleMapTypes.GoogleMap, private _maps: MapService, private _id: number) { }\r\n\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        throw (new Error('Events are not supported on Google Layers. You can still add events to individual markers.'));\r\n    }\r\n\r\n    /**\r\n     * Adds an entity to the layer. Use this method with caution as it will\r\n     * trigger a recaluation of the clusters (and associated markers if approprite) for\r\n     * each invocation. If you use this method to add many markers to the cluster, use\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline. Entity to add to the layer.\r\n     *\r\n     * @memberof GoogleLAyer\r\n     */\r\n    public AddEntity(entity: Marker | InfoWindow | Polygon | Polyline): void {\r\n        if (entity.NativePrimitve) {\r\n            this._entities.push(entity);\r\n            entity.NativePrimitve.setVisible(this._visible);\r\n            entity.NativePrimitve.setMap(this.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a number of entities to the layer. Entities in this context should be model abstractions of concered map functionality (such\r\n     * as marker, infowindow, polyline, polygon, etc..)\r\n     *\r\n     * @param entities Array<Marker|InfoWindow|Polygon|Polyline>. Entities to add to the layer.\r\n     *\r\n     * @memberof GoogleLAyer\r\n     */\r\n    public AddEntities(entities: Array<Marker|InfoWindow|Polygon|Polyline>): void {\r\n        if (entities != null && Array.isArray(entities) && entities.length !== 0 ) {\r\n            this._entities.push(...entities);\r\n            eachSeries([...entities], (e, next) => {\r\n                e.NativePrimitve.setVisible(this._visible);\r\n                e.NativePrimitve.setMap(this.NativePrimitve);\r\n                nextTick(() => next());\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes the layer anbd the markers in it.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public Delete(): void {\r\n        eachSeries(this._entities.splice(0), (e, next) => {\r\n            e.NativePrimitve.setMap(null);\r\n            nextTick(() => next());\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns ILayerOptions. The layer options.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public GetOptions(): ILayerOptions {\r\n        const options: ILayerOptions = {\r\n            id: this._id\r\n        };\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns Boolean. True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._visible;\r\n    }\r\n\r\n    /**\r\n     * Removes an entity from the layer.\r\n     *\r\n     * @param entity Marker|InfoWindow|Polygon|Polyline Entity to be removed from the layer.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public RemoveEntity(entity: Marker | InfoWindow | Polygon | Polyline): void {\r\n        if (entity.NativePrimitve) {\r\n            const j: number = this._entities.indexOf(entity);\r\n            if (j > -1) { this._entities.splice(j, 1); }\r\n            entity.NativePrimitve.setMap(null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the entities for the cluster layer.\r\n     *\r\n     * @param entities Array<Marker>|Array<InfoWindow>|Array<Polygon>|Array<Polyline> containing\r\n     * the entities to add to the cluster. This replaces any existing entities.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public SetEntities(entities: Array<Marker> | Array<InfoWindow> | Array<Polygon> | Array<Polyline>): void {\r\n        this.Delete();\r\n        this.AddEntities(entities);\r\n    }\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options ILayerOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof GoogleLayer\r\n     */\r\n    public SetOptions(options: ILayerOptions): void {\r\n        this._id = options.id;\r\n    }\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        eachSeries([...this._entities], (e, next) => {\r\n            e.NativePrimitve.setVisible(visible);\r\n            nextTick(() => next());\r\n        });\r\n        this._visible = visible;\r\n    }\r\n\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { Layer } from '../../models/layer';\r\nimport { GoogleLayer } from '../../models/google/google-layer';\r\nimport { GooglePolygon } from '../../models/google/google-polygon';\r\nimport { GooglePolyline } from '../../models/google/google-polyline';\r\nimport { MapLayerDirective } from '../../components/map-layer';\r\nimport { LayerService } from '../layer.service';\r\nimport { GoogleLayerBase } from './google-layer-base';\r\nimport { MapService } from '../map.service';\r\nimport { GoogleConversions } from './google-conversions';\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\ndeclare var google: any;\r\n\r\n/**\r\n * Implements the {@link LayerService} contract for a Google Maps specific implementation.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleLayerService extends GoogleLayerBase implements LayerService  {\r\n\r\n    ///\r\n    /// Field Declarations.\r\n    ///\r\n    protected _layers: Map<number, Promise<Layer>> = new Map<number, Promise<Layer>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleLayerService.\r\n     * @param _mapService - Instance of the Google Maps Service. Will generally be injected.\r\n     * @param _zone - NgZone instance to provide zone aware promises.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    constructor(_mapService: MapService, _zone: NgZone) {\r\n        super(_mapService, _zone);\r\n    }\r\n\r\n    /**\r\n     * Adds a layer to the map.\r\n     *\r\n     * @abstract\r\n     * @param layer - MapLayerDirective component object.\r\n     * Generally, MapLayerDirective will be injected with an instance of the\r\n     * LayerService and then self register on initialization.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public AddLayer(layer: MapLayerDirective): void {\r\n        const p: Promise<Layer> = new Promise<Layer>((resolve, reject) => {\r\n            this._mapService.MapPromise.then(m => {\r\n                const l: GoogleLayer = new GoogleLayer(m, this._mapService, layer.Id);\r\n                l.SetVisible(layer.Visible);\r\n                resolve(l);\r\n            });\r\n        });\r\n        this._layers.set(layer.Id, p);\r\n    }\r\n\r\n    /**\r\n     * Adds a polygon to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygon.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polygon model.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public CreatePolygon(layer: number, options: IPolygonOptions): Promise<Polygon> {\r\n        const p: Promise<Polygon> = this._mapService.CreatePolygon(options);\r\n        const l: Promise<Layer> = this._layers.get(layer);\r\n        Promise.all([p, l]).then(x => x[1].AddEntity(x[0]));\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polygons. Use this method to create arrays of polygons to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polygon.\r\n     * @param options - Polygon options defining the polygons.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polygon models.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public CreatePolygons(layer: number, options: Array<IPolygonOptions>): Promise<Array<Polygon>> {\r\n        //\r\n        // Note: we attempted using data.Polygons in an attempt to improve performance, but either data.Polygon\r\n        // or data.MultiPolygon actually operate significantly slower than generating the polygons this way.\r\n        // the slowness in google as opposed to bing probably comes from the point reduction algorithm uses.\r\n        // Signigicant performance improvements might be possible in google when using a pixel based reduction algorithm\r\n        // prior to setting the polygon path. This will lower to processing overhead of the google algorithm (with is Douglas-Peucker\r\n        // and rather compute intensive)\r\n        //\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const polygons: Promise<Array<Polygon>> = new Promise<Array<Polygon>>((resolve, reject) => {\r\n                const polys: Array<GooglePolygon> = options.map(o => {\r\n                    const op: GoogleMapTypes.PolygonOptions = GoogleConversions.TranslatePolygonOptions(o);\r\n                    const poly: GoogleMapTypes.Polygon = new google.maps.Polygon(op);\r\n                    const polygon: GooglePolygon = new GooglePolygon(poly);\r\n                    if (o.title && o.title !== '') { polygon.Title = o.title; }\r\n                    if (o.metadata) { o.metadata.forEach((val: any, key: string) => polygon.Metadata.set(key, val)); }\r\n                    return polygon;\r\n                });\r\n                resolve(polys);\r\n            });\r\n            return polygons;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a polyline to the layer.\r\n     *\r\n     * @abstract\r\n     * @param layer - The id of the layer to which to add the polyline.\r\n     * @param options - Polyline options defining the polyline.\r\n     * @returns - A promise that when fullfilled contains the an instance of the Polyline (or an array\r\n     * of polygons for complex paths) model.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public CreatePolyline(layer: number, options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        const p: Promise<Polyline|Array<Polyline>> = this._mapService.CreatePolyline(options);\r\n        const l: Promise<Layer> = this._layers.get(layer);\r\n        Promise.all([p, l]).then(x => {\r\n            const p1: Array<Polyline> =  Array.isArray(x[0]) ? <Array<Polyline>>x[0] : [<Polyline>x[0]];\r\n            for (const p2 of p1) {x[1].AddEntity(p2); }\r\n        });\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Creates an array of unbound polylines. Use this method to create arrays of polylines to be used in bulk\r\n     * operations.\r\n     *\r\n     * @param layer - The id of the layer to which to add the polylines.\r\n     * @param options - Polyline options defining the polylines.\r\n     * @returns - A promise that when fullfilled contains the an arrays of the Polyline models.\r\n     *\r\n     * @memberof GoogleLayerService\r\n     */\r\n    public CreatePolylines(layer: number, options: Array<IPolylineOptions>): Promise<Array<Polyline|Array<Polyline>>> {\r\n        const p: Promise<Layer> = this.GetLayerById(layer);\r\n        if (p == null) { throw (new Error(`Layer with id ${layer} not found in Layer Map`)); }\r\n        return p.then((l: Layer) => {\r\n            const polylines: Promise<Array<Polyline|Array<Polyline>>> = new Promise<Array<Polyline|Array<Polyline>>>((resolve, reject) => {\r\n                const polys: Array<Polyline|Array<Polyline>> = options.map(o => {\r\n                    const op: GoogleMapTypes.PolylineOptions = GoogleConversions.TranslatePolylineOptions(o);\r\n                    if (o.path && o.path.length > 0 && !Array.isArray(o.path[0])) {\r\n                        op.path = GoogleConversions.TranslatePaths(o.path)[0];\r\n                        const poly: GoogleMapTypes.Polyline = new google.maps.Polyline(op);\r\n                        const polyline: GooglePolyline = new GooglePolyline(poly);\r\n                        if (o.title && o.title !== '') { polyline.Title = o.title; }\r\n                        if (o.metadata) { o.metadata.forEach((v, k) => polyline.Metadata.set(k, v)); }\r\n                        return polyline;\r\n                    }\r\n                    else {\r\n                        const paths: Array<Array<GoogleMapTypes.LatLng>> = GoogleConversions.TranslatePaths(o.path);\r\n                        const lines: Array<Polyline> = new Array<Polyline>();\r\n                        paths.forEach(x => {\r\n                            op.path = x;\r\n                            const poly = new google.maps.Polyline(op);\r\n                            const polyline: GooglePolyline = new GooglePolyline(poly);\r\n                            if (o.metadata) { o.metadata.forEach((v, k) => polyline.Metadata.set(k, v)); }\r\n                            if (o.title && o.title !== '') {polyline.Title = o.title; }\r\n                            lines.push(polyline);\r\n                        });\r\n                        return lines;\r\n                    }\r\n                });\r\n                resolve(polys);\r\n            });\r\n            return polylines;\r\n        });\r\n    }\r\n\r\n}\r\n","import { Injectable, Optional } from '@angular/core';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from '../mapapiloader';\r\n\r\n/**\r\n * Protocol enumeration\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum ScriptProtocol {\r\n    HTTP,\r\n    HTTPS,\r\n    AUTO\r\n}\r\n\r\n/**\r\n * Bing Maps V8 specific loader configuration to be used with the {@link GoogleMapAPILoader}\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMapAPILoaderConfig {\r\n    /**\r\n       * The Google Maps API Key (see:\r\n       * https://developers.google.com/maps/documentation/javascript/get-api-key)\r\n       */\r\n    apiKey?: string;\r\n\r\n    /**\r\n     * The Google Maps client ID (for premium plans).\r\n     * When you have a Google Maps APIs Premium Plan license, you must authenticate\r\n     * your application with either an API key or a client ID.\r\n     * The Google Maps API will fail to load if both a client ID and an API key are included.\r\n     */\r\n    clientId?: string;\r\n\r\n    /**\r\n     * The Google Maps channel name (for premium plans).\r\n     * A channel parameter is an optional parameter that allows you to track usage under your client\r\n     * ID by assigning a distinct channel to each of your applications.\r\n     */\r\n    channel?: string;\r\n\r\n    /**\r\n     * Google Maps API version.\r\n     */\r\n    apiVersion?: string;\r\n\r\n    /**\r\n     * Host and Path used for the `<script>` tag.\r\n     */\r\n    hostAndPath?: string;\r\n\r\n    /**\r\n     * Protocol used for the `<script>` tag.\r\n     */\r\n    protocol?: ScriptProtocol;\r\n\r\n    /**\r\n     * Defines which Google Maps libraries should get loaded.\r\n     */\r\n    libraries?: string[];\r\n\r\n    /**\r\n     * The default bias for the map behavior is US.\r\n     * If you wish to alter your application to serve different map tiles or bias the\r\n     * application, you can overwrite the default behavior (US) by defining a `region`.\r\n     * See https://developers.google.com/maps/documentation/javascript/basics#Region\r\n     */\r\n    region?: string;\r\n\r\n    /**\r\n     * The Google Maps API uses the browser's preferred language when displaying\r\n     * textual information. If you wish to overwrite this behavior and force the API\r\n     * to use a given language, you can use this setting.\r\n     * See https://developers.google.com/maps/documentation/javascript/basics#Language\r\n     */\r\n    language?: string;\r\n\r\n    /**\r\n     * The Google Maps API requires a separate library for clustering. Set the property\r\n     * to true in order to load this library.\r\n     * See https://developers.google.com/maps/documentation/javascript/marker-clustering\r\n     */\r\n    enableClustering?: boolean;\r\n\r\n    /**\r\n     * Host and Path used for the cluster library `<script>` tag.\r\n     */\r\n    clusterHostAndPath?: string;\r\n}\r\n\r\n/**\r\n * Default loader configuration.\r\n */\r\nconst DEFAULT_CONFIGURATION = new GoogleMapAPILoaderConfig();\r\n\r\n/**\r\n * Bing Maps V8 implementation for the {@link MapAPILoader} service.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMapAPILoader extends MapAPILoader {\r\n\r\n    ///\r\n    /// Field defintitions.\r\n    ///\r\n    private _scriptLoadingPromise: Promise<void>;\r\n\r\n    ///\r\n    /// Property declarations.\r\n    ///\r\n\r\n    /**\r\n     * Gets the loader configuration.\r\n     *\r\n     * @readonly\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    public get Config(): GoogleMapAPILoaderConfig { return this._config; }\r\n\r\n    /**\r\n     * Creates an instance of GoogleMapAPILoader.\r\n     * @param _config - The loader configuration.\r\n     * @param _windowRef - An instance of {@link WindowRef}. Necessary because Bing Map V8 interacts with the window object.\r\n     * @param _documentRef - An instance of {@link DocumentRef}.\r\n     *                                     Necessary because Bing Map V8 interacts with the document object.\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    constructor( @Optional() private _config: GoogleMapAPILoaderConfig, private _windowRef: WindowRef, private _documentRef: DocumentRef) {\r\n        super();\r\n        if (this._config === null || this._config === undefined) {\r\n            this._config = DEFAULT_CONFIGURATION;\r\n        }\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapAPILoader implementation.\r\n    ///\r\n\r\n    /**\r\n     * Loads the necessary resources for Bing Maps V8.\r\n     *\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    public Load(): Promise<void> {\r\n        if (this._scriptLoadingPromise) {\r\n            return this._scriptLoadingPromise;\r\n        }\r\n\r\n        const script = this._documentRef.GetNativeDocument().createElement('script');\r\n        script.type = 'text/javascript';\r\n        script.async = true;\r\n        script.defer = true;\r\n        const callbackName = `Create`;\r\n        script.src = this.GetMapsScriptSrc(callbackName);\r\n\r\n        this._scriptLoadingPromise = new Promise<void>((resolve: Function, reject: Function) => {\r\n            (<any>this._windowRef.GetNativeWindow())[callbackName] = () => {\r\n                if (this._config.enableClustering) {\r\n                    // if clustering is enabled then delay the loading until after the cluster library is loaded\r\n                    const clusterScript = this._documentRef.GetNativeDocument().createElement('script');\r\n                    clusterScript.type = 'text/javascript';\r\n                    clusterScript.src = this.GetClusterScriptSrc();\r\n                    clusterScript.onload = clusterScript.onreadystatechange = () => {\r\n                        resolve();\r\n                    };\r\n                    this._documentRef.GetNativeDocument().head.appendChild(clusterScript);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            };\r\n            script.onerror = (error: Event) => { reject(error); };\r\n        });\r\n        this._documentRef.GetNativeDocument().head.appendChild(script);\r\n\r\n        return this._scriptLoadingPromise;\r\n    }\r\n\r\n    ///\r\n    /// Private methods\r\n    ///\r\n\r\n    /**\r\n     * Gets the Google Maps scripts url for injections into the header.\r\n     *\r\n     * @param callbackName - Name of the function to be called when the Google Maps scripts are loaded.\r\n     * @returns - The url to be used to load the Google Map scripts.\r\n     *\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    private GetMapsScriptSrc(callbackName: string) {\r\n        const hostAndPath: string = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';\r\n        const queryParams: { [key: string]: string | Array<string> } = {\r\n            v: this._config.apiVersion,\r\n            callback: callbackName,\r\n            key: this._config.apiKey,\r\n            client: this._config.clientId,\r\n            channel: this._config.channel,\r\n            libraries: this._config.libraries,\r\n            region: this._config.region,\r\n            language: this._config.language\r\n        };\r\n        return this.GetScriptSrc(hostAndPath, queryParams);\r\n    }\r\n\r\n    /**\r\n     * Gets the Google Maps Cluster library url for injections into the header.\r\n     *\r\n     * @returns - The url to be used to load the Google Map Cluster library.\r\n     *\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    private GetClusterScriptSrc() {\r\n        const hostAndPath: string = this._config.clusterHostAndPath ||\r\n            'developers.google.com/maps/documentation/javascript/examples/markerclusterer/markerclusterer.js';\r\n        return this.GetScriptSrc(hostAndPath, {});\r\n    }\r\n\r\n    /**\r\n     * Gets a scripts url for injections into the header.\r\n     *\r\n     * @param hostAndPath - Host and path name of the script to load.\r\n     * @param queryParams - Url query parameters.\r\n     * @returns - The url with correct protocol, path, and query parameters.\r\n     *\r\n     * @memberof GoogleMapAPILoader\r\n     */\r\n    private GetScriptSrc(hostAndPath: string, queryParams: { [key: string]: string | Array<string> }): string {\r\n        const protocolType: ScriptProtocol =\r\n            <ScriptProtocol>((this._config && this._config.protocol) || ScriptProtocol.HTTPS);\r\n        let protocol: string;\r\n\r\n        switch (protocolType) {\r\n            case ScriptProtocol.AUTO:\r\n                protocol = '';\r\n                break;\r\n            case ScriptProtocol.HTTP:\r\n                protocol = 'http:';\r\n                break;\r\n            case ScriptProtocol.HTTPS:\r\n                protocol = 'https:';\r\n                break;\r\n        }\r\n\r\n        const params: string =\r\n            Object.keys(queryParams)\r\n                .filter((k: string) => queryParams[k] != null)\r\n                .filter((k: string) => {\r\n                    // remove empty arrays\r\n                    return !Array.isArray(queryParams[k]) ||\r\n                        (Array.isArray(queryParams[k]) && queryParams[k].length > 0);\r\n                })\r\n                .map((k: string) => {\r\n                    // join arrays as comma seperated strings\r\n                    const i = queryParams[k];\r\n                    if (Array.isArray(i)) {\r\n                        return { key: k, value: i.join(',') };\r\n                    }\r\n                    return { key: k, value: queryParams[k] };\r\n                })\r\n                .map((entry: { key: string, value: string }) => { return `${entry.key}=${entry.value}`; })\r\n                .join('&');\r\n        return `${protocol}//${hostAndPath}?${params}`;\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { BehaviorSubject, Observable, Observer } from 'rxjs';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { Marker } from '../../models/marker';\r\nimport { MapMarkerDirective } from '../../components/map-marker';\r\nimport { MarkerService } from '../marker.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\nimport { ClusterService } from '../cluster.service';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { GoogleConversions } from './google-conversions';\r\n\r\n/**\r\n * Concrete implementation of the MarkerService abstract class for Google.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMarkerService implements MarkerService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _markers: Map<MapMarkerDirective, Promise<Marker>> = new Map<MapMarkerDirective, Promise<Marker>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleMarkerService.\r\n     * @param _mapService - {@link MapService} instance.\r\n     * The concrete {@link GoogleMapService} implementation is expected.\r\n     * @param _layerService - {@link LayerService} instance.\r\n     * The concrete {@link GoogleLayerService} implementation is expected.\r\n     * @param _clusterService - {@link ClusterService} instance.\r\n     * The concrete {@link GoogleClusterService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _clusterService: ClusterService,\r\n        private _zone: NgZone) {\r\n    }\r\n\r\n    /**\r\n     * Adds a marker. Depending on the marker context, the marker will either by added to the map or a correcsponding layer.\r\n     *\r\n     * @param marker - The {@link MapMarkerDirective} to be added.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public AddMarker(marker: MapMarkerDirective): void {\r\n        const o: IMarkerOptions = {\r\n            anchor: marker.Anchor,\r\n            position: { latitude: marker.Latitude, longitude: marker.Longitude },\r\n            title: marker.Title,\r\n            label: marker.Label,\r\n            draggable: marker.Draggable,\r\n            icon: marker.IconUrl,\r\n            iconInfo: marker.IconInfo,\r\n            width: marker.Width,\r\n            height: marker.Height,\r\n            isFirst: marker.IsFirstInSet,\r\n            isLast: marker.IsLastInSet\r\n        };\r\n\r\n        // create marker via promise.\r\n        let markerPromise: Promise<Marker> = null;\r\n        if (marker.InClusterLayer) {\r\n            markerPromise = this._clusterService.CreateMarker(marker.LayerId, o);\r\n        }\r\n        else if (marker.InCustomLayer) {\r\n            markerPromise = this._layerService.CreateMarker(marker.LayerId, o);\r\n        }\r\n        else {\r\n            markerPromise = this._mapService.CreateMarker(o);\r\n        }\r\n\r\n        this._markers.set(marker, markerPromise);\r\n        if (marker.IconInfo) {\r\n            markerPromise.then((m: Marker) => {\r\n                // update iconInfo to provide hook to do post icon creation activities and\r\n                // also re-anchor the marker\r\n                marker.DynamicMarkerCreated.emit(o.iconInfo);\r\n                const p: IPoint = {\r\n                    x: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.width * o.iconInfo.markerOffsetRatio.x) : 0,\r\n                    y: (o.iconInfo.size && o.iconInfo.markerOffsetRatio) ? (o.iconInfo.size.height * o.iconInfo.markerOffsetRatio.y) : 0,\r\n                };\r\n                m.SetAnchor(p);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers an event delegate for a marker.\r\n     *\r\n     * @param eventName - The name of the event to register (e.g. 'click')\r\n     * @param marker - The {@link MapMarkerDirective} for which to register the event.\r\n     * @returns - Observable emiting an instance of T each time the event occurs.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public CreateEventObservable<T>(eventName: string, marker: MapMarkerDirective): Observable<T> {\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._markers.get(marker).then((m: Marker) => {\r\n                m.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes a marker.\r\n     *\r\n     * @param marker - {@link MapMarkerDirective} to be deleted.\r\n     * @returns - A promise fullfilled once the marker has been deleted.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public DeleteMarker(marker: MapMarkerDirective): Promise<void> {\r\n        const m = this._markers.get(marker);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((ma: Marker) => {\r\n            if (marker.InClusterLayer) {\r\n                this._clusterService.GetNativeLayer(marker.LayerId).then(l => { l.RemoveEntity(ma); });\r\n            }\r\n            if (marker.InCustomLayer) {\r\n                this._layerService.GetNativeLayer(marker.LayerId).then(l => { l.RemoveEntity(ma); });\r\n            }\r\n            return this._zone.run(() => {\r\n                ma.DeleteMarker();\r\n                this._markers.delete(marker);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the marker on the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        if (!e) {\r\n            return null;\r\n        }\r\n        if (!e.latLng) {\r\n            return null;\r\n        }\r\n        if (!e.latLng.lat || !e.latLng.lng) {\r\n            return null;\r\n        }\r\n        return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker model for the marker allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param marker - The {@link MapMarkerDirective} for which to obtain the marker model.\r\n     * @returns - A promise that when fullfilled contains the {@link Marker} implementation of the underlying platform.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public GetNativeMarker(marker: MapMarkerDirective): Promise<Marker> {\r\n        return this._markers.get(marker);\r\n    }\r\n\r\n    /**\r\n     * Obtains the marker pixel location for the marker on the click location\r\n     *\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the pixels of the marker on the map canvas.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public GetPixelsFromClick(e: MouseEvent | any): IPoint {\r\n        if (!e || !e.latLng || !e.latLng.lat || !e.latLng.lng) {\r\n            return null;\r\n        }\r\n        if (this._mapService.MapInstance == null) {\r\n            return null;\r\n        }\r\n\r\n        let crossesDateLine: boolean = false;\r\n        const m = this._mapService.MapInstance;\r\n        const p = m.getProjection();\r\n        const s: number = Math.pow(2, m.getZoom());\r\n        const b: GoogleMapTypes.LatLngBounds = m.getBounds();\r\n        if (b.getCenter().lng() < b.getSouthWest().lng()  ||\r\n            b.getCenter().lng() > b.getNorthEast().lng()) { crossesDateLine = true; }\r\n\r\n        const offsetY: number = p.fromLatLngToPoint(b.getNorthEast()).y;\r\n        const offsetX: number = p.fromLatLngToPoint(b.getSouthWest()).x;\r\n        const point: GoogleMapTypes.Point = p.fromLatLngToPoint(e.latLng);\r\n        return {\r\n            x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),\r\n            y: Math.floor((point.y - offsetY) * s)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Converts a geo location to a pixel location relative to the map canvas.\r\n     *\r\n     * @param target - Either a {@link MapMarkerDirective}\r\n     * or a {@link ILatLong} for the basis of translation.\r\n     * @returns - A promise that when fullfilled contains a {@link IPoint}\r\n     * with the pixel coordinates of the MapMarker or ILatLong relative to the map canvas.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public LocationToPoint(target: MapMarkerDirective | ILatLong): Promise<IPoint> {\r\n        if (target == null) {\r\n            return Promise.resolve(null);\r\n        }\r\n        if (target instanceof MapMarkerDirective) {\r\n            return this._markers.get(target).then((m: Marker) => {\r\n                const l: ILatLong = m.Location;\r\n                const p: Promise<IPoint> = this._mapService.LocationToPoint(l);\r\n                return p;\r\n            });\r\n        }\r\n        return this._mapService.LocationToPoint(target);\r\n    }\r\n\r\n    /**\r\n     * Updates the anchor position for the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the anchor.\r\n     * Anchor information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the anchor position has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateAnchor(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => {\r\n            m.SetAnchor(marker.Anchor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates whether the marker is draggable.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate dragability.\r\n     * Dragability information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the marker has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateDraggable(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetDraggable(marker.Draggable));\r\n    }\r\n\r\n    /**\r\n     * Updates the Icon on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the icon. Icon information is present\r\n     * in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the icon information has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateIcon(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => {\r\n            if (marker.IconInfo) {\r\n                const x: IMarkerOptions = {\r\n                    position: { latitude: marker.Latitude, longitude: marker.Longitude },\r\n                    iconInfo: marker.IconInfo\r\n                };\r\n                const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(x);\r\n                m.SetIcon(o.icon);\r\n                marker.DynamicMarkerCreated.emit(x.iconInfo);\r\n            } else {\r\n                m.SetIcon(marker.IconUrl);\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the label on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the label.\r\n     * Label information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the label has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateLabel(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => { m.SetLabel(marker.Label); });\r\n    }\r\n\r\n    /**\r\n     * Updates the geo coordinates for the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the coordinates.\r\n     * Coordinate information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the position has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateMarkerPosition(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then(\r\n            (m: Marker) => m.SetPosition({\r\n                latitude: marker.Latitude,\r\n                longitude: marker.Longitude\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Updates the title on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the title.\r\n     * Title information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the title has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateTitle(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetTitle(marker.Title));\r\n    }\r\n\r\n    /**\r\n     * Updates the visibility on the marker.\r\n     *\r\n     * @param - The {@link MapMarkerDirective} object for which to upate the title.\r\n     * Title information is present in the underlying {@link Marker} model object.\r\n     * @returns - A promise that is fullfilled when the title has been updated.\r\n     * @memberof GoogleMarkerService\r\n     */\r\n    public UpdateVisible(marker: MapMarkerDirective): Promise<void> {\r\n        return this._markers.get(marker).then((m: Marker) => m.SetVisible(marker.Visible));\r\n    }\r\n\r\n}\r\n","import { GoogleMarker } from './google-marker';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { MapService } from '../../services/map.service';\r\nimport { Layer } from '../layer';\r\nimport { Marker } from '../marker';\r\nimport { InfoWindow } from '../info-window';\r\nimport { ClusterPlacementMode } from '../cluster-placement-mode';\r\nimport * as GoogleMapTypes from '../../services/google/google-map-types';\r\nimport { timer } from 'rxjs';\r\n\r\n/**\r\n * Concrete implementation of a clustering layer for the Google Map Provider.\r\n *\r\n * @export\r\n */\r\nexport class GoogleMarkerClusterer implements Layer {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _isClustering = true;\r\n    private _markerLookup: Map<GoogleMapTypes.Marker, Marker> = new Map<GoogleMapTypes.Marker, Marker>();\r\n    private _markers: Array<Marker> = new Array<Marker>();\r\n    private _pendingMarkers: Array<Marker> = new Array<Marker>();\r\n    private _mapclicks: number = 0;\r\n    private _currentZoom: number = 0;\r\n    private _visible: boolean = true;\r\n\r\n    ///\r\n    /// Property definitions\r\n    ///\r\n\r\n    /**\r\n     * Get the native primitive underneath the abstraction layer.\r\n     *\r\n     * @returns GoogleMapTypes.MarkerClusterer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public get NativePrimitve(): GoogleMapTypes.MarkerClusterer {\r\n        return this._layer;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates a new instance of the GoogleMarkerClusterer class.\r\n     *\r\n     * @param _layer GoogleMapTypes.MarkerClusterer. Native Google Maps Marker Clusterer supporting the cluster layer.\r\n     * @param _maps MapService. MapService implementation to leverage for the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    constructor(private _layer: GoogleMapTypes.MarkerClusterer) { }\r\n\r\n\r\n    ///\r\n    /// Public methods, Layer interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds an event listener for the layer.\r\n     *\r\n     * @param eventType string. Type of event to add (click, mouseover, etc). You can use any event that the underlying native\r\n     * layer supports.\r\n     * @param fn function. Handler to call when the event occurs.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public AddListener(eventType: string, fn: Function): void {\r\n        throw (new Error('Events are not supported on Google Cluster Layers. You can still add events to individual markers.'));\r\n    }\r\n\r\n    /**\r\n     * Adds an entity to the layer. Use this method with caution as it will\r\n     * trigger a recaluation of the clusters (and associated markers if approprite) for\r\n     * each invocation. If you use this method to add many markers to the cluster, use\r\n     *\r\n     * @param entity Marker. Entity to add to the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public AddEntity(entity: Marker): void {\r\n        let isMarker: boolean = entity instanceof Marker;\r\n        isMarker = entity instanceof GoogleMarker || isMarker;\r\n        if (isMarker) {\r\n            entity.NativePrimitve.setMap(null);\r\n                // remove the marker from the map as the clusterer will control marker visibility.\r\n            if (entity.IsFirst) {\r\n                this.StopClustering();\r\n            }\r\n        }\r\n        if (entity.NativePrimitve && entity.Location) {\r\n            if (this._isClustering && this._visible) {\r\n                this._layer.addMarker(entity.NativePrimitve);\r\n                this._markers.push(entity);\r\n            }\r\n            else {\r\n                this._pendingMarkers.push(entity);\r\n            }\r\n            this._markerLookup.set(entity.NativePrimitve, entity);\r\n        }\r\n        if (isMarker) {\r\n            if (entity.IsLast) {\r\n                this.StartClustering();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a number of markers to the layer.\r\n     *\r\n     * @param entities Array<Marker>. Entities to add to the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public AddEntities(entities: Array<Marker>): void {\r\n        if (entities != null && Array.isArray(entities) && entities.length !== 0 ) {\r\n            const e: Array<GoogleMapTypes.Marker> = entities.map(p => {\r\n                this._markerLookup.set(p.NativePrimitve, p);\r\n                p.NativePrimitve.setMap(null);\r\n                    // remove the marker from the map as the clusterer will control marker visibility.\r\n                return p.NativePrimitve;\r\n            });\r\n            if (this._isClustering && this._visible) {\r\n                this._layer.addMarkers(e);\r\n                this._markers.push(...entities);\r\n            }\r\n            else {\r\n                // if layer is not visible, always add to pendingMarkers. Setting the layer to visible later\r\n                // will render the markers appropriately\r\n                this._pendingMarkers.push(...entities);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes the clustering layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public Delete(): void {\r\n        this._layer.getMarkers().forEach(m => {\r\n            m.setMap(null);\r\n                // remove the marker from the map as the clusterer will control marker visibility.\r\n        });\r\n        this._layer.clearMarkers();\r\n        this._markers.splice(0);\r\n        this._pendingMarkers.splice(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the abstract marker used to wrap the Google Marker.\r\n     *\r\n     * @returns Marker. The abstract marker object representing the pushpin.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public GetMarkerFromGoogleMarker(pin: GoogleMapTypes.Marker): Marker {\r\n        const m: Marker = this._markerLookup.get(pin);\r\n        return m;\r\n    }\r\n\r\n    /**\r\n     * Returns the options governing the behavior of the layer.\r\n     *\r\n     * @returns IClusterOptions. The layer options.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public GetOptions(): IClusterOptions {\r\n        const options: IClusterOptions = {\r\n            id: 0,\r\n            gridSize: this._layer.getGridSize(),\r\n            clusteringEnabled: this._layer.getGridSize() === 0,\r\n            maxZoom: this._layer.getMaxZoom(),\r\n            minimumClusterSize: this._layer.getMinClusterSize(),\r\n            placementMode: this._layer.isAverageCenter() ? ClusterPlacementMode.MeanValue : ClusterPlacementMode.FirstPin,\r\n            visible: this._visible,\r\n            zoomOnClick: this._layer.isZoomOnClick(),\r\n            styles: this._layer.getStyles()\r\n        };\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * Returns the visibility state of the layer.\r\n     *\r\n     * @returns Boolean. True is the layer is visible, false otherwise.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public GetVisible(): boolean {\r\n        return this._visible;\r\n    }\r\n\r\n    /**\r\n     * Removes an entity from the cluster layer.\r\n     *\r\n     * @param entity Marker Entity to be removed from the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public RemoveEntity(entity: Marker): void {\r\n        if (entity.NativePrimitve && entity.Location) {\r\n            const j: number = this._markers.indexOf(entity);\r\n            const k: number = this._pendingMarkers.indexOf(entity);\r\n            if (j > -1) { this._markers.splice(j, 1); }\r\n            if (k > -1) { this._pendingMarkers.splice(k, 1); }\r\n            if (this._isClustering) {\r\n                this._layer.removeMarker(entity.NativePrimitve);\r\n            }\r\n            this._markerLookup.delete(entity.NativePrimitve);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the entities for the cluster layer.\r\n     *\r\n     * @param entities Array<Marker> containing\r\n     * the entities to add to the cluster. This replaces any existing entities.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public SetEntities(entities: Array<Marker>): void {\r\n        this._layer.getMarkers().forEach(m => {\r\n            m.setMap(null);\r\n        });\r\n        this._layer.clearMarkers();\r\n        this._markers.splice(0);\r\n        this._pendingMarkers.splice(0);\r\n        this._markerLookup.clear();\r\n\r\n        const p: Array<GoogleMapTypes.Marker> = new Array<GoogleMapTypes.Marker>();\r\n        entities.forEach((e: any) => {\r\n            if (e.NativePrimitve && e.Location) {\r\n                e.NativePrimitve.setMap(null);\r\n                this._markerLookup.set(e.NativePrimitve, e);\r\n                if (this._visible) {\r\n                    this._markers.push(e);\r\n                    p.push(e.NativePrimitve);\r\n                }\r\n                else {\r\n                    this._pendingMarkers.push(e);\r\n                }\r\n            }\r\n        });\r\n        this._layer.addMarkers(p);\r\n    }\r\n\r\n    /**\r\n     * Sets the options for the cluster layer.\r\n     *\r\n     * @param options IClusterOptions containing the options enumeration controlling the layer behavior. The supplied options\r\n     * are merged with the default/existing options.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public SetOptions(options: IClusterOptions): void {\r\n        if (options.placementMode != null) {\r\n            throw(new Error('GoogleMarkerClusterer: PlacementMode option cannot be set after initial creation.'));\r\n        }\r\n        if (options.zoomOnClick != null) {\r\n            throw(new Error('GoogleMarkerClusterer: ZoomOnClick option cannot be set after initial creation.'));\r\n        }\r\n        if (options.callback != null) {}\r\n        if (options.clusteringEnabled != null) {\r\n            this._layer.setMinClusterSize(options.clusteringEnabled ? 1 : 10000000);\r\n            this._layer.resetViewport();\r\n            this._layer.redraw();\r\n        }\r\n        if (options.gridSize != null && (options.clusteringEnabled == null || options.clusteringEnabled)) {\r\n            this._layer.setGridSize(options.gridSize);\r\n            this._layer.resetViewport();\r\n            this._layer.redraw();\r\n        }\r\n        if (options.maxZoom != null) { this._layer.setMaxZoom(options.maxZoom); }\r\n        if (options.minimumClusterSize != null) { this._layer.setMinClusterSize(options.minimumClusterSize); }\r\n        if (options.styles != null) { this._layer.setStyles(options.styles); }\r\n        if (options.visible != null) { this.SetVisible(options.visible); }\r\n    }\r\n\r\n    /**\r\n     * Toggles the cluster layer visibility.\r\n     *\r\n     * @param visible Boolean true to make the layer visible, false to hide the layer.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public SetVisible(visible: boolean): void {\r\n        const map: GoogleMapTypes.GoogleMap = visible ? this._layer.getMap() : null;\r\n        if (!visible) {\r\n            this._layer.resetViewport(true);\r\n        }\r\n        else {\r\n            const p: Array<GoogleMapTypes.Marker> = new Array<GoogleMapTypes.Marker>();\r\n            if (this._pendingMarkers.length > 0) {\r\n                this._pendingMarkers.forEach(e => {\r\n                    if (e.NativePrimitve && e.Location) {\r\n                        p.push(<GoogleMapTypes.Marker>e.NativePrimitve);\r\n                    }\r\n                });\r\n                this._layer.addMarkers(p);\r\n                this._markers = this._markers.concat(this._pendingMarkers.splice(0));\r\n            }\r\n            else {\r\n                this._layer.redraw();\r\n            }\r\n        }\r\n        this._visible = visible;\r\n    }\r\n\r\n    /**\r\n     * Start to actually cluster the entities in a cluster layer. This method should be called after the initial set of entities\r\n     * have been added to the cluster. This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public StartClustering(): void {\r\n        if (this._isClustering) { return; }\r\n\r\n        if (this._visible) {\r\n            const p: Array<GoogleMapTypes.Marker> = new Array<GoogleMapTypes.Marker>();\r\n            this._markers.forEach(e => {\r\n                if (e.NativePrimitve && e.Location) {\r\n                    p.push(<GoogleMapTypes.Marker>e.NativePrimitve);\r\n                }\r\n            });\r\n            this._pendingMarkers.forEach(e => {\r\n                if (e.NativePrimitve && e.Location) {\r\n                    p.push(<GoogleMapTypes.Marker>e.NativePrimitve);\r\n                }\r\n            });\r\n            this._layer.addMarkers(p);\r\n            this._markers = this._markers.concat(this._pendingMarkers.splice(0));\r\n        }\r\n\r\n        if (!this._visible) {\r\n            // only add the markers if the layer is visible. Otherwise, keep them pending. They would be added once the\r\n            // layer is set to visible.\r\n            timer(0).subscribe(() => {\r\n                this._layer.resetViewport(true);\r\n            });\r\n        }\r\n        this._isClustering = true;\r\n    }\r\n\r\n    /**\r\n     * Stop to actually cluster the entities in a cluster layer.\r\n     * This method is used for performance reasons as adding an entitiy will recalculate all clusters.\r\n     * As such, StopClustering should be called before adding many entities and StartClustering should be called once adding is\r\n     * complete to recalculate the clusters.\r\n     *\r\n     * @returns\r\n     *\r\n     * @memberof GoogleMarkerClusterer\r\n     */\r\n    public StopClustering() {\r\n        if (!this._isClustering) { return; }\r\n        this._isClustering = false;\r\n    }\r\n}\r\n","import { GoogleMarkerClusterer } from '../../models/google/google-marker-clusterer';\r\nimport { GoogleInfoWindow } from '../../models/google/google-info-window';\r\nimport { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { MapService } from '../map.service';\r\nimport { MapAPILoader } from '../mapapiloader';\r\nimport { GoogleMapAPILoader, GoogleMapAPILoaderConfig } from './google-map-api-loader.service';\r\nimport { GoogleClusterService } from './google-cluster.service';\r\nimport { ILayerOptions } from '../../interfaces/ilayer-options';\r\nimport { IClusterOptions } from '../../interfaces/icluster-options';\r\nimport { IMapOptions } from '../../interfaces/imap-options';\r\nimport { ILatLong } from '../../interfaces/ilatlong';\r\nimport { IPoint } from '../../interfaces/ipoint';\r\nimport { ISize } from '../../interfaces/isize';\r\nimport { IMarkerOptions } from '../../interfaces/imarker-options';\r\nimport { IMarkerIconInfo } from '../../interfaces/imarker-icon-info';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { IInfoWindowOptions } from '../../interfaces/iinfo-window-options';\r\nimport { MapTypeId } from '../../models/map-type-id';\r\nimport { Marker } from '../../models/marker';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { MixinMapLabelWithOverlayView } from '../../models/google/google-label';\r\nimport { MixinCanvasOverlay } from '../../models/google/google-canvas-overlay';\r\nimport { GoogleCanvasOverlay } from '../../models/google/google-canvas-overlay';\r\nimport { CanvasOverlay } from '../../models/canvas-overlay';\r\nimport { Layer } from '../../models/layer';\r\nimport { InfoWindow } from '../../models/info-window';\r\nimport { GooglePolygon } from '../../models/google/google-polygon';\r\nimport { GooglePolyline } from '../../models/google/google-polyline';\r\nimport { GoogleConversions } from './google-conversions';\r\nimport { GoogleMarker } from '../../models/google/google-marker';\r\nimport { GoogleLayer } from '../../models/google/google-layer';\r\nimport { IBox } from '../../interfaces/ibox';\r\nimport { GoogleMapEventsLookup } from '../../models/google/google-events-lookup';\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\ndeclare const google: any;\r\ndeclare const MarkerClusterer: any;\r\n\r\n/**\r\n * Concrete implementation of the MapService abstract implementing a Google Maps provider\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMapService implements MapService {\r\n\r\n    ///\r\n    /// Field Declarations\r\n    ///\r\n\r\n    private _map: Promise<GoogleMapTypes.GoogleMap>;\r\n    private _mapInstance: GoogleMapTypes.GoogleMap;\r\n    private _mapResolver: (value?: GoogleMapTypes.GoogleMap) => void;\r\n    private _config: GoogleMapAPILoaderConfig;\r\n\r\n    ///\r\n    /// Property Definitions\r\n    ///\r\n\r\n\r\n    /**\r\n     * Gets the Google Map control instance underlying the implementation\r\n     *\r\n     * @readonly\r\n     * @memberof GoogleMapService\r\n     */\r\n    public get MapInstance(): GoogleMapTypes.GoogleMap { return this._mapInstance; }\r\n\r\n    /**\r\n     * Gets a Promise for a Google Map control instance underlying the implementation. Use this instead of {@link MapInstance} if you\r\n     * are not sure if and when the instance will be created.\r\n     * @readonly\r\n     * @memberof GoogleMapService\r\n     */\r\n    public get MapPromise(): Promise<GoogleMapTypes.GoogleMap> { return this._map; }\r\n\r\n    /**\r\n     * Gets the maps physical size.\r\n     *\r\n     * @readonly\r\n     * @abstract\r\n     * @memberof BingMapService\r\n     */\r\n    public get MapSize(): ISize {\r\n        if (this.MapInstance) {\r\n            const el: HTMLDivElement = this.MapInstance.getDiv();\r\n            const s: ISize = { width: el.offsetWidth, height: el.offsetHeight };\r\n            return s;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleMapService.\r\n     * @param _loader MapAPILoader instance implemented for Google Maps. This instance will generally be injected.\r\n     * @param _zone NgZone object to enable zone aware promises. This will generally be injected.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    constructor(private _loader: MapAPILoader, private _zone: NgZone) {\r\n        this._map = new Promise<GoogleMapTypes.GoogleMap>(\r\n            (resolve: (map: GoogleMapTypes.GoogleMap) => void) => { this._mapResolver = resolve; }\r\n        );\r\n        this._config = (<GoogleMapAPILoader>this._loader).Config;\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapService interface implementation\r\n    ///\r\n\r\n    /**\r\n     * Creates a canvas overlay layer to perform custom drawing over the map with out\r\n     * some of the overhead associated with going through the Map objects.\r\n     * @param drawCallback A callback function that is triggered when the canvas is ready to be\r\n     * rendered for the current map view.\r\n     * @returns - Promise of a {@link CanvasOverlay} object.\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateCanvasOverlay(drawCallback: (canvas: HTMLCanvasElement) => void): Promise<CanvasOverlay> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const overlay: GoogleCanvasOverlay = new GoogleCanvasOverlay(drawCallback);\r\n            overlay.SetMap(map);\r\n            return overlay;\r\n        });\r\n    }\r\n\r\n    /*\r\n     * Creates a Google map cluster layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link IClusterOptions}.\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.ClusterLayer object.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateClusterLayer(options: IClusterOptions): Promise<Layer> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            let updateOptions: boolean = false;\r\n            const markerClusterer: GoogleMapTypes.MarkerClusterer = new MarkerClusterer(map, [], options);\r\n            const clusterLayer = new GoogleMarkerClusterer(markerClusterer);\r\n            const o: IClusterOptions = {\r\n                id: options.id\r\n            };\r\n            if (!options.visible) {\r\n                o.visible = false;\r\n                updateOptions = true;\r\n            }\r\n            if (!options.clusteringEnabled) {\r\n                o.clusteringEnabled = false;\r\n                updateOptions = true;\r\n            }\r\n            if (updateOptions) {\r\n                clusterLayer.SetOptions(o);\r\n            }\r\n            return clusterLayer;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an information window for a map position\r\n     *\r\n     * @param [options] - Infowindow options. See {@link IInfoWindowOptions}\r\n     * @returns - Promise of a {@link InfoWindow} object, which models the underlying Microsoft.Maps.Infobox object.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateInfoWindow(options?: IInfoWindowOptions): Promise<GoogleInfoWindow> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.InfoWindowOptions = GoogleConversions.TranslateInfoWindowOptions(options);\r\n            const infoWindow: GoogleMapTypes.InfoWindow = new google.maps.InfoWindow(o);\r\n            return new GoogleInfoWindow(infoWindow, this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a map layer within the map context\r\n     *\r\n     * @param options - Options for the layer. See {@link ILayerOptions}\r\n     * @returns - Promise of a {@link Layer} object, which models the underlying Microsoft.Maps.Layer object.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateLayer(options: ILayerOptions): Promise<Layer> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n             return new GoogleLayer(map, this, options.id);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a map instance\r\n     *\r\n     * @param el - HTML element to host the map.\r\n     * @param mapOptions - Map options\r\n     * @returns - Promise fullfilled once the map has been created.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateMap(el: HTMLElement, mapOptions: IMapOptions): Promise<void> {\r\n        return this._loader.Load().then(() => {\r\n            // apply mixins\r\n            MixinMapLabelWithOverlayView();\r\n            MixinCanvasOverlay();\r\n\r\n            // execute map startup\r\n            if (!mapOptions.mapTypeId == null) { mapOptions.mapTypeId = MapTypeId.hybrid; }\r\n            if (this._mapInstance != null) {\r\n                this.DisposeMap();\r\n            }\r\n            const o: GoogleMapTypes.MapOptions = GoogleConversions.TranslateOptions(mapOptions);\r\n            const map: GoogleMapTypes.GoogleMap = new google.maps.Map(el, o);\r\n            if (mapOptions.bounds) {\r\n                map.fitBounds(GoogleConversions.TranslateBounds(mapOptions.bounds));\r\n            }\r\n            this._mapInstance = map;\r\n            this._mapResolver(map);\r\n            return;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a Google map marker within the map context\r\n     *\r\n     * @param [options=<IMarkerOptions>{}] - Options for the marker. See {@link IMarkerOptions}.\r\n     * @returns - Promise of a {@link Marker} object, which models the underlying Microsoft.Maps.PushPin object.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public CreateMarker(options: IMarkerOptions = <IMarkerOptions>{}): Promise<Marker> {\r\n        const payload = (x: GoogleMapTypes.MarkerOptions, map: GoogleMapTypes.GoogleMap): GoogleMarker => {\r\n            const marker = new google.maps.Marker(x);\r\n            const m = new GoogleMarker(marker);\r\n            m.IsFirst = options.isFirst;\r\n            m.IsLast = options.isLast;\r\n            if (options.metadata) { options.metadata.forEach((val: any, key: string) => m.Metadata.set(key, val)); }\r\n            marker.setMap(map);\r\n            return m;\r\n        };\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.MarkerOptions = GoogleConversions.TranslateMarkerOptions(options);\r\n            if (options.iconInfo && options.iconInfo.markerType) {\r\n                const s = Marker.CreateMarker(options.iconInfo);\r\n                if (typeof(s) === 'string') {\r\n                    o.icon = s;\r\n                    return payload(o, map);\r\n                }\r\n                else {\r\n                    return s.then(x => {\r\n                        o.icon = x.icon;\r\n                        return payload(o, map);\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                return payload(o, map);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a polygon within the Google Map map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polygon. See {@link IPolygonOptions}.\r\n     * @returns - Promise of a {@link Polygon} object, which models the underlying native polygon.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    public CreatePolygon(options: IPolygonOptions): Promise<Polygon> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.PolygonOptions = GoogleConversions.TranslatePolygonOptions(options);\r\n            const polygon: GoogleMapTypes.Polygon = new google.maps.Polygon(o);\r\n            polygon.setMap(map);\r\n\r\n            const p: GooglePolygon = new GooglePolygon(polygon);\r\n            if (options.metadata) { options.metadata.forEach((val: any, key: string) => p.Metadata.set(key, val)); }\r\n            if (options.title && options.title !== '') { p.Title = options.title; }\r\n            if (options.showLabel != null) { p.ShowLabel = options.showLabel; }\r\n            if (options.showTooltip != null) { p.ShowTooltip = options.showTooltip; }\r\n            if (options.labelMaxZoom != null) { p.LabelMaxZoom = options.labelMaxZoom; }\r\n            if (options.labelMinZoom != null) { p.LabelMinZoom = options.labelMinZoom; }\r\n            return p;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a polyline within the Google Map map context\r\n     *\r\n     * @abstract\r\n     * @param options - Options for the polyline. See {@link IPolylineOptions}.\r\n     * @returns - Promise of a {@link Polyline} object (or an array therefore for complex paths)\r\n     * which models the underlying native polyline.\r\n     *\r\n     * @memberof MapService\r\n     */\r\n    public CreatePolyline(options: IPolylineOptions): Promise<Polyline|Array<Polyline>> {\r\n        let polyline: GoogleMapTypes.Polyline;\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.PolylineOptions = GoogleConversions.TranslatePolylineOptions(options);\r\n            if (options.path && options.path.length > 0 && !Array.isArray(options.path[0])) {\r\n                o.path = GoogleConversions.TranslatePaths(options.path)[0];\r\n                polyline = new google.maps.Polyline(o);\r\n                polyline.setMap(map);\r\n\r\n                const pl = new GooglePolyline(polyline);\r\n                if (options.metadata) { options.metadata.forEach((val: any, key: string) => pl.Metadata.set(key, val)); }\r\n                if (options.title && options.title !== '') { pl.Title = options.title; }\r\n                if (options.showTooltip != null) { pl.ShowTooltip = options.showTooltip; }\r\n                return pl;\r\n            }\r\n            else {\r\n                const paths: Array<Array<GoogleMapTypes.LatLng>> = GoogleConversions.TranslatePaths(options.path);\r\n                const lines: Array<Polyline> = new Array<Polyline>();\r\n                paths.forEach(p => {\r\n                    o.path = p;\r\n                    polyline = new google.maps.Polyline(o);\r\n                    polyline.setMap(map);\r\n\r\n                    const pl = new GooglePolyline(polyline);\r\n                    if (options.metadata) { options.metadata.forEach((val: any, key: string) => pl.Metadata.set(key, val)); }\r\n                    if (options.title && options.title !== '') { pl.Title = options.title; }\r\n                    if (options.showTooltip != null) { pl.ShowTooltip = options.showTooltip; }\r\n                    lines.push(pl);\r\n                });\r\n                return lines;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes a layer from the map.\r\n     *\r\n     * @param layer - Layer to delete. See {@link Layer}. This method expects the Google specific Layer model implementation.\r\n     * @returns - Promise fullfilled when the layer has been removed.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public DeleteLayer(layer: Layer): Promise<void> {\r\n        // return resolved promise as there is no conept of a custom layer in Google.\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Dispaose the map and associated resoures.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public DisposeMap(): void {\r\n        if (this._map == null && this._mapInstance == null) { return; }\r\n        if (this._mapInstance != null) {\r\n            this._mapInstance = null;\r\n            this._map = new Promise<GoogleMapTypes.GoogleMap>((resolve: () => void) => { this._mapResolver = resolve; });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map center\r\n     *\r\n     * @returns - A promise that when fullfilled contains the goe location of the center. See {@link ILatLong}.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public GetCenter(): Promise<ILatLong> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const center: GoogleMapTypes.LatLng = map.getCenter();\r\n            return <ILatLong>{\r\n                latitude: center.lat(),\r\n                longitude: center.lng()\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the geo coordinates of the map bounding box\r\n     *\r\n     * @returns - A promise that when fullfilled contains the geo location of the bounding box. See {@link IBox}.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public GetBounds(): Promise<IBox> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const box = map.getBounds();\r\n            return <IBox>{\r\n                maxLatitude: box.getNorthEast().lat(),\r\n                maxLongitude: Math.max(box.getNorthEast().lng(), box.getSouthWest().lng()),\r\n                minLatitude: box.getSouthWest().lat(),\r\n                minLongitude: Math.min(box.getNorthEast().lng(), box.getSouthWest().lng()),\r\n                center: { latitude: box.getCenter().lat(), longitude: box.getCenter().lng() },\r\n                padding: 0\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the current zoom level of the map.\r\n     *\r\n     * @returns - A promise that when fullfilled contains the zoom level.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public GetZoom(): Promise<number> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => map.getZoom());\r\n    }\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface representing the pixels. This promise resolves to null\r\n     * if the goe coordinates are not in the view port.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public LocationToPoint(loc: ILatLong): Promise<IPoint> {\r\n        return this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n            let crossesDateLine: boolean = false;\r\n            const l: GoogleMapTypes.LatLng = GoogleConversions.TranslateLocationObject(loc);\r\n            const p = m.getProjection();\r\n            const s: number = Math.pow(2, m.getZoom());\r\n            const b: GoogleMapTypes.LatLngBounds = m.getBounds();\r\n            if (b.getCenter().lng() < b.getSouthWest().lng()  ||\r\n                b.getCenter().lng() > b.getNorthEast().lng()) { crossesDateLine = true; }\r\n\r\n\r\n            const offsetY: number = p.fromLatLngToPoint(b.getNorthEast()).y;\r\n            const offsetX: number = p.fromLatLngToPoint(b.getSouthWest()).x;\r\n            const point: GoogleMapTypes.Point = p.fromLatLngToPoint(l);\r\n            return {\r\n                x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),\r\n                y: Math.floor((point.y - offsetY) * s)\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Provides a conversion of geo coordinates to pixels on the map control.\r\n     *\r\n     * @param loc - The geo coordinates to translate.\r\n     * @returns - Promise of an {@link IPoint} interface array representing the pixels.\r\n     *\r\n     * @memberof BingMapService\r\n     */\r\n    public LocationsToPoints(locs: Array<ILatLong>): Promise<Array<IPoint>> {\r\n        return this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n            let crossesDateLine: boolean = false;\r\n            const p = m.getProjection();\r\n            const s: number = Math.pow(2, m.getZoom());\r\n            const b: GoogleMapTypes.LatLngBounds = m.getBounds();\r\n            if (b.getCenter().lng() < b.getSouthWest().lng()  ||\r\n                b.getCenter().lng() > b.getNorthEast().lng()) { crossesDateLine = true; }\r\n\r\n            const offsetX: number = p.fromLatLngToPoint(b.getSouthWest()).x;\r\n            const offsetY: number = p.fromLatLngToPoint(b.getNorthEast()).y;\r\n            const l = locs.map(ll => {\r\n                const l1: GoogleMapTypes.LatLng = GoogleConversions.TranslateLocationObject(ll);\r\n                const point: GoogleMapTypes.Point = p.fromLatLngToPoint(l1);\r\n                return {\r\n                    x: Math.floor((point.x - offsetX + ((crossesDateLine && point.x < offsetX) ? 256 : 0)) * s),\r\n                    y: Math.floor((point.y - offsetY) * s)\r\n                };\r\n            });\r\n            return l;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Centers the map on a geo location.\r\n     *\r\n     * @param latLng - GeoCoordinates around which to center the map. See {@link ILatLong}\r\n     * @returns - Promise that is fullfilled when the center operations has been completed.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SetCenter(latLng: ILatLong): Promise<void> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => {\r\n            const center: GoogleMapTypes.LatLng = GoogleConversions.TranslateLocationObject(latLng);\r\n            map.setCenter(center);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the generic map options.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SetMapOptions(options: IMapOptions) {\r\n        this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n            const o: GoogleMapTypes.MapOptions = GoogleConversions.TranslateOptions(options);\r\n            m.setOptions(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the view options of the map.\r\n     *\r\n     * @param options - Options to set.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SetViewOptions(options: IMapOptions) {\r\n        this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n            if (options.bounds) {\r\n                m.fitBounds(GoogleConversions.TranslateBounds(options.bounds));\r\n            }\r\n            const o: GoogleMapTypes.MapOptions = GoogleConversions.TranslateOptions(options);\r\n            m.setOptions(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the zoom level of the map.\r\n     *\r\n     * @param zoom - Zoom level to set.\r\n     * @returns - A Promise that is fullfilled once the zoom operation is complete.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SetZoom(zoom: number): Promise<void> {\r\n        return this._map.then((map: GoogleMapTypes.GoogleMap) => map.setZoom(zoom));\r\n    }\r\n\r\n    /**\r\n     * Creates an event subscription\r\n     *\r\n     * @param eventName - The name of the event (e.g. 'click')\r\n     * @returns - An observable of type E that fires when the event occurs.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public SubscribeToMapEvent<E>(eventName: string): Observable<E> {\r\n        const googleEventName: string = GoogleMapEventsLookup[eventName];\r\n        return Observable.create((observer: Observer<E>) => {\r\n            this._map.then((m: GoogleMapTypes.GoogleMap) => {\r\n                m.addListener(googleEventName, (e: any) => {\r\n                    this._zone.run(() => observer.next(e));\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Triggers the given event name on the map instance.\r\n     *\r\n     * @param eventName - Event to trigger.\r\n     * @returns - A promise that is fullfilled once the event is triggered.\r\n     *\r\n     * @memberof GoogleMapService\r\n     */\r\n    public TriggerMapEvent(eventName: string): Promise<void> {\r\n        return this._map.then((m) => google.maps.event.trigger(m, eventName, null));\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { IPolygonOptions } from '../../interfaces/ipolygon-options';\r\nimport { Polygon } from '../../models/polygon';\r\nimport { MapPolygonDirective } from '../../components/map-polygon';\r\nimport { PolygonService } from '../polygon.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\n/**\r\n * Concrete implementation of the Polygon Service abstract class for Google Maps.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GooglePolygonService implements PolygonService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _polygons: Map<MapPolygonDirective, Promise<Polygon>> = new Map<MapPolygonDirective, Promise<Polygon>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GooglePolygonService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link GoogleMapService} implementation is expected.\r\n     * @param _layerService - {@link GoogleLayerService} instance.\r\n     * The concrete {@link GoogleLayerService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _zone: NgZone) {\r\n    }\r\n\r\n    ///\r\n    /// Public members and MarkerService implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds a polygon to a map. Depending on the polygon context, the polygon will either by added to the map or a\r\n     * correcsponding layer.\r\n     *\r\n     * @param polygon - The {@link MapPolygonDirective} to be added.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public AddPolygon(polygon: MapPolygonDirective): void {\r\n        const o: IPolygonOptions = {\r\n            id: polygon.Id,\r\n            clickable: polygon.Clickable,\r\n            draggable: polygon.Draggable,\r\n            editable: polygon.Editable,\r\n            fillColor: polygon.FillColor,\r\n            fillOpacity: polygon.FillOpacity,\r\n            geodesic: polygon.Geodesic,\r\n            labelMaxZoom: polygon.LabelMaxZoom,\r\n            labelMinZoom: polygon.LabelMinZoom,\r\n            paths: polygon.Paths,\r\n            showLabel: polygon.ShowLabel,\r\n            showTooltip: polygon.ShowTooltip,\r\n            strokeColor: polygon.StrokeColor,\r\n            strokeOpacity: polygon.StrokeOpacity,\r\n            strokeWeight: polygon.StrokeWeight,\r\n            title: polygon.Title,\r\n            visible: polygon.Visible,\r\n            zIndex: polygon.zIndex,\r\n        };\r\n        const polygonPromise: Promise<Polygon> = this._mapService.CreatePolygon(o);\r\n        this._polygons.set(polygon, polygonPromise);\r\n    }\r\n\r\n    /**\r\n      * Registers an event delegate for a polygon.\r\n      *\r\n      * @param eventName - The name of the event to register (e.g. 'click')\r\n      * @param polygon - The {@link MapPolygonDirective} for which to register the event.\r\n      * @returns - Observable emiting an instance of T each time the event occurs.\r\n      *\r\n      * @memberof GooglePolygonService\r\n      */\r\n    public CreateEventObservable<T>(eventName: string, polygon: MapPolygonDirective): Observable<T> {\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._polygons.get(polygon).then((p: Polygon) => {\r\n                p.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e)));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Deletes a polygon.\r\n      *\r\n      * @param polygon - {@link MapPolygonDirective} to be deleted.\r\n      * @returns - A promise fullfilled once the polygon has been deleted.\r\n      *\r\n      * @memberof GooglePolygonService\r\n      */\r\n    public DeletePolygon(polygon: MapPolygonDirective): Promise<void> {\r\n        const m = this._polygons.get(polygon);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polygon) => {\r\n            return this._zone.run(() => {\r\n                l.Delete();\r\n                this._polygons.delete(polygon);\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the polygon on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked marker.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };\r\n    }\r\n\r\n    /**\r\n     * Obtains the polygon model for the polygon allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param polygon - The {@link MapPolygonDirective} for which to obtain the polygon model.\r\n     * @returns - A promise that when fullfilled contains the {@link Polygon} implementation of the underlying platform.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public GetNativePolygon(polygon: MapPolygonDirective): Promise<Polygon> {\r\n        return this._polygons.get(polygon);\r\n    }\r\n\r\n    /**\r\n     * Set the polygon options.\r\n     *\r\n     * @param polygon - {@link MapPolygonDirective} to be updated.\r\n     * @param options - {@link IPolygonOptions} object containing the options. Options will be merged with the\r\n     * options already on the underlying object.\r\n     * @returns - A promise fullfilled once the polygon options have been set.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public SetOptions(polygon: MapPolygonDirective, options: IPolygonOptions): Promise<void> {\r\n        return this._polygons.get(polygon).then((l: Polygon) => { l.SetOptions(options); });\r\n    }\r\n\r\n    /**\r\n     * Updates the Polygon path\r\n     *\r\n     * @param polygon - {@link MapPolygonDirective} to be updated.\r\n     * @returns - A promise fullfilled once the polygon has been updated.\r\n     *\r\n     * @memberof GooglePolygonService\r\n     */\r\n    public UpdatePolygon(polygon: MapPolygonDirective): Promise<void> {\r\n        const m = this._polygons.get(polygon);\r\n        if (m == null || polygon.Paths == null || !Array.isArray(polygon.Paths) || polygon.Paths.length === 0) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then((l: Polygon) => {\r\n            if (Array.isArray(polygon.Paths[0])) {\r\n                l.SetPaths(polygon.Paths);\r\n            }\r\n            else {\r\n                l.SetPath(<Array<ILatLong>>polygon.Paths);\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n","import { ILatLong } from '../../interfaces/ilatlong';\r\nimport { Injectable, NgZone } from '@angular/core';\r\nimport { Observable, Observer } from 'rxjs';\r\nimport { IPolylineOptions } from '../../interfaces/ipolyline-options';\r\nimport { Polyline } from '../../models/polyline';\r\nimport { MapPolylineDirective } from '../../components/map-polyline';\r\nimport { PolylineService } from '../polyline.service';\r\nimport { MapService } from '../map.service';\r\nimport { LayerService } from '../layer.service';\r\n\r\n/**\r\n * Concrete implementation of the Polyline Service abstract class for Google Maps.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GooglePolylineService implements PolylineService {\r\n\r\n    ///\r\n    /// Field declarations\r\n    ///\r\n    private _polylines: Map<MapPolylineDirective, Promise<Polyline|Array<Polyline>>> =\r\n        new Map<MapPolylineDirective, Promise<Polyline|Array<Polyline>>>();\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GooglePolylineService.\r\n     * @param _mapService - {@link MapService} instance. The concrete {@link GoogleMapService} implementation is expected.\r\n     * @param _layerService - {@link LayerService} instance.\r\n     * The concrete {@link GoogleLayerService} implementation is expected.\r\n     * @param _zone - NgZone instance to support zone aware promises.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    constructor(private _mapService: MapService,\r\n        private _layerService: LayerService,\r\n        private _zone: NgZone) { }\r\n\r\n    ///\r\n    /// Public members and MarkerService implementation\r\n    ///\r\n\r\n    /**\r\n     * Adds a polyline to a map. Depending on the polyline context, the polyline will either by added to the map or a\r\n     * correcsponding layer.\r\n     *\r\n     * @param polyline - The {@link MapPolylineDirective} to be added.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public AddPolyline(polyline: MapPolylineDirective): void {\r\n        const o: IPolylineOptions = {\r\n            id: polyline.Id,\r\n            clickable: polyline.Clickable,\r\n            draggable: polyline.Draggable,\r\n            editable: polyline.Editable,\r\n            geodesic: polyline.Geodesic,\r\n            path: polyline.Path,\r\n            showTooltip: polyline.ShowTooltip,\r\n            strokeColor: polyline.StrokeColor,\r\n            strokeOpacity: polyline.StrokeOpacity,\r\n            strokeWeight: polyline.StrokeWeight,\r\n            title: polyline.Title,\r\n            visible: polyline.Visible,\r\n            zIndex: polyline.zIndex,\r\n        };\r\n        const polylinePromise: Promise<Polyline|Array<Polyline>> = this._mapService.CreatePolyline(o);\r\n        this._polylines.set(polyline, polylinePromise);\r\n    }\r\n\r\n    /**\r\n      * Registers an event delegate for a line.\r\n      *\r\n      * @param eventName - The name of the event to register (e.g. 'click')\r\n      * @param polyline - The {@link MapPolylineDirective} for which to register the event.\r\n      * @returns - Observable emiting an instance of T each time the event occurs.\r\n      *\r\n      * @memberof GooglePolylineService\r\n      */\r\n    public CreateEventObservable<T>(eventName: string, polyline: MapPolylineDirective): Observable<T> {\r\n        return Observable.create((observer: Observer<T>) => {\r\n            this._polylines.get(polyline).then(p => {\r\n                const x: Array<Polyline> = Array.isArray(p) ? p : [p];\r\n                x.forEach(line => line.AddListener(eventName, (e: T) => this._zone.run(() => observer.next(e))));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Deletes a polyline.\r\n      *\r\n      * @param polyline - {@link MapPolylineDirective} to be deleted.\r\n      * @returns - A promise fullfilled once the polyline has been deleted.\r\n      *\r\n      * @memberof GooglePolylineService\r\n      */\r\n    public DeletePolyline(polyline: MapPolylineDirective): Promise<void> {\r\n        const m = this._polylines.get(polyline);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then(l => {\r\n            return this._zone.run(() => {\r\n                const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n                x.forEach(line =>  line.Delete());\r\n                this._polylines.delete(polyline);\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Obtains geo coordinates for the line on the click location\r\n     *\r\n     * @abstract\r\n     * @param e - The mouse event.\r\n     * @returns - {@link ILatLong} containing the geo coordinates of the clicked line.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public GetCoordinatesFromClick(e: MouseEvent | any): ILatLong {\r\n        if (!e) {\r\n            return null;\r\n        }\r\n        if (!e.latLng) {\r\n            return null;\r\n        }\r\n        if (!e.latLng.lat || !e.latLng.lng) {\r\n            return null;\r\n        }\r\n        return { latitude: e.latLng.lat(), longitude: e.latLng.lng() };\r\n    }\r\n\r\n    /**\r\n     * Obtains the polyline model for the line allowing access to native implementation functionatiliy.\r\n     *\r\n     * @param polyline - The {@link MapPolylineDirective} for which to obtain the polyline model.\r\n     * @returns - A promise that when fullfilled contains the {@link Polyline}\r\n     * implementation of the underlying platform. For complex paths, returns an array of polylines.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public GetNativePolyline(polyline: MapPolylineDirective): Promise<Polyline|Array<Polyline>> {\r\n        return this._polylines.get(polyline);\r\n    }\r\n\r\n    /**\r\n     * Set the polyline options.\r\n     *\r\n     * @param polyline - {@link MapPolylineDirective} to be updated.\r\n     * @param options - {@link IPolylineOptions} object containing the options. Options will be merged with the\r\n     * options already on the underlying object.\r\n     * @returns - A promise fullfilled once the polyline options have been set.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public SetOptions(polyline: MapPolylineDirective, options: IPolylineOptions): Promise<void> {\r\n        return this._polylines.get(polyline).then(l => {\r\n            const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n            x.forEach(line => line.SetOptions(options));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates the Polyline path\r\n     *\r\n     * @param polyline - {@link MapPolylineDirective} to be updated.\r\n     * @returns - A promise fullfilled once the polyline has been updated.\r\n     *\r\n     * @memberof GooglePolylineService\r\n     */\r\n    public UpdatePolyline(polyline: MapPolylineDirective): Promise<void> {\r\n        const m = this._polylines.get(polyline);\r\n        if (m == null) {\r\n            return Promise.resolve();\r\n        }\r\n        return m.then(l => this._zone.run(() => {\r\n            const x: Array<Polyline> = Array.isArray(l) ? l : [l];\r\n            const p: Array<Array<ILatLong>> =\r\n                polyline.Path.length > 0 && Array.isArray(polyline.Path[0]) ? <Array<Array<ILatLong>>>polyline.Path :\r\n                <Array<Array<ILatLong>>>[polyline.Path];\r\n            x.forEach((line, index) => {\r\n                if (p.length > index) { line.SetPath(p[index]); }\r\n            });\r\n            if (Array.isArray(l) && l.length > p.length) {\r\n                l.splice(p.length - 1).forEach(line => line.Delete());\r\n            }\r\n        }));\r\n    }\r\n}\r\n","import { Injectable, NgZone } from '@angular/core';\r\nimport { MapServiceFactory } from '../mapservicefactory';\r\nimport { MapService } from '../map.service';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from '../mapapiloader';\r\nimport { MarkerService } from '../marker.service';\r\nimport { InfoBoxService } from '../infobox.service';\r\nimport { LayerService } from '../layer.service';\r\nimport { ClusterService } from '../cluster.service';\r\nimport { PolygonService } from '../polygon.service';\r\nimport { PolylineService } from '../polyline.service';\r\n\r\nimport * as GoogleMapTypes from './google-map-types';\r\n\r\nimport { GoogleMapAPILoader, GoogleMapAPILoaderConfig } from './google-map-api-loader.service';\r\nimport { GoogleInfoBoxService } from './google-infobox.service';\r\nimport { GoogleMarkerService } from './google-marker.service';\r\nimport { GoogleMapService } from './google-map.service';\r\nimport { GoogleLayerService } from './google-layer.service';\r\nimport { GoogleClusterService } from './google-cluster.service';\r\nimport { GooglePolygonService } from './google-polygon.service';\r\nimport { GooglePolylineService } from './google-polyline.service';\r\n\r\n/**\r\n * Implements a factory to create three necessary Google Maps specific service instances.\r\n *\r\n * @export\r\n */\r\n@Injectable()\r\nexport class GoogleMapServiceFactory implements MapServiceFactory {\r\n    private _map: Promise<GoogleMapTypes.GoogleMap>;\r\n    private _mapResolver: (value?: GoogleMapTypes.GoogleMap) => void;\r\n\r\n    ///\r\n    /// Constructor\r\n    ///\r\n\r\n    /**\r\n     * Creates an instance of GoogleMapServiceFactory.\r\n     * @param _loader - {@link MapAPILoader} implementation for the Google Map provider.\r\n     * @param _zone - NgZone object to implement zone aware promises.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    constructor(private _loader: MapAPILoader, private _zone: NgZone) {\r\n        this._map =\r\n            new Promise<GoogleMapTypes.GoogleMap>((resolve: () => void) => { this._mapResolver = resolve; });\r\n    }\r\n\r\n    ///\r\n    /// Public methods and MapServiceFactory implementation.\r\n    ///\r\n\r\n    /**\r\n     * Creates the map service for the Google Maps implementation.\r\n     *\r\n     * @returns - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public Create(): MapService {\r\n        return new GoogleMapService(this._loader, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the cluster service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     * @returns - {@link ClusterService}. A concreted instance of the {@link GoogleClusterService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public CreateClusterService(_mapService: MapService): ClusterService {\r\n        return new GoogleClusterService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates thh info box service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     * @param map - {@link MarkerService}. A concreted instance of the {@link GoogleMarkerService}.\r\n     * @returns - {@link InfoBoxService}. A concreted instance of the {@link GoogleInfoBoxService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public CreateInfoBoxService(_mapService: MapService, _markerService: MarkerService) {\r\n        return new GoogleInfoBoxService(_mapService, _markerService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the layer service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     * @returns - {@link LayerService}. A concreted instance of the {@link GoogleLayerService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public CreateLayerService(_mapService: MapService) {\r\n        return new GoogleLayerService(_mapService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the marker service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService}. A concreted instance of the {@link GoogleMapService}.\r\n     * @param layers - {@link LayerService}. A concreted instance of the {@link GoogleLayerService}.\r\n     * @param clusters  - {@link ClusterService}. A concreted instance of the {@link GoogleClusterService}.\r\n     * @returns - {@link MarkerService}. A concreted instance of the {@link GoogleMarkerService}.\r\n     *\r\n     * @memberof GoogleMapServiceFactory\r\n     */\r\n    public CreateMarkerService(_mapService: MapService, _layerService: GoogleLayerService, _clusterService: GoogleClusterService) {\r\n        return new GoogleMarkerService(_mapService, _layerService, _clusterService, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolygonService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    public CreatePolygonService(map: MapService, layers: LayerService): PolygonService {\r\n        return new GooglePolygonService(map, layers, this._zone);\r\n    }\r\n\r\n    /**\r\n     * Creates the polyline service for the Google Maps implementation.\r\n     *\r\n     * @param map - {@link MapService} implementation for thh underlying map archticture.\r\n     * @param layers - {@link LayerService} implementation for the underlying map architecture.\r\n     * @returns - {@link PolylineService} implementation for the underlying map architecture.\r\n     *\r\n     * @memberof MapServiceFactory\r\n     */\r\n    public CreatePolylineService(map: MapService, layers: LayerService): PolylineService {\r\n        return new GooglePolylineService(map, layers, this._zone);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *  Creates a new instance of a plaform specific MapServiceFactory.\r\n *\r\n * @param apiLoader - An {@link MapAPILoader} instance. This is expected to the a {@link GoogleMapAPILoader}.\r\n * @param zone - An NgZone instance to provide zone aware promises.\r\n *\r\n * @returns - A {@link MapServiceFactory} instance.\r\n */\r\nexport function GoogleMapServiceFactoryFactory(apiLoader: MapAPILoader, zone: NgZone): MapServiceFactory {\r\n    return new GoogleMapServiceFactory(apiLoader, zone);\r\n}\r\n\r\n/**\r\n * Creates a new instance of a plaform specific MapLoaderFactory.\r\n *\r\n * @export\r\n * @returns - A {@link MapAPILoader} instance.\r\n */\r\nexport function GoogleMapLoaderFactory(): MapAPILoader {\r\n    return new GoogleMapAPILoader(new GoogleMapAPILoaderConfig(), new WindowRef(), new DocumentRef());\r\n}\r\n","import { NgModule, ModuleWithProviders, NgZone } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport 'bingmaps';\r\n\r\n///\r\n/// import module interfaces\r\n///\r\nimport { ILatLong } from './src/interfaces/ilatlong';\r\nimport { IInfoWindowOptions } from './src/interfaces/iinfo-window-options';\r\nimport { IInfoWindowAction } from './src/interfaces/iinfo-window-action';\r\nimport { IMarkerOptions } from './src/interfaces/imarker-options';\r\nimport { IMapOptions } from './src/interfaces/imap-options';\r\nimport { ISize } from './src/interfaces/isize';\r\nimport { IPoint } from './src/interfaces/ipoint';\r\nimport { IBox } from './src/interfaces/ibox';\r\nimport { IMarkerEvent } from './src/interfaces/imarker-event';\r\nimport { IMarkerIconInfo } from './src/interfaces/imarker-icon-info';\r\nimport { ILayerOptions } from './src/interfaces/ilayer-options';\r\nimport { IClusterOptions } from './src/interfaces/icluster-options';\r\nimport { ISpiderClusterOptions } from './src/interfaces/ispider-cluster-options';\r\nimport { ILineOptions } from './src/interfaces/iline-options';\r\nimport { IPolygonOptions } from './src/interfaces/ipolygon-options';\r\nimport { IPolylineOptions } from './src/interfaces/ipolyline-options';\r\nimport { IPolygonEvent } from './src/interfaces/ipolygon-event';\r\nimport { IPolylineEvent } from './src/interfaces/ipolyline-event';\r\nimport { IMapEventLookup } from './src/interfaces/imap-event-lookup';\r\nimport { ILabelOptions } from './src/interfaces/ilabel-options';\r\n\r\n///\r\n/// import module models\r\n///\r\nimport { InfoWindow } from './src/models/info-window';\r\nimport { Marker } from './src/models/marker';\r\nimport { MarkerTypeId } from './src/models/marker-type-id';\r\nimport { MapTypeId } from './src/models/map-type-id';\r\nimport { Layer } from './src/models/layer';\r\nimport { Polygon } from './src/models/polygon';\r\nimport { Polyline } from './src/models/polyline';\r\nimport { SpiderClusterMarker } from './src/models/spider-cluster-marker';\r\nimport { ClusterPlacementMode } from './src/models/cluster-placement-mode';\r\nimport { ClusterClickAction } from './src/models/cluster-click-action';\r\nimport { CanvasOverlay} from './src/models/canvas-overlay';\r\nimport { BingLayer } from './src/models/bing/bing-layer';\r\nimport { BingClusterLayer } from './src/models/bing/bing-cluster-layer';\r\nimport { BingSpiderClusterMarker } from './src/models/bing/bing-spider-cluster-marker';\r\nimport { BingInfoWindow } from './src/models/bing/bing-info-window';\r\nimport { BingMarker } from './src/models/bing/bing-marker';\r\nimport { BingPolygon } from './src/models/bing/bing-polygon';\r\nimport { BingPolyline } from './src/models/bing/bing-polyline';\r\nimport { BingMapEventsLookup } from './src/models/bing/bing-events-lookup';\r\nimport { BingCanvasOverlay } from './src/models/bing/bing-canvas-overlay';\r\nimport { GoogleInfoWindow } from './src/models/google/google-info-window';\r\nimport { GoogleMarker } from './src/models/google/google-marker';\r\nimport { GooglePolygon } from './src/models/google/google-polygon';\r\nimport { GooglePolyline } from './src/models/google/google-polyline';\r\nimport { GoogleMapEventsLookup } from './src/models/google/google-events-lookup';\r\nimport { GoogleCanvasOverlay } from './src/models/google/google-canvas-overlay';\r\n\r\n///\r\n/// import module components\r\n///\r\nimport { MapComponent } from './src/components/map';\r\nimport { MapMarkerDirective } from './src/components/map-marker';\r\nimport { InfoBoxComponent } from './src/components/infobox';\r\nimport { InfoBoxActionDirective } from './src/components/infobox-action';\r\nimport { MapLayerDirective } from './src/components/map-layer';\r\nimport { ClusterLayerDirective } from './src/components/cluster-layer';\r\nimport { MapPolygonDirective } from './src/components/map-polygon';\r\nimport { MapPolylineDirective } from './src/components/map-polyline';\r\nimport { MapMarkerLayerDirective } from './src/components/map-marker-layer';\r\nimport { MapPolygonLayerDirective } from './src/components/map-polygon-layer';\r\nimport { MapPolylineLayerDirective } from './src/components/map-polyline-layer';\r\n\r\n///\r\n/// import module services\r\n///\r\nimport { MapServiceFactory } from './src/services/mapservicefactory';\r\nimport { MapService } from './src/services/map.service';\r\nimport { MapAPILoader, WindowRef, DocumentRef } from './src/services/mapapiloader';\r\nimport { InfoBoxService } from './src/services/infobox.service';\r\nimport { LayerService } from './src/services/layer.service';\r\nimport { MarkerService } from './src/services/marker.service';\r\nimport { ClusterService } from './src/services/cluster.service';\r\nimport { PolygonService } from './src/services/polygon.service';\r\nimport { PolylineService } from './src/services/polyline.service';\r\nimport { BingMapServiceFactory,\r\n    BingMapServiceFactoryFactory, BingMapLoaderFactory } from './src/services/bing/bing-map.service.factory';\r\nimport { BingMapService } from './src/services/bing/bing-map.service';\r\nimport { BingMapAPILoader, BingMapAPILoaderConfig } from './src/services/bing/bing-map.api-loader.service';\r\nimport { BingInfoBoxService } from './src/services/bing/bing-infobox.service';\r\nimport { BingMarkerService } from './src/services/bing/bing-marker.service';\r\nimport { BingLayerService } from './src/services/bing/bing-layer.service';\r\nimport { BingClusterService } from './src/services/bing/bing-cluster.service';\r\nimport { BingPolygonService } from './src/services/bing/bing-polygon.service';\r\nimport { BingPolylineService } from './src/services/bing/bing-polyline.service';\r\nimport { GoogleClusterService } from './src/services/google/google-cluster.service';\r\nimport { GoogleInfoBoxService } from './src/services/google/google-infobox.service';\r\nimport { GoogleLayerService } from './src/services/google/google-layer.service';\r\nimport { GoogleMapAPILoader, GoogleMapAPILoaderConfig } from './src/services/google/google-map-api-loader.service';\r\nimport {\r\n    GoogleMapServiceFactory, GoogleMapServiceFactoryFactory,\r\n    GoogleMapLoaderFactory\r\n} from './src/services/google/google-map.service.factory';\r\nimport { GoogleMapService } from './src/services/google/google-map.service';\r\nimport { GoogleMarkerService } from './src/services/google/google-marker.service';\r\nimport { GooglePolygonService } from './src/services/google/google-polygon.service';\r\nimport { GooglePolylineService } from './src/services/google/google-polyline.service';\r\n\r\n///\r\n/// export publics components, models, interfaces etc for external reuse.\r\n///\r\nexport {\r\n    ILatLong, IInfoWindowOptions, IInfoWindowAction, ISize, IMarkerOptions, IBox, IMapOptions, IPoint, IMarkerEvent, IPolygonEvent,\r\n    IPolylineEvent, IMapEventLookup, IMarkerIconInfo, ILayerOptions, IClusterOptions, ISpiderClusterOptions, ILineOptions,\r\n    IPolygonOptions, IPolylineOptions, ILabelOptions, MapComponent, InfoBoxComponent, MapMarkerDirective, MapPolygonDirective,\r\n    MapPolylineDirective, InfoBoxActionDirective, MapMarkerLayerDirective, MapPolygonLayerDirective, MapLayerDirective,\r\n    ClusterLayerDirective, MapPolylineLayerDirective, MapTypeId, Marker, MarkerTypeId, InfoWindow, Layer, ClusterPlacementMode,\r\n    ClusterClickAction, SpiderClusterMarker, Polygon, Polyline, CanvasOverlay, MapService, MapServiceFactory, MarkerService,\r\n    InfoBoxService, MapAPILoader, WindowRef, DocumentRef, LayerService, PolygonService, PolylineService, ClusterService\r\n};\r\nexport {\r\n    BingMapServiceFactory, BingMapAPILoaderConfig, BingMapService, BingInfoBoxService,\r\n    BingMarkerService, BingPolygonService, BingPolylineService, BingMapAPILoader,\r\n    BingLayerService, BingClusterService, BingLayer, BingMarker, BingPolyline, BingMapEventsLookup, BingPolygon,\r\n    BingInfoWindow, BingClusterLayer, BingSpiderClusterMarker, BingCanvasOverlay\r\n};\r\nexport {\r\n    GoogleClusterService, GoogleInfoBoxService, GoogleLayerService, GoogleMapAPILoader, GoogleMapAPILoaderConfig,\r\n    GoogleMapServiceFactory, GoogleMapService, GoogleMarkerService, GooglePolygonService, GooglePolylineService,\r\n    GoogleMarker, GoogleInfoWindow, GooglePolygon, GooglePolyline, GoogleMapEventsLookup, GoogleCanvasOverlay\r\n};\r\n\r\n///\r\n/// define module\r\n///\r\n@NgModule({\r\n    declarations: [\r\n        MapLayerDirective,\r\n        MapComponent,\r\n        MapMarkerDirective,\r\n        InfoBoxComponent,\r\n        InfoBoxActionDirective,\r\n        MapPolygonDirective,\r\n        MapPolylineDirective,\r\n        ClusterLayerDirective,\r\n        MapMarkerLayerDirective,\r\n        MapPolygonLayerDirective,\r\n        MapPolylineLayerDirective\r\n    ],\r\n    imports: [CommonModule],\r\n    exports: [\r\n        CommonModule,\r\n        MapComponent,\r\n        MapMarkerDirective,\r\n        MapPolygonDirective,\r\n        MapPolylineDirective,\r\n        InfoBoxComponent,\r\n        InfoBoxActionDirective,\r\n        MapLayerDirective,\r\n        ClusterLayerDirective,\r\n        MapMarkerLayerDirective,\r\n        MapPolygonLayerDirective,\r\n        MapPolylineLayerDirective\r\n    ]\r\n})\r\nexport class MapModule {\r\n\r\n    static forRoot(mapServiceFactory?: MapServiceFactory, loader?: MapAPILoader): ModuleWithProviders {\r\n        return {\r\n            ngModule: MapModule,\r\n            providers: [\r\n                mapServiceFactory ? { provide: MapServiceFactory, useValue: mapServiceFactory } :\r\n                    { provide: MapServiceFactory, deps: [MapAPILoader, NgZone], useFactory: BingMapServiceFactoryFactory },\r\n                loader ? { provide: MapAPILoader, useValue: loader } : { provide: MapAPILoader, useFactory: BingMapLoaderFactory },\r\n                DocumentRef,\r\n                WindowRef\r\n            ]\r\n        };\r\n    }\r\n\r\n    static forRootBing(): ModuleWithProviders {\r\n        return {\r\n            ngModule: MapModule,\r\n            providers: [\r\n                { provide: MapServiceFactory, deps: [MapAPILoader, NgZone], useFactory: BingMapServiceFactoryFactory },\r\n                { provide: MapAPILoader, useFactory: BingMapLoaderFactory },\r\n                DocumentRef,\r\n                WindowRef\r\n            ]\r\n        };\r\n    }\r\n\r\n    static forRootGoogle(): ModuleWithProviders {\r\n        return {\r\n            ngModule: MapModule,\r\n            providers: [\r\n                { provide: MapServiceFactory, deps: [MapAPILoader, NgZone], useFactory: GoogleMapServiceFactoryFactory },\r\n                { provide: MapAPILoader, useFactory: GoogleMapLoaderFactory },\r\n                DocumentRef,\r\n                WindowRef\r\n            ]\r\n        };\r\n    }\r\n}\r\n"]}